
namespace ERRORLOG
{
class ErrlUserDetailsParserAttribute : public ErrlUserDetailsParser {
public:

    ErrlUserDetailsParserAttribute() {}

    virtual ~ErrlUserDetailsParserAttribute() {}
  /**
   *  @brief Parses Attribute user detail data from an error log
   *  @param  i_version Version of the data
   *  @param  i_parse   ErrlUsrParser object for outputting information
   *  @param  i_pBuffer Pointer to buffer containing detail data
   *  @param  i_buflen  Length of the buffer
   */
  virtual void parse(errlver_t i_version,
                        ErrlUsrParser & i_parser,
                        void * i_pBuffer,
                        const uint32_t i_buflen) const
  {
    const char *pLabel = NULL;
    uint8_t *l_ptr = static_cast<uint8_t *>(i_pBuffer);
    std::vector<char> l_traceEntry(64);
    i_parser.PrintString("Target Attributes", NULL);

    for (; (l_ptr + sizeof(uint32_t)) <= ((uint8_t*)i_pBuffer + i_buflen); )
    {
        // first 4 bytes is the attr enum
        uint32_t attrEnum = ntohl(UINT32_FROM_PTR(l_ptr));
        l_ptr += sizeof(attrEnum);
        char* tmplabel = NULL;

        switch (attrEnum) {
          case 0x00116c3: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_LINK_ACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x001189a: {
              //simpleType:uint
              pLabel = "SYSTEM_PSTATE0_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x002156b: {
              //simpleType:uint
              pLabel = "SCRATCH_UINT32_2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0025f83: {
              //simpleType:uint
              pLabel = "EXPLR_ENABLE_US_TMPL_B";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0036125: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0041f25: {
              //simpleType:uint
              pLabel = "DLR_LINKS_ENABLED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 7);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 5 * sizeof(uint16_t);
              break;
          }
          case 0x0056bc3: {
              //simpleType:uint
              pLabel = "SMF_CONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x006e0bd: {
              //complexType - skipping
              break;
          }
          case 0x00ea92e: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x00fabfe: {
              //simpleType:uint
              pLabel = "MSL_CHECK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x010fb1f: {
              //simpleType:uint
              pLabel = "CLOCK_MUX3_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x01204e8: {
              //simpleType:uint
              pLabel = "FREQ_A_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0157499: {
              //simpleType:uint
              pLabel = "MSS_OMI_VDD_UPLIFT_APPLIED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0166494: {
              //simpleType:uint
              pLabel = "FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x017bc4f: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F1RC03";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x019e5ac: {
              //simpleType:uint
              pLabel = "TOD_ROLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x01a8fc7: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_VREFCA_SWEEP_MIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x01e31e8: {
              //simpleType:uint
              pLabel = "MAX_ALLOWED_DIMM_FREQ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 11);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 5 * sizeof(uint32_t);
              break;
          }
          case 0x01febfc: {
              break;
          }
          case 0x0202831: {
              //simpleType:uint
              pLabel = "CHTM_MODE_VGTARGET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x0202f28: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_SLEW_RATE_CSCID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x020a135: {
              //simpleType:uint
              pLabel = "PAYLOAD_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x02190b7: {
              //simpleType:uint
              pLabel = "NEST_PLL_BUCKET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0220177: {
              //simpleType:uint
              pLabel = "RUNN_QUAD_CYCLE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x0241bf2: {
              //simpleType:uint
              pLabel = "PM_SPIPSS_CLOCK_POLARITY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x025b084: {
              //simpleType:uint
              pLabel = "PROC_PCIE_LANE_REVERSAL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0x025f142: {
              //simpleType:uint
              pLabel = "IS_IBM_SIMULATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0271124: {
              //simpleType:uint
              pLabel = "FREQ_BIAS_ULTRATURBO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x02db547: {
              //simpleType:uint
              pLabel = "FREQ_MC_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x03010e0: {
              break;
          }
          case 0x030e8ef: {
              //simpleType:uint
              pLabel = "MSS_MCC_GROUP_32";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[16][21]:");
              l_traceEntry.resize(10+offset + 336 * 11);
              for (uint32_t i = 0;i<336;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 336 * sizeof(uint32_t);
              break;
          }
          case 0x0310a49: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x033b23b: {
              //simpleType:uint
              pLabel = "RCW0F_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x03622b1: {
              //simpleType:uint
              pLabel = "AVSBUS_VRM_FAIL_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x03744de: {
              //simpleType:uint
              pLabel = "DIMM_POWER_UTIL_INTERMEDIATE_POINTS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[10]:");
              l_traceEntry.resize(10+offset + 10 * 5);
              for (uint32_t i = 0;i<10;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 10 * sizeof(uint8_t);
              break;
          }
          case 0x037feec: {
              //simpleType:uint
              pLabel = "PROC_NX_RNG_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x03a7dcf: {
              //simpleType:uint
              pLabel = "SBE_BOOTLOADER_CODELEVEL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0x03a8b72: {
              //simpleType:uint
              pLabel = "VPD_REC_NUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x03ec4a4: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_INDIRECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0432b91: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_TOPOLOGY_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x043e8e0: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_MFG_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x048d1a2: {
              //simpleType:uint
              pLabel = "MEM_SI_WINDAGE_RD_CTR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int16_t);
              break;
          }
          case 0x0496af4: {
              //simpleType:uint
              pLabel = "PROC_TMPL_0_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x04bf0c7: {
              //simpleType:uint
              pLabel = "ODY_RST_RXTRK_STATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x04e2520: {
              //simpleType:uint
              pLabel = "MEM_DDR5_DFE_GAIN_BIAS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x0505dad: {
              //simpleType:uint
              pLabel = "MMIO_PHYS_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x05193dd: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TWR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x053231c: {
              //simpleType:uint
              pLabel = "SCANRING_FACTORY_PTR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x055981e: {
              //simpleType:uint
              pLabel = "EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x0577bb4: {
              //simpleType:uint
              pLabel = "RCW01_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x057bedc: {
              //simpleType:uint
              pLabel = "ODY_PHY_RX2D_TRAIN_OPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0596764: {
              break;
          }
          case 0x05b494e: {
              //simpleType:uint
              pLabel = "DDS_DPLL_SLEW_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x05c88c6: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_RESET_COUNTER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x05cbd4d: {
              //simpleType:uint
              pLabel = "ODY_ENABLE_MALERT_ASYNC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x05d46e3: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_SRANK_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0602310: {
              //simpleType:uint
              pLabel = "PCI1_REFCLOCK_RCVR_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x06065ab: {
              //simpleType:uint
              pLabel = "CLOCK_MUX12_OMI_LCPLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x061c783: {
              //simpleType:uint
              pLabel = "ISTEP_CALLOUT_INJECT_ACTION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x06668e3: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8][4]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x06716dc: {
              //simpleType:uint
              pLabel = "PROC_INT_IC_BAR_PAGE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x06b6027: {
              //simpleType:uint
              pLabel = "COLLECT_SBE_SCRATCH_DATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x06d133f: {
              //simpleType:uint
              pLabel = "EFF_DRAM_BANK_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x06d3ba7: {
              //simpleType:uint
              pLabel = "IBSCOM_PROC_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x06e1416: {
              //simpleType:uint
              pLabel = "UNSECURE_HOMER_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x06e992f: {
              //simpleType:uint
              pLabel = "ALL_MCS_IN_INTERLEAVING_GROUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x070464c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x071500e: {
              //simpleType:uint
              pLabel = "EXP_TOTAL_PWR_SLOPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x078d31b: {
              //simpleType:uint
              pLabel = "PROC_TMPL_7_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x079d52d: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x07a2758: {
              //simpleType:uint
              pLabel = "L2_CACHE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x07a9643: {
              //simpleType:uint
              pLabel = "EFF_DRAM_DENSITY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x07bf802: {
              //simpleType:uint
              pLabel = "MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x07ccc77: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC1X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x07e49ed: {
              //simpleType:uint
              pLabel = "WOF_IO_STEP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x08765f3: {
              //simpleType:uint
              pLabel = "MSS_EXP_FW_API_VERSION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x08a4518: {
              //simpleType:uint
              pLabel = "MEM_EFF_FREQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x08b7922: {
              //simpleType:uint
              pLabel = "PGPE_BOOT_COPIER_IVPR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x08f223c: {
              //simpleType:uint
              pLabel = "PGPE_PHANTOM_HALT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x092ecab: {
              //simpleType:uint
              pLabel = "EFF_DIMM_RANKS_CONFIGED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x0942635: {
              //simpleType:uint
              pLabel = "DYNAMIC_INIT_FEATURE_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x097b409: {
              //simpleType:uint
              pLabel = "PROC_PCIE_CARD_WORKAROUND";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x098c48e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0999272: {
              //simpleType:uint
              pLabel = "ODY_PHY_ENABLED_DQ_CHA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x09bf27c: {
              break;
          }
          case 0x09d1306: {
              //simpleType:uint
              pLabel = "MSS_OCMB_SPECATTN_OBJ_HANDLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x0a708ad: {
              //simpleType:uint
              pLabel = "RCW47_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0a745be: {
              //simpleType:uint
              pLabel = "FILTER_PLL_BUCKET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0a8379a: {
              //simpleType:enum
              pLabel = "EEPROM_VPD_REDUNDANCY";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_REDUNDANCY_POSSIBLE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_REDUNDANCY_PRESENT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_REDUNDANCY_NOT_PRESENT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x0a96a60: {
              //simpleType:uint
              pLabel = "SYSTEM_FUSED_CORE_PAIRED_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0a9ad3f: {
              //simpleType:uint
              pLabel = "RCW40_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0aa0ab1: {
              //simpleType:uint
              pLabel = "HOSTSVC_PLID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0ad06df: {
              //simpleType:uint
              pLabel = "EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x0adf7aa: {
              //simpleType:uint
              pLabel = "MSS_EXP_OMI_CDR_OFFSET_LANE_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0b12e9e: {
              //simpleType:uint
              pLabel = "MEM_EFF_NUM_MASTER_RANKS_PER_DIMM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x0b14185: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_DIFF_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0b207b3: {
              //simpleType:uint
              pLabel = "MSS_CENT_AVDD_SLOPE_ACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0b347d3: {
              //simpleType:uint
              pLabel = "ODY_DFIPHYUPDRESP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0b391d7: {
              //simpleType:uint
              pLabel = "SYSTEM_MAX_OPERATING_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0b4a2fc: {
              //simpleType:uint
              pLabel = "MEM_EFF_REGISTER_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x0bbbf7b: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_RECOVERY_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0bce06b: {
              //simpleType:uint
              pLabel = "DCACHE_ASSOC_SETS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0bf05d1: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_2_USAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0c55226: {
              break;
          }
          case 0x0c63607: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0x0c8b64a: {
              //simpleType:uint
              pLabel = "SW511706_CHECKSTOP_ON_GTE_LV1_HANG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x0ca664f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0cbd3fd: {
              //simpleType:uint
              pLabel = "MSS_CENT_VCS_SLOPE_INACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0cf02b5: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0cf60f4: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_SELF_REF_ABORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0d1a22c: {
              //simpleType:uint
              pLabel = "IO_O_CHANNEL_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0d33633: {
              //simpleType:uint
              pLabel = "EFF_DRAM_GEN";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x0d40743: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_ATTACHED_CHIP_CNFG";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x0d7122c: {
              //simpleType:uint
              pLabel = "OCMB_GOLDEN_BOOT_ATTEMPTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0d8a911: {
              //simpleType:uint
              pLabel = "VDN_UPLIFT_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0db7587: {
              //simpleType:uint
              pLabel = "MIN_PROC_POWER_PER_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x0dc047f: {
              //simpleType:uint
              pLabel = "FORCE_SBE_SCRATCH_DATA_COLLECTION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0dcd6cd: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8][2]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0x0dddcbc: {
              //simpleType:uint
              pLabel = "PROC_ENABLE_DL_TMPL_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0ddfd25: {
              //simpleType:uint
              pLabel = "STOP5_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0de7e70: {
              //simpleType:uint
              pLabel = "ODY_ENABLE_US_TMPL_9";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0df4605: {
              //complexType - skipping
              break;
          }
          case 0x0dfd293: {
              //simpleType:uint
              pLabel = "SECURE_SETTINGS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0e05a7c: {
              //simpleType:uint
              pLabel = "OCC_START_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0e57a47: {
              //simpleType:uint
              pLabel = "DDR5_VDN_UPLIFT_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x0e715c8: {
              //simpleType:uint
              pLabel = "EFF_NUM_MASTER_RANKS_PER_DIMM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x0e8df6e: {
              //simpleType:uint
              pLabel = "CEN_EFF_DIMM_SIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x0ea4707: {
              //simpleType:uint
              pLabel = "HTM_QUEUES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x0eb9d5d: {
              break;
          }
          case 0x0ec17cd: {
              //simpleType:uint
              pLabel = "MEM_DIMM_TYPE_METADATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0ed1fca: {
              //simpleType:uint
              pLabel = "IS_MASTER_CORE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0f1b8e1: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0f27151: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0f373ad: {
              //simpleType:uint
              pLabel = "SYSTEM_WOF_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0f4af00: {
              //simpleType:uint
              pLabel = "ODY_MRR_ODT_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0f7ac8a: {
              //simpleType:uint
              pLabel = "PROC_INT_NVC_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0f9d926: {
              //simpleType:uint
              pLabel = "MNFG_ABUS_MIN_EYE_WIDTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x0fb9e1f: {
              //simpleType:uint
              pLabel = "MSS_MRW_MEM_M_DRAM_CLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x0fd5c68: {
              //simpleType:uint
              pLabel = "EXPLR_TMPL_5_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1013c3d: {
              //simpleType:uint
              pLabel = "FREQ_BIAS_NOMINAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x102ae5e: {
              //simpleType:enum
              pLabel = "REDUNDANT_MF_CLOCKS";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "REDUNDANT_MF_CLOCKS_TRUE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "REDUNDANT_MF_CLOCKS_FALSE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x102dda7: {
              //simpleType:uint
              pLabel = "PCI_PLL_BUCKET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x103f0e0: {
              //simpleType:uint
              pLabel = "ODY_PHY_MSTRCTRLMODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1049d17: {
              //simpleType:uint
              pLabel = "MNFG_TH_MEMORY_IMPES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x107988d: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC02";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x10ae5b3: {
              //simpleType:uint
              pLabel = "MNFG_TH_L2_DIR_CES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x10c8327: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_PHY_VREF_RD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x10cd9ed: {
              //simpleType:uint
              pLabel = "ODY_SENSOR_READ_FIRST_FAIL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 5);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 5 * sizeof(uint8_t);
              break;
          }
          case 0x10d2a3d: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR3_VDDR_SLOPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x10d5dbc: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_PHASE_COMB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x10e6b93: {
              //simpleType:uint
              pLabel = "ENABLE_ABIST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1166570: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VPP_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x116670c: {
              //simpleType:enum
              pLabel = "FSI_MASTER_TYPE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "FSI_MASTER_TYPE_MFSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "FSI_MASTER_TYPE_CMFSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "FSI_MASTER_TYPE_NO_MASTER");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x117c575: {
              //simpleType:uint
              pLabel = "NHTM_HTMSC_MODE_CONTENT_SEL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1192453: {
              //simpleType:uint
              pLabel = "TIME_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x11a66f1: {
              //simpleType:uint
              pLabel = "HB_HRMOR_NODAL_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x11b28b1: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_TX_SLEW_RISE_CK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x11db9be: {
              //simpleType:uint
              pLabel = "MEM_CS_ASSERT_IN_MPC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x11f5010: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x11f71fb: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x12aa7fd: {
              //simpleType:uint
              pLabel = "MEM_EFF_SUPPORTED_RCD";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x12b0629: {
              //simpleType:uint
              pLabel = "RUNN_STOP_ON_XSTOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x12be307: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_VERBOSITY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x13326ac: {
              //simpleType:uint
              pLabel = "MSS_PHY_SEQ_REFRESH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x133d3ca: {
              //simpleType:uint
              pLabel = "CLOCK_MUX13_OPT_133_SOURCE_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x134e3f0: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x134fdb0: {
              //simpleType:uint
              pLabel = "TLB_INSTR_ASSOC_SETS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x137d006: {
              //simpleType:uint
              pLabel = "MEM_WL_INTERNAL_CYCLE_ALIGNMENT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0x13cd0a9: {
              //simpleType:uint
              pLabel = "RUNN_CYCLE_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x13fdcc3: {
              //simpleType:uint
              pLabel = "INTERPOSER_REV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x140ddc8: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1439e9f: {
              //simpleType:uint
              pLabel = "PROC_PCIE_LANE_MASK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0x14625e7: {
              //simpleType:uint
              pLabel = "PROC_OCC_SANDBOX_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x148c185: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1587d89: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x158ad24: {
              //simpleType:uint
              pLabel = "MEM_EFF_EXTCALRESVAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x158bb98: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_VREFCS_SWEEP_MAX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x159dbfd: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_RTT_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 5);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 16 * sizeof(uint8_t);
              break;
          }
          case 0x15c7694: {
              //simpleType:uint
              pLabel = "PBAX_BRDCST_ID_VECTOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x15c8113: {
              //simpleType:uint
              pLabel = "FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x15da8c9: {
              //simpleType:uint
              pLabel = "I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x15f7d77: {
              //simpleType:uint
              pLabel = "CORE_HASPOWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x164477a: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_RCV_IMP_DQ_DQS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 8 * sizeof(uint16_t);
              break;
          }
          case 0x16824ac: {
              //simpleType:uint
              pLabel = "PM_SPIPSS_CLOCK_DIVIDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x169e135: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_TX_SLEW_RISE_AC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x16a3e9f: {
              //simpleType:uint
              pLabel = "CHTM_CTRL_TRIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x16ca47a: {
              //simpleType:uint
              pLabel = "IO_OMI_PRE2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x16cbbfb: {
              //simpleType:uint
              pLabel = "MNFG_TH_L2_LINE_DELETES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x16d0d5a: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_CHANNEL_BUS_WIDTH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x16e4587: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ODTLON_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x16ed83e: {
              //simpleType:uint
              pLabel = "MEM_DDR5_MIN_REF_RATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x16fbd51: {
              //complexType - skipping
              break;
          }
          case 0x17228f8: {
              //simpleType:uint
              pLabel = "MSS_VDD_PROGRAM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x172d7c5: {
              //simpleType:uint
              pLabel = "HTMSC_TSIZEFILT_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1737151: {
              //simpleType:uint
              pLabel = "DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x174a2ca: {
              //simpleType:uint
              pLabel = "RCW05_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x177f39f: {
              //simpleType:uint
              pLabel = "I2C_DEV_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1788780: {
              //simpleType:uint
              pLabel = "MNFG_TH_L3_LINE_DELETES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x17ca2c5: {
              //simpleType:uint
              pLabel = "ODY_DQS_OSC_RUNTIME_SEL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x17daf7d: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x17dbf79: {
              //simpleType:uint
              pLabel = "MEM_EXP_RCD_DIC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x17f1548: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_IOHS_BUS_WIDTH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x18128bb: {
              //simpleType:uint
              pLabel = "PROC_MIRROR_SIZES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x183c3a9: {
              //simpleType:uint
              pLabel = "MEM_SI_DRAM_RTT_PARK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x18658a8: {
              //simpleType:uint
              pLabel = "CLOCK_MUX0A_RCS_PLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1865b64: {
              //simpleType:uint
              pLabel = "EXPLR_ENABLE_US_TMPL_5";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1871395: {
              //not readable
              break;
          }
          case 0x18849c5: {
              //not readable
              break;
          }
          case 0x18a11eb: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VPP_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x18a17a2: {
              //simpleType:uint
              pLabel = "SCRATCH_UINT64_2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x18ba600: {
              //simpleType:uint
              pLabel = "PROC_INT_NVC_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x18bfacf: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x18d405f: {
              //simpleType:uint
              pLabel = "EFF_RANK_GROUP_OVERRIDE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0x18d5136: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_DQS_RTT_PARK_PER_DRAM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0x18dd068: {
              //simpleType:uint
              pLabel = "MSS_VPD_MT_MC_BIAS_TRIM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x18ee29e: {
              //simpleType:uint
              pLabel = "RCW44_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1902629: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1949903: {
              //simpleType:uint
              pLabel = "MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x1952ef4: {
              //simpleType:uint
              pLabel = "IO_OBUS_TX_FFE_POSTCURSOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1983e2d: {
              //simpleType:uint
              pLabel = "IBSCOM_MCS_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x198c24a: {
              //simpleType:uint
              pLabel = "EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x19a4504: {
              //simpleType:uint
              pLabel = "PIB_I2C_NEST_PLL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x19bf475: {
              //simpleType:uint
              pLabel = "EXPLR_TMPL_B_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x19c712c: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VDD_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x19d1b7e: {
              //complexType - skipping
              break;
          }
          case 0x19f4158: {
              //simpleType:uint
              pLabel = "NV_OPS_TIMEOUT_MSEC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[6]:");
              l_traceEntry.resize(10+offset + 6 * 11);
              for (uint32_t i = 0;i<6;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 6 * sizeof(uint32_t);
              break;
          }
          case 0x1a091ba: {
              //simpleType:uint
              pLabel = "EXTERNAL_VRM_STEPSIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x1a17aae: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1a4dca3: {
              //simpleType:uint
              pLabel = "WOV_OVERV_STEP_INCR_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1a946e7: {
              //complexType - skipping
              break;
          }
          case 0x1a9b1f1: {
              //simpleType:uint
              pLabel = "MSS_OCMB_HALF_DIMM_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1b14ba7: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1b2a533: {
              //simpleType:uint
              pLabel = "MELTBOX_FREQ_PB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x1b37f43: {
              //simpleType:uint
              pLabel = "OCMB_PLL_BUCKET_SIM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1b589a0: {
              //simpleType:uint
              pLabel = "RECONFIGURE_LOOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1bc94b8: {
              //simpleType:uint
              pLabel = "SYSTEM_RESCLK_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1bcdba6: {
              //simpleType:uint
              pLabel = "HW_RECONFIG_CURRENT_ITR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x1bd05b0: {
              break;
          }
          case 0x1c05310: {
              //simpleType:uint
              pLabel = "PROC_PCIE_LANE_EQUALIZATION_GEN5";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[16]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0x1c0d755: {
              //simpleType:uint
              pLabel = "MEM_MIRROR_PLACEMENT_POLICY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1c28c5e: {
              //simpleType:uint
              pLabel = "EFF_DRAM_ROW_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x1c4fb0a: {
              //simpleType:uint
              pLabel = "APPLY_PCIE_WORKAROUND";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1c5c585: {
              //simpleType:uint
              pLabel = "HWAS_STATE_CHANGED_FLAG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x1ca5b41: {
              //simpleType:uint
              pLabel = "SYSTEM_RESCLK_ISTEP4_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1ca612d: {
              //simpleType:uint
              pLabel = "IO_O_MFG_STRESS_PR_OFFSET_ODD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1cfc587: {
              //complexType - skipping
              break;
          }
          case 0x1d1394c: {
              //simpleType:uint
              pLabel = "I2C_SPEED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x1d2e7e8: {
              //simpleType:uint
              pLabel = "EXPLR_SHRT_BACKOFF_TIMER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1d3faf3: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_SCOPE_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1d55f3f: {
              //simpleType:uint
              pLabel = "PEC_PCIE_IOP_SWAP_BIFURCATED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1dabb0c: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC04";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x1db941d: {
              //simpleType:uint
              pLabel = "FSP_PM_SPWUP_OHA_FLAG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1dbe9ca: {
              //simpleType:uint
              pLabel = "MEM_EFF_TSV_8H_SUPPORT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x1e03c6f: {
              //simpleType:uint
              pLabel = "HCSI_CHIP_SBE_INTERFACE_PTR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x1e1c64d: {
              //complexType - skipping
              break;
          }
          case 0x1e33fa9: {
              //simpleType:uint
              pLabel = "RCW41_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1e5007b: {
              //simpleType:uint
              pLabel = "CHTM_MODE_LLAT_PAUSE_ON_PURGE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x1e53923: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1e8208b: {
              //simpleType:uint
              pLabel = "MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1e83d32: {
              break;
          }
          case 0x1e96f94: {
              //simpleType:uint
              pLabel = "OMI_RX_LTEG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(INT32_FROM_PTR(reinterpret_cast<const int32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int32_t);
              break;
          }
          case 0x1ea2968: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1eb366d: {
              //simpleType:uint
              pLabel = "IS_MASTER_NODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1edce66: {
              //simpleType:uint
              pLabel = "EXP_DATABUS_UTIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x1ef2a04: {
              //simpleType:uint
              pLabel = "PROC_SBE_MCS_SETUP_REG_STATES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[9]:");
              l_traceEntry.resize(10+offset + 9 * 19);
              for (uint32_t i = 0;i<9;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 9 * sizeof(uint64_t);
              break;
          }
          case 0x1f2c617: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_ADDR_DIS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x1f50813: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_GEARDOWN_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1f722ba: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_CS_ODT_PER_DRAM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 7);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 160 * sizeof(uint16_t);
              break;
          }
          case 0x1fbf757: {
              //complexType - skipping
              break;
          }
          case 0x1fddb6b: {
              //simpleType:uint
              pLabel = "MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x1fe3e53: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x1ffe3ce: {
              //simpleType:uint
              pLabel = "LPC_BUS_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x2010712: {
              //simpleType:uint
              pLabel = "C0_HASPOWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2022c38: {
              //simpleType:uint
              pLabel = "IPL_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x203d77f: {
              //simpleType:uint
              pLabel = "MSS_OCMB_CHECKSTOP_OBJ_HANDLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x206be4b: {
              //simpleType:uint
              pLabel = "PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x208baa7: {
              //simpleType:uint
              pLabel = "EFF_PACKAGE_RANK_MAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2][18]:");
              l_traceEntry.resize(10+offset + 72 * 5);
              for (uint32_t i = 0;i<72;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 72 * sizeof(uint8_t);
              break;
          }
          case 0x20ee8fd: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SEQUENCE_CFG1_R41";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x21049e0: {
              //simpleType:uint
              pLabel = "PROC_EPS_READ_CYCLES_T0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x210fee7: {
              //simpleType:uint
              pLabel = "ODY_PHY_CALINTERVAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x211648c: {
              //simpleType:uint
              pLabel = "CORE_THROTTLE_ASSERT_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x21371e3: {
              //simpleType:uint
              pLabel = "RCW42_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x213ac30: {
              //simpleType:uint
              pLabel = "IO_X_MFG_CHK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x214b9d8: {
              //simpleType:uint
              pLabel = "PRD_DD1_OMI_DEGRADE_PREDICTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2165e1d: {
              //simpleType:uint
              pLabel = "USE_11S_SPD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x216a1a7: {
              //simpleType:uint
              pLabel = "ODY_SWIZZLE_DETECT_FAIL_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x21889e5: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x218e65f: {
              //simpleType:uint
              pLabel = "DYNAMIC_INIT_MODE_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x219028e: {
              //simpleType:uint
              pLabel = "VDN_VOLTAGE_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x219583a: {
              //simpleType:uint
              pLabel = "SYSTEM_MMA_POWERON_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x219cef7: {
              //simpleType:uint
              pLabel = "BACKING_CACHES_NUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x21c70fd: {
              //simpleType:uint
              pLabel = "FSI_SLAVE_CASCADE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x21d59a2: {
              //simpleType:uint
              pLabel = "NV_STATUS_FLAG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x221fcbe: {
              //simpleType:uint
              pLabel = "FREQ_SYSTEM_CORE_CEILING_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2239266: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRFC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x22428b6: {
              //simpleType:uint
              pLabel = "I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2280840: {
              //simpleType:uint
              pLabel = "MSS_VPP_PROGRAM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x22941b3: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 8 * sizeof(uint16_t);
              break;
          }
          case 0x22d9035: {
              //simpleType:uint
              pLabel = "VENDOR_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x22ecfb0: {
              //simpleType:uint
              pLabel = "ODY_DISABLE_PMU_ECC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x231c430: {
              //simpleType:uint
              pLabel = "MEM_REF_INTERVAL_RATE_INDIC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x232c72e: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_RBT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2354c19: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x238be14: {
              break;
          }
          case 0x23ad20f: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_AGGREGATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x23b1510: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x23c87d8: {
              //simpleType:uint
              pLabel = "PROC_EPS_TABLE_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x23d66fa: {
              //simpleType:uint
              pLabel = "MSS_MRW_SUPPORTED_FREQ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x23e3fd9: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2412cf9: {
              //simpleType:uint
              pLabel = "DDS_FMIN_OVERRIDE_KHZ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 7);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 5 * sizeof(uint16_t);
              break;
          }
          case 0x2412f59: {
              //simpleType:uint
              pLabel = "DDS_DROOP_EXTREME_OVERRIDE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[9]:");
              l_traceEntry.resize(10+offset + 9 * 5);
              for (uint32_t i = 0;i<9;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 9 * sizeof(uint8_t);
              break;
          }
          case 0x241918a: {
              //simpleType:uint
              pLabel = "MC_SYNC_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x244f3e1: {
              //simpleType:uint
              pLabel = "WOV_UNDERV_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x24a02c8: {
              //complexType - skipping
              break;
          }
          case 0x24a0f92: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x24a8d09: {
              //simpleType:uint
              pLabel = "SKIP_HBRT_ATTR_UPDATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x24dbd79: {
              //simpleType:uint
              pLabel = "RCW0D_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2543532: {
              //simpleType:uint
              pLabel = "ODY_SETUP_SAFEMODE_THROTTLES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x25683a0: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_RTT_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x2591cf9: {
              //simpleType:uint
              pLabel = "FREQ_PROC_REFCLOCK_ACTUAL_KHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2596df8: {
              //simpleType:uint
              pLabel = "ODY_PHY_DISABLED_DBYTE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x25b0084: {
              //nativeType:EntityPath
              pLabel = "FSI_MASTER_CHIP";
              const char *pathString;
              // from targeting/common/entitypath.[CH]
              const uint8_t lPtype = *l_ptr; // PATH_TYPE
              switch (lPtype) {
                  case 0x01: pathString = "Logical:"; break;
                  case 0x02: pathString = "Physical:"; break;
                  case 0x03: pathString = "Device:"; break;
                  case 0x04: pathString = "Power:"; break;
                  default:   pathString = "Unknown:"; break;
              }
              l_traceEntry.resize(strlen(pathString) + 128);
              uint32_t dataSize = sprintf(&(l_traceEntry[0]), "%s",pathString);
              const uint8_t lSize = *(l_ptr + 1); // number of elements
              uint8_t *lElementInstance = (l_ptr + 2);
              for (uint32_t i=0;i<lSize;i += 2) {
                  switch (lElementInstance[i]) {
                      case 0x00: { pathString = "/NA"; break; }
                      case 0x01: { pathString = "/Sys"; break; }
                      case 0x02: { pathString = "/Node"; break; }
                      case 0x03: { pathString = "/DIMM"; break; }
                      case 0x04: { pathString = "/Membuf"; break; }
                      case 0x05: { pathString = "/Proc"; break; }
                      case 0x06: { pathString = "/EX"; break; }
                      case 0x07: { pathString = "/Core"; break; }
                      case 0x08: { pathString = "/L2"; break; }
                      case 0x09: { pathString = "/L3"; break; }
                      case 0x0A: { pathString = "/L4"; break; }
                      case 0x0B: { pathString = "/MCS"; break; }
                      case 0x0D: { pathString = "/MBA"; break; }
                      case 0x0E: { pathString = "/XBUS"; break; }
                      case 0x0F: { pathString = "/ABUS"; break; }
                      case 0x10: { pathString = "/PCI"; break; }
                      case 0x11: { pathString = "/DPSS"; break; }
                      case 0x12: { pathString = "/APSS"; break; }
                      case 0x13: { pathString = "/OCC"; break; }
                      case 0x14: { pathString = "/PSI"; break; }
                      case 0x15: { pathString = "/FSP"; break; }
                      case 0x16: { pathString = "/PNOR"; break; }
                      case 0x17: { pathString = "/OSC"; break; }
                      case 0x18: { pathString = "/TODCLK"; break; }
                      case 0x19: { pathString = "/CONTROL_NODE"; break; }
                      case 0x1A: { pathString = "/OSCREFCLK"; break; }
                      case 0x1B: { pathString = "/OSCPCICLK"; break; }
                      case 0x1C: { pathString = "/REFCLKENDPT"; break; }
                      case 0x1D: { pathString = "/PCICLKENDPT"; break; }
                      case 0x1E: { pathString = "/NX"; break; }
                      case 0x1F: { pathString = "/PORE"; break; }
                      case 0x20: { pathString = "/PCIESWITCH"; break; }
                      case 0x21: { pathString = "/CAPP"; break; }
                      case 0x22: { pathString = "/FSI"; break; }
                      case 0x23: { pathString = "/EQ"; break; }
                      case 0x24: { pathString = "/MCA"; break; }
                      case 0x25: { pathString = "/MCBIST"; break; }
                      case 0x26: { pathString = "/MI"; break; }
                      case 0x27: { pathString = "/DMI"; break; }
                      case 0x28: { pathString = "/OBUS"; break; }
                      case 0x2A: { pathString = "/SBE"; break; }
                      case 0x2B: { pathString = "/PPE"; break; }
                      case 0x2C: { pathString = "/PERV"; break; }
                      case 0x2D: { pathString = "/PEC"; break; }
                      case 0x2E: { pathString = "/PHB"; break; }
                      case 0x2F: { pathString = "/SYSREFCLKENDPT"; break; }
                      case 0x30: { pathString = "/MFREFCLKENDPT"; break; }
                      case 0x31: { pathString = "/TPM"; break; }
                      case 0x32: { pathString = "/SP"; break; }
                      case 0x33: { pathString = "/UART"; break; }
                      case 0x34: { pathString = "/PS"; break; }
                      case 0x35: { pathString = "/FAN"; break; }
                      case 0x36: { pathString = "/VRM"; break; }
                      case 0x37: { pathString = "/USB"; break; }
                      case 0x38: { pathString = "/ETH"; break; }
                      case 0x39: { pathString = "/PANEL"; break; }
                      case 0x3A: { pathString = "/BMC"; break; }
                      case 0x3B: { pathString = "/FLASH"; break; }
                      case 0x3C: { pathString = "/SEEPROM"; break; }
                      case 0x3D: { pathString = "/TMP"; break; }
                      case 0x3E: { pathString = "/GPIO_EXPANDER"; break; }
                      case 0x3F: { pathString = "/POWER_SEQUENCER"; break; }
                      case 0x40: { pathString = "/RTC"; break; }
                      case 0x41: { pathString = "/FANCTLR"; break; }
                      case 0x42: { pathString = "/OBUS_BRICK"; break; }
                      case 0x43: { pathString = "/NPU"; break; }
                      case 0x44: { pathString = "/MC"; break; }
                      case 0x45: { pathString = "/TEST_FAIL"; break; }
                      case 0x46: { pathString = "/MFREFCLK"; break; }
                      case 0x47: { pathString = "/SMPGROUP"; break; }
                      case 0x48: { pathString = "/OMI"; break; }
                      case 0x49: { pathString = "/MCC"; break; }
                      case 0x4A: { pathString = "/OMIC"; break; }
                      case 0x4B: { pathString = "/OCMB_CHIP"; break; }
                      case 0x4C: { pathString = "/MEM_PORT"; break; }
                      case 0x4D: { pathString = "/I2C_MUX"; break; }
                      case 0x4E: { pathString = "/PMIC"; break; }
                      case 0x4F: { pathString = "/NMMU"; break; }
                      case 0x50: { pathString = "/PAU"; break; }
                      case 0x51: { pathString = "/IOHS"; break; }
                      case 0x52: { pathString = "/PAUC"; break; }
                      case 0x53: { pathString = "/FC"; break; }
                      case 0x54: { pathString = "/LPCREFCLKENDPT"; break; }
                      case 0x55: { pathString = "/GENERIC_I2C_DEVICE"; break; }
                      case 0x56: { pathString = "/MDS_CTLR"; break; }
                      case 0x57: { pathString = "/DCM"; break; }
                      case 0x66: { pathString = "/POWER_IC"; break; }
                      case 0x67: { pathString = "/TEMP_SENSOR"; break; }
                      case 0x68: { pathString = "/LAST_IN_RANGE"; break; }
                      default:   { pathString = "/UNKNOWN"; break; }
                  } // switch
                  // copy next part in, overwritting previous terminator
                  dataSize += sprintf(&(l_traceEntry[0]) + dataSize, "%s%d",pathString,lElementInstance[i+1]);
                  l_ptr += 2 * sizeof(uint8_t);
              } // for
              break;
          }
          case 0x25ef505: {
              //simpleType:uint
              pLabel = "CHTM_MODE_LLAT_IMBEDDED_TS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x2601b9e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x260fed1: {
              //simpleType:uint
              pLabel = "SBE_BOOTLOADER_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x263ef7e: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ODTLON_RD_NT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x2641d60: {
              //simpleType:uint
              pLabel = "SBE_SECURE_BOOT_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2659dd9: {
              //simpleType:uint
              pLabel = "DEFAULT_NEST_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x268a991: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_CL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x26a0f2c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_MFG_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x26a1129: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_WRITE_DBI";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x26ecfec: {
              //simpleType:uint
              pLabel = "EXTENDED_FREQ_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2716b4f: {
              //simpleType:uint
              pLabel = "DLR_PLSF_OVERRIDE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x2751df0: {
              //simpleType:uint
              pLabel = "RCW0F_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2754e20: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_OCC_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2763107: {
              //simpleType:uint
              pLabel = "PMIC_CALLBACK_STAGGER_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x278bc56: {
              //simpleType:uint
              pLabel = "FRU_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2790722: {
              //simpleType:enum
              pLabel = "PNOR_PARTITION_SIDE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "PNOR_PARTITION_SIDE_SIDEA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "PNOR_PARTITION_SIDE_SIDEB");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "PNOR_PARTITION_SIDE_INVALID");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x27a866f: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_CA_ODT_PER_DRAM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 7);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 160 * sizeof(uint16_t);
              break;
          }
          case 0x27bb801: {
              //simpleType:uint
              pLabel = "MEM_EXP_RCD_VOLTAGE_CTRL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x28068b9: {
              //simpleType:uint
              pLabel = "EFF_HOSTBOOT_IMG_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x280b074: {
              //simpleType:uint
              pLabel = "CLOCK_MUX_PCI_LCPLL_INPUT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x284334b: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2851ca1: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x285a024: {
              //simpleType:uint
              pLabel = "ODY_PHY_CONFIG_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x28f86dd: {
              //simpleType:uint
              pLabel = "MEM_MPSM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x290257b: {
              //simpleType:uint
              pLabel = "WOV_OVERV_EXTENDED_MAX_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x29081fa: {
              //simpleType:uint
              pLabel = "PROC_EPS_GB_PERCENTAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2914dff: {
              //simpleType:uint
              pLabel = "AVSBUS_BUSNUM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x2925ef3: {
              //simpleType:uint
              pLabel = "DDR5_TX_DM_PREAMBLE_PATTERN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x295e3af: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ODTLOFF_WR_NT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x2996256: {
              //simpleType:uint
              pLabel = "SYSTEM_IVRM_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2997eae: {
              //simpleType:uint
              pLabel = "MSS_MRW_DRAM_2N_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x29bcc00: {
              //simpleType:uint
              pLabel = "NUM_KEY_ADDR_PAIR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x29bf0cb: {
              //simpleType:uint
              pLabel = "OMI_CHANNEL_LENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x29d3a9f: {
              //simpleType:uint
              pLabel = "HB_HRMOR_BYTES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x29e9ba8: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2a254db: {
              //simpleType:uint
              pLabel = "OVERRIDE_FREQ_PROC_REFCLOCK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2a4b620: {
              //simpleType:uint
              pLabel = "MIN_NUM_PSI_LINKS_PER_FSP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2a9cfd3: {
              //simpleType:uint
              pLabel = "VDD_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x2ab342e: {
              //simpleType:uint
              pLabel = "SLW_IN_CHECKSTOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2ab46d8: {
              //simpleType:uint
              pLabel = "EXP_RUNTIME_MEM_M_DRAM_CLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2af1514: {
              //simpleType:uint
              pLabel = "RCW45_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2afc21f: {
              //simpleType:uint
              pLabel = "ZERO_CORE_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2b00bff: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VPP_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2b044eb: {
              //simpleType:uint
              pLabel = "ATTN_AREA_1_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x2b1e162: {
              //simpleType:uint
              pLabel = "ODY_DIS_PTRINITCLR_TXTRACKING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2b21694: {
              //simpleType:uint
              pLabel = "MSS_MNFG_EDPL_THRESHOLD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2b23c7c: {
              //simpleType:uint
              pLabel = "SBE_UPDATE_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2b5f6b7: {
              //simpleType:uint
              pLabel = "MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2b732f9: {
              break;
          }
          case 0x2b742a3: {
              //simpleType:uint
              pLabel = "MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x2b8523d: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TCCD_L";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2b8d151: {
              //simpleType:uint
              pLabel = "PROC_DCM_INSTALLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2bf8757: {
              //simpleType:uint
              pLabel = "EX_INSIDE_SPECIAL_WAKEUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2bfa1f9: {
              //simpleType:uint
              pLabel = "CME_CHTM_TRACE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2c12791: {
              //simpleType:uint
              pLabel = "MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2c13580: {
              //simpleType:uint
              pLabel = "ICACHE_BLOCK_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2c34124: {
              //simpleType:uint
              pLabel = "MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2c3dd0b: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_SOURCE_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2cb2b25: {
              //simpleType:uint
              pLabel = "ODY_PHY_USE_BROADCAST_MR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2cf6852: {
              //simpleType:uint
              pLabel = "ISTEP_PAUSE_CONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x2d07bed: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_MODULE_HEIGHT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2d207b6: {
              //simpleType:uint
              pLabel = "FABRIC_TO_PHYSICAL_NODE_MAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x2d47f25: {
              //simpleType:uint
              pLabel = "MFG_SCREEN_OMI_EDPL_ALLOWED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x2d5e154: {
              //simpleType:uint
              pLabel = "IO_IOHS_XTALK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2d603ab: {
              //simpleType:uint
              pLabel = "NEST_DPLL_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2d6153f: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_SLEW_RATE_CLK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x2d75431: {
              //simpleType:uint
              pLabel = "PRIMARY_SEEPROM_FAIL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2d75ccd: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRCD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2d9433b: {
              //simpleType:uint
              pLabel = "OBUS_BRICK_LANE_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2d95c98: {
              break;
          }
          case 0x2da9fc2: {
              //simpleType:uint
              pLabel = "ODY_PHY_CA_TRAIN_OPTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2dae314: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_PORT1_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2dc6337: {
              //simpleType:uint
              pLabel = "SBE_MEASUREMENT_SEEPROM_VERSION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2dc6458: {
              //simpleType:uint
              pLabel = "SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2dd7524: {
              //simpleType:uint
              pLabel = "EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x2df5e4a: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_OUTPUT_BUFFER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2e0dedf: {
              //simpleType:uint
              pLabel = "CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x2e199fe: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_IMP_CNTL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x2e226ad: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2e3af06: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2e48910: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDP_COMPATIBILITY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x2e5f49c: {
              //simpleType:uint
              pLabel = "CHIPLET_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2e92774: {
              //simpleType:uint
              pLabel = "SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2e988c0: {
              //simpleType:uint
              pLabel = "ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x2e9bbeb: {
              //simpleType:uint
              pLabel = "MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[50]:");
              l_traceEntry.resize(10+offset + 50 * 19);
              for (uint32_t i = 0;i<50;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 50 * sizeof(uint64_t);
              break;
          }
          case 0x2eccc49: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_DLR_PSAVE_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2eda5ab: {
              //simpleType:uint
              pLabel = "NO_XSCOM_ENFORCEMENT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2ef58ce: {
              //simpleType:uint
              pLabel = "WOF_OMI_FORCE_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2efe391: {
              //simpleType:uint
              pLabel = "SYSTEM_OCS_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2f0f359: {
              //simpleType:uint
              pLabel = "MFG_FLAGS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x2f2f11c: {
              //simpleType:uint
              pLabel = "EFF_DRAM_COLUMN_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x2f4ac23: {
              //simpleType:uint
              pLabel = "SYSTEM_DDS_FREQ_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2fae486: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_MPR_RD_FORMAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2fc08c0: {
              //simpleType:uint
              pLabel = "OCS_WITH_DDS_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x2fcf5a5: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_FREEZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x2fd4ceb: {
              //simpleType:uint
              pLabel = "MSL_FIELD_SUPPORTED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[12]:");
              l_traceEntry.resize(10+offset + 12 * 7);
              for (uint32_t i = 0;i<12;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 12 * sizeof(uint16_t);
              break;
          }
          case 0x2fd62ba: {
              //simpleType:uint
              pLabel = "XGPE_BOOT_COPIER_IVPR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x2ff4978: {
              //simpleType:uint
              pLabel = "RCW49_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x309917b: {
              //simpleType:uint
              pLabel = "SYS_ENABLE_MC_HW520600_X4CTR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x30c07c8: {
              //simpleType:uint
              pLabel = "PNOR_FLASH_WORKAROUNDS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x30c46b3: {
              //simpleType:uint
              pLabel = "REL_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x30cbc29: {
              //simpleType:uint
              pLabel = "TEST_NEGATIVE_FCN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x310948f: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_RD_PREAMBLE_TRAIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3126bb2: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_REDUNDANCY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x313a22a: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_RD_PREAMBLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x314253a: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC5X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x317b181: {
              //simpleType:uint
              pLabel = "FCO_SUPPORTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x317b69f: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x31a8e4b: {
              //simpleType:uint
              pLabel = "SKEWADJ_CACHE_PDLY_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x326b38b: {
              //simpleType:uint
              pLabel = "FSP_VDDR_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x326c7fd: {
              //simpleType:uint
              pLabel = "ODY_ENABLE_US_TMPL_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x326e0e2: {
              //simpleType:uint
              pLabel = "MSS_OCMB_ENTERPRISE_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x32adc69: {
              //complexType - skipping
              break;
          }
          case 0x32c01e3: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC0F";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x32cec3d: {
              //simpleType:uint
              pLabel = "SAVED_DLP_FIR_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x32cf5cd: {
              break;
          }
          case 0x32d623a: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VCS_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x32d84bd: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VCS_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x32d9a77: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x32f9c30: {
              //simpleType:uint
              pLabel = "CONTAINED_LOAD_PATH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x32ff12d: {
              //simpleType:uint
              pLabel = "MSS_EXP_FW_VERSION_B";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3310305: {
              //simpleType:uint
              pLabel = "DDS_TRIP_INTERPOLATION_CONTROL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3317838: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VDDR_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3322938: {
              //simpleType:uint
              pLabel = "PEC_PCIE_IOP_REVERSAL_BIFURCATED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x3322c7e: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_TX_SLEW_FALL_CK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3332949: {
              //simpleType:uint
              pLabel = "OMI_BIST_TIMER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3342c24: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SEQUENCE_CFG1_R41";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3351ea6: {
              //simpleType:uint
              pLabel = "PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x335e006: {
              //simpleType:uint
              pLabel = "SECURE_VERSION_LOCKIN_POLICY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3371dc2: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x33a20f8: {
              //simpleType:uint
              pLabel = "DDS_DPLL_FMAX_FAST_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x33afdd0: {
              //complexType - skipping
              break;
          }
          case 0x343de3b: {
              //simpleType:uint
              pLabel = "PROC_INT_NVPG_BAR_RANGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x346c2dc: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SEQUENCE_CFG2_R42";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x347b055: {
              //simpleType:uint
              pLabel = "PROC_TMPL_1_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x347eff6: {
              //simpleType:uint
              pLabel = "HOSTBOOT_HRMOR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x34c35e2: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x34e5f5b: {
              //simpleType:uint
              pLabel = "RCW09_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x34eeb58: {
              //simpleType:uint
              pLabel = "FABRIC_CHIP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3519971: {
              //simpleType:uint
              pLabel = "WOF_VRATIO_VCS_10THPCT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 8 * sizeof(uint16_t);
              break;
          }
          case 0x355e81c: {
              //simpleType:uint
              pLabel = "OMI_TX_PRE2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3565220: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x359f511: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x35d5e3f: {
              //simpleType:uint
              pLabel = "OCMB_REL_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36519d8: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_RD_PREAMBLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x365d06b: {
              //simpleType:uint
              pLabel = "MEM_EFF_PSTATES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x36ac7a5: {
              //simpleType:uint
              pLabel = "PROC_SELECT_SEEPROM_IMAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36b1670: {
              //simpleType:uint
              pLabel = "PDW_TRACE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36b5355: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x36cb5ff: {
              //simpleType:uint
              pLabel = "ISTEP_CALLOUT_INJECT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36db145: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36e454b: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_ATTACHED_LINK_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x36ea053: {
              //simpleType:uint
              pLabel = "SYSTEM_VDM_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36ebdf0: {
              //simpleType:uint
              pLabel = "PBAO_LFIRMASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x36f124b: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_CRC_WR_LATENCY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36f90c5: {
              //simpleType:uint
              pLabel = "BOOT_PAU_DPLL_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x36fb870: {
              //simpleType:enum
              pLabel = "SBE_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "SBE_STATE_NOT_USABLE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "SBE_STATE_BOOTED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "SBE_STATE_CHECK_CFAM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "SBE_STATE_DEBUG_MODE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "SBE_STATE_FAILED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000005: {
                      sprintf(&(l_traceEntry[0]), "SBE_STATE_UNKNOWN");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x3712d9f: {
              //simpleType:uint
              pLabel = "ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3761a65: {
              //simpleType:uint
              pLabel = "SYNC_BETWEEN_STEPS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x37796c6: {
              //simpleType:uint
              pLabel = "SAFE_MODE_THROTTLE_IDX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x37e48f5: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_CA_PARITY_ERROR_STATUS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x38313b7: {
              //simpleType:uint
              pLabel = "EFF_REGISTER_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x3849826: {
              //simpleType:uint
              pLabel = "PROC_MEM_BASES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x3883186: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_PRESENT_GROUPS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3884378: {
              //simpleType:uint
              pLabel = "MRW_DEFAULT_RISK_LEVEL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x38a35a1: {
              //simpleType:uint
              pLabel = "FREQ_X_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x38a7b13: {
              //simpleType:uint
              pLabel = "PRD_HWP_PLID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x38a9ed0: {
              //simpleType:uint
              pLabel = "MSS_EXP_FW_VERSION_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x38da24e: {
              //simpleType:uint
              pLabel = "OMI_DL_NUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x38feb73: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3917523: {
              //simpleType:uint
              pLabel = "WOF_DCCR_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x392c87c: {
              //simpleType:uint
              pLabel = "RCW44_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3952eeb: {
              //simpleType:uint
              pLabel = "PHY_GET_MAIL_TIMEOUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x39691ca: {
              //simpleType:uint
              pLabel = "SAFE_MODE_FREQUENCY_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3982c85: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_PHASE_COMB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x399d463: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_WR_VREFDQ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0x39e6bbf: {
              //simpleType:uint
              pLabel = "ENABLE_FIR_UNMASKING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3a1816c: {
              //complexType - skipping
              break;
          }
          case 0x3a53581: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_RTT_NOM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x3a9b8a6: {
              //simpleType:uint
              pLabel = "SYSTEM_COMPAT_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3aa234f: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VPP_INTERCEPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3ad5ca0: {
              //simpleType:uint
              pLabel = "NHTM_HTMSC_MODE_SYNC_STAMP_FORCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3b00047: {
              //simpleType:uint
              pLabel = "MEM_SI_DRAM_PREAMBLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x3b039dc: {
              //complexType - skipping
              break;
          }
          case 0x3b1ed0d: {
              //simpleType:uint
              pLabel = "WOV_OVERV_VMAX_SETPOINT_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3b6e39f: {
              //complexType - skipping
              break;
          }
          case 0x3b80bcf: {
              //simpleType:uint
              pLabel = "QME_HCODE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3b8b4a9: {
              //simpleType:uint
              pLabel = "MEM_EFF_MRAM_SUPPORT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x3b98454: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3baf9ca: {
              break;
          }
          case 0x3bb3b7a: {
              //simpleType:uint
              pLabel = "ODY_LP2_PWRSAVINGS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3be1427: {
              //simpleType:uint
              pLabel = "WOF_TABLE_OVERRIDE_RC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3c0bdfa: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8][2]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0x3c24379: {
              //not readable
              break;
          }
          case 0x3c26b28: {
              //simpleType:uint
              pLabel = "MSS_IS_APOLLO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3ca6acc: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_DLL_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3cedd73: {
              //simpleType:uint
              pLabel = "MSS_EXP_I2C_FW_LOG_DUMP_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3cf621f: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_TX_SLEW_FALL_DQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3d086ed: {
              //simpleType:uint
              pLabel = "WOF_TABLE_OVERRIDE_PS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3d1a60f: {
              //simpleType:uint
              pLabel = "RCD_PARITY_RECONFIG_LOOPS_ALLOWED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3d3e8d5: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC05";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x3d57633: {
              //simpleType:uint
              pLabel = "WOF_TABLE_IO_POWER_BASE_W";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3d6c66d: {
              //simpleType:uint
              pLabel = "ODY_TMPL_0_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3d7757a: {
              //simpleType:uint
              pLabel = "ALTFSI_MASTER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3d77935: {
              //simpleType:uint
              pLabel = "MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3d84c2e: {
              //simpleType:uint
              pLabel = "HTMSC_MODE_SINGLE_TSTAMP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3da9467: {
              //simpleType:uint
              pLabel = "CORE_LPAR_MODE_POLICY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3dbc21a: {
              //simpleType:uint
              pLabel = "VDDR_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3ddbd96: {
              //simpleType:uint
              pLabel = "OCMB_BOOT_FLAGS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3df05de: {
              //simpleType:uint
              pLabel = "SPI_BUS_DIV_REF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3df34de: {
              //complexType - skipping
              break;
          }
          case 0x3e06229: {
              //simpleType:uint
              pLabel = "RCW48_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3e06dcd: {
              //simpleType:uint
              pLabel = "MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3e10c4b: {
              //simpleType:uint
              pLabel = "RCW0F_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3e2ad88: {
              //simpleType:uint
              pLabel = "TPM_UNUSABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3e336e0: {
              //simpleType:uint
              pLabel = "PM_SPIPSS_INTER_FRAME_DELAY_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3e38294: {
              //simpleType:uint
              pLabel = "FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3e7ad0d: {
              //simpleType:uint
              pLabel = "MSS_CENT_VDD_SLOPE_INACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x3e8c6de: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3eb05bb: {
              //simpleType:uint
              pLabel = "IOHS_MNFG_BAD_LANE_DURATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3eda036: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_MAX_POWERDOWN_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3f2ddb0: {
              //simpleType:uint
              pLabel = "EXP_DIMM_THERMAL_LIMIT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 11);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint32_t);
              break;
          }
          case 0x3f4dd16: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC03";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x3f6b102: {
              //simpleType:uint
              pLabel = "MEM_3DS_HEIGHT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x3f7b7e7: {
              //simpleType:uint
              pLabel = "ODY_EN_RXDQS_TRACKING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3f8999b: {
              //simpleType:uint
              pLabel = "MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x3fa5781: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3fd6b69: {
              //simpleType:uint
              pLabel = "EC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x3fe9f90: {
              //simpleType:uint
              pLabel = "PROC_XSCOM_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x401fdfd: {
              //simpleType:uint
              pLabel = "FFO_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x40202e1: {
              //simpleType:uint
              pLabel = "MEM_DDR5_REF_TUF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4028ad3: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4028d5e: {
              //simpleType:uint
              pLabel = "SYSTEM_RING_DBG_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x404b923: {
              //simpleType:uint
              pLabel = "ODY_D5MISC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4068890: {
              //simpleType:uint
              pLabel = "SKIP_RD_VREF_VREFSENSE_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x40aa7b9: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x40bfda4: {
              //simpleType:uint
              pLabel = "MSS_MRW_ALLOW_UNSUPPORTED_RCW";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x40c76ee: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x413ef1d: {
              //simpleType:uint
              pLabel = "MSS_EXP_REORDER_QUEUE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x41415b6: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_WIDTH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x414abdc: {
              //simpleType:uint
              pLabel = "MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4194918: {
              //simpleType:uint
              pLabel = "TCE_START_TOKEN_FOR_HDAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x41ed7c4: {
              //simpleType:uint
              pLabel = "MSS_INTERLEAVE_GRANULARITY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x420d32d: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x420ee16: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_COLUMN_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x421ef26: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_ASYNC_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4221eb9: {
              //simpleType:uint
              pLabel = "DUMP_STOP_INFO_ENABLE_ERRORLOG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4222d51: {
              //simpleType:uint
              pLabel = "RUNN_MASTER_SEED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x423512e: {
              //simpleType:uint
              pLabel = "MSS_OCMB_PHY_INIT_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x424be69: {
              //simpleType:uint
              pLabel = "MSS_MRW_NVDIMM_PLUG_RULES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x4269836: {
              //complexType - skipping
              break;
          }
          case 0x428de15: {
              //complexType - skipping
              break;
          }
          case 0x428e6a8: {
              break;
          }
          case 0x42964ef: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x42aac82: {
              //simpleType:uint
              pLabel = "RCW46_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x42af08e: {
              //simpleType:uint
              pLabel = "OMI_DL_PREIPL_PRBS_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x42b4fae: {
              //simpleType:uint
              pLabel = "MSS_CENT_VCS_INTERCEPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x42d226a: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x42f81c1: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC7X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x4313fe7: {
              //simpleType:uint
              pLabel = "CLOCK_MUX2B_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x434f057: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_ERROR_ON_FAILURE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4354d61: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_IMP_CSCID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x4362604: {
              //simpleType:uint
              pLabel = "SECURITY_LEVEL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4367508: {
              //simpleType:uint
              pLabel = "IS_SIMULATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x436dd94: {
              //simpleType:uint
              pLabel = "TLB_INSTR_ENTRIES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4386d3c: {
              break;
          }
          case 0x43a0d7e: {
              //simpleType:uint
              pLabel = "EFF_RCD_MFG_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0x43ba247: {
              //simpleType:uint
              pLabel = "PEC_PCIE_HX_KEYWORD_DATA";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[9]:");
              l_traceEntry.resize(10+offset + 9 * 5);
              for (uint32_t i = 0;i<9;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 9 * sizeof(uint8_t);
              break;
          }
          case 0x43cb904: {
              //simpleType:uint
              pLabel = "EFF_HYBRID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x440bec8: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TWTR_S";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x442b881: {
              //complexType - skipping
              break;
          }
          case 0x44451f9: {
              //simpleType:uint
              pLabel = "RCW00_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4447a44: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_CS_ODT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0x446e9d5: {
              //simpleType:uint
              pLabel = "RCW45_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4479a4c: {
              //simpleType:uint
              pLabel = "PROC_CHTM_BAR_SIZES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 19);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 32 * sizeof(uint64_t);
              break;
          }
          case 0x448c629: {
              //simpleType:uint
              pLabel = "MSS_OCMB_APPINTR_OBJ_HANDLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x44a66ec: {
              //simpleType:uint
              pLabel = "WOF_IO_POWER_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x44eae3a: {
              //simpleType:enum
              pLabel = "OCMB_FW_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "OCMB_FW_STATE_UNKNOWN");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "OCMB_FW_STATE_UP_TO_DATE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "OCMB_FW_STATE_OUT_OF_DATE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x44f4167: {
              //complexType - skipping
              break;
          }
          case 0x45149fa: {
              //simpleType:uint
              pLabel = "LPC_CONSOLE_CNFG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4523b41: {
              //simpleType:uint
              pLabel = "OMI_RX_LTEZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(INT32_FROM_PTR(reinterpret_cast<const int32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int32_t);
              break;
          }
          case 0x452cbf0: {
              //simpleType:uint
              pLabel = "MSS_MRW_DDR5_DRAM_READ_CRC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x45764b5: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x45769cb: {
              //simpleType:uint
              pLabel = "DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x45a548d: {
              //simpleType:uint
              pLabel = "MEM_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x45b1c68: {
              //simpleType:enum
              pLabel = "RISK_LEVEL_ORIGIN";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "RISK_LEVEL_ORIGIN_USER");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "RISK_LEVEL_ORIGIN_MRW");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x45f1d0e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SEQUENCE_CFG0_R40";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4611411: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x461601a: {
              //simpleType:uint
              pLabel = "IO_IOHS_PRE2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x46189b8: {
              //simpleType:uint
              pLabel = "CONTAINED_IPL_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x46304b2: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x464339e: {
              //simpleType:uint
              pLabel = "MSS_MRW_OCMB_RESET_GROUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x464bfaf: {
              //simpleType:uint
              pLabel = "NHTM_HTMSC_MODE_CAPTURE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x465e7ca: {
              //simpleType:uint
              pLabel = "MEM_DDR5_GLOBAL_DFE_TAP4";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x467a7c6: {
              //simpleType:uint
              pLabel = "AUX_FUNC_INVOCATION_TIME_MS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x46a1caf: {
              //simpleType:uint
              pLabel = "HTMSC_MODE_VGTARGET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x46af527: {
              //simpleType:uint
              pLabel = "ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x46cca69: {
              //simpleType:uint
              pLabel = "C0_EXEC_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x470d34f: {
              //simpleType:uint
              pLabel = "POWERSAVE_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x472b4fc: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_XSTOP_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x473b72c: {
              break;
          }
          case 0x47688d7: {
              //simpleType:uint
              pLabel = "EXPLR_METADATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x47770b9: {
              //simpleType:uint
              pLabel = "RCW0A_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x47b7017: {
              //simpleType:uint
              pLabel = "FREQ_DPLL_REFCLOCK_KHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x47d4973: {
              //simpleType:uint
              pLabel = "HCSI_CHIP_INTERFACE_PTR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x47d766c: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_SOFT_PPR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x47de4ea: {
              //simpleType:uint
              pLabel = "HTMSC_TTAGFILT_INVERT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x47f04dc: {
              break;
          }
          case 0x4820f8b: {
              //simpleType:uint
              pLabel = "SYSTEM_PDV_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x482b817: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_EFF_TOPOLOGY_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x483910a: {
              //simpleType:uint
              pLabel = "DDR5_TX_DQ_PREAMBLE_PATTERN_U1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x484fa88: {
              //simpleType:uint
              pLabel = "RUNN_THREAD_SEEDS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 19);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint64_t);
              break;
          }
          case 0x4851132: {
              //simpleType:uint
              pLabel = "PM_FIRINIT_DONE_ONCE_FLAG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x486d205: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_EQ_DQ_DQS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x486f50e: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_RANKS_CONFIGED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x4871927: {
              //simpleType:uint
              pLabel = "SYSTEM_DDS_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x48a8902: {
              //simpleType:uint
              pLabel = "PROC_PCIE_IOVALID_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x48b4eb2: {
              //simpleType:enum
              pLabel = "FOUND_PRESENT_BY_SP";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "FOUND_PRESENT_BY_SP_NO_ATTEMPT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "FOUND_PRESENT_BY_SP_FOUND");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "FOUND_PRESENT_BY_SP_MISSING");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "FOUND_PRESENT_BY_SP_SKIP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x48c79e0: {
              //simpleType:uint
              pLabel = "WOF_FLMR_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x48dfadb: {
              //simpleType:uint
              pLabel = "ODY_ALERT_RECOV_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x48e4bf5: {
              //simpleType:uint
              pLabel = "OMI_TX_PRE1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4916096: {
              //simpleType:uint
              pLabel = "ECO_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4934fda: {
              //simpleType:uint
              pLabel = "EFF_PRIM_STACK_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x4950959: {
              //simpleType:uint
              pLabel = "IOHS_CONFIG_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4971d0d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x49b1d2e: {
              //simpleType:uint
              pLabel = "FREQ_CORE_FLOOR_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x49b21cc: {
              //simpleType:uint
              pLabel = "IVRM_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x49eb22a: {
              //simpleType:uint
              pLabel = "IOHS_MNFG_BAD_LANE_MAX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x49f38fe: {
              //simpleType:uint
              pLabel = "PG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4a3e94f: {
              //simpleType:uint
              pLabel = "EECACHE_DISABLE_AUTO_RESET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4a69bbd: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4a70af5: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_CHIP1_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4a72e5b: {
              //simpleType:uint
              pLabel = "MEM_IGNORE_PLUG_RULES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4a76d45: {
              //simpleType:uint
              pLabel = "HWAS_STATE_CHANGED_SUBSCRIPTION_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x4aa1c38: {
              //simpleType:uint
              pLabel = "MSS_ODY_PHY_IMAGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4ac8a0d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4b12a86: {
              break;
          }
          case 0x4b21c2c: {
              //simpleType:uint
              pLabel = "CLOCK_MUX_IOHS_LCPLL_INPUT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x4b2ea2d: {
              //simpleType:uint
              pLabel = "SYS0_REFCLOCK_RCVR_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4b65c7e: {
              //simpleType:uint
              pLabel = "RCW01_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4b839c0: {
              //simpleType:uint
              pLabel = "PROC_PCIE_LANE_EQUALIZATION_GEN3";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[16]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0x4b8ed0c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4baf80d: {
              //simpleType:uint
              pLabel = "WOF_POWER_LIMIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4bbfd53: {
              //simpleType:uint
              pLabel = "EFF_DRAM_MFG_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0x4bf64b9: {
              //simpleType:uint
              pLabel = "PROC_EPS_READ_CYCLES_T1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4c1219d: {
              //simpleType:uint
              pLabel = "PM_SPWUP_IGNORE_XSTOP_FLAG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c334cb: {
              //simpleType:uint
              pLabel = "IOHS_PHY_TO_PAU_MAPPING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c3b83c: {
              //simpleType:uint
              pLabel = "RCW08_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c3ccba: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c3dbf1: {
              //simpleType:uint
              pLabel = "MSS_MRW_TEMP_REFRESH_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c3e08d: {
              //simpleType:uint
              pLabel = "MEM_DDR5_GLOBAL_DFE_TAP1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c42b9b: {
              //simpleType:uint
              pLabel = "PROC_SBE_MASTER_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4c51a2e: {
              //simpleType:uint
              pLabel = "PROC_R_DISTLOSS_UOHM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x4cb206d: {
              //simpleType:uint
              pLabel = "RCW0C_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4cb9215: {
              //simpleType:enum
              pLabel = "EEPROM_CONTENT_TYPE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_RAW");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_ISDIMM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_IBM_FRUVPD");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_IBM_MVPD");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_DDIMM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000005: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_SBE_BOOT_CODE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000006: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_SBE_MEASUREMENT_CODE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000007: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_WOF_DATA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000008: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_KEYSTORE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000009: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_CONTENT_TYPE_PLANAR_OCMB_SPD");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x4d2d908: {
              //simpleType:uint
              pLabel = "MSS_MRW_ALLOW_DDR5";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4d787f5: {
              //simpleType:uint
              pLabel = "PROC_MIRROR_SIZES_ACK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x4d84e76: {
              //simpleType:uint
              pLabel = "MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4d911fa: {
              //simpleType:uint
              pLabel = "SYSTEM_WOV_UNDERV_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4d9c040: {
              //simpleType:uint
              pLabel = "PRIORITY_PSI_LINK_SELECTION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4da870d: {
              //simpleType:uint
              pLabel = "PCI0_REFCLOCK_RCVR_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4e0385e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4e64812: {
              //simpleType:uint
              pLabel = "PSI_HB_ESB_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x4e64981: {
              //simpleType:uint
              pLabel = "NOMINAL_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4ea37f9: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_SERIAL_NUMBER";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[26]:");
              l_traceEntry.resize(10+offset + 26 * 5);
              for (uint32_t i = 0;i<26;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 26 * sizeof(uint8_t);
              break;
          }
          case 0x4eb8996: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC0B";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x4ebab49: {
              //simpleType:uint
              pLabel = "SADDLEBACK_VRM_ROLLOVER_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4ebecae: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4ec2278: {
              //simpleType:uint
              pLabel = "BOOT_VOLTAGE_BIAS_0P5PCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4ee84c2: {
              break;
          }
          case 0x4eee267: {
              //simpleType:uint
              pLabel = "ODY_WL_ADJ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4f0f469: {
              //simpleType:uint
              pLabel = "MSS_VOLT_AVDD_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x4f60a5e: {
              //simpleType:uint
              pLabel = "MSS_MRW_RESET_DELAY_BEFORE_CAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x4fe6548: {
              //simpleType:uint
              pLabel = "RECONFIG_LOOP_TESTS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 19);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 5 * sizeof(uint64_t);
              break;
          }
          case 0x501a584: {
              break;
          }
          case 0x501dc5e: {
              //simpleType:uint
              pLabel = "MSS_EXP_OMI_CDR_BW_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x506af1e: {
              //simpleType:uint
              pLabel = "BUS_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x50892df: {
              //simpleType:uint
              pLabel = "EXPLR_ENABLE_US_TMPL_9";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5097420: {
              //simpleType:uint
              pLabel = "PMIC_HEALTH_CHECK_DDR5_TIMER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x50ba16b: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC05";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x5121315: {
              //simpleType:uint
              pLabel = "IO_O_MFG_STRESS_PR_OFFSET_EVEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x51289c7: {
              //simpleType:uint
              pLabel = "MSS_VDDR_PROGRAM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5154cf0: {
              //simpleType:uint
              pLabel = "FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x515fe7b: {
              //simpleType:uint
              pLabel = "EXPLR_PASID_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x5164d0c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5171c01: {
              //simpleType:uint
              pLabel = "ISTEP_PAUSE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5176174: {
              //simpleType:uint
              pLabel = "MEM_EFF_PRIM_BUS_WIDTH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x51cc341: {
              //simpleType:uint
              pLabel = "SLOT_INDEX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x51dd309: {
              //simpleType:uint
              pLabel = "HTMSC_MEM_PRIORITY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5207f78: {
              //simpleType:uint
              pLabel = "MBA_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5223195: {
              //simpleType:uint
              pLabel = "CHTM_MODE_DIS_TSTAMP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x522a158: {
              //simpleType:uint
              pLabel = "ECID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 19);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint64_t);
              break;
          }
          case 0x5297c70: {
              //simpleType:uint
              pLabel = "ODY_SIM_TCASL_ADD";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0x52aba1a: {
              //simpleType:uint
              pLabel = "RCW0C_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x52b38f3: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F1RC00";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x52de0d7: {
              //simpleType:uint
              pLabel = "ODY_PHY_TX2D_DFE_MISC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x52f654c: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_RD_POSTAMBLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x53689d6: {
              //simpleType:uint
              pLabel = "IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5390d2b: {
              //simpleType:uint
              pLabel = "HTMSC_MODE_WRAP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x53b8bd1: {
              //simpleType:uint
              pLabel = "MSS_EFF_WR_CRC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x53beb18: {
              //simpleType:uint
              pLabel = "WOF_THROTTLE_CONTROL_KI";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x53e9209: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC00";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x53f3625: {
              //simpleType:uint
              pLabel = "RESUME_PAYLOAD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5401234: {
              //simpleType:uint
              pLabel = "IOHS_FABRIC_TOD_CROSS_CONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5437d12: {
              //simpleType:uint
              pLabel = "L3_HASPOWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5450c2f: {
              //simpleType:uint
              pLabel = "RCW0D_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5464e01: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_DBG0_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x549cb5b: {
              //simpleType:uint
              pLabel = "PAYLOAD_STARTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x54d128f: {
              //simpleType:uint
              pLabel = "ISTEP_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x54fd267: {
              //simpleType:uint
              pLabel = "MSS_INTERLEAVE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x552f904: {
              //simpleType:uint
              pLabel = "MEM_VPD_DQ_MAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[80]:");
              l_traceEntry.resize(10+offset + 80 * 5);
              for (uint32_t i = 0;i<80;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 80 * sizeof(uint8_t);
              break;
          }
          case 0x5534fbf: {
              //simpleType:uint
              pLabel = "EFF_DRAM_SOFT_PPR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x558f98e: {
              //simpleType:uint
              pLabel = "MAX_NUM_PSI_LINKS_PER_FSP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x55a8aba: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_RCV_IMP_ALERT_N";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x55bf804: {
              //simpleType:uint
              pLabel = "PMCR_MOST_RECENT_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x55cb385: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_MFG_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x55ddfeb: {
              //simpleType:uint
              pLabel = "PROC_FAVOR_AGGRESSIVE_PREFETCH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x55f05dc: {
              //simpleType:uint
              pLabel = "CLOCK_MUX0B_RCS_PLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x55fe8eb: {
              //simpleType:uint
              pLabel = "EFF_DRAM_RANK_MIX";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x56566ef: {
              break;
          }
          case 0x565ee7d: {
              //simpleType:uint
              pLabel = "OCMB_CODE_UPDATED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5665717: {
              //simpleType:uint
              pLabel = "PROC_DSTLCFG_MMIO_ADDRBIT_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x56b3514: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR4_VDDR_INTERCEPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x56be955: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_ATTACHED_LINK_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x56cd34f: {
              //simpleType:uint
              pLabel = "SBE_MASTER_HRMOR_ADDRESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x56ef574: {
              //simpleType:uint
              pLabel = "IS_INTER_ENCLOSURE_BUS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x56efb21: {
              //simpleType:uint
              pLabel = "SYSTEM_WOF_DISABLE_DIMENSION";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 5);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 5 * sizeof(uint8_t);
              break;
          }
          case 0x56ff0f8: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_R_INDIRECT_EN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x570ac35: {
              //simpleType:uint
              pLabel = "PROC_INT_NVC_BAR_RANGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x571be23: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_INTERNAL_VREF_MONITOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x577af13: {
              //simpleType:uint
              pLabel = "SRAM_WRITE_ASSIST_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x579faa0: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x57ab3c7: {
              //simpleType:uint
              pLabel = "PROC_LPC_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x57acb4d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x57cb1d1: {
              //complexType - skipping
              break;
          }
          case 0x57f72b2: {
              //simpleType:uint
              pLabel = "DYNAMIC_INIT_MODE_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x5811f59: {
              //simpleType:enum
              pLabel = "PAYLOAD_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_STATE_NOT_LOADED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_STATE_RUNNING");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_STATE_STOPPED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x582dc2d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5834bdd: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_FW_DATA_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x588aed6: {
              //simpleType:uint
              pLabel = "SPIPSS_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5893c69: {
              //simpleType:uint
              pLabel = "MEM_EFF_NIBBLE_ENABLES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 11);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint32_t);
              break;
          }
          case 0x58a1971: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_COUNT_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x58a7917: {
              //simpleType:uint
              pLabel = "WOF_ENABLE_VRATIO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x58d355a: {
              //simpleType:uint
              pLabel = "WOV_MAX_DROOP_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x58e0f72: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_WR_PREAMBLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x58e2a3d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x58f9cb3: {
              //simpleType:uint
              pLabel = "SMF_MEM_AMT_REQUESTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x5910d31: {
              //simpleType:uint
              pLabel = "ODY_ACTAG_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x5921342: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC04";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x59253de: {
              //simpleType:uint
              pLabel = "DECONFIG_GARDABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x596417a: {
              //simpleType:uint
              pLabel = "MSL_MFG_ALLOW";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[12]:");
              l_traceEntry.resize(10+offset + 12 * 7);
              for (uint32_t i = 0;i<12;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 12 * sizeof(uint16_t);
              break;
          }
          case 0x597acd8: {
              //simpleType:uint
              pLabel = "CLOCK_MUX0D_RCS_PLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x59a4fc1: {
              //simpleType:uint
              pLabel = "FREQ_O_MHZ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x59b35d5: {
              //simpleType:uint
              pLabel = "POUNDV_BUCKET_NUM_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x59c3ee2: {
              //simpleType:uint
              pLabel = "ALLOW_EEPROM_WRITES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x59d033d: {
              //simpleType:uint
              pLabel = "PROC_INT_TM_BAR_PAGE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x59d7ace: {
              //simpleType:uint
              pLabel = "OCMB_ISTEP_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x59daf6e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5a2ffe9: {
              //simpleType:uint
              pLabel = "MEM_EXP_INIT_PHY_VREF";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x5a56a24: {
              //simpleType:uint
              pLabel = "MSS_OCMB_HALF_DIMM_MODE_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5a8ea4b: {
              //simpleType:uint
              pLabel = "C1_HASPOWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5ab3bbc: {
              //simpleType:uint
              pLabel = "CP_PLLTODFLT_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5ab71e7: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRRD_L";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x5add085: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_DBG1_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5b0aae0: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_TEMP_READOUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5b0d3bc: {
              //simpleType:uint
              pLabel = "RCD_PARITY_RECONFIG_LOOP_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5b3b3c9: {
              //simpleType:uint
              pLabel = "OMI_EDPL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5b6809b: {
              //simpleType:uint
              pLabel = "HB_FALLBACK_CORES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x5b7c99d: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x5bec079: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5c0af49: {
              //simpleType:uint
              pLabel = "MSS_MRW_OCMB_PWR_INTERCEPT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[50]:");
              l_traceEntry.resize(10+offset + 50 * 19);
              for (uint32_t i = 0;i<50;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 50 * sizeof(uint64_t);
              break;
          }
          case 0x5c4a180: {
              //simpleType:uint
              pLabel = "IO_O_MFG_CHK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5c5498f: {
              //simpleType:uint
              pLabel = "BOOT_VOLTAGE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x5c61990: {
              //complexType - skipping
              break;
          }
          case 0x5c63b38: {
              //complexType - skipping
              break;
          }
          case 0x5c75b22: {
              //simpleType:uint
              pLabel = "I2C_BUS_SPEED_ARRAY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4][16]:");
              l_traceEntry.resize(10+offset + 64 * 7);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 64 * sizeof(uint16_t);
              break;
          }
          case 0x5cdae1e: {
              //simpleType:uint
              pLabel = "MEM_DRAM_ADDRESS_MIRRORING";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x5ced586: {
              //simpleType:uint
              pLabel = "RCW40_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5cf9d4a: {
              //simpleType:uint
              pLabel = "DDR5_TX_DQ_PREAMBLE_PATTERN_U0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5d2467e: {
              //simpleType:uint
              pLabel = "RCW46_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5d36cba: {
              //simpleType:uint
              pLabel = "I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5d3796a: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PHB_ACTIVE_BASE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0x5d56393: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR4_VDDR_SLOPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x5d59877: {
              //simpleType:uint
              pLabel = "PROC_LCO_MODE_SETUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5d7eb9f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5d966f9: {
              //simpleType:uint
              pLabel = "MSS_POST_MEMDIAGS_READ_SUBTEST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5da8533: {
              //simpleType:uint
              pLabel = "MRW_P1PF_MIN_CONFIDENCE_3";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5dd7e45: {
              //simpleType:uint
              pLabel = "SYSTEM_POUNDV_VALIDITY_HALT_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5e0f70a: {
              //simpleType:uint
              pLabel = "MEM_EFF_VOLT_VDDQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x5e154c1: {
              //simpleType:uint
              pLabel = "RVRM_DEADZONE_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5e6c304: {
              //simpleType:uint
              pLabel = "WOF_THROTTLE_CONTROL_LOOP_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5e7cb0a: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_RTT_PARK_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x5eb10a7: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_X4_WRITES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5ed4258: {
              //simpleType:uint
              pLabel = "MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5ee2cf9: {
              //simpleType:uint
              pLabel = "ODY_MSG_MISC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5ef02dc: {
              //simpleType:enum
              pLabel = "SPL_WAKEUP_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "SPL_WAKEUP_STATE_DISABLE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "SPL_WAKEUP_STATE_ENABLE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x5ef37d7: {
              //simpleType:uint
              pLabel = "SLOT_NAME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5f1a686: {
              //simpleType:uint
              pLabel = "CURRENT_SCALING_FACTOR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x5f1aa39: {
              break;
          }
          case 0x5f4f64d: {
              //simpleType:uint
              pLabel = "ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int16_t);
              break;
          }
          case 0x5f877fa: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x5f943d0: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_ATTACHED_CHIP_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x5f9ce72: {
              //simpleType:uint
              pLabel = "PROC_REFCLOCK_RCVR_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5fa7892: {
              //simpleType:uint
              pLabel = "HTMSC_MODE_MARKERS_ONLY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x5fd9713: {
              //simpleType:uint
              pLabel = "MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x603ef87: {
              //simpleType:uint
              pLabel = "MEM_EFF_RCD_MFG_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x6040956: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_DQ_DQS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x6052228: {
              //simpleType:enum
              pLabel = "FMBX_DMA_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "FMBX_DMA_STATE_REJECT_DMA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "FMBX_DMA_STATE_DMA_VIA_FSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "FMBX_DMA_STATE_DMA_VIA_PSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x6077b5a: {
              //simpleType:uint
              pLabel = "FSP_SECURITY_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x609c749: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8][4]:");
              l_traceEntry.resize(10+offset + 32 * 7);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 32 * sizeof(uint16_t);
              break;
          }
          case 0x60af368: {
              //simpleType:uint
              pLabel = "CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x6129fe7: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6134e50: {
              //simpleType:uint
              pLabel = "EXECUTION_PLATFORM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x61356e1: {
              //simpleType:uint
              pLabel = "NEST_VDN_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x615ada9: {
              //simpleType:uint
              pLabel = "MEM_EXP_DRAM_ADDRESS_MIRRORING";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x6167a77: {
              //simpleType:uint
              pLabel = "CORE_THROTTLE_DEASSERT_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x617e775: {
              //simpleType:uint
              pLabel = "PROC_INT_NVPG_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x61d3421: {
              //simpleType:uint
              pLabel = "MSS_MRW_MAX_DRAM_DATABUS_UTIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x61d7f4f: {
              //simpleType:uint
              pLabel = "PROC_MEM_SIZES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x61f8882: {
              //simpleType:uint
              pLabel = "BOOT_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x62195c1: {
              //simpleType:uint
              pLabel = "SLOW_MEM_POOL_TEST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6234fc5: {
              //simpleType:uint
              pLabel = "PROC_NX_RNG_FAILED_INT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6237f69: {
              //simpleType:uint
              pLabel = "PROC_LCO_MODE_SETUP_ADAPTIVE_N";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6266c59: {
              //simpleType:uint
              pLabel = "ODY_IS_HIGHVDD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x628f4c8: {
              //simpleType:uint
              pLabel = "IOHS_SMP9_INTERCONNECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x62ad824: {
              //simpleType:uint
              pLabel = "UCD_MFR_REVISION_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x62e05e5: {
              //simpleType:uint
              pLabel = "MEM_BURST_LENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x62e9ef2: {
              //simpleType:uint
              pLabel = "PROC_ENABLE_DL_TMPL_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x630ca7e: {
              //simpleType:uint
              pLabel = "MAX_EID_ON_HBEL_FSP_B";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6311ded: {
              //simpleType:uint
              pLabel = "DECONFIG_BUT_NOT_GARDED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x63546d5: {
              //simpleType:uint
              pLabel = "DLR_SAMPLE_TIME_MS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x637e6da: {
              //simpleType:uint
              pLabel = "PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[6]:");
              l_traceEntry.resize(10+offset + 6 * 19);
              for (uint32_t i = 0;i<6;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 6 * sizeof(uint64_t);
              break;
          }
          case 0x6381afd: {
              //simpleType:uint
              pLabel = "SKIP_WAKEUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x639dd88: {
              //simpleType:uint
              pLabel = "MRU_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x63a4fd4: {
              //simpleType:uint
              pLabel = "SBE_FIFO_CAPABILITIES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[40]:");
              l_traceEntry.resize(10+offset + 40 * 11);
              for (uint32_t i = 0;i<40;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 40 * sizeof(uint32_t);
              break;
          }
          case 0x63c5ad2: {
              //simpleType:uint
              pLabel = "WOF_IO_START";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x63d094c: {
              //simpleType:uint
              pLabel = "RCW49_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x63e1613: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRRD_L";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x641d0e3: {
              //simpleType:uint
              pLabel = "MEM_DRAM_CWL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x641e1d5: {
              //simpleType:uint
              pLabel = "BASE_PVR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x647869e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_REDUNDANCY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x647f6d0: {
              //simpleType:uint
              pLabel = "MSS_MEM_IPL_COMPLETE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6485e5d: {
              //simpleType:uint
              pLabel = "RCW43_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x649a489: {
              //simpleType:uint
              pLabel = "LPC_CONSOLE_INITIALIZED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x64b6d86: {
              //simpleType:uint
              pLabel = "PAYLOAD_ENTRY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x64e7e70: {
              //simpleType:uint
              pLabel = "PCI_REFCLOCK_RCVR_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x64f3058: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SEQUENCE_CFG3_R43";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6508321: {
              //simpleType:uint
              pLabel = "PSI_BRIDGE_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x650fda1: {
              //simpleType:uint
              pLabel = "MFG_SCREEN_OMI_CRC_ALLOWED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x655aa2b: {
              //simpleType:uint
              pLabel = "SYSTEM_CORECACHE_SKEWADJ_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6574e37: {
              break;
          }
          case 0x65a01d5: {
              //simpleType:uint
              pLabel = "ODY_EN_TDQS2DQ_TRACKING";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x65a19cd: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x65a6fb3: {
              //simpleType:uint
              pLabel = "PEC_PCIE_LANE_MASK_NON_BIFURCATED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0x65b4f2c: {
              //simpleType:uint
              pLabel = "HB_HW_DECONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x65c995d: {
              //simpleType:uint
              pLabel = "NHTM_CTRL_TRIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x666457d: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VDDR_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x666532f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SEQUENCE_CFG3_R43";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x667433c: {
              //simpleType:uint
              pLabel = "EFF_DRAM_BANK_GROUP_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x667e81e: {
              //simpleType:uint
              pLabel = "WOF_TDP_ALTITUDE_REFERENCE_M";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x668db70: {
              //simpleType:uint
              pLabel = "WOV_UNDERV_MAX_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x66919bb: {
              //simpleType:uint
              pLabel = "BACKING_CACHES_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x669e8d5: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRFC_DLR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x66c4d30: {
              //simpleType:uint
              pLabel = "CHTM_MODE_LLAT_CAPTURE_STORE_DIS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x66df8b2: {
              //simpleType:uint
              pLabel = "MEM_DDR5_WR_CRC_AUTODISABLE_STATUS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6704d48: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_LINKS_CNFG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x671128a: {
              //simpleType:uint
              pLabel = "RCW43_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6766dce: {
              //simpleType:uint
              pLabel = "TARGET_SCOMABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x67bf05e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x67fa3f7: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6809efd: {
              //simpleType:uint
              pLabel = "ROW_REPAIR_SUPPORTED_MRW";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x683ae9e: {
              //simpleType:uint
              pLabel = "RCW42_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68400ca: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_MDS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68495bc: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_DLL_RESET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68b9d58: {
              //simpleType:uint
              pLabel = "RVRM_VID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68c895f: {
              //simpleType:uint
              pLabel = "RCW42_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68ccec0: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TWTR_L";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68dd522: {
              //simpleType:uint
              pLabel = "FREQ_CORE_BOOT_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x68de0ff: {
              //simpleType:uint
              pLabel = "SYS_CLK_NE_TERMINATION_STRENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x68e1db7: {
              //simpleType:uint
              pLabel = "PROC_MASTER_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x69014fc: {
              //simpleType:uint
              pLabel = "CLOCK_MUX2A_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6902c81: {
              //simpleType:uint
              pLabel = "OMI_RX_HORIZ_DATA_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x69153a8: {
              //simpleType:uint
              pLabel = "MEM_PMIC_4U_N_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6937db7: {
              //simpleType:uint
              pLabel = "RCW0E_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6942ee4: {
              //simpleType:uint
              pLabel = "ODY_SIM_TPDM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x69653af: {
              //simpleType:uint
              pLabel = "PROC_PCIE_IS_SLOT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x6992256: {
              //simpleType:uint
              pLabel = "OMI_X4_DEGRADE_ACTION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x69b9e21: {
              //simpleType:uint
              pLabel = "MRW_DDR4_VDDR_MAX_LIMIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x69c6484: {
              //simpleType:uint
              pLabel = "SMP_CONNECTION_STATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x69ce066: {
              //simpleType:uint
              pLabel = "EXPLR_TMPL_0_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x69e5db1: {
              //simpleType:uint
              pLabel = "FREQ_PB_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x69f97d1: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC03";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x69fbe43: {
              //simpleType:uint
              pLabel = "EXPLR_TMPL_9_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a00c9c: {
              //simpleType:uint
              pLabel = "HDDW_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a08b4b: {
              //simpleType:uint
              pLabel = "ODY_PHY_CFG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a22222: {
              //simpleType:uint
              pLabel = "NEST_VDDR_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x6a258b6: {
              //simpleType:uint
              pLabel = "MIRROR_BASE_ADDRESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x6a37320: {
              //simpleType:uint
              pLabel = "PROC_PCIE_BAR_SIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 19);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 3 * sizeof(uint64_t);
              break;
          }
          case 0x6a47337: {
              //simpleType:uint
              pLabel = "SYSTEM_IPL_PHASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a4f7bc: {
              //simpleType:uint
              pLabel = "MSS_MNFG_EDPL_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a61fce: {
              //simpleType:uint
              pLabel = "MEM_EFF_FOUR_RANK_MODE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x6a6a83d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SEQUENCE_CFG2_R42";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a83eea: {
              //simpleType:uint
              pLabel = "MEM_REORDER_QUEUE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a84e01: {
              //simpleType:uint
              pLabel = "ODY_PHY_TX2D_TRAIN_OPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6a98d21: {
              break;
          }
          case 0x6ac0905: {
              //simpleType:uint
              pLabel = "MRW_DDR3_VDDR_MAX_LIMIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6b341e3: {
              //simpleType:uint
              pLabel = "MEM_PORT_POS_OF_FAIL_THROTTLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x6b48c0f: {
              //simpleType:uint
              pLabel = "FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6b5b079: {
              //simpleType:uint
              pLabel = "DUMMY_RW";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[1][3][5]:");
              l_traceEntry.resize(10+offset + 15 * 5);
              for (uint32_t i = 0;i<15;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 15 * sizeof(uint8_t);
              break;
          }
          case 0x6b72984: {
              //simpleType:uint
              pLabel = "DISABLE_PREDICTIVE_MEM_GUARD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6b84338: {
              //simpleType:uint
              pLabel = "UPDATE_SLW_SCOM_TO_PHYP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6b981a7: {
              //simpleType:uint
              pLabel = "ODY_SIM_TDQSCK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x6ba66f8: {
              //simpleType:uint
              pLabel = "PROC_INT_TM_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6bae177: {
              //simpleType:uint
              pLabel = "DEBUG_ODY_HRESET_CONTROL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6c0c2a9: {
              //simpleType:uint
              pLabel = "OMI_CRC_DEBUG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6c26bcb: {
              //simpleType:uint
              pLabel = "PROC_SBE_MCS_SETUP_SELECTED_MC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6c5ec9f: {
              break;
          }
          case 0x6c81641: {
              //simpleType:uint
              pLabel = "DDS_DELAY_ADJUST";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(int16_t);
              break;
          }
          case 0x6c8bf3d: {
              //simpleType:uint
              pLabel = "OCMB_COUNTER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6cb15ee: {
              //simpleType:uint
              pLabel = "EFF_REGISTER_REV";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x6cba771: {
              //simpleType:uint
              pLabel = "MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6cd7f34: {
              //simpleType:uint
              pLabel = "ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int16_t);
              break;
          }
          case 0x6cd872a: {
              //simpleType:uint
              pLabel = "MEM_EFF_HYBRID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x6d05234: {
              //simpleType:uint
              pLabel = "MSS_MRW_POWER_CONTROL_REQUESTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6d3696b: {
              //simpleType:uint
              pLabel = "CHIP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6de3ae5: {
              //simpleType:uint
              pLabel = "MEM_SI_ODT_RD";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x6e2352a: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_MODE_CORE_INSTR_STALL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x6e3d1bf: {
              //simpleType:uint
              pLabel = "MEM_EFF_NIBBLE_MAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][20]:");
              l_traceEntry.resize(10+offset + 40 * 5);
              for (uint32_t i = 0;i<40;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 40 * sizeof(uint8_t);
              break;
          }
          case 0x6e979d7: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_READ_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6ed9642: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_IMP_CLK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x6efcd46: {
              //simpleType:uint
              pLabel = "WOF_TDP_IO_INDEX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6f08f4b: {
              //simpleType:uint
              pLabel = "MIN_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6f09c49: {
              //simpleType:uint
              pLabel = "MSS_VOLT_AVDD_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6f11c24: {
              //simpleType:uint
              pLabel = "CDM_POLICIES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6f26f00: {
              //simpleType:uint
              pLabel = "SYS_DISABLE_MCU_TIMEOUTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6f2adc3: {
              //simpleType:uint
              pLabel = "FREQ_PAU_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x6f76a92: {
              break;
          }
          case 0x6fb6b11: {
              //simpleType:uint
              pLabel = "ODY_PHY_CA_DFE_TRAIN_OPTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6fccada: {
              //simpleType:uint
              pLabel = "ODY_POWERDOWN_ANIBS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x6fd010f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SEQUENCE_CFG3_R43";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x6fd2aa7: {
              break;
          }
          case 0x6ff404d: {
              //simpleType:uint
              pLabel = "FSP_VMEM_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7014d18: {
              //simpleType:uint
              pLabel = "TARGET_IS_SCOMMABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x703fb93: {
              //simpleType:uint
              pLabel = "MEM_DDR5_PLUG_RULES_SPD_REV_TESTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x70406e6: {
              //simpleType:uint
              pLabel = "PEC_PCIE_IOP_SWAP_NON_BIFURCATED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x706e27b: {
              //simpleType:uint
              pLabel = "REDUNDANT_CLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x70d1f95: {
              //simpleType:uint
              pLabel = "DRAM_PD_DRV_IMP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x70d4d6d: {
              //simpleType:uint
              pLabel = "MEM_EXP_SPD_CL_SUPPORTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x70d8395: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x70e6a22: {
              //simpleType:uint
              pLabel = "MNFG_TH_L3_CACHE_CES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x712e3fe: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_TTAG_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7130751: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_3_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x71527f3: {
              //simpleType:uint
              pLabel = "RUNN_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7172b53: {
              //simpleType:uint
              pLabel = "SYS1_REFCLOCK_RCVR_TERM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x71a31ad: {
              //simpleType:uint
              pLabel = "MEM_SI_ODT_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x71cc41c: {
              break;
          }
          case 0x71d7b85: {
              //simpleType:enum
              pLabel = "PROC_COMPATIBILITY_REQ";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "PROC_COMPATIBILITY_REQ_ALLOW_COMPATIBILITY");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "PROC_COMPATIBILITY_REQ_FORCED_COMPATIBILITY");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "PROC_COMPATIBILITY_REQ_FORCED_NATIVE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x7222c88: {
              break;
          }
          case 0x723f825: {
              //simpleType:uint
              pLabel = "MNFG_TH_MEMORY_IUES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7249ab4: {
              //simpleType:uint
              pLabel = "RCW05_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x724bc5c: {
              //simpleType:uint
              pLabel = "DDS_TRIP_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x724e782: {
              //simpleType:uint
              pLabel = "PLL_BUCKET_BUILD_INDEX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x725d3a6: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x726e42c: {
              //simpleType:uint
              pLabel = "ODY_SIM_TCASL_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x729602f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x72b7486: {
              //simpleType:uint
              pLabel = "MNFG_DMI_MIN_EYE_WIDTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x72c194d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x72e61a8: {
              //simpleType:uint
              pLabel = "MSS_MRW_SUPPORTED_DRAM_WIDTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x72f340b: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x72f4865: {
              //simpleType:uint
              pLabel = "WOF_THROTTLE_CONTROL_LOOP_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x72f49a4: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VPP_SLOPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x732fad3: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TCCD_L";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x736309b: {
              //simpleType:uint
              pLabel = "FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x738ed86: {
              //simpleType:uint
              pLabel = "IS_SP_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x73ade63: {
              //simpleType:uint
              pLabel = "MSS_EXP_SERIAL_NUMBER";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[26]:");
              l_traceEntry.resize(10+offset + 26 * 5);
              for (uint32_t i = 0;i<26;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 26 * sizeof(uint8_t);
              break;
          }
          case 0x73cc90f: {
              //simpleType:uint
              pLabel = "EXPLR_ENABLE_US_TMPL_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x73da768: {
              //simpleType:uint
              pLabel = "CP_PLLNESTFLT_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7405667: {
              //simpleType:uint
              pLabel = "XGPE_PHANTOM_HALT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x744b48b: {
              //simpleType:uint
              pLabel = "CEN_MSS_FREQ_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7461177: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x7469e45: {
              //simpleType:uint
              pLabel = "FIELD_TH_L2_LINE_DELETES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x747f7a5: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_TDQS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x748298e: {
              //simpleType:uint
              pLabel = "CHTM_MODE_DIS_GROUP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x74974ba: {
              //simpleType:uint
              pLabel = "PROC_SELECT_CLOCK_MUX_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7515d41: {
              //simpleType:uint
              pLabel = "ENABLE_LBIST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7532644: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x75576dc: {
              //simpleType:uint
              pLabel = "SYSTEM_SUSPEND_OCC_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7584c35: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x75b3b6d: {
              //simpleType:uint
              pLabel = "OMI_RX_LANES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x75ef2a9: {
              //simpleType:uint
              pLabel = "WOF_DCM_TRACKING_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7606944: {
              //simpleType:uint
              pLabel = "EXP_PORT_MAXPOWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7628329: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F1RC02";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x762c08b: {
              //simpleType:uint
              pLabel = "RCW00_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7631332: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_SPARE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x763e8c5: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PHB_ACTIVE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0x7663ec5: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x76ca9d6: {
              //simpleType:uint
              pLabel = "VPD_POWERSAVE_MIN_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x76d2e17: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x76d448e: {
              //simpleType:uint
              pLabel = "IO_OMI_PRE1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x771b18e: {
              //simpleType:uint
              pLabel = "MSS_MBA_CACHELINE_INTERLEAVE_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x775e116: {
              //simpleType:uint
              pLabel = "MSS_RUN_DCD_CALIBRATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x776a736: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x777f418: {
              //simpleType:uint
              pLabel = "SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x778bcbb: {
              //simpleType:uint
              pLabel = "RUN_MAX_MEM_PATTERNS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x77ae7b1: {
              //simpleType:uint
              pLabel = "RCW46_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x77c5cd3: {
              //simpleType:uint
              pLabel = "I2C_SUB_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x77da343: {
              //simpleType:uint
              pLabel = "NPU_MMIO_BAR_SIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4][2]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x7803464: {
              //simpleType:uint
              pLabel = "XSCOM_BASE_ADDRESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x780a573: {
              //simpleType:uint
              pLabel = "VCS_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x782c053: {
              //simpleType:uint
              pLabel = "SCRATCH_UINT32_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7836c10: {
              //simpleType:uint
              pLabel = "IS_PNOR_ECC_RECOVERY_IN_PROGRESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x785ff65: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_SUSPENDED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x787d424: {
              //simpleType:uint
              pLabel = "NEST_LEAKAGE_PERCENT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x789ba7e: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_FIR_CHECK_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x78c64c6: {
              //simpleType:uint
              pLabel = "NEST_PLL_FREQ_I2CDIV_LIST";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 11);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 5 * sizeof(uint32_t);
              break;
          }
          case 0x7913dc5: {
              //simpleType:uint
              pLabel = "MEM_PMIC_FORCE_N_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7959bae: {
              //simpleType:uint
              pLabel = "POUND_V_STATIC_DATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x79c2dd2: {
              //simpleType:uint
              pLabel = "WOF_VRATIO_VDD_10THPCT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 8 * sizeof(uint16_t);
              break;
          }
          case 0x7a03bac: {
              //simpleType:enum
              pLabel = "MODEL";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "MODEL_NA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000010: {
                      sprintf(&(l_traceEntry[0]), "MODEL_RESERVED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000011: {
                      sprintf(&(l_traceEntry[0]), "MODEL_VENICE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000012: {
                      sprintf(&(l_traceEntry[0]), "MODEL_MURANO");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000013: {
                      sprintf(&(l_traceEntry[0]), "MODEL_NAPLES");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000014: {
                      sprintf(&(l_traceEntry[0]), "MODEL_NIMBUS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000015: {
                      sprintf(&(l_traceEntry[0]), "MODEL_CUMULUS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000016: {
                      sprintf(&(l_traceEntry[0]), "MODEL_AXONE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000030: {
                      sprintf(&(l_traceEntry[0]), "MODEL_CENTAUR");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000031: {
                      sprintf(&(l_traceEntry[0]), "MODEL_OCMB");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000050: {
                      sprintf(&(l_traceEntry[0]), "MODEL_JEDEC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000051: {
                      sprintf(&(l_traceEntry[0]), "MODEL_CDIMM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000070: {
                      sprintf(&(l_traceEntry[0]), "MODEL_POWER8");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000090: {
                      sprintf(&(l_traceEntry[0]), "MODEL_POWER9");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000091: {
                      sprintf(&(l_traceEntry[0]), "MODEL_POWER10");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000092: {
                      sprintf(&(l_traceEntry[0]), "MODEL_CECTPM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000093: {
                      sprintf(&(l_traceEntry[0]), "MODEL_BMC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000094: {
                      sprintf(&(l_traceEntry[0]), "MODEL_AST2500");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000095: {
                      sprintf(&(l_traceEntry[0]), "MODEL_AST2600");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000096: {
                      sprintf(&(l_traceEntry[0]), "MODEL_PCA9847");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000097: {
                      sprintf(&(l_traceEntry[0]), "MODEL_UCD9090");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000098: {
                      sprintf(&(l_traceEntry[0]), "MODEL_UCD90120A");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000099: {
                      sprintf(&(l_traceEntry[0]), "MODEL_UCD90320");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x7a1246a: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_TX_SLEW_RISE_DQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7a3283c: {
              //simpleType:uint
              pLabel = "ENABLE_CORE_TEMP_CHECK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7a4868d: {
              //simpleType:uint
              pLabel = "ACTIVE_CORES_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7aabf03: {
              //simpleType:uint
              pLabel = "DDS_FREQ_JUMP_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7ac0e9a: {
              //simpleType:uint
              pLabel = "MEM_EFF_CHANNELS_PER_DIMM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x7adbf9e: {
              //simpleType:uint
              pLabel = "ODY_TMPL_9_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7b20e9d: {
              break;
          }
          case 0x7b28a16: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ODTLOFF_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x7b36ccf: {
              //simpleType:uint
              pLabel = "DCADJ_TARGET_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x7b5c147: {
              //simpleType:uint
              pLabel = "MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7b5c8b8: {
              //simpleType:uint
              pLabel = "RCW0C_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7b7fc78: {
              //simpleType:uint
              pLabel = "MSS_MRW_DRAM_WRITE_CRC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7bbb645: {
              //simpleType:uint
              pLabel = "SYS_DISABLE_HWFM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7bc6bec: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_MFG_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x7bf34fc: {
              //simpleType:enum
              pLabel = "PSI_LINK_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "PSI_LINK_STATE_NOT_ACTIVE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "PSI_LINK_STATE_ACTIVE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "PSI_LINK_STATE_CANDIDATE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x7c07477: {
              //simpleType:uint
              pLabel = "ODY_PHY_CALONCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7c84367: {
              //simpleType:uint
              pLabel = "EXP_MEM_PORT_POS_OF_FAIL_THROTTLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x7ce5ba8: {
              //simpleType:uint
              pLabel = "WOFBASE_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7ce66ef: {
              //simpleType:uint
              pLabel = "MSS_RDVREF_CAL_ENABLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x7cfd099: {
              //simpleType:uint
              pLabel = "SYSTEM_AUXILLARY_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7d275f0: {
              //simpleType:uint
              pLabel = "ICACHE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7d6c44c: {
              //simpleType:uint
              pLabel = "MSS_MRW_CONFIG_FREQ_LIMIT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 8 * sizeof(uint16_t);
              break;
          }
          case 0x7d95979: {
              //simpleType:uint
              pLabel = "CP_PLLIOSSFLT_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7dfffde: {
              //simpleType:uint
              pLabel = "MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x7e1fa3b: {
              //simpleType:uint
              pLabel = "PCIE_64BIT_DMA_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7e23d04: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7e3a34b: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SEQUENCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7e6967a: {
              //simpleType:uint
              pLabel = "ODY_AFU_ACTAG_LEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x7ec5eb9: {
              //simpleType:uint
              pLabel = "CHTM_MODE_MARKERS_ONLY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x7f0a438: {
              //simpleType:uint
              pLabel = "RCW0F_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7f199a1: {
              //simpleType:uint
              pLabel = "PBAX_CHIPID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7f51090: {
              //simpleType:uint
              pLabel = "MSS_MRW_IDLE_POWER_CONTROL_REQUESTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7f829da: {
              //simpleType:uint
              pLabel = "PCIE_CAPABILITES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7f95302: {
              //simpleType:uint
              pLabel = "DUMMY_RO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x7fe3065: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_CA_ODT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0x7fffb1b: {
              //simpleType:uint
              pLabel = "RCW0E_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x80161a9: {
              //simpleType:uint
              pLabel = "MEM_AVDD_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8032442: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x803a0ef: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_MPR_PAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8046daf: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_LPASR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8063772: {
              //simpleType:uint
              pLabel = "EXPLR_ENABLE_US_TMPL_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x806e2cd: {
              //simpleType:uint
              pLabel = "SBE_HW_KEY_HASH_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x8072646: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_2_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x80817dc: {
              //simpleType:uint
              pLabel = "FAPI_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x80964fa: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SEQUENCE_CFG2_R42";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x80b9cd7: {
              //simpleType:uint
              pLabel = "MBA_DIMM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x80e11fa: {
              break;
          }
          case 0x8105e72: {
              //simpleType:uint
              pLabel = "MAX_COMPUTE_NODES_PER_SYSTEM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x812d582: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_WL_ADJ_START";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x8135b05: {
              //simpleType:enum
              pLabel = "KEY_TRANSITION_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "KEY_TRANSITION_STATE_KEY_TRANSITION_NOT_REQUESTED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "KEY_TRANSITION_STATE_KEY_TRANSITION_STARTED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "KEY_TRANSITION_STATE_KEY_TRANSITION_FAILED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "KEY_TRANSITION_STATE_KEY_TRANSITION_SUCCEEDED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x815fdfc: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8188de0: {
              //simpleType:uint
              pLabel = "PROC_PAU_MMIO_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8196e7d: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TMAW";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x81d308e: {
              //simpleType:uint
              pLabel = "RCW44_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x81d3593: {
              break;
          }
          case 0x81e7c0c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8218c38: {
              //simpleType:uint
              pLabel = "MRW_MEM_THROTTLE_DENOMINATOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8269cf5: {
              //simpleType:uint
              pLabel = "I2C_ADDRESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x829c075: {
              //simpleType:uint
              pLabel = "OCMB_RESET_DELAY_SEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x829cc6b: {
              //simpleType:uint
              pLabel = "DISABLE_PLD_WAIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x829fde2: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x82b807e: {
              //simpleType:uint
              pLabel = "PM_SPIPSS_CLOCK_PHASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x82b8963: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_CHB_ACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x82cf1be: {
              //simpleType:uint
              pLabel = "MSS_OCMB_ENTERPRISE_POLICY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x82f2d14: {
              //simpleType:uint
              pLabel = "WOF_THROTTLE_CONTROL_DISABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x82f58e6: {
              //simpleType:uint
              pLabel = "FREQ_PCIE_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x832a26f: {
              //simpleType:uint
              pLabel = "RUNN_SRESET_THREADS_BVEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x833d2c7: {
              //simpleType:uint
              pLabel = "HTMSC_IMA_PDBAR_ADDR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 19);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 32 * sizeof(uint64_t);
              break;
          }
          case 0x836d048: {
              //simpleType:uint
              pLabel = "ORIG_FIR_SETTINGS_ACTION0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x837b78a: {
              //simpleType:uint
              pLabel = "HOT_PLUG_POWER_CONTROLLER_INFO";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8][8]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0x837c29b: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x837f7ab: {
              //simpleType:uint
              pLabel = "EC_GARD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x83950cf: {
              //simpleType:uint
              pLabel = "ECS_ERROR_COUNT_THRESHOLD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x83a8012: {
              //simpleType:uint
              pLabel = "ODY_PASID_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x83cc1e9: {
              //simpleType:enum
              pLabel = "PROC_MODULE_TYPE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000050: {
                      sprintf(&(l_traceEntry[0]), "PROC_MODULE_TYPE_GODEL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000051: {
                      sprintf(&(l_traceEntry[0]), "PROC_MODULE_TYPE_BLAISE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000052: {
                      sprintf(&(l_traceEntry[0]), "PROC_MODULE_TYPE_P11_GODEL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000053: {
                      sprintf(&(l_traceEntry[0]), "PROC_MODULE_TYPE_P11_BLAISE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x83fe364: {
              //simpleType:uint
              pLabel = "REQUIRED_SYNCH_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x841f53b: {
              //simpleType:uint
              pLabel = "SPPE_I2C_ENGINE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8452e3a: {
              //simpleType:uint
              pLabel = "NVDIMM_ENCRYPTION_KEYS_ANCHOR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[96]:");
              l_traceEntry.resize(10+offset + 96 * 5);
              for (uint32_t i = 0;i<96;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 96 * sizeof(uint8_t);
              break;
          }
          case 0x8455d8c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8467756: {
              //simpleType:uint
              pLabel = "SYS_CLK_NE_TERMINATION_SITE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x84844ff: {
              //simpleType:uint
              pLabel = "PROC_CHIP_IPL_PHASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x84a4edb: {
              break;
          }
          case 0x84b3cfb: {
              //simpleType:uint
              pLabel = "SKEWADJ_CORE_PDLY_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x84bd9ba: {
              //simpleType:uint
              pLabel = "PROC_PCIE_FW_VERSION_0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x84f709a: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_TEST_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x852b409: {
              //simpleType:uint
              pLabel = "CHIP_CONTAINED_ACTIVE_CORES_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x854b79b: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x85528b9: {
              //simpleType:uint
              pLabel = "IO_IOHS_PRE1_ISC1_WORKAROUND";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8560487: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC04";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x856b2c4: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_3_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x856b84d: {
              //simpleType:uint
              pLabel = "MEM_DRAM_GEN_METADATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x859437f: {
              //simpleType:uint
              pLabel = "XIVE_CONTROLLER_BAR_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x85a4a4b: {
              //simpleType:uint
              pLabel = "SECURE_VERSION_NUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x85b98d6: {
              //simpleType:uint
              pLabel = "MEM_2N_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x85bae1f: {
              //simpleType:uint
              pLabel = "LAST_KNOWN_CONFIGURED_MEM_SIZE_MB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x85c31e5: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_THRESHOLD_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x85ef6e9: {
              //simpleType:uint
              pLabel = "INT_CQ_TM_BAR_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x85fcda1: {
              //simpleType:uint
              pLabel = "NHTM_TRACE_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x86695d0: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x86917a6: {
              //simpleType:uint
              pLabel = "MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x86bad95: {
              //simpleType:uint
              pLabel = "MSS_MRW_FORCE_BCMODE_OFF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x86e21ac: {
              //simpleType:uint
              pLabel = "MAX_MCS_PER_SYSTEM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x86feede: {
              //simpleType:uint
              pLabel = "EFF_NIBBLE_MAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2][18]:");
              l_traceEntry.resize(10+offset + 72 * 5);
              for (uint32_t i = 0;i<72;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 72 * sizeof(uint8_t);
              break;
          }
          case 0x878bcaf: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRFC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x87bdfb9: {
              //simpleType:uint
              pLabel = "MSS_MRW_FINE_REFRESH_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x87e3ed0: {
              //simpleType:uint
              pLabel = "RUNN_STAGGER_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x87ff43a: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_LINKS_CNFG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8804d03: {
              //simpleType:uint
              pLabel = "SPPE_BOOT_SIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x882b99c: {
              //simpleType:uint
              pLabel = "MNFG_TH_L2_CACHE_CES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8845c5b: {
              //simpleType:uint
              pLabel = "L2_CACHE_ASSOC_SETS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8883a11: {
              //simpleType:uint
              pLabel = "PROC_PSI_BRIDGE_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x888c903: {
              //simpleType:uint
              pLabel = "MEM_EFF_PRIM_STACK_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x88ba0c5: {
              //simpleType:uint
              pLabel = "EFF_NUM_RANKS_PER_DIMM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x891d6d1: {
              //simpleType:uint
              pLabel = "HBRT_HYP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x89224bc: {
              //simpleType:uint
              pLabel = "NEST_VDD_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x892eeb6: {
              //simpleType:uint
              pLabel = "MEM_SI_SIGNATURE_HASH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8944726: {
              //simpleType:uint
              pLabel = "TCE_START_TOKEN_FOR_PAYLOAD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8944ca8: {
              //simpleType:uint
              pLabel = "IS_TCES_MODE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8949e92: {
              //simpleType:uint
              pLabel = "SOCKET_POWER_TURBO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8990bb0: {
              //simpleType:uint
              pLabel = "MSS_OMI_EDPL_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x89937ca: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8997fc6: {
              //simpleType:uint
              pLabel = "SYSTEM_IQ_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x89af58e: {
              //simpleType:uint
              pLabel = "OMI_CHANNEL_FAIL_ACTION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x89b8414: {
              //simpleType:uint
              pLabel = "PROC_MEM_BASES_ACK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0x89b9a48: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8a18c2a: {
              //simpleType:uint
              pLabel = "MRW_MAX_DDR_FREQ_PER_SLOT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x8a5e99e: {
              //simpleType:uint
              pLabel = "ODY_PHY_MSTRMAXREQTOACK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8a7db83: {
              //simpleType:uint
              pLabel = "SYSTEM_PSTATES_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8a9711e: {
              //simpleType:uint
              pLabel = "DCADJ_DCC_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x8ab374a: {
              //simpleType:uint
              pLabel = "IO_IOHS_PRE1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ad2e2a: {
              //simpleType:uint
              pLabel = "NDL_MESHCTRL_SETUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8b159e0: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8b1986a: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_RTT_PARK_RD";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x8b29691: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC0F";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x8b4f3ef: {
              //simpleType:uint
              pLabel = "MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8b58e8c: {
              //simpleType:uint
              pLabel = "MEM_RDIMM_BUFFER_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8b5ae6e: {
              //simpleType:uint
              pLabel = "HTMSC_TTYPEFILT_INVERT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8b6b012: {
              //simpleType:uint
              pLabel = "PM_MALF_CYCLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8b78d35: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x8be06f8: {
              //simpleType:uint
              pLabel = "WOV_OVERV_MAX_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8c5fb5a: {
              //simpleType:uint
              pLabel = "PAYLOAD_IN_MIRROR_MEM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ca929b: {
              //simpleType:uint
              pLabel = "NVDIMM_AUTO_ARM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8cc8333: {
              //simpleType:uint
              pLabel = "PROC_INT_IC_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ccc316: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_WR_PREAMBLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8cd1455: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TWTR_L";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x8ce790d: {
              //simpleType:uint
              pLabel = "THREAD_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8d11dd8: {
              //simpleType:uint
              pLabel = "MEM_EFF_ATXDLY_B";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x8d2dc76: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8d614de: {
              //simpleType:uint
              pLabel = "OCC_LFIRMASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x8d7f254: {
              //simpleType:uint
              pLabel = "POUNDV_BUCKET_NUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8dc56b6: {
              //simpleType:uint
              pLabel = "ODY_RX2D_DFE_MISC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8dc78ef: {
              //simpleType:uint
              pLabel = "MAX_PROC_CHIPS_PER_NODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8dc9d7c: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_RTT_NOM_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 5);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 16 * sizeof(uint8_t);
              break;
          }
          case 0x8dfa6d6: {
              //simpleType:uint
              pLabel = "START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x8dfd2fd: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_WR_POSTAMBLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8e10b37: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8e2a2e3: {
              //simpleType:uint
              pLabel = "MEM_EFF_SPD_CONTENT_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8e2c3d7: {
              //simpleType:uint
              pLabel = "CP_REFCLOCK_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8e5a6f8: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8e6a027: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ec531c: {
              //simpleType:uint
              pLabel = "MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ecc32e: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC02";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x8eda99e: {
              //simpleType:uint
              pLabel = "FUSED_CORE_PAIRED_MODE_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ee2d89: {
              //simpleType:uint
              pLabel = "MSS_MBA_ADDR_INTERLEAVE_BIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ee5f82: {
              //simpleType:uint
              pLabel = "ACTIVE_CORES_NUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8f00dcd: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8f1af9c: {
              //simpleType:uint
              pLabel = "PROC_FSP_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8f2556b: {
              //simpleType:uint
              pLabel = "MSS_CONFIG_FREQ_LIMIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8f2a29b: {
              //simpleType:uint
              pLabel = "ODY_TMPL_5_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8f2bd1d: {
              //simpleType:uint
              pLabel = "PAU_DPLL_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8f2e0ff: {
              //simpleType:uint
              pLabel = "WOF_TABLE_OVERRIDE_UT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x8f50763: {
              //simpleType:uint
              pLabel = "PROC_LCO_MODE_SETUP_ADAPTIVE_D";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x8f5a12c: {
              //simpleType:uint
              pLabel = "DISABLE_TOD_SYNC_SPREAD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8fc28b1: {
              //simpleType:uint
              pLabel = "SBE_ADDR_KEY_STASH_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x8fe48a2: {
              //simpleType:uint
              pLabel = "MEM_MRW_IS_PLANAR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8fe7d97: {
              //simpleType:uint
              pLabel = "AW_STATIC_DATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8fec09a: {
              //simpleType:uint
              pLabel = "SPPE_I2C_MAX_RETRY_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ff8d9c: {
              //simpleType:uint
              pLabel = "EFFECTIVE_EC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x8ffa8f1: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_VREFCS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0x90059b3: {
              //simpleType:uint
              pLabel = "HTMSC_MODE_DIS_TSTAMP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9008e43: {
              //nativeType:EntityPath
              pLabel = "ALTFSI_MASTER_CHIP";
              const char *pathString;
              // from targeting/common/entitypath.[CH]
              const uint8_t lPtype = *l_ptr; // PATH_TYPE
              switch (lPtype) {
                  case 0x01: pathString = "Logical:"; break;
                  case 0x02: pathString = "Physical:"; break;
                  case 0x03: pathString = "Device:"; break;
                  case 0x04: pathString = "Power:"; break;
                  default:   pathString = "Unknown:"; break;
              }
              l_traceEntry.resize(strlen(pathString) + 128);
              uint32_t dataSize = sprintf(&(l_traceEntry[0]), "%s",pathString);
              const uint8_t lSize = *(l_ptr + 1); // number of elements
              uint8_t *lElementInstance = (l_ptr + 2);
              for (uint32_t i=0;i<lSize;i += 2) {
                  switch (lElementInstance[i]) {
                      case 0x00: { pathString = "/NA"; break; }
                      case 0x01: { pathString = "/Sys"; break; }
                      case 0x02: { pathString = "/Node"; break; }
                      case 0x03: { pathString = "/DIMM"; break; }
                      case 0x04: { pathString = "/Membuf"; break; }
                      case 0x05: { pathString = "/Proc"; break; }
                      case 0x06: { pathString = "/EX"; break; }
                      case 0x07: { pathString = "/Core"; break; }
                      case 0x08: { pathString = "/L2"; break; }
                      case 0x09: { pathString = "/L3"; break; }
                      case 0x0A: { pathString = "/L4"; break; }
                      case 0x0B: { pathString = "/MCS"; break; }
                      case 0x0D: { pathString = "/MBA"; break; }
                      case 0x0E: { pathString = "/XBUS"; break; }
                      case 0x0F: { pathString = "/ABUS"; break; }
                      case 0x10: { pathString = "/PCI"; break; }
                      case 0x11: { pathString = "/DPSS"; break; }
                      case 0x12: { pathString = "/APSS"; break; }
                      case 0x13: { pathString = "/OCC"; break; }
                      case 0x14: { pathString = "/PSI"; break; }
                      case 0x15: { pathString = "/FSP"; break; }
                      case 0x16: { pathString = "/PNOR"; break; }
                      case 0x17: { pathString = "/OSC"; break; }
                      case 0x18: { pathString = "/TODCLK"; break; }
                      case 0x19: { pathString = "/CONTROL_NODE"; break; }
                      case 0x1A: { pathString = "/OSCREFCLK"; break; }
                      case 0x1B: { pathString = "/OSCPCICLK"; break; }
                      case 0x1C: { pathString = "/REFCLKENDPT"; break; }
                      case 0x1D: { pathString = "/PCICLKENDPT"; break; }
                      case 0x1E: { pathString = "/NX"; break; }
                      case 0x1F: { pathString = "/PORE"; break; }
                      case 0x20: { pathString = "/PCIESWITCH"; break; }
                      case 0x21: { pathString = "/CAPP"; break; }
                      case 0x22: { pathString = "/FSI"; break; }
                      case 0x23: { pathString = "/EQ"; break; }
                      case 0x24: { pathString = "/MCA"; break; }
                      case 0x25: { pathString = "/MCBIST"; break; }
                      case 0x26: { pathString = "/MI"; break; }
                      case 0x27: { pathString = "/DMI"; break; }
                      case 0x28: { pathString = "/OBUS"; break; }
                      case 0x2A: { pathString = "/SBE"; break; }
                      case 0x2B: { pathString = "/PPE"; break; }
                      case 0x2C: { pathString = "/PERV"; break; }
                      case 0x2D: { pathString = "/PEC"; break; }
                      case 0x2E: { pathString = "/PHB"; break; }
                      case 0x2F: { pathString = "/SYSREFCLKENDPT"; break; }
                      case 0x30: { pathString = "/MFREFCLKENDPT"; break; }
                      case 0x31: { pathString = "/TPM"; break; }
                      case 0x32: { pathString = "/SP"; break; }
                      case 0x33: { pathString = "/UART"; break; }
                      case 0x34: { pathString = "/PS"; break; }
                      case 0x35: { pathString = "/FAN"; break; }
                      case 0x36: { pathString = "/VRM"; break; }
                      case 0x37: { pathString = "/USB"; break; }
                      case 0x38: { pathString = "/ETH"; break; }
                      case 0x39: { pathString = "/PANEL"; break; }
                      case 0x3A: { pathString = "/BMC"; break; }
                      case 0x3B: { pathString = "/FLASH"; break; }
                      case 0x3C: { pathString = "/SEEPROM"; break; }
                      case 0x3D: { pathString = "/TMP"; break; }
                      case 0x3E: { pathString = "/GPIO_EXPANDER"; break; }
                      case 0x3F: { pathString = "/POWER_SEQUENCER"; break; }
                      case 0x40: { pathString = "/RTC"; break; }
                      case 0x41: { pathString = "/FANCTLR"; break; }
                      case 0x42: { pathString = "/OBUS_BRICK"; break; }
                      case 0x43: { pathString = "/NPU"; break; }
                      case 0x44: { pathString = "/MC"; break; }
                      case 0x45: { pathString = "/TEST_FAIL"; break; }
                      case 0x46: { pathString = "/MFREFCLK"; break; }
                      case 0x47: { pathString = "/SMPGROUP"; break; }
                      case 0x48: { pathString = "/OMI"; break; }
                      case 0x49: { pathString = "/MCC"; break; }
                      case 0x4A: { pathString = "/OMIC"; break; }
                      case 0x4B: { pathString = "/OCMB_CHIP"; break; }
                      case 0x4C: { pathString = "/MEM_PORT"; break; }
                      case 0x4D: { pathString = "/I2C_MUX"; break; }
                      case 0x4E: { pathString = "/PMIC"; break; }
                      case 0x4F: { pathString = "/NMMU"; break; }
                      case 0x50: { pathString = "/PAU"; break; }
                      case 0x51: { pathString = "/IOHS"; break; }
                      case 0x52: { pathString = "/PAUC"; break; }
                      case 0x53: { pathString = "/FC"; break; }
                      case 0x54: { pathString = "/LPCREFCLKENDPT"; break; }
                      case 0x55: { pathString = "/GENERIC_I2C_DEVICE"; break; }
                      case 0x56: { pathString = "/MDS_CTLR"; break; }
                      case 0x57: { pathString = "/DCM"; break; }
                      case 0x66: { pathString = "/POWER_IC"; break; }
                      case 0x67: { pathString = "/TEMP_SENSOR"; break; }
                      case 0x68: { pathString = "/LAST_IN_RANGE"; break; }
                      default:   { pathString = "/UNKNOWN"; break; }
                  } // switch
                  // copy next part in, overwritting previous terminator
                  dataSize += sprintf(&(l_traceEntry[0]) + dataSize, "%s%d",pathString,lElementInstance[i+1]);
                  l_ptr += 2 * sizeof(uint8_t);
              } // for
              break;
          }
          case 0x900fdc4: {
              //simpleType:uint
              pLabel = "OMI_BIST_ESD_TEST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x905ce7f: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_PER_DRAM_ACCESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x90885f2: {
              //simpleType:uint
              pLabel = "SYSTEM_MMA_POWEROFF_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x90b16d2: {
              //simpleType:uint
              pLabel = "RCW40_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x90b4ba7: {
              //simpleType:uint
              pLabel = "POSITION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x90ddd8e: {
              //simpleType:uint
              pLabel = "MAX_MBAS_PER_MEMBUF_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x90e81d5: {
              //simpleType:uint
              pLabel = "PCIE_NVME_PHB_CONFIG";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 19);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint64_t);
              break;
          }
          case 0x9130cb8: {
              //simpleType:uint
              pLabel = "MAX_DIMMS_PER_MBA_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9133f91: {
              //simpleType:uint
              pLabel = "WOF_TABLE_OVERRIDE_SP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9135ce2: {
              //simpleType:enum
              pLabel = "KEY_CLEAR_REQUEST";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_NONE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00008000: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_ALL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00004000: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_OS_KEYS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00001000: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_POWERVM_SYSKEY");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00002C00: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_RESERVED_1");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000200: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_MFG_ALL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000100: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_MFG");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x000000FF: {
                      sprintf(&(l_traceEntry[0]), "KEY_CLEAR_REQUEST_RESERVED_2");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x913e3f3: {
              //simpleType:uint
              pLabel = "RCW00_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x91498cd: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9166bde: {
              //simpleType:uint
              pLabel = "VIO_RAILS_NOT_POWERED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9184d62: {
              //simpleType:uint
              pLabel = "DUMMY_HEAP_ZERO_DEFAULT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x91b6902: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_SL_DOMAIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x91dcae8: {
              //simpleType:uint
              pLabel = "SKEWADJ_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9209ebe: {
              //simpleType:uint
              pLabel = "QME_LFIRMASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x920e9b8: {
              //simpleType:uint
              pLabel = "EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x920fc84: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x922a9c2: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SEQUENCE_CFG2_R42";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9238d54: {
              //simpleType:uint
              pLabel = "MEM_SI_DRAM_RTT_NOM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x9243579: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_WR_LVL_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x925e5fc: {
              //simpleType:uint
              pLabel = "DEFAULT_FREQ_PB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x926d37e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x928d6c3: {
              //simpleType:uint
              pLabel = "PROC_NX_RNG_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x92913ca: {
              //simpleType:uint
              pLabel = "SECURITY_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x929775e: {
              //simpleType:uint
              pLabel = "MEM_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x92ddf6e: {
              //simpleType:uint
              pLabel = "FSP_AVDD_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x92fced8: {
              //simpleType:uint
              pLabel = "MEM_CS_CMD_LATENCY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x92ff37a: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_OCC_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x931031c: {
              //simpleType:uint
              pLabel = "WOV_OVERV_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9330425: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x93430f7: {
              //simpleType:uint
              pLabel = "DEFAULT_FREQ_X";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x934de01: {
              //simpleType:uint
              pLabel = "ICACHE_LINE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x935d008: {
              //simpleType:uint
              pLabel = "MAX_POWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x939f9be: {
              //simpleType:uint
              pLabel = "MSS_MRW_DIMM_SLOT_AIRFLOW";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x93af940: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC00";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x93b353c: {
              //simpleType:uint
              pLabel = "ODY_TMPL_B_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x93b8597: {
              //simpleType:uint
              pLabel = "WOF_VRATIO_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x93e688d: {
              //simpleType:uint
              pLabel = "SAVED_PB_PTL_FIR_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x93f2355: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_ODT_INPUT_BUFF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x944866d: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_SLEW_RATE_CNTL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x945a086: {
              //simpleType:uint
              pLabel = "DISABLE_SECURITY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x948370e: {
              //simpleType:uint
              pLabel = "PROC_EPS_WRITE_CYCLES_T1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9484951: {
              //simpleType:enum
              pLabel = "TYPE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "TYPE_NA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "TYPE_SYS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "TYPE_NODE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "TYPE_DIMM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MEMBUF");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000005: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PROC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000006: {
                      sprintf(&(l_traceEntry[0]), "TYPE_EX");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000007: {
                      sprintf(&(l_traceEntry[0]), "TYPE_CORE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000008: {
                      sprintf(&(l_traceEntry[0]), "TYPE_L2");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000009: {
                      sprintf(&(l_traceEntry[0]), "TYPE_L3");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000A: {
                      sprintf(&(l_traceEntry[0]), "TYPE_L4");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000B: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MCS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000D: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MBA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000E: {
                      sprintf(&(l_traceEntry[0]), "TYPE_XBUS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000F: {
                      sprintf(&(l_traceEntry[0]), "TYPE_ABUS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000010: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PCI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000011: {
                      sprintf(&(l_traceEntry[0]), "TYPE_DPSS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000012: {
                      sprintf(&(l_traceEntry[0]), "TYPE_APSS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000013: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OCC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000014: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000015: {
                      sprintf(&(l_traceEntry[0]), "TYPE_FSP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000016: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PNOR");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000017: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OSC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000018: {
                      sprintf(&(l_traceEntry[0]), "TYPE_TODCLK");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000019: {
                      sprintf(&(l_traceEntry[0]), "TYPE_CONTROL_NODE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000001A: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OSCREFCLK");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000001B: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OSCPCICLK");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000001C: {
                      sprintf(&(l_traceEntry[0]), "TYPE_REFCLKENDPT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000001D: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PCICLKENDPT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000001E: {
                      sprintf(&(l_traceEntry[0]), "TYPE_NX");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000001F: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PORE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000020: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PCIESWITCH");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000021: {
                      sprintf(&(l_traceEntry[0]), "TYPE_CAPP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000022: {
                      sprintf(&(l_traceEntry[0]), "TYPE_FSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000023: {
                      sprintf(&(l_traceEntry[0]), "TYPE_EQ");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000024: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MCA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000025: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MCBIST");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000026: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000027: {
                      sprintf(&(l_traceEntry[0]), "TYPE_DMI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000028: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OBUS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000002A: {
                      sprintf(&(l_traceEntry[0]), "TYPE_SBE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000002B: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PPE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000002C: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PERV");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000002D: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PEC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000002E: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PHB");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000002F: {
                      sprintf(&(l_traceEntry[0]), "TYPE_SYSREFCLKENDPT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000030: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MFREFCLKENDPT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000031: {
                      sprintf(&(l_traceEntry[0]), "TYPE_TPM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000032: {
                      sprintf(&(l_traceEntry[0]), "TYPE_SP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000033: {
                      sprintf(&(l_traceEntry[0]), "TYPE_UART");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000034: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000035: {
                      sprintf(&(l_traceEntry[0]), "TYPE_FAN");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000036: {
                      sprintf(&(l_traceEntry[0]), "TYPE_VRM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000037: {
                      sprintf(&(l_traceEntry[0]), "TYPE_USB");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000038: {
                      sprintf(&(l_traceEntry[0]), "TYPE_ETH");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000039: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PANEL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000003A: {
                      sprintf(&(l_traceEntry[0]), "TYPE_BMC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000003B: {
                      sprintf(&(l_traceEntry[0]), "TYPE_FLASH");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000003C: {
                      sprintf(&(l_traceEntry[0]), "TYPE_SEEPROM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000003D: {
                      sprintf(&(l_traceEntry[0]), "TYPE_TMP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000003E: {
                      sprintf(&(l_traceEntry[0]), "TYPE_GPIO_EXPANDER");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000003F: {
                      sprintf(&(l_traceEntry[0]), "TYPE_POWER_SEQUENCER");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000040: {
                      sprintf(&(l_traceEntry[0]), "TYPE_RTC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000041: {
                      sprintf(&(l_traceEntry[0]), "TYPE_FANCTLR");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000042: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OBUS_BRICK");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000043: {
                      sprintf(&(l_traceEntry[0]), "TYPE_NPU");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000044: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000045: {
                      sprintf(&(l_traceEntry[0]), "TYPE_TEST_FAIL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000046: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MFREFCLK");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000047: {
                      sprintf(&(l_traceEntry[0]), "TYPE_SMPGROUP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000048: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OMI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000049: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MCC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000004A: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OMIC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000004B: {
                      sprintf(&(l_traceEntry[0]), "TYPE_OCMB_CHIP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000004C: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MEM_PORT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000004D: {
                      sprintf(&(l_traceEntry[0]), "TYPE_I2C_MUX");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000004E: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PMIC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000004F: {
                      sprintf(&(l_traceEntry[0]), "TYPE_NMMU");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000050: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PAU");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000051: {
                      sprintf(&(l_traceEntry[0]), "TYPE_IOHS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000052: {
                      sprintf(&(l_traceEntry[0]), "TYPE_PAUC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000053: {
                      sprintf(&(l_traceEntry[0]), "TYPE_FC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000054: {
                      sprintf(&(l_traceEntry[0]), "TYPE_LPCREFCLKENDPT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000055: {
                      sprintf(&(l_traceEntry[0]), "TYPE_GENERIC_I2C_DEVICE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000056: {
                      sprintf(&(l_traceEntry[0]), "TYPE_MDS_CTLR");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000057: {
                      sprintf(&(l_traceEntry[0]), "TYPE_DCM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000066: {
                      sprintf(&(l_traceEntry[0]), "TYPE_POWER_IC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000067: {
                      sprintf(&(l_traceEntry[0]), "TYPE_TEMP_SENSOR");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000068: {
                      sprintf(&(l_traceEntry[0]), "TYPE_LAST_IN_RANGE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0x948775e: {
              //simpleType:uint
              pLabel = "ODY_MSG_BLOCK_DATA_SOURCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9487ddb: {
              //simpleType:uint
              pLabel = "PCIE_64BIT_MMIO_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x948b8b8: {
              //simpleType:uint
              pLabel = "MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[25]:");
              l_traceEntry.resize(10+offset + 25 * 19);
              for (uint32_t i = 0;i<25;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 25 * sizeof(uint64_t);
              break;
          }
          case 0x94901ad: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9493ec3: {
              //simpleType:uint
              pLabel = "SPIPSS_FREQUENCY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x949ac11: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ODTLON_WR_NT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x94c8d08: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x94d33d8: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_VREFCS_SWEEP_MIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x94f0f3c: {
              //simpleType:uint
              pLabel = "IOHS_LINK_TRAIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x95525f4: {
              //simpleType:uint
              pLabel = "FSP_VDN_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9553606: {
              //simpleType:uint
              pLabel = "CEN_MBA_DIMM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x955e6b7: {
              //simpleType:uint
              pLabel = "PBAX_GROUPID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x956902a: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_DENSITY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x957176b: {
              //simpleType:uint
              pLabel = "CENTAUR_ECID_FRU_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9599693: {
              //simpleType:uint
              pLabel = "PVR_82_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x95a5499: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x95c569b: {
              //simpleType:uint
              pLabel = "WOV_UNDERV_STEP_INCR_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x95ec877: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TREFI";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9604985: {
              //simpleType:uint
              pLabel = "MSS_EXP_FW_PARTITION_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x96069bd: {
              //simpleType:uint
              pLabel = "MNFG_TH_MEMORY_RCD_PARITY_ERRORS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9615865: {
              //simpleType:uint
              pLabel = "CHIP_UNIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9640d61: {
              //simpleType:uint
              pLabel = "IOHS_FABRIC_LANE_REVERSAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9641a9b: {
              //simpleType:uint
              pLabel = "MEM_SI_GEARDOWN_MODE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x96494e2: {
              //simpleType:uint
              pLabel = "EFF_DRAM_PPR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x9653ac9: {
              //simpleType:uint
              pLabel = "ORIG_FIR_SETTINGS_ACTION1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x9688fe1: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 7);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 8 * sizeof(uint16_t);
              break;
          }
          case 0x968f7cc: {
              //simpleType:uint
              pLabel = "FREQ_PAU_VPD_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x96ac2d1: {
              break;
          }
          case 0x96b7c4b: {
              //simpleType:uint
              pLabel = "MSS_OCMB_ECID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[14]:");
              l_traceEntry.resize(10+offset + 14 * 7);
              for (uint32_t i = 0;i<14;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 14 * sizeof(uint16_t);
              break;
          }
          case 0x96ed273: {
              //simpleType:uint
              pLabel = "SBE_SELECT_EX_POLICY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x96f8bd3: {
              //simpleType:uint
              pLabel = "SECUREBOOT_PROTECT_DECONFIGURED_TPM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x970ff46: {
              //simpleType:uint
              pLabel = "CHTM_CTRL_MARK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9711cca: {
              //simpleType:uint
              pLabel = "RCW47_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9712229: {
              //simpleType:uint
              pLabel = "IS_IPL_DECONFIG_ALLOWED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9717572: {
              //complexType - skipping
              break;
          }
          case 0x9761e43: {
              //simpleType:uint
              pLabel = "SECTOR_BUFFER_STRENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x977494c: {
              //simpleType:uint
              pLabel = "SYSTEM_PDV_LAB_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x978723d: {
              //simpleType:uint
              pLabel = "IOHS_MFG_BAD_LANE_VEC_VALID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x97999e4: {
              //simpleType:uint
              pLabel = "ODYSSEY_PRIORITY_CODE_UPDATE_RULE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 19);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint64_t);
              break;
          }
          case 0x97bb3e7: {
              //simpleType:uint
              pLabel = "MEM_INTERNAL_WR_TIMING_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x97c0210: {
              //simpleType:uint
              pLabel = "MAX_SBE_SEEPROM_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x97d43be: {
              //simpleType:uint
              pLabel = "RECONFIG_LOOP_TESTS_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x97d528f: {
              //simpleType:uint
              pLabel = "EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x97e0876: {
              //simpleType:uint
              pLabel = "PEC_PCIE_IOP_REVERSAL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0x98551c7: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_IMP_CMD_ADDR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x987618b: {
              //simpleType:uint
              pLabel = "MEM_EFF_REDUNDANT_CS_EN";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x987bc15: {
              //simpleType:uint
              pLabel = "DDS_FMAX_OVERRIDE_KHZ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[9]:");
              l_traceEntry.resize(10+offset + 9 * 7);
              for (uint32_t i = 0;i<9;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 9 * sizeof(uint16_t);
              break;
          }
          case 0x98a084e: {
              //simpleType:uint
              pLabel = "MEM_REF_WIDE_RANGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x98fab6d: {
              //simpleType:uint
              pLabel = "VOLTAGE_EXT_BIAS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][8]:");
              l_traceEntry.resize(10+offset + 16 * 5);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 16 * sizeof(uint8_t);
              break;
          }
          case 0x990d5ea: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SEQUENCE_CFG0_R40";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x992bab8: {
              //simpleType:uint
              pLabel = "FSP_VIO_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x997b4ac: {
              //simpleType:uint
              pLabel = "I2C_FAIL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x997e20e: {
              //simpleType:uint
              pLabel = "HDAT_RSV_MEM_NUM_SECTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x998757c: {
              //simpleType:uint
              pLabel = "PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[6]:");
              l_traceEntry.resize(10+offset + 6 * 19);
              for (uint32_t i = 0;i<6;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 6 * sizeof(uint64_t);
              break;
          }
          case 0x999e613: {
              //simpleType:uint
              pLabel = "RCW08_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x99b51a5: {
              //simpleType:uint
              pLabel = "LAST_IPLTIME_EID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x99f7795: {
              //simpleType:uint
              pLabel = "MSS_MRW_TEMP_REFRESH_RANGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9a0cac6: {
              //simpleType:uint
              pLabel = "DRAM_PU_DRV_IMP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x9a1b903: {
              //simpleType:uint
              pLabel = "SYSTEM_THERMAL_RESISTANCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9a283f7: {
              //simpleType:uint
              pLabel = "EXPLR_ACTAG_BASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9a2f3fb: {
              //simpleType:uint
              pLabel = "INCREASED_PAU_FREQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9a3213c: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F1RC05";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x9a3b18e: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VDD_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9a8a800: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SEQUENCE_CFG1_R41";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9ad35b5: {
              //simpleType:uint
              pLabel = "DDS_THRESHOLD_PSTATE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9aef30c: {
              //simpleType:uint
              pLabel = "MSS_CENT_VDD_SLOPE_ACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9b073da: {
              //simpleType:uint
              pLabel = "RUNN_CORE_CYCLE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9b1338c: {
              break;
          }
          case 0x9b2b581: {
              //simpleType:uint
              pLabel = "FSP_VDD_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9b2f9cf: {
              //simpleType:uint
              pLabel = "RCW41_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9b7099c: {
              //simpleType:uint
              pLabel = "NEST_PLL_FREQ_LIST";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[5]:");
              l_traceEntry.resize(10+offset + 5 * 11);
              for (uint32_t i = 0;i<5;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 5 * sizeof(uint32_t);
              break;
          }
          case 0x9bb1f90: {
              //simpleType:uint
              pLabel = "PM_RESET_FFDC_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9c05f84: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_RTT_PARK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 5);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 16 * sizeof(uint8_t);
              break;
          }
          case 0x9c16ebb: {
              //simpleType:uint
              pLabel = "MEM_EFF_BYTE_ENABLES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0x9c3a3d6: {
              //simpleType:uint
              pLabel = "MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9c878db: {
              //simpleType:uint
              pLabel = "OMI_FFE_POST_CURSOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9cb426e: {
              //simpleType:uint
              pLabel = "PROC_R_LOADLINE_UOHM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x9cb467b: {
              //simpleType:uint
              pLabel = "DCACHE_LINE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9cc78b8: {
              //simpleType:uint
              pLabel = "MEM_SI_VREF_MC_RD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9ce2145: {
              //simpleType:uint
              pLabel = "RCW43_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9cedf5f: {
              //simpleType:uint
              pLabel = "CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0x9cf4fc4: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_GEN";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x9d0a4a8: {
              //simpleType:uint
              pLabel = "TPM_SPI_BUS_DIV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9d169d9: {
              //simpleType:uint
              pLabel = "FORCE_SERIAL_ISTEPS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9d575cb: {
              //simpleType:uint
              pLabel = "CORE_IS_SPARE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9db3e24: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_ATTACHED_CHIP_CNFG";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0x9dc1f05: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_WL_ADJ_END";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9dc28f2: {
              break;
          }
          case 0x9dcade3: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TWR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9dd54f3: {
              //simpleType:uint
              pLabel = "RCW42_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9ddd63b: {
              //simpleType:uint
              pLabel = "THROTTLE_TABLE_OVERRIDE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 11);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 64 * sizeof(uint32_t);
              break;
          }
          case 0x9df5889: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9dfa8e3: {
              //simpleType:uint
              pLabel = "EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0x9e2f6b7: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9e4aac2: {
              //complexType - skipping
              break;
          }
          case 0x9e4ee59: {
              //simpleType:uint
              pLabel = "SPPE_RUNTIME_MEASUREMENT_HASH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0x9e66e24: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_TSNOOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0x9e6ab5c: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_EFFICIENCY_ALG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9ebf155: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_BANK_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x9eda982: {
              //complexType - skipping
              break;
          }
          case 0x9ef1783: {
              //simpleType:uint
              pLabel = "IO_O_DEBUG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9f10191: {
              //simpleType:uint
              pLabel = "HDAT_EC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9f3cbef: {
              //simpleType:uint
              pLabel = "PROC_OCC_SANDBOX_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0x9f5b11a: {
              //simpleType:uint
              pLabel = "MSS_MRW_DIMM_HEIGHT_MIXING_POLICY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9f670db: {
              //simpleType:uint
              pLabel = "FUSED_CORE_OPTION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9f7bd88: {
              //simpleType:uint
              pLabel = "MEM_EFF_HOST_TO_DDR_SPEED_RATIO";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0x9f8f049: {
              //simpleType:uint
              pLabel = "ODY_SIM_TSTAOFF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9fae533: {
              //simpleType:uint
              pLabel = "ODY_SIM_TDQS2DQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0x9fc8b45: {
              //simpleType:uint
              pLabel = "VOLTAGE_EXT_VDN_BIAS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0x9fd70fb: {
              //simpleType:uint
              pLabel = "FSP_HW_RECONFIG_MAX_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa030cff: {
              //simpleType:uint
              pLabel = "CME_CHTM_TRACE_MEMORY_CONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa098a7e: {
              break;
          }
          case 0xa0bf6f9: {
              //simpleType:uint
              pLabel = "PROC_HW_TOPOLOGY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa0cb35b: {
              //simpleType:uint
              pLabel = "MEM_OVERRIDE_FREQ_LIMITATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa0dd16a: {
              //simpleType:uint
              pLabel = "MNFG_TH_L3_DIR_CES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa10bfc8: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PCS_RX_LOFF_CONTROL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0xa12ad5c: {
              //simpleType:uint
              pLabel = "ODY_ADV_TRAIN_OPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa140a0e: {
              //simpleType:uint
              pLabel = "DRAMINIT_TRAINING_TIMEOUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa147b1c: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRAS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa15fc01: {
              //simpleType:uint
              pLabel = "MSS_MRW_VCS_OFFSET_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa186078: {
              //simpleType:uint
              pLabel = "ODY_SEQUENCE_CTRL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa1ab2a1: {
              //simpleType:uint
              pLabel = "DVFS_ADJUSTMENT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa1bd115: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TCCD_L_WR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa1e433c: {
              //simpleType:uint
              pLabel = "CHTM_TRACE_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xa1f38fc: {
              break;
          }
          case 0xa1f54ec: {
              //simpleType:uint
              pLabel = "DDS_COARSE_THROTTLE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa22aac4: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xa232f81: {
              //simpleType:uint
              pLabel = "MEM_DDR5_WR_CRC_ERR_STATUS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa235b8b: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_PORT1_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa24c56a: {
              //simpleType:uint
              pLabel = "POUND_W_STATIC_DATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa258a52: {
              //simpleType:uint
              pLabel = "PEC_PCIE_LANE_MASK_BIFURCATED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0xa26f1f9: {
              //simpleType:uint
              pLabel = "CLOCKSTOP_ON_XSTOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa2ab303: {
              //simpleType:uint
              pLabel = "PREHEAT_PERCENT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa2c9bd2: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_GROUP_MASTER_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa2f9494: {
              //simpleType:uint
              pLabel = "MSS_DATABUS_UTIL_PER_MBA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa2fea8f: {
              //simpleType:uint
              pLabel = "VDN_BOOT_VOLTAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa31ec38: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa31ee72: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa35f85d: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa3a1b06: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa3a4736: {
              //simpleType:uint
              pLabel = "PSTATES_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa3a830c: {
              //simpleType:uint
              pLabel = "PM_MALF_ALERT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa3dc291: {
              //simpleType:uint
              pLabel = "FREQ_CORE_CEILING_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa3e1a5f: {
              //simpleType:uint
              pLabel = "PROC_PCIE_CACHE_INJ_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa40efa1: {
              break;
          }
          case 0xa411747: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC1X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xa41ce38: {
              //simpleType:uint
              pLabel = "SYS_VFRT_STATIC_DATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa42690f: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_RTT_NOM_RD";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 5);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 16 * sizeof(uint8_t);
              break;
          }
          case 0xa432982: {
              //simpleType:uint
              pLabel = "MSS_OCMB_RECOV_OBJ_HANDLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa450ad9: {
              //simpleType:uint
              pLabel = "HW543384_WAR_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa45db0f: {
              //simpleType:uint
              pLabel = "CLOCK_MUX10_PAU_DPLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa4d2083: {
              //simpleType:enum
              pLabel = "PAYLOAD_KIND";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_KIND_UNKNOWN");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_KIND_PHYP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_KIND_SAPPHIRE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "PAYLOAD_KIND_NONE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xa4d2323: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xa4f1b0b: {
              //simpleType:uint
              pLabel = "DISABLE_SPECIAL_WAKEUP_ON_SYSTEM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa5113fc: {
              //simpleType:uint
              pLabel = "OCMB_BOOT_SIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa543693: {
              //simpleType:uint
              pLabel = "PROC_INT_TM_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa5447c0: {
              //simpleType:uint
              pLabel = "DDS_TRIP_OFFSET_ADJUST";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xa56649e: {
              //simpleType:uint
              pLabel = "PROC_LCO_TARGETS_MIN";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0xa59a4fa: {
              //simpleType:uint
              pLabel = "MAX_EXS_PER_PROC_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa59d641: {
              //simpleType:uint
              pLabel = "OMI_DL_GROUP_POS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa5a748f: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_BROADCAST_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa5c1fbe: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa5ccc9a: {
              //simpleType:uint
              pLabel = "VPP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa607f58: {
              //simpleType:uint
              pLabel = "IO_XBUS_CHAN_EQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa608b2e: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa611583: {
              //simpleType:uint
              pLabel = "MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa628606: {
              //simpleType:uint
              pLabel = "RID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa65395b: {
              //simpleType:enum
              pLabel = "SPD_DRAM_DIMM_DEVICE_TYPE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "SPD_DRAM_DIMM_DEVICE_TYPE_NONE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000B: {
                      sprintf(&(l_traceEntry[0]), "SPD_DRAM_DIMM_DEVICE_TYPE_DDR3");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000C: {
                      sprintf(&(l_traceEntry[0]), "SPD_DRAM_DIMM_DEVICE_TYPE_DDR4");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000012: {
                      sprintf(&(l_traceEntry[0]), "SPD_DRAM_DIMM_DEVICE_TYPE_DDR5");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xa6640ef: {
              //simpleType:uint
              pLabel = "INTERPOSER_ECID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa6645a7: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa687574: {
              //simpleType:uint
              pLabel = "INTERPOSER_FEATURE_HW632898";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa68e8ba: {
              //simpleType:uint
              pLabel = "VCS_BOOT_VOLTAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa6a5da4: {
              //simpleType:uint
              pLabel = "SAFE_MODE_NODDS_UPLIFT_0P5PCT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 11);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint32_t);
              break;
          }
          case 0xa6c0769: {
              //simpleType:uint
              pLabel = "FREQ_OMI_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa6c89f0: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TMAW";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa71ccac: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa71dd22: {
              //simpleType:uint
              pLabel = "EFF_HYBRID_MEMORY_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xa71e033: {
              //simpleType:uint
              pLabel = "MAX_DMI_PER_PROC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa74c8da: {
              //simpleType:uint
              pLabel = "TPM_POISONED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa780baa: {
              //simpleType:enum
              pLabel = "PRIMARY_MF_CLOCK";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "PRIMARY_MF_CLOCK_BOTH_SRC0");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "PRIMARY_MF_CLOCK_BOTH_SRC1");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "PRIMARY_MF_CLOCK_SRC0");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "PRIMARY_MF_CLOCK_SRC1");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "PRIMARY_MF_CLOCK_SRC_NONE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xa78e807: {
              //simpleType:uint
              pLabel = "PROC_EPS_READ_CYCLES_T2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa78eaae: {
              //simpleType:uint
              pLabel = "WOV_UNDERV_VMIN_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa799fe9: {
              //simpleType:uint
              pLabel = "RCW48_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa7a6601: {
              //simpleType:uint
              pLabel = "WOF_ENABLE_FRATIO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa7b26cf: {
              //simpleType:uint
              pLabel = "MRW_MAX_DDR_FREQ_ON_IOSCM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xa7e62d3: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa7ea6d2: {
              //simpleType:uint
              pLabel = "LINK_TRAIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa7fc90e: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_3_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa813135: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa82e8ff: {
              //complexType - skipping
              break;
          }
          case 0xa85a352: {
              //simpleType:uint
              pLabel = "WOV_OVERV_STEP_DECR_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa8672bd: {
              //simpleType:uint
              pLabel = "PROC_SMF_BAR_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa8b10e1: {
              //simpleType:uint
              pLabel = "PIB_I2C_REFCLOCK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xa8c5e49: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa8e207c: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa8ec5ac: {
              //simpleType:uint
              pLabel = "ODY_PSRO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xa8fffa4: {
              //simpleType:uint
              pLabel = "CEN_SPD_DRAM_DEVICE_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa90a6fa: {
              //complexType - skipping
              break;
          }
          case 0xa914ec9: {
              //complexType - skipping
              break;
          }
          case 0xa95efea: {
              //simpleType:uint
              pLabel = "WOF_INDEX_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa96afb3: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_ATTACHED_CHIP_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xa970ba4: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRTP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa982f98: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRAS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xa99637f: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_DIFF_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xa9a7c39: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_ADDR_DIS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xa9d881f: {
              //simpleType:enum
              pLabel = "ENGINE_TYPE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "ENGINE_TYPE_NA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "ENGINE_TYPE_ENGINE_IIC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "ENGINE_TYPE_ENGINE_SCOM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xa9e7355: {
              //simpleType:uint
              pLabel = "CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xaa04632: {
              //simpleType:uint
              pLabel = "IOHS_LINK_SPLIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa1d410: {
              //simpleType:uint
              pLabel = "FREQ_PB_MHZ_POUNDV_FALLBACK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xaa2e048: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_2_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa3176d: {
              //simpleType:uint
              pLabel = "SBE_HBBL_EXCEPTION_INSTRUCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xaa3902b: {
              //simpleType:uint
              pLabel = "IO_OBUS_DCCAL_FLAGS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa4803f: {
              //simpleType:uint
              pLabel = "OMI_FFE_PRE_CURSOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xaa4ce6c: {
              //simpleType:uint
              pLabel = "ODY_PNOR_COMBINED_IMAGES_HASH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0xaa54450: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_AL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa68a22: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC3X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xaa74969: {
              //simpleType:uint
              pLabel = "PROC_FORCE_MC_PLL_BANDSEL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa89323: {
              //simpleType:uint
              pLabel = "WOF_TABLE_OVERRIDE_WB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xaa8cfef: {
              //simpleType:uint
              pLabel = "RCW0D_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa9080d: {
              //simpleType:uint
              pLabel = "RESCLK_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaa99dde: {
              //simpleType:uint
              pLabel = "SYSTEM_WOV_DDS_CALIBRATION_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaac24d5: {
              //simpleType:uint
              pLabel = "FREQ_PROC_REFCLOCK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xaadf350: {
              //simpleType:uint
              pLabel = "ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int16_t);
              break;
          }
          case 0xab1f0d1: {
              //simpleType:uint
              pLabel = "SPPE_BOOTLOADER_MEASUREMENT_HASH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0xab4c632: {
              //simpleType:uint
              pLabel = "OCMB_FW_UPDATE_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xab67f8c: {
              //simpleType:uint
              pLabel = "ODY_SENSOR_POLLING_PERIOD_MS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xab70ca8: {
              //simpleType:uint
              pLabel = "PEC_IS_BIFURCATABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xab82746: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRRD_S";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xab8959f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xabb5e9c: {
              //simpleType:uint
              pLabel = "WOV_UNDERV_STEP_DECR_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xac2958b: {
              //simpleType:uint
              pLabel = "CLOCK_MUX11_NEST_DPLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xacbf06c: {
              //simpleType:uint
              pLabel = "CEN_MBA_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xacc8025: {
              //simpleType:uint
              pLabel = "ICACHE_ASSOC_SETS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xacca48f: {
              //simpleType:uint
              pLabel = "FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xad171df: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_AVDD_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xad366df: {
              //simpleType:uint
              pLabel = "BACKUP_MEASUREMENT_SEEPROM_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xad3e4fe: {
              //simpleType:uint
              pLabel = "NEST_PLL_FREQ_BUCKETS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xad63b90: {
              //simpleType:uint
              pLabel = "SAFE_MODE_VOLTAGE_MV";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 11);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint32_t);
              break;
          }
          case 0xad706f2: {
              //simpleType:enum
              pLabel = "CHECK_ATTN_AFTER_ISTEP_FAIL";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "CHECK_ATTN_AFTER_ISTEP_FAIL_DEFAULT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "CHECK_ATTN_AFTER_ISTEP_FAIL_NO");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xad742c1: {
              //simpleType:uint
              pLabel = "RUNN_CORE_SEED_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xad86cfa: {
              //simpleType:uint
              pLabel = "IOHS_PLL_BUCKET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xad8dd9f: {
              //simpleType:uint
              pLabel = "RCW05_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xada1fc2: {
              //simpleType:uint
              pLabel = "ODY_DISABLE_DRAM_WITH_BAD_DQ0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xadb2ae7: {
              //simpleType:uint
              pLabel = "ODY_PHY_DFIMRL_MARGIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xadddfcd: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_WRITEBACK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xae13b85: {
              //simpleType:uint
              pLabel = "MEM_EXP_RCD_SLEW_RATE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0xae1e6c4: {
              //simpleType:uint
              pLabel = "C1_PC_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xae3040d: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0xae3bc8f: {
              //nativeType:EntityPath
              pLabel = "PEER_PATH";
              const char *pathString;
              // from targeting/common/entitypath.[CH]
              const uint8_t lPtype = *l_ptr; // PATH_TYPE
              switch (lPtype) {
                  case 0x01: pathString = "Logical:"; break;
                  case 0x02: pathString = "Physical:"; break;
                  case 0x03: pathString = "Device:"; break;
                  case 0x04: pathString = "Power:"; break;
                  default:   pathString = "Unknown:"; break;
              }
              l_traceEntry.resize(strlen(pathString) + 128);
              uint32_t dataSize = sprintf(&(l_traceEntry[0]), "%s",pathString);
              const uint8_t lSize = *(l_ptr + 1); // number of elements
              uint8_t *lElementInstance = (l_ptr + 2);
              for (uint32_t i=0;i<lSize;i += 2) {
                  switch (lElementInstance[i]) {
                      case 0x00: { pathString = "/NA"; break; }
                      case 0x01: { pathString = "/Sys"; break; }
                      case 0x02: { pathString = "/Node"; break; }
                      case 0x03: { pathString = "/DIMM"; break; }
                      case 0x04: { pathString = "/Membuf"; break; }
                      case 0x05: { pathString = "/Proc"; break; }
                      case 0x06: { pathString = "/EX"; break; }
                      case 0x07: { pathString = "/Core"; break; }
                      case 0x08: { pathString = "/L2"; break; }
                      case 0x09: { pathString = "/L3"; break; }
                      case 0x0A: { pathString = "/L4"; break; }
                      case 0x0B: { pathString = "/MCS"; break; }
                      case 0x0D: { pathString = "/MBA"; break; }
                      case 0x0E: { pathString = "/XBUS"; break; }
                      case 0x0F: { pathString = "/ABUS"; break; }
                      case 0x10: { pathString = "/PCI"; break; }
                      case 0x11: { pathString = "/DPSS"; break; }
                      case 0x12: { pathString = "/APSS"; break; }
                      case 0x13: { pathString = "/OCC"; break; }
                      case 0x14: { pathString = "/PSI"; break; }
                      case 0x15: { pathString = "/FSP"; break; }
                      case 0x16: { pathString = "/PNOR"; break; }
                      case 0x17: { pathString = "/OSC"; break; }
                      case 0x18: { pathString = "/TODCLK"; break; }
                      case 0x19: { pathString = "/CONTROL_NODE"; break; }
                      case 0x1A: { pathString = "/OSCREFCLK"; break; }
                      case 0x1B: { pathString = "/OSCPCICLK"; break; }
                      case 0x1C: { pathString = "/REFCLKENDPT"; break; }
                      case 0x1D: { pathString = "/PCICLKENDPT"; break; }
                      case 0x1E: { pathString = "/NX"; break; }
                      case 0x1F: { pathString = "/PORE"; break; }
                      case 0x20: { pathString = "/PCIESWITCH"; break; }
                      case 0x21: { pathString = "/CAPP"; break; }
                      case 0x22: { pathString = "/FSI"; break; }
                      case 0x23: { pathString = "/EQ"; break; }
                      case 0x24: { pathString = "/MCA"; break; }
                      case 0x25: { pathString = "/MCBIST"; break; }
                      case 0x26: { pathString = "/MI"; break; }
                      case 0x27: { pathString = "/DMI"; break; }
                      case 0x28: { pathString = "/OBUS"; break; }
                      case 0x2A: { pathString = "/SBE"; break; }
                      case 0x2B: { pathString = "/PPE"; break; }
                      case 0x2C: { pathString = "/PERV"; break; }
                      case 0x2D: { pathString = "/PEC"; break; }
                      case 0x2E: { pathString = "/PHB"; break; }
                      case 0x2F: { pathString = "/SYSREFCLKENDPT"; break; }
                      case 0x30: { pathString = "/MFREFCLKENDPT"; break; }
                      case 0x31: { pathString = "/TPM"; break; }
                      case 0x32: { pathString = "/SP"; break; }
                      case 0x33: { pathString = "/UART"; break; }
                      case 0x34: { pathString = "/PS"; break; }
                      case 0x35: { pathString = "/FAN"; break; }
                      case 0x36: { pathString = "/VRM"; break; }
                      case 0x37: { pathString = "/USB"; break; }
                      case 0x38: { pathString = "/ETH"; break; }
                      case 0x39: { pathString = "/PANEL"; break; }
                      case 0x3A: { pathString = "/BMC"; break; }
                      case 0x3B: { pathString = "/FLASH"; break; }
                      case 0x3C: { pathString = "/SEEPROM"; break; }
                      case 0x3D: { pathString = "/TMP"; break; }
                      case 0x3E: { pathString = "/GPIO_EXPANDER"; break; }
                      case 0x3F: { pathString = "/POWER_SEQUENCER"; break; }
                      case 0x40: { pathString = "/RTC"; break; }
                      case 0x41: { pathString = "/FANCTLR"; break; }
                      case 0x42: { pathString = "/OBUS_BRICK"; break; }
                      case 0x43: { pathString = "/NPU"; break; }
                      case 0x44: { pathString = "/MC"; break; }
                      case 0x45: { pathString = "/TEST_FAIL"; break; }
                      case 0x46: { pathString = "/MFREFCLK"; break; }
                      case 0x47: { pathString = "/SMPGROUP"; break; }
                      case 0x48: { pathString = "/OMI"; break; }
                      case 0x49: { pathString = "/MCC"; break; }
                      case 0x4A: { pathString = "/OMIC"; break; }
                      case 0x4B: { pathString = "/OCMB_CHIP"; break; }
                      case 0x4C: { pathString = "/MEM_PORT"; break; }
                      case 0x4D: { pathString = "/I2C_MUX"; break; }
                      case 0x4E: { pathString = "/PMIC"; break; }
                      case 0x4F: { pathString = "/NMMU"; break; }
                      case 0x50: { pathString = "/PAU"; break; }
                      case 0x51: { pathString = "/IOHS"; break; }
                      case 0x52: { pathString = "/PAUC"; break; }
                      case 0x53: { pathString = "/FC"; break; }
                      case 0x54: { pathString = "/LPCREFCLKENDPT"; break; }
                      case 0x55: { pathString = "/GENERIC_I2C_DEVICE"; break; }
                      case 0x56: { pathString = "/MDS_CTLR"; break; }
                      case 0x57: { pathString = "/DCM"; break; }
                      case 0x66: { pathString = "/POWER_IC"; break; }
                      case 0x67: { pathString = "/TEMP_SENSOR"; break; }
                      case 0x68: { pathString = "/LAST_IN_RANGE"; break; }
                      default:   { pathString = "/UNKNOWN"; break; }
                  } // switch
                  // copy next part in, overwritting previous terminator
                  dataSize += sprintf(&(l_traceEntry[0]) + dataSize, "%s%d",pathString,lElementInstance[i+1]);
                  l_ptr += 2 * sizeof(uint8_t);
              } // for
              break;
          }
          case 0xae5b915: {
              //simpleType:uint
              pLabel = "CORE_INSIDE_SPECIAL_WAKEUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xae84e31: {
              //simpleType:uint
              pLabel = "PM_SPIPSS_IN_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xae90c41: {
              //simpleType:uint
              pLabel = "IO_XBUS_GRP0_PRE_BAD_LANE_DATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xaf0a215: {
              //simpleType:uint
              pLabel = "RCW0A_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaf0dc82: {
              //simpleType:uint
              pLabel = "RUNN_DO_CONFIG_CHECKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaf1aa7c: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_INTERNAL_FW_REVISION1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xaf2e876: {
              //simpleType:uint
              pLabel = "OCC_MIN_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xaf57fed: {
              //simpleType:uint
              pLabel = "MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaf60522: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_RECAL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xaf6e256: {
              //simpleType:uint
              pLabel = "INITIATED_PM_HALT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaf7ed15: {
              //simpleType:uint
              pLabel = "RCW09_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xaf91cc7: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TFAW";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xaf98ef4: {
              //simpleType:uint
              pLabel = "MEM_SI_DIMM_RCD_IBT_CKE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xafeb5ce: {
              //simpleType:uint
              pLabel = "MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[25]:");
              l_traceEntry.resize(10+offset + 25 * 19);
              for (uint32_t i = 0;i<25;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 25 * sizeof(uint64_t);
              break;
          }
          case 0xafef4d7: {
              //simpleType:uint
              pLabel = "RNG_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xaff2273: {
              //simpleType:uint
              pLabel = "FIELD_CORE_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb0328d5: {
              //simpleType:uint
              pLabel = "MEM_SI_DIMM_RCD_IBT_CA";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xb03f256: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_ODIC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xb069fed: {
              //simpleType:uint
              pLabel = "PROC_LCO_TARGETS_VECTOR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 11);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 3 * sizeof(uint32_t);
              break;
          }
          case 0xb07c927: {
              //simpleType:uint
              pLabel = "MEM_DEVICE15_MPSM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb089450: {
              //simpleType:uint
              pLabel = "ODY_PHY_DEBUG_TRAIN_OPTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb0b1979: {
              //simpleType:uint
              pLabel = "RT_DECONFIG_FAILED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb0c96e5: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_CK_ODT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0xb11a217: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb1987de: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_USAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb1c3653: {
              //simpleType:uint
              pLabel = "DISABLE_HBBL_VECTORS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb1d0a53: {
              //simpleType:uint
              pLabel = "MEM_DDR5_GLOBAL_DFE_TAP3";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb1fab71: {
              //complexType - skipping
              break;
          }
          case 0xb20c6e2: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_CK_ODT_PER_DRAM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 7);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 160 * sizeof(uint16_t);
              break;
          }
          case 0xb22f067: {
              //simpleType:uint
              pLabel = "OCS_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb257082: {
              //simpleType:uint
              pLabel = "MFG_TRACE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb25cde0: {
              //simpleType:uint
              pLabel = "PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb28a4f5: {
              //simpleType:uint
              pLabel = "PROC_MIRROR_BASES_ACK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0xb28a8fb: {
              //simpleType:uint
              pLabel = "MEM_EFF_PACKAGE_RANK_MAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][20]:");
              l_traceEntry.resize(10+offset + 40 * 5);
              for (uint32_t i = 0;i<40;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 40 * sizeof(uint8_t);
              break;
          }
          case 0xb2b25f6: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_ADDR_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xb2bacb2: {
              //simpleType:uint
              pLabel = "SYSTEM_WOF_LAB_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb2d229a: {
              break;
          }
          case 0xb312257: {
              //simpleType:uint
              pLabel = "PCIE_32BIT_MMIO_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb33ecf6: {
              //simpleType:uint
              pLabel = "MSS_EXP_INTR_MASK_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb36fcfa: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb397e66: {
              //simpleType:uint
              pLabel = "PROC_PCIE_FW_VERSION_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xb3adef2: {
              //simpleType:uint
              pLabel = "RISK_LEVEL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb3b1e66: {
              //simpleType:uint
              pLabel = "RCW01_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb3d7076: {
              //simpleType:uint
              pLabel = "RCW0E_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb3e8ad9: {
              //simpleType:uint
              pLabel = "MSS_MRW_PWR_SLOPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[100]:");
              l_traceEntry.resize(10+offset + 100 * 19);
              for (uint32_t i = 0;i<100;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 100 * sizeof(uint64_t);
              break;
          }
          case 0xb436d4f: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_PERIOD_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb43f2fe: {
              //simpleType:uint
              pLabel = "MC_PLL_BUCKET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xb441dca: {
              //simpleType:uint
              pLabel = "CLOCK_PLL_MUX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb4bc1d3: {
              //simpleType:uint
              pLabel = "IO_OMI_CHANNEL_LOSS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb4f1718: {
              //simpleType:uint
              pLabel = "MSS_VCS_PROGRAM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb50fc28: {
              //simpleType:uint
              pLabel = "EXP_TOTAL_PWR_INTERCEPT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0xb52fb82: {
              //simpleType:uint
              pLabel = "MEM_EXP_SPD_TAA_MIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xb541170: {
              //simpleType:uint
              pLabel = "SPPE_TARGET_STATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb5623a6: {
              //simpleType:uint
              pLabel = "MEM_DIMM_POS_METADATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb57d3ee: {
              //simpleType:uint
              pLabel = "PMIC_HEALTH_CHECK_TIMER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb5913fd: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb5ade27: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb5afcd7: {
              //nativeType:EntityPath
              pLabel = "AFFINITY_PATH";
              const char *pathString;
              // from targeting/common/entitypath.[CH]
              const uint8_t lPtype = *l_ptr; // PATH_TYPE
              switch (lPtype) {
                  case 0x01: pathString = "Logical:"; break;
                  case 0x02: pathString = "Physical:"; break;
                  case 0x03: pathString = "Device:"; break;
                  case 0x04: pathString = "Power:"; break;
                  default:   pathString = "Unknown:"; break;
              }
              l_traceEntry.resize(strlen(pathString) + 128);
              uint32_t dataSize = sprintf(&(l_traceEntry[0]), "%s",pathString);
              const uint8_t lSize = *(l_ptr + 1); // number of elements
              uint8_t *lElementInstance = (l_ptr + 2);
              for (uint32_t i=0;i<lSize;i += 2) {
                  switch (lElementInstance[i]) {
                      case 0x00: { pathString = "/NA"; break; }
                      case 0x01: { pathString = "/Sys"; break; }
                      case 0x02: { pathString = "/Node"; break; }
                      case 0x03: { pathString = "/DIMM"; break; }
                      case 0x04: { pathString = "/Membuf"; break; }
                      case 0x05: { pathString = "/Proc"; break; }
                      case 0x06: { pathString = "/EX"; break; }
                      case 0x07: { pathString = "/Core"; break; }
                      case 0x08: { pathString = "/L2"; break; }
                      case 0x09: { pathString = "/L3"; break; }
                      case 0x0A: { pathString = "/L4"; break; }
                      case 0x0B: { pathString = "/MCS"; break; }
                      case 0x0D: { pathString = "/MBA"; break; }
                      case 0x0E: { pathString = "/XBUS"; break; }
                      case 0x0F: { pathString = "/ABUS"; break; }
                      case 0x10: { pathString = "/PCI"; break; }
                      case 0x11: { pathString = "/DPSS"; break; }
                      case 0x12: { pathString = "/APSS"; break; }
                      case 0x13: { pathString = "/OCC"; break; }
                      case 0x14: { pathString = "/PSI"; break; }
                      case 0x15: { pathString = "/FSP"; break; }
                      case 0x16: { pathString = "/PNOR"; break; }
                      case 0x17: { pathString = "/OSC"; break; }
                      case 0x18: { pathString = "/TODCLK"; break; }
                      case 0x19: { pathString = "/CONTROL_NODE"; break; }
                      case 0x1A: { pathString = "/OSCREFCLK"; break; }
                      case 0x1B: { pathString = "/OSCPCICLK"; break; }
                      case 0x1C: { pathString = "/REFCLKENDPT"; break; }
                      case 0x1D: { pathString = "/PCICLKENDPT"; break; }
                      case 0x1E: { pathString = "/NX"; break; }
                      case 0x1F: { pathString = "/PORE"; break; }
                      case 0x20: { pathString = "/PCIESWITCH"; break; }
                      case 0x21: { pathString = "/CAPP"; break; }
                      case 0x22: { pathString = "/FSI"; break; }
                      case 0x23: { pathString = "/EQ"; break; }
                      case 0x24: { pathString = "/MCA"; break; }
                      case 0x25: { pathString = "/MCBIST"; break; }
                      case 0x26: { pathString = "/MI"; break; }
                      case 0x27: { pathString = "/DMI"; break; }
                      case 0x28: { pathString = "/OBUS"; break; }
                      case 0x2A: { pathString = "/SBE"; break; }
                      case 0x2B: { pathString = "/PPE"; break; }
                      case 0x2C: { pathString = "/PERV"; break; }
                      case 0x2D: { pathString = "/PEC"; break; }
                      case 0x2E: { pathString = "/PHB"; break; }
                      case 0x2F: { pathString = "/SYSREFCLKENDPT"; break; }
                      case 0x30: { pathString = "/MFREFCLKENDPT"; break; }
                      case 0x31: { pathString = "/TPM"; break; }
                      case 0x32: { pathString = "/SP"; break; }
                      case 0x33: { pathString = "/UART"; break; }
                      case 0x34: { pathString = "/PS"; break; }
                      case 0x35: { pathString = "/FAN"; break; }
                      case 0x36: { pathString = "/VRM"; break; }
                      case 0x37: { pathString = "/USB"; break; }
                      case 0x38: { pathString = "/ETH"; break; }
                      case 0x39: { pathString = "/PANEL"; break; }
                      case 0x3A: { pathString = "/BMC"; break; }
                      case 0x3B: { pathString = "/FLASH"; break; }
                      case 0x3C: { pathString = "/SEEPROM"; break; }
                      case 0x3D: { pathString = "/TMP"; break; }
                      case 0x3E: { pathString = "/GPIO_EXPANDER"; break; }
                      case 0x3F: { pathString = "/POWER_SEQUENCER"; break; }
                      case 0x40: { pathString = "/RTC"; break; }
                      case 0x41: { pathString = "/FANCTLR"; break; }
                      case 0x42: { pathString = "/OBUS_BRICK"; break; }
                      case 0x43: { pathString = "/NPU"; break; }
                      case 0x44: { pathString = "/MC"; break; }
                      case 0x45: { pathString = "/TEST_FAIL"; break; }
                      case 0x46: { pathString = "/MFREFCLK"; break; }
                      case 0x47: { pathString = "/SMPGROUP"; break; }
                      case 0x48: { pathString = "/OMI"; break; }
                      case 0x49: { pathString = "/MCC"; break; }
                      case 0x4A: { pathString = "/OMIC"; break; }
                      case 0x4B: { pathString = "/OCMB_CHIP"; break; }
                      case 0x4C: { pathString = "/MEM_PORT"; break; }
                      case 0x4D: { pathString = "/I2C_MUX"; break; }
                      case 0x4E: { pathString = "/PMIC"; break; }
                      case 0x4F: { pathString = "/NMMU"; break; }
                      case 0x50: { pathString = "/PAU"; break; }
                      case 0x51: { pathString = "/IOHS"; break; }
                      case 0x52: { pathString = "/PAUC"; break; }
                      case 0x53: { pathString = "/FC"; break; }
                      case 0x54: { pathString = "/LPCREFCLKENDPT"; break; }
                      case 0x55: { pathString = "/GENERIC_I2C_DEVICE"; break; }
                      case 0x56: { pathString = "/MDS_CTLR"; break; }
                      case 0x57: { pathString = "/DCM"; break; }
                      case 0x66: { pathString = "/POWER_IC"; break; }
                      case 0x67: { pathString = "/TEMP_SENSOR"; break; }
                      case 0x68: { pathString = "/LAST_IN_RANGE"; break; }
                      default:   { pathString = "/UNKNOWN"; break; }
                  } // switch
                  // copy next part in, overwritting previous terminator
                  dataSize += sprintf(&(l_traceEntry[0]) + dataSize, "%s%d",pathString,lElementInstance[i+1]);
                  l_ptr += 2 * sizeof(uint8_t);
              } // for
              break;
          }
          case 0xb5c4f8b: {
              //simpleType:uint
              pLabel = "MSS_SAFEMODE_DRAM_DATABUS_UTIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb5f758a: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SEQUENCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb630402: {
              //simpleType:uint
              pLabel = "MINI_EC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb63387a: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SEQUENCE_CFG0_R40";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb639c30: {
              //simpleType:uint
              pLabel = "C0_PC_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb63ad57: {
              //simpleType:uint
              pLabel = "DDS_LARGE_DROOP_DETECT_ADJUST";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xb65b981: {
              //simpleType:uint
              pLabel = "PROC_NHTM_BAR_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xb69562d: {
              //simpleType:uint
              pLabel = "PM_SPIPSS_FRAME_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb697f6d: {
              //simpleType:uint
              pLabel = "IO_GROUNDED_LINKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xb6ad76f: {
              //simpleType:uint
              pLabel = "HW543822_WAR_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb6cd941: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb6d6b39: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb6d7403: {
              //simpleType:uint
              pLabel = "ODY_TMPL_1_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb6f0cd7: {
              //simpleType:uint
              pLabel = "PHB_BASE_ADDRS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 19);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint64_t);
              break;
          }
          case 0xb728460: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_PPR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xb728b91: {
              //simpleType:enum
              pLabel = "CDM_DOMAIN";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_NONE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_CPU");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_DIMM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_FABRIC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_MEM");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000005: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_IO");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000006: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_NODE");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000007: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_CLOCK");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000008: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_PSI");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000009: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_FSP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000A: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_SECURITY");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000B: {
                      sprintf(&(l_traceEntry[0]), "CDM_DOMAIN_ALL");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xb78c1f9: {
              //simpleType:uint
              pLabel = "IO_XBUS_GRP1_PRE_BAD_LANE_DATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb7b1ac5: {
              //simpleType:uint
              pLabel = "MEM_VCS_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb7b2c40: {
              //simpleType:uint
              pLabel = "SECONDARY_SEEPROM_FAIL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb7dddfb: {
              //simpleType:uint
              pLabel = "MRW_HW_MIRRORING_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb812834: {
              //simpleType:uint
              pLabel = "BACKUP_SEEPROM_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb846e46: {
              //simpleType:uint
              pLabel = "ISTEP_TIMEOUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xb84e7b5: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_SCOPE_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb88d1cf: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_STRUCT_ENDIAN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb8b3f00: {
              //simpleType:uint
              pLabel = "REPLACED_BY_SPARE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb8cb525: {
              //simpleType:uint
              pLabel = "OCMB_IGNORE_SCOM_CHECK_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb8d2a23: {
              //simpleType:uint
              pLabel = "MEM_THERMAL_INIT_COMPLETE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb91f5de: {
              //simpleType:uint
              pLabel = "PROC_EFF_FABRIC_CHIP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9270af: {
              //simpleType:uint
              pLabel = "PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xb93929e: {
              //simpleType:uint
              pLabel = "SYSTEM_WOV_OVERV_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb973ab4: {
              //simpleType:uint
              pLabel = "I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9adbfd: {
              //simpleType:uint
              pLabel = "MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9afeb8: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_PHASE_COMB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9c0fc3: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9cc761: {
              //simpleType:uint
              pLabel = "NHTM_CTRL_MARK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9dc486: {
              //simpleType:uint
              pLabel = "MRW_L2_INCREASE_JITTER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xb9ee432: {
              //simpleType:uint
              pLabel = "PROC_MIRROR_BASES";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0xb9ee451: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xba10231: {
              //simpleType:uint
              pLabel = "PROC_L3_HASH_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xba4cb42: {
              //simpleType:uint
              pLabel = "PLCK_IPL_ATTR_OVERRIDES_EXIST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xba62227: {
              //simpleType:uint
              pLabel = "MEM_EXP_INIT_VREF_DQ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xba6f1c6: {
              //complexType - skipping
              break;
          }
          case 0xba8abbe: {
              //simpleType:uint
              pLabel = "SBE_IMAGE_MINIMUM_VALID_ECS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbaa5d46: {
              //simpleType:uint
              pLabel = "MSS_CENT_AVDD_SLOPE_INACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbaef615: {
              break;
          }
          case 0xbb0ac42: {
              //simpleType:uint
              pLabel = "MSS_CENT_AVDD_INTERCEPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbb36ec8: {
              //simpleType:uint
              pLabel = "USE_PIPE_FIFO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbb5d3e9: {
              //simpleType:uint
              pLabel = "PROC_EFF_FABRIC_GROUP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbb90f0a: {
              //simpleType:uint
              pLabel = "PGPE_HCODE_FUNCTION_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbbb7d6f: {
              //simpleType:uint
              pLabel = "PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbbc3ceb: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xbbd2eef: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_INTERNAL_FW_REVISION0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xbbf242e: {
              //simpleType:uint
              pLabel = "IO_X_MFG_MIN_EYE_WIDTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbc265b8: {
              //simpleType:uint
              pLabel = "OMI_TX_POST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbc51273: {
              //simpleType:uint
              pLabel = "MSS_MRW_OCMB_PWR_SLOPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[50]:");
              l_traceEntry.resize(10+offset + 50 * 19);
              for (uint32_t i = 0;i<50;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 50 * sizeof(uint64_t);
              break;
          }
          case 0xbc5137d: {
              //simpleType:uint
              pLabel = "THROTTLE_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbc55176: {
              //simpleType:uint
              pLabel = "SUPPORTED_STOP_STATES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbc8d08b: {
              //complexType - skipping
              break;
          }
          case 0xbca8078: {
              //simpleType:uint
              pLabel = "IO_GROUNDED_CONTROLLERS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xbcc0968: {
              //simpleType:uint
              pLabel = "EFF_DRAM_WIDTH";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xbcdda58: {
              //simpleType:uint
              pLabel = "PROC_SLEEP_WINKLE_LID_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbcf856d: {
              //simpleType:uint
              pLabel = "PROC_FSP_MMIO_MASK_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbd13798: {
              //simpleType:uint
              pLabel = "MSS_MRW_REFRESH_RATE_REQUEST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbd313d5: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_STOP_CYCLES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbd6da05: {
              //simpleType:uint
              pLabel = "FREQ_IO_REFCLOCK_KHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbd8bf3c: {
              //simpleType:uint
              pLabel = "MEM_EFF_VOLT_VPP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbdb2023: {
              //simpleType:uint
              pLabel = "OMI_SPREAD_SPECTRUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbdb2233: {
              //simpleType:uint
              pLabel = "NVDIMM_ENCRYPTION_KEYS_FW";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[96]:");
              l_traceEntry.resize(10+offset + 96 * 5);
              for (uint32_t i = 0;i<96;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 96 * sizeof(uint8_t);
              break;
          }
          case 0xbdb835c: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbdbbd24: {
              //simpleType:uint
              pLabel = "OCMB_FORCE_IMAGE_SYNC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbdccc4d: {
              //simpleType:uint
              pLabel = "SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbdd1f8c: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC7X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xbde3ab9: {
              //simpleType:uint
              pLabel = "USE_TCES_FOR_DMAS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbdf333e: {
              //simpleType:uint
              pLabel = "MSS_VOLT_DDR3_VDDR_INTERCEPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbe0602d: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_MEM_PORT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbe06c50: {
              //simpleType:uint
              pLabel = "MSS_MRW_THERMAL_MEMORY_POWER_LIMIT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[10]:");
              l_traceEntry.resize(10+offset + 10 * 19);
              for (uint32_t i = 0;i<10;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 10 * sizeof(uint64_t);
              break;
          }
          case 0xbe0ba18: {
              //simpleType:uint
              pLabel = "IS_MPIPL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbe451d1: {
              break;
          }
          case 0xbe4e0de: {
              //simpleType:uint
              pLabel = "SIM_CHIPLET_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xbe90420: {
              //simpleType:uint
              pLabel = "CME_INSTRUCTION_TRACE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbe9c5f4: {
              //simpleType:uint
              pLabel = "DDR5_EN_TX_DM_PREAMBLE_PATTERN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbea907f: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC2X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xbeb4dd6: {
              //simpleType:uint
              pLabel = "SBE_RUNTIME_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbec986e: {
              //simpleType:uint
              pLabel = "MEM_EFF_MDS_DDIMM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xbecf4b6: {
              //simpleType:uint
              pLabel = "VDD_BOOT_VOLTAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbf0610c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbf11ec0: {
              //simpleType:uint
              pLabel = "HB_RSV_MEM_SIZE_MB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbf1b8d3: {
              //simpleType:uint
              pLabel = "IO_IOHS_CHANNEL_LOSS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbf86bc1: {
              //simpleType:uint
              pLabel = "SYSTEM_CONFIG_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xbfa8f5f: {
              //simpleType:uint
              pLabel = "RCW0D_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbfae9a6: {
              //simpleType:uint
              pLabel = "WOF_ALTITUDE_TEMP_ADJUSTMENT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xbfcaf43: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xbfccf0c: {
              //simpleType:uint
              pLabel = "RESOURCE_IS_CRITICAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc03336d: {
              //simpleType:uint
              pLabel = "ODY_SPECIAL_OFFSET_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc03d18e: {
              //simpleType:uint
              pLabel = "PROC_PCIE_BAR_ENABLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0xc070edb: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_3_USAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc08f9e2: {
              //simpleType:uint
              pLabel = "MEM_EFF_HYBRID_MEMORY_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xc0b9ce3: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc0bb633: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_A_LINK_DELAY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 11);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint32_t);
              break;
          }
          case 0xc0f898a: {
              //simpleType:uint
              pLabel = "OPTICS_CONFIG_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc0f9335: {
              //simpleType:uint
              pLabel = "MSS_MRW_PWR_INTERCEPT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[100]:");
              l_traceEntry.resize(10+offset + 100 * 19);
              for (uint32_t i = 0;i<100;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 100 * sizeof(uint64_t);
              break;
          }
          case 0xc110745: {
              //simpleType:uint
              pLabel = "WOF_THROTTLE_CONTROL_KP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc11b0c7: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_MFG_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0xc11d96f: {
              //simpleType:uint
              pLabel = "RCW40_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc122ecf: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SEQUENCE_CFG3_R43";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc13aa28: {
              //simpleType:uint
              pLabel = "CLOCK_PLL_MUX_TOD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc14452f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc1598bd: {
              //simpleType:uint
              pLabel = "FREQ_CORE_NOMINAL_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc17a0dc: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc18acac: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_CRC_ERROR_CLEAR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc18c43e: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_VREFCA";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0xc18e8f1: {
              //simpleType:enum
              pLabel = "CLASS";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "CLASS_NA");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "CLASS_CARD");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "CLASS_ENC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000003: {
                      sprintf(&(l_traceEntry[0]), "CLASS_CHIP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "CLASS_UNIT");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000005: {
                      sprintf(&(l_traceEntry[0]), "CLASS_DEV");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000006: {
                      sprintf(&(l_traceEntry[0]), "CLASS_SYS");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000007: {
                      sprintf(&(l_traceEntry[0]), "CLASS_LOGICAL_CARD");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000008: {
                      sprintf(&(l_traceEntry[0]), "CLASS_BATTERY");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000009: {
                      sprintf(&(l_traceEntry[0]), "CLASS_LED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000A: {
                      sprintf(&(l_traceEntry[0]), "CLASS_SP");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000B: {
                      sprintf(&(l_traceEntry[0]), "CLASS_ASIC");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x0000000C: {
                      sprintf(&(l_traceEntry[0]), "CLASS_MAX");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xc1dab35: {
              break;
          }
          case 0xc1e40a4: {
              //simpleType:uint
              pLabel = "EFF_DIMM_SIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0xc1f79e8: {
              //simpleType:uint
              pLabel = "SPECIAL_WAKEUP_NEEDED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc20758d: {
              //simpleType:uint
              pLabel = "MEM_SI_DRAM_RTT_WR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xc2163fb: {
              //simpleType:uint
              pLabel = "RCW47_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc2278f4: {
              break;
          }
          case 0xc22853c: {
              //simpleType:uint
              pLabel = "MAX_MS_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xc239aaf: {
              //simpleType:uint
              pLabel = "CRITICAL_CORE_TEMP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xc278ed9: {
              //simpleType:uint
              pLabel = "MEM_EFF_PRIM_DIE_COUNT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xc2a8db1: {
              //simpleType:uint
              pLabel = "PBAF_LFIRMASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xc2c35e5: {
              break;
          }
          case 0xc2fdc31: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[6]:");
              l_traceEntry.resize(10+offset + 6 * 19);
              for (uint32_t i = 0;i<6;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 6 * sizeof(uint64_t);
              break;
          }
          case 0xc315c52: {
              //simpleType:uint
              pLabel = "PM_GLOBAL_FIR_TRACE_EN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc352d05: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_RUN_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc36bada: {
              break;
          }
          case 0xc37b3da: {
              //simpleType:uint
              pLabel = "FREQ_IOHS_LINK_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc3a80c1: {
              //simpleType:uint
              pLabel = "HW_DECONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc3b3e7b: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xc3c0eb5: {
              //simpleType:uint
              pLabel = "DYNAMIC_INIT_FEATURE_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xc3e64a1: {
              //simpleType:uint
              pLabel = "PROC_MEM_SIZES_ACK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0xc3f35bf: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc406bf3: {
              //simpleType:uint
              pLabel = "MEM_EFF_VOLT_VDDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc412634: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_FW_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc4230d1: {
              //simpleType:uint
              pLabel = "MEM_EXP_FIRMWARE_EMULATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc44c3e5: {
              //simpleType:uint
              pLabel = "LMB_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc44fb48: {
              //simpleType:uint
              pLabel = "MELTBOX_FREQ_X";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc4572fd: {
              //simpleType:uint
              pLabel = "MAX_LOL_ERR_CNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc462253: {
              //simpleType:uint
              pLabel = "SAVED_STATE_UINT8";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc46febc: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC05";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xc470648: {
              //simpleType:uint
              pLabel = "MSS_CHECK_FOR_READY_TIMEOUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc476bf6: {
              //simpleType:uint
              pLabel = "ODY_ENABLE_US_TMPL_5";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc4941e4: {
              //simpleType:uint
              pLabel = "PROC_NHTM_BAR_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xc498800: {
              //simpleType:uint
              pLabel = "NEST_VCS_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc4be98e: {
              //simpleType:uint
              pLabel = "MSS_EXP_COMM_STATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc4be99d: {
              //simpleType:uint
              pLabel = "MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc4d3c24: {
              //simpleType:uint
              pLabel = "SBE_LOAD_BOOTLOADER_HBBL_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xc4fcb9a: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc538c17: {
              //simpleType:enum
              pLabel = "EEPROM_VPD_ACCESSIBILITY";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_ACCESSIBILITY_NONE_DISABLED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_ACCESSIBILITY_CACHE_DISABLED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000002: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_ACCESSIBILITY_PRIMARY_DISABLED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000004: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_ACCESSIBILITY_SECONDARY_DISABLED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000008: {
                      sprintf(&(l_traceEntry[0]), "EEPROM_VPD_ACCESSIBILITY_LAST_DISABLED");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xc593c05: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc5bf44b: {
              //simpleType:uint
              pLabel = "MEM_EFF_MODULE_MFG_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 7);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 2 * sizeof(uint16_t);
              break;
          }
          case 0xc5d939e: {
              break;
          }
          case 0xc60a499: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ODTLOFF_RD_NT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xc610fe3: {
              //simpleType:uint
              pLabel = "OBUS_SLOT_INDEX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc62f1ae: {
              //simpleType:uint
              pLabel = "MSS_MRW_VDD_OFFSET_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc635854: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc658f74: {
              //simpleType:uint
              pLabel = "PROC_INT_NVC_BAR_PAGE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc666c00: {
              //simpleType:uint
              pLabel = "MSS_MEM_MC_IN_GROUP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xc667245: {
              //simpleType:uint
              pLabel = "I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc687d1e: {
              //simpleType:uint
              pLabel = "SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc68f5ea: {
              //simpleType:uint
              pLabel = "MEM_SI_DRAM_DRV_IMP_DQ_DQS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xc6cf6dd: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_CORE_COUNT_INDEX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc6d3718: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc6d6b45: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_ECS_IN_SELF_REFRESH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc6dfefe: {
              //simpleType:uint
              pLabel = "HDAT_HBRT_NUM_SECTIONS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc6e1174: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc710685: {
              //simpleType:uint
              pLabel = "AVDD_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc73cd4e: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VDDR_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc76fe71: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VCS_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc774921: {
              //simpleType:uint
              pLabel = "BOOT_FLAGS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc77c618: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_READ_DBI";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc784cff: {
              //simpleType:uint
              pLabel = "MEM_EFF_ARDPTRINITVALOVR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc794239: {
              //simpleType:uint
              pLabel = "ASYNC_NEST_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc7a1d47: {
              //simpleType:uint
              pLabel = "LINK_SPEED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xc7b1e3f: {
              //simpleType:uint
              pLabel = "SBE_NUM_IMAGES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc7bc372: {
              //simpleType:uint
              pLabel = "SCRATCH_UINT8_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc7d9261: {
              //simpleType:uint
              pLabel = "FUSED_CORE_MODE_HB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc7deda5: {
              //simpleType:uint
              pLabel = "QME_BOOT_CONTROL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc87684a: {
              //simpleType:uint
              pLabel = "MSS_OCMB_DISABLE_THERM_INIT_READ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc8ab5a1: {
              //simpleType:uint
              pLabel = "EXTERNAL_VRM_TRANSITION_START_NS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0xc8bd195: {
              //simpleType:uint
              pLabel = "INSIDE_SPECIAL_WAKEUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc8c49e7: {
              break;
          }
          case 0xc8c5949: {
              //simpleType:uint
              pLabel = "SBE_NUM_CAPABILITIES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc95df70: {
              //simpleType:uint
              pLabel = "QME_STOP_PHANTOM_HALT_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc965d72: {
              //simpleType:uint
              pLabel = "OMI_BIST_DAC_TEST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc96a9e2: {
              //simpleType:uint
              pLabel = "DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc976513: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc9b42ea: {
              //simpleType:uint
              pLabel = "MSS_EXP_CDR_BW_OVERRIDE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc9b93c9: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRCD";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xc9c1f1a: {
              //simpleType:uint
              pLabel = "TURBO_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xc9c2d97: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_MPR_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc9cddc6: {
              //simpleType:uint
              pLabel = "DCADJ_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xc9dddb2: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_BANK_GROUP_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xca00099: {
              //simpleType:uint
              pLabel = "WOF_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xca20b66: {
              //simpleType:uint
              pLabel = "RCW44_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xca2de0a: {
              //simpleType:uint
              pLabel = "ULTRA_TURBO_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xca985e0: {
              //simpleType:uint
              pLabel = "QME_HCODE_BLOCK_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xcab73ca: {
              //simpleType:uint
              pLabel = "FREQ_CP_REFCLOCK_KHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xcac6a4c: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0xcac816f: {
              //simpleType:uint
              pLabel = "HOMER_PHYS_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xcadc29f: {
              //simpleType:uint
              pLabel = "C1_EXEC_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcb12e02: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcb1fddb: {
              //simpleType:uint
              pLabel = "DEAD_CORE_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcb72894: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_COUNT_THRESHOLD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xcb749b3: {
              //simpleType:uint
              pLabel = "TPM_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcb7b544: {
              //simpleType:uint
              pLabel = "EQ_INSIDE_SPECIAL_WAKEUP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcb9c4fa: {
              //simpleType:uint
              pLabel = "OMI_FFE_SETTINGS_COMMAND";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcba1600: {
              //complexType - skipping
              break;
          }
          case 0xcbd7ed0: {
              //simpleType:uint
              pLabel = "MNFG_XBUS_MIN_EYE_WIDTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcbf1228: {
              //simpleType:uint
              pLabel = "MEM_EFF_ARDPTRINITVAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcbf6008: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_TEMP_THRESHOLD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcc07b62: {
              //simpleType:uint
              pLabel = "AVSBUS_FREQUENCY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xcc28df8: {
              //simpleType:uint
              pLabel = "MEM_VDD_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xcc3d988: {
              //simpleType:uint
              pLabel = "FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xcc8bf2b: {
              //simpleType:uint
              pLabel = "AVSBUS_RAIL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xcc9dffd: {
              //simpleType:uint
              pLabel = "PROC_PCIE_LANE_REVERSAL_BASE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0xcca10d0: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SEQUENCE_CFG0_R40";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xccc15e8: {
              //simpleType:uint
              pLabel = "MNFG_DMI_MIN_EYE_HEIGHT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcced88f: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC01";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xcd0fc4e: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TWTR_S";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcd1457b: {
              //simpleType:uint
              pLabel = "SBE_BOOT_SIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcd35acb: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC6X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xcd4cd7a: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcd7817c: {
              //simpleType:uint
              pLabel = "CEN_DQ_TO_DIMM_CONN_DQ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[80]:");
              l_traceEntry.resize(10+offset + 80 * 5);
              for (uint32_t i = 0;i<80;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 80 * sizeof(uint8_t);
              break;
          }
          case 0xcd7be76: {
              //simpleType:uint
              pLabel = "PROC_ENABLE_DL_TMPL_4";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcd8f015: {
              //simpleType:uint
              pLabel = "HB_RUNNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcd97b51: {
              //simpleType:uint
              pLabel = "MASTER_CORE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcdbfb30: {
              //complexType - skipping
              break;
          }
          case 0xcde0848: {
              //simpleType:uint
              pLabel = "HTMSC_TTYPEFILT_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcdf2144: {
              break;
          }
          case 0xce01813: {
              //simpleType:uint
              pLabel = "MGC_LOAD_SOURCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xce16d63: {
              //simpleType:uint
              pLabel = "QME_STATE_LOSS_CORES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xce3e5e5: {
              //simpleType:uint
              pLabel = "HTMSC_CRESPFILT_INVERT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xce4b78c: {
              //simpleType:uint
              pLabel = "CP_PLLIOFLT_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xce6f012: {
              //simpleType:uint
              pLabel = "DIMM_POWER_UTIL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[12]:");
              l_traceEntry.resize(10+offset + 12 * 5);
              for (uint32_t i = 0;i<12;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 12 * sizeof(uint8_t);
              break;
          }
          case 0xce7d97c: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_ADDR_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xce99337: {
              //simpleType:uint
              pLabel = "ODY_ENABLE_US_TMPL_B";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcea118a: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC7X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xcf18598: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcf1e319: {
              //simpleType:uint
              pLabel = "IO_TANK_PLL_BYPASS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcf3611f: {
              //simpleType:uint
              pLabel = "MEM_EFF_MEMALERTEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcf85c28: {
              //simpleType:uint
              pLabel = "CHTM_MODE_CORE_WRAP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xcfadec6: {
              //complexType - skipping
              break;
          }
          case 0xcfcfb46: {
              //simpleType:uint
              pLabel = "XSTOP_ON_SPATTN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcfd9488: {
              //simpleType:uint
              pLabel = "PROC_L2_HASH_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xcfe5811: {
              //simpleType:uint
              pLabel = "MEM_EFF_MODULE_THERMAL_SENSORS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd0167e2: {
              //simpleType:uint
              pLabel = "HDAT_HBRT_SECTION_SIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[9]:");
              l_traceEntry.resize(10+offset + 9 * 19);
              for (uint32_t i = 0;i<9;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 9 * sizeof(uint64_t);
              break;
          }
          case 0xd05f482: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd07262c: {
              //simpleType:uint
              pLabel = "RCW09_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd099bb4: {
              //simpleType:uint
              pLabel = "SYSTEM_PDW_VALIDATION_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd09f4f3: {
              //simpleType:uint
              pLabel = "MEM_SI_VREF_DRAM_WR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd0b06da: {
              //simpleType:uint
              pLabel = "RCW45_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd0b5036: {
              //simpleType:uint
              pLabel = "IO_OBUS_TX_FFE_PRECURSOR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd0c86c6: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd0ddacf: {
              //simpleType:uint
              pLabel = "QME_BROADSIDE_SCAN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd1e26f4: {
              //complexType - skipping
              break;
          }
          case 0xd22cf5f: {
              //simpleType:uint
              pLabel = "ODY_PHY_ENABLED_DQ_CHB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd2401e6: {
              break;
          }
          case 0xd282763: {
              //simpleType:uint
              pLabel = "SPARE_CORES_DEPLOYED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd2942c8: {
              //simpleType:uint
              pLabel = "DDS_BIAS_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd29c2de: {
              //simpleType:uint
              pLabel = "SPARE_CORE_ACTIONS_DISABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd2ee0c7: {
              //simpleType:uint
              pLabel = "VDM_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd301294: {
              //simpleType:uint
              pLabel = "CPU_ATTR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd304550: {
              //simpleType:uint
              pLabel = "RCW05_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd3087be: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd34bb04: {
              //simpleType:uint
              pLabel = "MSS_RTT_NOM_OVERRIDE_DISABLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xd36e7f1: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_FAILED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd3704fd: {
              //simpleType:uint
              pLabel = "MEM_EFF_SPD_REVISION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd3a4b37: {
              //simpleType:uint
              pLabel = "EXPLR_PASID_LEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd3b25a9: {
              //simpleType:uint
              pLabel = "MSS_MRW_ENTER_STR_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xd3dcb59: {
              //simpleType:uint
              pLabel = "MEM_EFF_ATXDLY_A";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xd415c67: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F1RC4X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xd43ef5c: {
              //nativeType:EntityPath
              pLabel = "POWER_PATH";
              const char *pathString;
              // from targeting/common/entitypath.[CH]
              const uint8_t lPtype = *l_ptr; // PATH_TYPE
              switch (lPtype) {
                  case 0x01: pathString = "Logical:"; break;
                  case 0x02: pathString = "Physical:"; break;
                  case 0x03: pathString = "Device:"; break;
                  case 0x04: pathString = "Power:"; break;
                  default:   pathString = "Unknown:"; break;
              }
              l_traceEntry.resize(strlen(pathString) + 128);
              uint32_t dataSize = sprintf(&(l_traceEntry[0]), "%s",pathString);
              const uint8_t lSize = *(l_ptr + 1); // number of elements
              uint8_t *lElementInstance = (l_ptr + 2);
              for (uint32_t i=0;i<lSize;i += 2) {
                  switch (lElementInstance[i]) {
                      case 0x00: { pathString = "/NA"; break; }
                      case 0x01: { pathString = "/Sys"; break; }
                      case 0x02: { pathString = "/Node"; break; }
                      case 0x03: { pathString = "/DIMM"; break; }
                      case 0x04: { pathString = "/Membuf"; break; }
                      case 0x05: { pathString = "/Proc"; break; }
                      case 0x06: { pathString = "/EX"; break; }
                      case 0x07: { pathString = "/Core"; break; }
                      case 0x08: { pathString = "/L2"; break; }
                      case 0x09: { pathString = "/L3"; break; }
                      case 0x0A: { pathString = "/L4"; break; }
                      case 0x0B: { pathString = "/MCS"; break; }
                      case 0x0D: { pathString = "/MBA"; break; }
                      case 0x0E: { pathString = "/XBUS"; break; }
                      case 0x0F: { pathString = "/ABUS"; break; }
                      case 0x10: { pathString = "/PCI"; break; }
                      case 0x11: { pathString = "/DPSS"; break; }
                      case 0x12: { pathString = "/APSS"; break; }
                      case 0x13: { pathString = "/OCC"; break; }
                      case 0x14: { pathString = "/PSI"; break; }
                      case 0x15: { pathString = "/FSP"; break; }
                      case 0x16: { pathString = "/PNOR"; break; }
                      case 0x17: { pathString = "/OSC"; break; }
                      case 0x18: { pathString = "/TODCLK"; break; }
                      case 0x19: { pathString = "/CONTROL_NODE"; break; }
                      case 0x1A: { pathString = "/OSCREFCLK"; break; }
                      case 0x1B: { pathString = "/OSCPCICLK"; break; }
                      case 0x1C: { pathString = "/REFCLKENDPT"; break; }
                      case 0x1D: { pathString = "/PCICLKENDPT"; break; }
                      case 0x1E: { pathString = "/NX"; break; }
                      case 0x1F: { pathString = "/PORE"; break; }
                      case 0x20: { pathString = "/PCIESWITCH"; break; }
                      case 0x21: { pathString = "/CAPP"; break; }
                      case 0x22: { pathString = "/FSI"; break; }
                      case 0x23: { pathString = "/EQ"; break; }
                      case 0x24: { pathString = "/MCA"; break; }
                      case 0x25: { pathString = "/MCBIST"; break; }
                      case 0x26: { pathString = "/MI"; break; }
                      case 0x27: { pathString = "/DMI"; break; }
                      case 0x28: { pathString = "/OBUS"; break; }
                      case 0x2A: { pathString = "/SBE"; break; }
                      case 0x2B: { pathString = "/PPE"; break; }
                      case 0x2C: { pathString = "/PERV"; break; }
                      case 0x2D: { pathString = "/PEC"; break; }
                      case 0x2E: { pathString = "/PHB"; break; }
                      case 0x2F: { pathString = "/SYSREFCLKENDPT"; break; }
                      case 0x30: { pathString = "/MFREFCLKENDPT"; break; }
                      case 0x31: { pathString = "/TPM"; break; }
                      case 0x32: { pathString = "/SP"; break; }
                      case 0x33: { pathString = "/UART"; break; }
                      case 0x34: { pathString = "/PS"; break; }
                      case 0x35: { pathString = "/FAN"; break; }
                      case 0x36: { pathString = "/VRM"; break; }
                      case 0x37: { pathString = "/USB"; break; }
                      case 0x38: { pathString = "/ETH"; break; }
                      case 0x39: { pathString = "/PANEL"; break; }
                      case 0x3A: { pathString = "/BMC"; break; }
                      case 0x3B: { pathString = "/FLASH"; break; }
                      case 0x3C: { pathString = "/SEEPROM"; break; }
                      case 0x3D: { pathString = "/TMP"; break; }
                      case 0x3E: { pathString = "/GPIO_EXPANDER"; break; }
                      case 0x3F: { pathString = "/POWER_SEQUENCER"; break; }
                      case 0x40: { pathString = "/RTC"; break; }
                      case 0x41: { pathString = "/FANCTLR"; break; }
                      case 0x42: { pathString = "/OBUS_BRICK"; break; }
                      case 0x43: { pathString = "/NPU"; break; }
                      case 0x44: { pathString = "/MC"; break; }
                      case 0x45: { pathString = "/TEST_FAIL"; break; }
                      case 0x46: { pathString = "/MFREFCLK"; break; }
                      case 0x47: { pathString = "/SMPGROUP"; break; }
                      case 0x48: { pathString = "/OMI"; break; }
                      case 0x49: { pathString = "/MCC"; break; }
                      case 0x4A: { pathString = "/OMIC"; break; }
                      case 0x4B: { pathString = "/OCMB_CHIP"; break; }
                      case 0x4C: { pathString = "/MEM_PORT"; break; }
                      case 0x4D: { pathString = "/I2C_MUX"; break; }
                      case 0x4E: { pathString = "/PMIC"; break; }
                      case 0x4F: { pathString = "/NMMU"; break; }
                      case 0x50: { pathString = "/PAU"; break; }
                      case 0x51: { pathString = "/IOHS"; break; }
                      case 0x52: { pathString = "/PAUC"; break; }
                      case 0x53: { pathString = "/FC"; break; }
                      case 0x54: { pathString = "/LPCREFCLKENDPT"; break; }
                      case 0x55: { pathString = "/GENERIC_I2C_DEVICE"; break; }
                      case 0x56: { pathString = "/MDS_CTLR"; break; }
                      case 0x57: { pathString = "/DCM"; break; }
                      case 0x66: { pathString = "/POWER_IC"; break; }
                      case 0x67: { pathString = "/TEMP_SENSOR"; break; }
                      case 0x68: { pathString = "/LAST_IN_RANGE"; break; }
                      default:   { pathString = "/UNKNOWN"; break; }
                  } // switch
                  // copy next part in, overwritting previous terminator
                  dataSize += sprintf(&(l_traceEntry[0]) + dataSize, "%s%d",pathString,lElementInstance[i+1]);
                  l_ptr += 2 * sizeof(uint8_t);
              } // for
              break;
          }
          case 0xd463c27: {
              //simpleType:uint
              pLabel = "STOP_LEVELS_DISABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xd4805eb: {
              //simpleType:uint
              pLabel = "PCIE_NVME_CCIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xd484fd1: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_STOP_ON_MATCH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd4a3c59: {
              //simpleType:uint
              pLabel = "MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd4a475d: {
              //simpleType:uint
              pLabel = "MEM_VPP_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd4bbddc: {
              //simpleType:uint
              pLabel = "MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd513657: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd53c70b: {
              //simpleType:uint
              pLabel = "WOF_TABLE_OVERRIDE_FF";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xd54b4ac: {
              //simpleType:uint
              pLabel = "IO_OBUS_TX_MARGIN_RATIO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd55bf40: {
              //simpleType:uint
              pLabel = "CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd55e4f9: {
              //simpleType:uint
              pLabel = "SCAN0_SCAN_RATIO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd56672f: {
              //simpleType:uint
              pLabel = "WOV_OVERV_WITH_DDS_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd5741a4: {
              //simpleType:uint
              pLabel = "DDS_DPLL_FMIN_FAST_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd5c924a: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F0RC0E";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xd5dfc35: {
              //simpleType:uint
              pLabel = "SBE_RUNTIME_CODELEVEL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0xd6007fa: {
              //simpleType:uint
              pLabel = "FREQ_PROC_IOHS_MHZ";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 11);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint32_t);
              break;
          }
          case 0xd6045da: {
              //simpleType:uint
              pLabel = "EFF_DRAM_TRRD_S";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xd60cf0a: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_LINK_DELAY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 11);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint32_t);
              break;
          }
          case 0xd60cfd7: {
              //simpleType:enum
              pLabel = "EECACHE_VPD_STATE";
              switch (*((uint32_t*)l_ptr)) {
                  case 0x00000000: {
                      sprintf(&(l_traceEntry[0]), "EECACHE_VPD_STATE_VPD_GOOD");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  case 0x00000001: {
                      sprintf(&(l_traceEntry[0]), "EECACHE_VPD_STATE_VPD_NEEDS_REFRESH");
                      l_ptr += sizeof(uint32_t);
                      break;
                  }
                  default: break;
              }
              break;
          }
          case 0xd66b345: {
              //simpleType:uint
              pLabel = "CORE_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd6af0b6: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_TOPOLOGY_ID_TABLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xd6ece64: {
              //simpleType:uint
              pLabel = "FREQ_BIAS_TURBO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd6f5f46: {
              //simpleType:uint
              pLabel = "SBE_UPDATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd75007e: {
              //simpleType:uint
              pLabel = "DATA_CACHE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd754024: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_PORT_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd7735da: {
              //simpleType:uint
              pLabel = "SBE_HANDLES_SMP_TPM_EXTEND";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd77c5ad: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd7851cd: {
              break;
          }
          case 0xd7a3f4c: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_TTAG_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd7a919b: {
              break;
          }
          case 0xd7aa47b: {
              //simpleType:uint
              pLabel = "PROC_MC_PLL_BANDSEL_OVERRIDE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xd7bebc5: {
              //simpleType:uint
              pLabel = "IS_IOSCM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd7c305f: {
              //simpleType:uint
              pLabel = "WOF_PITCH_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd7d9779: {
              //simpleType:uint
              pLabel = "VIO_SET_POINT_MV";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd7e2c04: {
              //simpleType:uint
              pLabel = "SYSTEM_WOF_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd7ed561: {
              //simpleType:uint
              pLabel = "RCW00_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd7f8bcd: {
              //simpleType:uint
              pLabel = "MSS_MRW_VDDR_OFFSET_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd820de6: {
              //simpleType:uint
              pLabel = "ODY_SHRT_BACKOFF_TIMER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd82c5bd: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC03";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xd82ca0c: {
              //simpleType:uint
              pLabel = "FSP_VCS_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd82d29a: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_RTT_PARK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xd837641: {
              //simpleType:uint
              pLabel = "PROC_PCIE_NUM_PEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd84795a: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_CORE_FREQ_RATIO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd84c572: {
              //complexType - skipping
              break;
          }
          case 0xd862f0b: {
              break;
          }
          case 0xd86ab4c: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_CA_PARITY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd8793e4: {
              //simpleType:uint
              pLabel = "MAX_EID_ON_HBEL_FSP_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd881d9a: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd8add56: {
              //simpleType:uint
              pLabel = "SKIP_HW_VREF_CAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd8af594: {
              //simpleType:uint
              pLabel = "HOTPLUG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd8dde00: {
              //simpleType:uint
              pLabel = "FSP_BAR_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xd940b8a: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd94832a: {
              //simpleType:uint
              pLabel = "CLOCK_MUX0C_RCS_PLL_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd94ff32: {
              //simpleType:uint
              pLabel = "ODY_ENABLE_US_TMPL_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd950380: {
              //simpleType:uint
              pLabel = "MELTBOX_NEST_FREQ_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xd969845: {
              //simpleType:uint
              pLabel = "MEM_SI_MC_RCV_EQ_DQ_DQS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xd990683: {
              //simpleType:uint
              pLabel = "CORE_LPAR_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd9976e1: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd9a9f4f: {
              //simpleType:uint
              pLabel = "ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xd9b9ad9: {
              //simpleType:uint
              pLabel = "SPPE_I2C_DEV_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd9c2af0: {
              break;
          }
          case 0xd9da851: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xd9db2d5: {
              //simpleType:uint
              pLabel = "IO_O_MFG_MIN_EYE_WIDTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xda1809c: {
              //simpleType:uint
              pLabel = "RCW0E_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xda376c3: {
              //simpleType:uint
              pLabel = "EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xda95638: {
              //simpleType:uint
              pLabel = "MEM_EFF_LOGICAL_RANKS_PER_DIMM";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xdab5f58: {
              //simpleType:uint
              pLabel = "PROC_PCIE_LANE_EQUALIZATION_GEN4";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[16]:");
              l_traceEntry.resize(10+offset + 16 * 7);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 16 * sizeof(uint16_t);
              break;
          }
          case 0xdadf803: {
              //simpleType:uint
              pLabel = "ODY_DRAMINIT_STEP_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdaf3379: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_2_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdafb56e: {
              //simpleType:uint
              pLabel = "FREQ_IOHS_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xdb283e0: {
              //simpleType:uint
              pLabel = "NHTM_HTMSC_MODE_WRITETOIO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdb3e968: {
              //simpleType:uint
              pLabel = "RCW0A_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdb4e40c: {
              //simpleType:uint
              pLabel = "FABRIC_GROUP_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdb65bdd: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdb6c503: {
              break;
          }
          case 0xdb89c57: {
              //simpleType:uint
              pLabel = "MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdba3bba: {
              //simpleType:uint
              pLabel = "PROC_SELECT_BOOT_SEEPROM_IMAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdbb83fc: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_HALF_DIMM_TARGET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdbe5186: {
              //complexType - skipping
              break;
          }
          case 0xdbfb744: {
              //simpleType:uint
              pLabel = "PROC_VRM_VOFFSET_UV";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 11);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 4 * sizeof(uint32_t);
              break;
          }
          case 0xdbffc50: {
              //simpleType:uint
              pLabel = "L3_CACHE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xdc339a7: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_ROW_BITS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xdc5e368: {
              break;
          }
          case 0xdc82830: {
              //simpleType:uint
              pLabel = "FREQ_SYSTEM_CORE_FLOOR_MHZ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xdc91e7c: {
              //simpleType:uint
              pLabel = "FSP_VPP_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdca883d: {
              //simpleType:uint
              pLabel = "IQ_STATIC_DATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdcbd688: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VDD_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xdcc378b: {
              //simpleType:uint
              pLabel = "ODY_UPPERNIBBLE_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdceaabb: {
              //simpleType:uint
              pLabel = "MEM_DDR5_DFE_SIGN_BIT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xdcf9224: {
              //simpleType:uint
              pLabel = "PM_HALT_FFDC_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdcfdaa2: {
              //simpleType:uint
              pLabel = "MEM_EFF_Z_MODE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdd84994: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xddbc151: {
              //simpleType:uint
              pLabel = "ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int16_t);
              break;
          }
          case 0xddd3f7e: {
              //simpleType:uint
              pLabel = "EXP_MEM_WATT_TARGET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 11);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint32_t);
              break;
          }
          case 0xdde9311: {
              //simpleType:uint
              pLabel = "MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xdded48e: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xde00084: {
              //simpleType:uint
              pLabel = "RCW47_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xde03ed3: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xde075fd: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_RXEN_ADJ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xde2c10c: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xde419d0: {
              //simpleType:uint
              pLabel = "PROC_DPLL_DIVIDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xde60dc4: {
              //simpleType:uint
              pLabel = "EXPLR_TMPL_1_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xde7bca9: {
              //simpleType:uint
              pLabel = "MEM_DDR5_GLOBAL_DFE_TAP2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdece9f6: {
              //simpleType:uint
              pLabel = "L2_HASPOWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xded6f91: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_PERIOD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdeda910: {
              break;
          }
          case 0xdee8fd0: {
              //simpleType:uint
              pLabel = "PROC_MEMORY_ENCRYPTION_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf06b22: {
              //simpleType:uint
              pLabel = "MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf28a49: {
              //simpleType:uint
              pLabel = "RCW08_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf2b36c: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TFAW";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf5ac38: {
              //simpleType:uint
              pLabel = "RCW48_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf66855: {
              //simpleType:uint
              pLabel = "PROC_TMPL_4_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf6bde0: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_CHIP0_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdf90286: {
              //simpleType:uint
              pLabel = "ENABLED_THREADS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xdfa0ab1: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xdfb2703: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][20]:");
              l_traceEntry.resize(10+offset + 160 * 5);
              for (uint32_t i = 0;i<160;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 160 * sizeof(uint8_t);
              break;
          }
          case 0xdfbb097: {
              //simpleType:uint
              pLabel = "MSS_CENT_VCS_SLOPE_ACTIVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xdfbd498: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe00ac20: {
              //simpleType:uint
              pLabel = "PERST_CONTROL_PIN_NUMBERS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0xe06e33e: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_PORT_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe0cbfed: {
              //simpleType:uint
              pLabel = "ODY_DQS_TRACKING_LOG";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[24]:");
              l_traceEntry.resize(10+offset + 24 * 19);
              for (uint32_t i = 0;i<24;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 24 * sizeof(uint64_t);
              break;
          }
          case 0xe0cee5c: {
              //simpleType:uint
              pLabel = "CEN_MSS_FREQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe153bec: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC0B";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xe1b47d7: {
              //simpleType:uint
              pLabel = "WOF_TABLE_LID_NUMBER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe1c520c: {
              //simpleType:uint
              pLabel = "SPPE_I2C_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe20c541: {
              //simpleType:uint
              pLabel = "SBE_VERSION_INFO";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe226c94: {
              //simpleType:uint
              pLabel = "PERF_24x7_INVOCATION_TIME_MS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe2328b9: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xe242d68: {
              //simpleType:uint
              pLabel = "PCIE_32BIT_DMA_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe2457f8: {
              //simpleType:uint
              pLabel = "OMI_INBAND_BAR_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe2556ce: {
              //simpleType:uint
              pLabel = "HTMSC_IMA_PDBAR_SCOPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xe281690: {
              //simpleType:uint
              pLabel = "MODEL_EC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe2ab0d2: {
              //simpleType:uint
              pLabel = "SOCKET_POWER_NOMINAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xe2bf285: {
              //simpleType:uint
              pLabel = "RNG_BAR_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xe2c64ec: {
              //simpleType:uint
              pLabel = "MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe2cfa5e: {
              //simpleType:uint
              pLabel = "PROC_PCIE_REFCLOCK_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe2df671: {
              //simpleType:uint
              pLabel = "ORDINAL_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe30fb00: {
              //simpleType:uint
              pLabel = "MEM_DDR5_GLOBAL_DFE_GAIN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe31e711: {
              //simpleType:uint
              pLabel = "MSS_EXP_FW_FAILED_AUTHENTICATION_A";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe3352f1: {
              //simpleType:uint
              pLabel = "PROC_FSP_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xe356be6: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_CRESP_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe35b4c7: {
              //simpleType:uint
              pLabel = "EFF_DIMM_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][2]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xe390ea6: {
              //simpleType:uint
              pLabel = "MEM_VDDR_OFFSET_MILLIVOLTS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe3947ec: {
              //simpleType:uint
              pLabel = "BMC_FRU_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe3950d2: {
              //simpleType:uint
              pLabel = "HTMSC_MODE_DIS_FORCE_GROUP_SCOPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe3a87c3: {
              //simpleType:uint
              pLabel = "MEM_EXP_DFIMRL_CLK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe3b1a88: {
              //simpleType:uint
              pLabel = "WOV_HEAVY_PERF_LOSS_THRESH_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe3b2a94: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_SOURCE_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe3b5b79: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_TYPE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xe3db688: {
              //simpleType:uint
              pLabel = "RCW41_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe444f3b: {
              //simpleType:uint
              pLabel = "PROC_LCO_MODE_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe4e2b19: {
              //simpleType:uint
              pLabel = "WOV_DIRTY_UNCURRENT_CONTROL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xe53583f: {
              //simpleType:uint
              pLabel = "HB_SETTINGS_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe54617c: {
              //simpleType:uint
              pLabel = "MSS_CENT_VDD_INTERCEPT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe54bcd6: {
              //simpleType:uint
              pLabel = "IS_STANDALONE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe551d52: {
              //simpleType:uint
              pLabel = "PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe595eec: {
              //simpleType:uint
              pLabel = "MAX_INTERLEAVE_GROUP_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xe5bb6b4: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_2_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe5e057a: {
              //simpleType:uint
              pLabel = "FIELD_TH_L3_LINE_DELETES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe5e91b7: {
              //simpleType:uint
              pLabel = "MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe63aed7: {
              //simpleType:uint
              pLabel = "SBE_COMMIT_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe63e435: {
              //simpleType:uint
              pLabel = "RCW09_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe6a19c7: {
              //simpleType:uint
              pLabel = "PROC_INT_IC_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xe6c4c3f: {
              //simpleType:uint
              pLabel = "IS_MASTER_EX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe6dbaaf: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SEQUENCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe6f5561: {
              //simpleType:uint
              pLabel = "EXPLR_AFU_ACTAG_LEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe712112: {
              //simpleType:uint
              pLabel = "RTG_SCAN_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe72dc05: {
              //simpleType:uint
              pLabel = "FREQ_BIAS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe756f73: {
              //simpleType:uint
              pLabel = "MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe77b99f: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_TM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe79bdaf: {
              //simpleType:uint
              pLabel = "RCW49_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe79c887: {
              //simpleType:uint
              pLabel = "TPM_REQUIRED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe7e15a5: {
              //simpleType:uint
              pLabel = "OCC_MASTER_CAPABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe7f65d8: {
              //simpleType:uint
              pLabel = "MEM_SI_DIMM_RCD_IBT_ODT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xe802bb9: {
              //simpleType:uint
              pLabel = "SCAN_CHIPLET_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe80bb76: {
              //simpleType:uint
              pLabel = "PROC_ENABLE_DL_TMPL_7";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe81aec2: {
              //simpleType:uint
              pLabel = "OMI_TX_LANES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe831572: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_SYSTEM_MASTER_CHIP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe831adc: {
              //simpleType:uint
              pLabel = "SPARE_CORES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe83d6b0: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe83f987: {
              //simpleType:uint
              pLabel = "NVDIMM_ENCRYPTION_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe862fae: {
              //simpleType:uint
              pLabel = "OCMB_PLL_BUCKET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe88d183: {
              //simpleType:uint
              pLabel = "MSS_FREQ";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xe8a4ed4: {
              //simpleType:uint
              pLabel = "DDS_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe8bc6dc: {
              //simpleType:uint
              pLabel = "MSS_EXP_OMI_SETUP_POLL_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe8e795c: {
              //simpleType:uint
              pLabel = "SYSTEM_CORECACHE_DCADJ_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe911abb: {
              //simpleType:uint
              pLabel = "MRW_CONVERT_DCBZ_TO_RWITM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe926ea8: {
              //simpleType:uint
              pLabel = "SBE_IS_STARTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe93419a: {
              //simpleType:uint
              pLabel = "SCRATCH_UINT8_2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe94e26a: {
              //simpleType:uint
              pLabel = "ODY_SENSOR_POLLING_PERIOD_MS_INIT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xe96da20: {
              //simpleType:uint
              pLabel = "OMI_REFCLOCK_SWIZZLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe977d9f: {
              //simpleType:uint
              pLabel = "L3_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe98cc14: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe992285: {
              //simpleType:uint
              pLabel = "RVRM_ENABLED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe9af745: {
              //complexType - skipping
              break;
          }
          case 0xe9c4920: {
              //simpleType:uint
              pLabel = "RCW41_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe9cec48: {
              //simpleType:uint
              pLabel = "CHTM_MODE_SINGLE_TIME_STAMP";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xe9d04d7: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_VREFCA_SWEEP_MAX";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xe9fe5d3: {
              //simpleType:uint
              pLabel = "TEMP_LOL_ERR_CNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xea0b51a: {
              //simpleType:uint
              pLabel = "POWERVS_P10_FW_VER";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3][3]:");
              l_traceEntry.resize(10+offset + 9 * 5);
              for (uint32_t i = 0;i<9;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 9 * sizeof(uint8_t);
              break;
          }
          case 0xea3d478: {
              //simpleType:uint
              pLabel = "SBE_LOAD_BOOTLOADER_CHUNK_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xea4c21f: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xea5d545: {
              //simpleType:uint
              pLabel = "HTMSC_FILT_CRESP_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xea7105b: {
              //simpleType:uint
              pLabel = "L2_HASCLOCKS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xea74580: {
              //simpleType:uint
              pLabel = "MEM_CA_PARITY_LATENCY";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xea75a30: {
              //simpleType:uint
              pLabel = "RCW48_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xea8022a: {
              //simpleType:uint
              pLabel = "HOTPLUG_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xeaa3fa0: {
              //simpleType:uint
              pLabel = "MNFG_ABUS_MIN_EYE_HEIGHT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeaacc79: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeada36c: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_AGGREGATE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb0420c: {
              //simpleType:uint
              pLabel = "TLB_RESERVE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xeb1a81f: {
              //simpleType:uint
              pLabel = "PROC_INT_NVPG_BAR_PAGE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb1d539: {
              //simpleType:uint
              pLabel = "MAX_MBA_PORTS_PER_MBA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb223ec: {
              //simpleType:uint
              pLabel = "RUNN_CHIP_CYCLE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xeb26033: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb2b814: {
              //simpleType:uint
              pLabel = "FORCE_SRAM_MMIO_OVER_I2C";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb40b74: {
              //simpleType:uint
              pLabel = "RCW49_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb5a690: {
              //simpleType:uint
              pLabel = "PROC_NX_RNG_FAILED_INT_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xeb604df: {
              //simpleType:uint
              pLabel = "PROC_PCIE_IOP_CONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeb660ee: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_PHASE_COMB";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xebb5b0c: {
              //simpleType:uint
              pLabel = "PROC_OMI_OC_MINOR_VER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xebbaf50: {
              //simpleType:uint
              pLabel = "PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 5);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 4 * sizeof(uint8_t);
              break;
          }
          case 0xebc1836: {
              //simpleType:uint
              pLabel = "MSS_EXP_OMI_CDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xebd258e: {
              //simpleType:uint
              pLabel = "MEM_EFF_DIMM_SIZE";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 11);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 2 * sizeof(uint32_t);
              break;
          }
          case 0xec20bac: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xec66ecd: {
              //simpleType:uint
              pLabel = "RCW0C_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xec67366: {
              //simpleType:uint
              pLabel = "HB_MIN_BACKING_CACHE_FC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xec7753d: {
              //simpleType:uint
              pLabel = "RCW01_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xec80f7c: {
              //simpleType:uint
              pLabel = "ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(INT16_FROM_PTR(reinterpret_cast<const int16_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(int16_t);
              break;
          }
          case 0xec8827a: {
              //simpleType:uint
              pLabel = "NEST_VIO_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xec99916: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DDR4_F1RC04";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xecc42ef: {
              //simpleType:uint
              pLabel = "HTMSC_CTRL_OTHER_DBG0_STOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed124b9: {
              //simpleType:uint
              pLabel = "WOV_LIGHT_PERF_LOSS_THRESH_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed1a955: {
              //simpleType:uint
              pLabel = "PM_RESTART_PHASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed1d603: {
              //simpleType:uint
              pLabel = "INIT_TO_AVAILABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed4417b: {
              //simpleType:uint
              pLabel = "HOMER_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed4f5de: {
              //simpleType:uint
              pLabel = "DDR5_DRAM_DQS_RTT_PARK";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4][2]:");
              l_traceEntry.resize(10+offset + 16 * 5);
              for (uint32_t i = 0;i<16;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 16 * sizeof(uint8_t);
              break;
          }
          case 0xed6a4b4: {
              //simpleType:uint
              pLabel = "CLOCK_MUX14_OPT_156_SOURCE_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed6c3e0: {
              //simpleType:uint
              pLabel = "DIMM_PREHEAT_POWER";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[12]:");
              l_traceEntry.resize(10+offset + 12 * 11);
              for (uint32_t i = 0;i<12;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 12 * sizeof(uint32_t);
              break;
          }
          case 0xed8a03a: {
              //simpleType:uint
              pLabel = "RCW0A_CHB_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xed9e25a: {
              //simpleType:uint
              pLabel = "MEM_EFF_REGISTER_REV";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xed9fafb: {
              //simpleType:uint
              pLabel = "RCW43_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeda0efc: {
              //simpleType:uint
              pLabel = "WOF_FMMR_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xeda695b: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_DIFF_USAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xedc754f: {
              //simpleType:uint
              pLabel = "MEM_DIMM_DDR4_F0RC1X";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xedd201c: {
              //simpleType:uint
              pLabel = "MEM_SI_DIMM_RCD_IBT_CS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xee87648: {
              //simpleType:uint
              pLabel = "ODY_PHY_MSTRTRAIN_INTERVAL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xeee9926: {
              //simpleType:uint
              pLabel = "SCRATCH_UINT64_1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xef60a38: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_0_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xef63d66: {
              //simpleType:uint
              pLabel = "UNSECURE_HOMER_ADDRESS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xef89eb6: {
              //simpleType:uint
              pLabel = "WOF_IO_BASE_POWER_0P01W";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0xefa25a2: {
              //simpleType:uint
              pLabel = "ODY_UPPERNIBBLE_TG";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4]:");
              l_traceEntry.resize(10+offset + 4 * 7);
              for (uint32_t i = 0;i<4;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 4 * sizeof(uint16_t);
              break;
          }
          case 0xefb544c: {
              //simpleType:uint
              pLabel = "MSS_AVDD_PROGRAM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xefb989b: {
              //simpleType:uint
              pLabel = "NO_RECONFIG_ON_DECONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xefc5783: {
              //simpleType:uint
              pLabel = "HTMSC_TSIZEFILT_PAT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xefe1a41: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DRAM_BURST_LENGTH";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf033211: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[8]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xf036277: {
              //simpleType:uint
              pLabel = "PROC_SMF_BAR_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xf056e93: {
              break;
          }
          case 0xf091dbc: {
              //simpleType:uint
              pLabel = "SYSTEM_PGPE_CURRENT_READ_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf0961f9: {
              //simpleType:uint
              pLabel = "POS_ON_MEM_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf0baf47: {
              //simpleType:uint
              pLabel = "OMI_INBAND_BAR_BASE_ADDR_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xf0ccd74: {
              //simpleType:uint
              pLabel = "IOHS_MFG_BAD_LANE_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf1021f7: {
              break;
          }
          case 0xf104f67: {
              //simpleType:uint
              pLabel = "PROC_EPS_WRITE_CYCLES_T2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf113798: {
              //simpleType:uint
              pLabel = "CHIP_FAN_CFM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf12ba3b: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SEQUENCE_CFG1_R41";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf13ce5f: {
              //simpleType:uint
              pLabel = "ALLOW_ATTR_OVERRIDES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf169a2b: {
              //simpleType:uint
              pLabel = "RCW08_CHA_D0";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf1d0ed1: {
              //simpleType:uint
              pLabel = "PG_SAVED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf1dc314: {
              //simpleType:uint
              pLabel = "CLOCK_MUX1_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf1df866: {
              //simpleType:uint
              pLabel = "DIMM_POWER";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[12]:");
              l_traceEntry.resize(10+offset + 12 * 11);
              for (uint32_t i = 0;i<12;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 12 * sizeof(uint32_t);
              break;
          }
          case 0xf1e3ebe: {
              //simpleType:uint
              pLabel = "CLOCK_MUX23_PCI_INPUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf2039e4: {
              //simpleType:uint
              pLabel = "PROC_PCIE_PCS_RX_SIGDET_CNTL";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf21023b: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_USAGE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf21ca17: {
              //simpleType:uint
              pLabel = "MSS_EXP_FW_FAILED_AUTHENTICATION_B";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf24fe73: {
              //simpleType:uint
              pLabel = "PROC_FABRIC_TOPOLOGY_ID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf25be4a: {
              break;
          }
          case 0xf278a76: {
              //simpleType:uint
              pLabel = "MSS_MRW_MIN_DOMAIN_REDUCTION_TIME";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf337a7a: {
              //complexType - skipping
              break;
          }
          case 0xf33f29f: {
              //simpleType:uint
              pLabel = "ODY_PASID_LEN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf349c89: {
              //simpleType:uint
              pLabel = "MEM_EFF_DDR5_TX_SLEW_FALL_AC";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2]:");
              l_traceEntry.resize(10+offset + 2 * 5);
              for (uint32_t i = 0;i<2;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 2 * sizeof(uint8_t);
              break;
          }
          case 0xf3c3e44: {
              //simpleType:uint
              pLabel = "DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf3d0e4c: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_1_LOCATION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf3db67c: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf41ef0a: {
              //simpleType:uint
              pLabel = "ODY_TX_IMPEDANCE_CTRL1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf42d558: {
              //simpleType:uint
              pLabel = "PROC_CHTM_BAR_BASE_ADDR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 19);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 32 * sizeof(uint64_t);
              break;
          }
          case 0xf43c049: {
              //simpleType:uint
              pLabel = "ATTN_AREA_2_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xf43e474: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf4637bc: {
              //simpleType:uint
              pLabel = "FSI_MASTER_PORT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf466e86: {
              //simpleType:uint
              pLabel = "CHIP_CONTAINED_BACKING_CACHES_VEC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf46d0b9: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC1_SWC_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf46d814: {
              //simpleType:uint
              pLabel = "ECMD_TARGET";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[64]:");
              l_traceEntry.resize(10+offset + 64 * 5);
              for (uint32_t i = 0;i<64;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 64 * sizeof(uint8_t);
              break;
          }
          case 0xf4ac0bc: {
              //simpleType:uint
              pLabel = "DD1_SLOW_PCI_REF_CLOCK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf4e0097: {
              //simpleType:uint
              pLabel = "DATA_CACHE_LINE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf4e4164: {
              //simpleType:uint
              pLabel = "IOHS_SPREAD_SPECTRUM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf4f230f: {
              //simpleType:uint
              pLabel = "MEMORY_BAR_REGS";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4][10][2]:");
              l_traceEntry.resize(10+offset + 80 * 19);
              for (uint32_t i = 0;i<80;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 80 * sizeof(uint64_t);
              break;
          }
          case 0xf517753: {
              //simpleType:uint
              pLabel = "MEM_EFF_DRAM_TRRD_DLR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf578144: {
              //simpleType:uint
              pLabel = "EEPROM_VPD_ACTIVE_COPY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf5ac814: {
              //simpleType:uint
              pLabel = "CHTM_MODE_DIS_STALL";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[32]:");
              l_traceEntry.resize(10+offset + 32 * 5);
              for (uint32_t i = 0;i<32;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 32 * sizeof(uint8_t);
              break;
          }
          case 0xf5b42fe: {
              //simpleType:uint
              pLabel = "OMI_RX_HORIZ_EDGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf5ddeb3: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf5f80be: {
              //simpleType:uint
              pLabel = "HOSTBOOT_TIME_OUT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf620eaa: {
              //simpleType:uint
              pLabel = "MSS_ODY_PASSED_SWIZZLE_DETECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf64a675: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SEQUENCE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf64aeb7: {
              //simpleType:uint
              pLabel = "SBE_SYS_CONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xf669530: {
              //simpleType:uint
              pLabel = "MEM_DDR5_SPD_CL_SUPPORTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xf693e4d: {
              //simpleType:uint
              pLabel = "ODY_TX_IMPEDANCE_CTRL2";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf6aafcb: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC3_SWC_CURRENT_WARNING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf70279f: {
              //simpleType:uint
              pLabel = "SUPPORTS_DYNAMIC_MEM_VOLT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf77c444: {
              //simpleType:uint
              pLabel = "PROC_OMI_OC_MAJOR_VER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf796610: {
              //simpleType:uint
              pLabel = "SAFE_MODE_XSTOP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf79b949: {
              //simpleType:uint
              pLabel = "DEALLOCATED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf7abb7c: {
              //nativeType:EntityPath
              pLabel = "PHYS_PATH";
              const char *pathString;
              // from targeting/common/entitypath.[CH]
              const uint8_t lPtype = *l_ptr; // PATH_TYPE
              switch (lPtype) {
                  case 0x01: pathString = "Logical:"; break;
                  case 0x02: pathString = "Physical:"; break;
                  case 0x03: pathString = "Device:"; break;
                  case 0x04: pathString = "Power:"; break;
                  default:   pathString = "Unknown:"; break;
              }
              l_traceEntry.resize(strlen(pathString) + 128);
              uint32_t dataSize = sprintf(&(l_traceEntry[0]), "%s",pathString);
              const uint8_t lSize = *(l_ptr + 1); // number of elements
              uint8_t *lElementInstance = (l_ptr + 2);
              for (uint32_t i=0;i<lSize;i += 2) {
                  switch (lElementInstance[i]) {
                      case 0x00: { pathString = "/NA"; break; }
                      case 0x01: { pathString = "/Sys"; break; }
                      case 0x02: { pathString = "/Node"; break; }
                      case 0x03: { pathString = "/DIMM"; break; }
                      case 0x04: { pathString = "/Membuf"; break; }
                      case 0x05: { pathString = "/Proc"; break; }
                      case 0x06: { pathString = "/EX"; break; }
                      case 0x07: { pathString = "/Core"; break; }
                      case 0x08: { pathString = "/L2"; break; }
                      case 0x09: { pathString = "/L3"; break; }
                      case 0x0A: { pathString = "/L4"; break; }
                      case 0x0B: { pathString = "/MCS"; break; }
                      case 0x0D: { pathString = "/MBA"; break; }
                      case 0x0E: { pathString = "/XBUS"; break; }
                      case 0x0F: { pathString = "/ABUS"; break; }
                      case 0x10: { pathString = "/PCI"; break; }
                      case 0x11: { pathString = "/DPSS"; break; }
                      case 0x12: { pathString = "/APSS"; break; }
                      case 0x13: { pathString = "/OCC"; break; }
                      case 0x14: { pathString = "/PSI"; break; }
                      case 0x15: { pathString = "/FSP"; break; }
                      case 0x16: { pathString = "/PNOR"; break; }
                      case 0x17: { pathString = "/OSC"; break; }
                      case 0x18: { pathString = "/TODCLK"; break; }
                      case 0x19: { pathString = "/CONTROL_NODE"; break; }
                      case 0x1A: { pathString = "/OSCREFCLK"; break; }
                      case 0x1B: { pathString = "/OSCPCICLK"; break; }
                      case 0x1C: { pathString = "/REFCLKENDPT"; break; }
                      case 0x1D: { pathString = "/PCICLKENDPT"; break; }
                      case 0x1E: { pathString = "/NX"; break; }
                      case 0x1F: { pathString = "/PORE"; break; }
                      case 0x20: { pathString = "/PCIESWITCH"; break; }
                      case 0x21: { pathString = "/CAPP"; break; }
                      case 0x22: { pathString = "/FSI"; break; }
                      case 0x23: { pathString = "/EQ"; break; }
                      case 0x24: { pathString = "/MCA"; break; }
                      case 0x25: { pathString = "/MCBIST"; break; }
                      case 0x26: { pathString = "/MI"; break; }
                      case 0x27: { pathString = "/DMI"; break; }
                      case 0x28: { pathString = "/OBUS"; break; }
                      case 0x2A: { pathString = "/SBE"; break; }
                      case 0x2B: { pathString = "/PPE"; break; }
                      case 0x2C: { pathString = "/PERV"; break; }
                      case 0x2D: { pathString = "/PEC"; break; }
                      case 0x2E: { pathString = "/PHB"; break; }
                      case 0x2F: { pathString = "/SYSREFCLKENDPT"; break; }
                      case 0x30: { pathString = "/MFREFCLKENDPT"; break; }
                      case 0x31: { pathString = "/TPM"; break; }
                      case 0x32: { pathString = "/SP"; break; }
                      case 0x33: { pathString = "/UART"; break; }
                      case 0x34: { pathString = "/PS"; break; }
                      case 0x35: { pathString = "/FAN"; break; }
                      case 0x36: { pathString = "/VRM"; break; }
                      case 0x37: { pathString = "/USB"; break; }
                      case 0x38: { pathString = "/ETH"; break; }
                      case 0x39: { pathString = "/PANEL"; break; }
                      case 0x3A: { pathString = "/BMC"; break; }
                      case 0x3B: { pathString = "/FLASH"; break; }
                      case 0x3C: { pathString = "/SEEPROM"; break; }
                      case 0x3D: { pathString = "/TMP"; break; }
                      case 0x3E: { pathString = "/GPIO_EXPANDER"; break; }
                      case 0x3F: { pathString = "/POWER_SEQUENCER"; break; }
                      case 0x40: { pathString = "/RTC"; break; }
                      case 0x41: { pathString = "/FANCTLR"; break; }
                      case 0x42: { pathString = "/OBUS_BRICK"; break; }
                      case 0x43: { pathString = "/NPU"; break; }
                      case 0x44: { pathString = "/MC"; break; }
                      case 0x45: { pathString = "/TEST_FAIL"; break; }
                      case 0x46: { pathString = "/MFREFCLK"; break; }
                      case 0x47: { pathString = "/SMPGROUP"; break; }
                      case 0x48: { pathString = "/OMI"; break; }
                      case 0x49: { pathString = "/MCC"; break; }
                      case 0x4A: { pathString = "/OMIC"; break; }
                      case 0x4B: { pathString = "/OCMB_CHIP"; break; }
                      case 0x4C: { pathString = "/MEM_PORT"; break; }
                      case 0x4D: { pathString = "/I2C_MUX"; break; }
                      case 0x4E: { pathString = "/PMIC"; break; }
                      case 0x4F: { pathString = "/NMMU"; break; }
                      case 0x50: { pathString = "/PAU"; break; }
                      case 0x51: { pathString = "/IOHS"; break; }
                      case 0x52: { pathString = "/PAUC"; break; }
                      case 0x53: { pathString = "/FC"; break; }
                      case 0x54: { pathString = "/LPCREFCLKENDPT"; break; }
                      case 0x55: { pathString = "/GENERIC_I2C_DEVICE"; break; }
                      case 0x56: { pathString = "/MDS_CTLR"; break; }
                      case 0x57: { pathString = "/DCM"; break; }
                      case 0x66: { pathString = "/POWER_IC"; break; }
                      case 0x67: { pathString = "/TEMP_SENSOR"; break; }
                      case 0x68: { pathString = "/LAST_IN_RANGE"; break; }
                      default:   { pathString = "/UNKNOWN"; break; }
                  } // switch
                  // copy next part in, overwritting previous terminator
                  dataSize += sprintf(&(l_traceEntry[0]) + dataSize, "%s%d",pathString,lElementInstance[i+1]);
                  l_ptr += 2 * sizeof(uint8_t);
              } // for
              break;
          }
          case 0xf7bb641: {
              //simpleType:uint
              pLabel = "MSS_EXP_CDR_BW_OVERRIDE_VALUE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf7f89d6: {
              //simpleType:uint
              pLabel = "CORE_TEMP_CHECK_INTERVAL_SECONDS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf811b59: {
              //simpleType:uint
              pLabel = "SYSTEM_FMAX_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf844545: {
              //simpleType:uint
              pLabel = "MSS_MRW_VPP_OFFSET_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf84a889: {
              //simpleType:uint
              pLabel = "RCW46_CHB_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf873da7: {
              //simpleType:uint
              pLabel = "BLOCK_SPEC_DECONFIG";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf883c12: {
              //complexType - skipping
              break;
          }
          case 0xf88f412: {
              //simpleType:uint
              pLabel = "PROC_LCO_TARGETS_COUNT";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[3]:");
              l_traceEntry.resize(10+offset + 3 * 5);
              for (uint32_t i = 0;i<3;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 3 * sizeof(uint8_t);
              break;
          }
          case 0xf8dd85b: {
              //simpleType:uint
              pLabel = "PROC_FSP_BAR_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xf907441: {
              //simpleType:uint
              pLabel = "MNFG_TH_MEMORY_RT_RCE_PER_RANK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf908b6e: {
              //simpleType:uint
              pLabel = "MEM_SI_PHY_EQUALIZATION";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[2][4]:");
              l_traceEntry.resize(10+offset + 8 * 5);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 8 * sizeof(uint8_t);
              break;
          }
          case 0xf91795a: {
              //simpleType:uint
              pLabel = "HTMSC_TTYPEFILT_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf93274e: {
              //simpleType:uint
              pLabel = "PG_MVPD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xf949e3a: {
              //simpleType:uint
              pLabel = "SYSTEM_RVRM_DISABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf991bc4: {
              //simpleType:uint
              pLabel = "SBE_CUST_FORCE_MVPD_ONLY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf995f8c: {
              //simpleType:uint
              pLabel = "WOF_IO_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf99ae48: {
              //simpleType:uint
              pLabel = "FREQ_BIAS_POWERSAVE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf9a81a2: {
              //simpleType:uint
              pLabel = "IOHS_DRAWER_INTERCONNECT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf9ab3cb: {
              //simpleType:uint
              pLabel = "PROC_TMPL_A_PACING";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf9d3311: {
              //simpleType:uint
              pLabel = "WOV_UNDERV_EXTENDED_MAX_10THPCT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xf9e5235: {
              //simpleType:uint
              pLabel = "RCW45_CHA_D1";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf9eeb51: {
              //simpleType:uint
              pLabel = "SECURE_VERSION_SEEPROM";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf9f4fcc: {
              //simpleType:uint
              pLabel = "RUNN_USE_QME_TIMEBASE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xf9fde6a: {
              //simpleType:uint
              pLabel = "HUID";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfa1c9e6: {
              //simpleType:uint
              pLabel = "MAX_CHIPLETS_PER_PROC";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfaa68ab: {
              //simpleType:uint
              pLabel = "TOD_CPU_DATA";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[44]:");
              l_traceEntry.resize(10+offset + 44 * 5);
              for (uint32_t i = 0;i<44;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 44 * sizeof(uint8_t);
              break;
          }
          case 0xfacac31: {
              //simpleType:uint
              pLabel = "ODY_METADATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfaf66cf: {
              //simpleType:uint
              pLabel = "MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((int8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfafcbf2: {
              //simpleType:uint
              pLabel = "MAIL_MESSAGE_BITMAP";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfb5ce79: {
              //simpleType:uint
              pLabel = "TLB_DATA_ENTRIES";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfb84286: {
              //simpleType:uint
              pLabel = "ODY_PLL_BYPASS_EN";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfbef093: {
              //simpleType:uint
              pLabel = "ODY_DMEM_FIRST_LOAD";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfc1f6d8: {
              //simpleType:uint
              pLabel = "OMI_RX_VERT_OFFSET";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfc574bf: {
              //simpleType:uint
              pLabel = "L3_CACHE_LINE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfc5f71e: {
              break;
          }
          case 0xfc7c1e8: {
              //simpleType:uint
              pLabel = "L2_CACHE_LINE_SIZE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfc9bdd9: {
              //simpleType:uint
              pLabel = "MSS_MRW_AVDD_OFFSET_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfca622c: {
              //simpleType:uint
              pLabel = "TLB_DATA_ASSOC_SETS";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfcb8929: {
              //simpleType:uint
              pLabel = "MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfcea8b7: {
              //simpleType:uint
              pLabel = "ODY_DFIPHYUPDCNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfceb067: {
              //simpleType:uint
              pLabel = "SYS_VRT_STATIC_DATA_ENABLE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfcfe1a6: {
              //simpleType:uint
              pLabel = "FSP_BASE_ADDR";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 19);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint64_t);
              break;
          }
          case 0xfd41e04: {
              //simpleType:uint
              pLabel = "STOP_LEVELS_SUPPORTED";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 7);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*7]), "0x%.4X ", ntohs(UINT16_FROM_PTR(reinterpret_cast<const uint16_t*>(l_ptr) + i)));
              }
              l_ptr += 1 * sizeof(uint16_t);
              break;
          }
          case 0xfd54264: {
              //simpleType:uint
              pLabel = "DISABLE_SBE_RUNTIME_RECOVERY";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfdbc8b2: {
              //simpleType:uint
              pLabel = "HTMSC_MEM_SCOPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfded6f8: {
              //simpleType:uint
              pLabel = "COLLECT_ONLY_CLOCK_ON_DATA";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfe2fc3a: {
              //simpleType:uint
              pLabel = "WTH_OVERRIDE_TEST_CORE_COUNT";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfeeb8d6: {
              //simpleType:uint
              pLabel = "MAX_DIMM_POWER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xfefe6c5: {
              //simpleType:uint
              pLabel = "MEM_EFF_THERM_SENSOR_3_TYPE";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xff18a73: {
              //simpleType:uint
              pLabel = "NPU_MMIO_BAR_BASE_ADDR";
              uint32_t offset = sprintf(&(l_traceEntry[0]), "[4][2]:");
              l_traceEntry.resize(10+offset + 8 * 19);
              for (uint32_t i = 0;i<8;i++) {
                  sprintf(&(l_traceEntry[offset+i*19]), "0x%.16llX ", ntohll(UINT64_FROM_PTR(reinterpret_cast<const uint64_t*>(l_ptr)+i)));
              }
              l_ptr += 8 * sizeof(uint64_t);
              break;
          }
          case 0xff69c2e: {
              //simpleType:uint
              pLabel = "ALG_TYPE_TO_ALG_TOKEN_CONTAINER";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 11);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*11]), "0x%.8X ", ntohl(UINT32_FROM_PTR(reinterpret_cast<const uint32_t*>(l_ptr)+i)));
              }
              l_ptr += 1 * sizeof(uint32_t);
              break;
          }
          case 0xff6c8c6: {
              //simpleType:uint
              pLabel = "SBE_MINIMUM_SECURE_VERSION";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xffba6d7: {
              //simpleType:uint
              pLabel = "MSS_EXP_RESP_DATA_MASK";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          case 0xfff38c9: {
              //simpleType:uint
              pLabel = "RUN_ODY_HWP_FROM_HOST";
              uint32_t offset = 0;
              l_traceEntry.resize(10+offset + 1 * 5);
              for (uint32_t i = 0;i<1;i++) {
                  sprintf(&(l_traceEntry[offset+i*5]), "0x%.2X ", *(((uint8_t *)l_ptr)+i));
              }
              l_ptr += 1 * sizeof(uint8_t);
              break;
          }
          default: {
              tmplabel = new char[30];
              sprintf( tmplabel, "Unknown [0x%x]", attrEnum );
              pLabel = tmplabel;
              break;
          }
        } // switch

        // pointing to something - print it.
        if (pLabel != NULL) {
            i_parser.PrintString(pLabel, &(l_traceEntry[0]));
        }
        if( tmplabel != NULL ) { delete[] tmplabel; }
    } // for
  } // parse

private:

// Disabled
ErrlUserDetailsParserAttribute(const ErrlUserDetailsParserAttribute &);
ErrlUserDetailsParserAttribute & operator=(const ErrlUserDetailsParserAttribute &);
};
} // namespace

