
#ifndef TARG_ATTRIBUTEENUMS_H
#define TARG_ATTRIBUTEENUMS_H

/**
 *  @file attributeenums.H
 *
 *  @brief Defined enums for platform attributes
 *
 *  This header file contains enumerations for supported platform attributes
 *  (as opposed to HWPF attributes).  This file is automatically
 *  generated and should not be altered.
 */

//******************************************************************************
// Includes
//******************************************************************************

#include <stdint.h>
#include <stdlib.h>

//******************************************************************************
// Enumerations
//******************************************************************************

namespace TARGETING
{

/**
 *  @brief Platform attribute IDs
 *
 *  Enumeration defining every possible platform attribute that can be
 *  associated with a target. This file is autogenerated and should not be
 *  altered.
 */
enum ATTRIBUTE_ID
{
    ATTR_NA                                                        = 0,
    ATTR_AUX_FUNC_INVOCATION_TIME_MS                               = 0x467a7c6,
    ATTR_FREQ_BIAS                                                 = 0xe72dc05,
    ATTR_VOLTAGE_EXT_BIAS                                          = 0x98fab6d,
    ATTR_VOLTAGE_EXT_VDN_BIAS                                      = 0x9fc8b45,
    ATTR_DDR5_VDN_UPLIFT_MV                                        = 0x0e57a47,
    ATTR_WOF_DCCR_VALUE                                            = 0x3917523,
    ATTR_WOF_FLMR_VALUE                                            = 0x48c79e0,
    ATTR_WOF_FMMR_VALUE                                            = 0xeda0efc,
    ATTR_DDS_DELAY_ADJUST                                          = 0x6c81641,
    ATTR_DDS_LARGE_DROOP_DETECT_ADJUST                             = 0xb63ad57,
    ATTR_DDS_TRIP_OFFSET_ADJUST                                    = 0xa5447c0,
    ATTR_DDS_DROOP_EXTREME_OVERRIDE                                = 0x2412f59,
    ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT                             = 0xa6a5da4,
    ATTR_DDS_DPLL_SLEW_MODE                                        = 0x05b494e,
    ATTR_DDS_TRIP_MODE                                             = 0x724bc5c,
    ATTR_DDS_TRIP_INTERPOLATION_CONTROL                            = 0x3310305,
    ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG                            = 0x4221eb9,
    ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE                       = 0xc96a9e2,
    ATTR_PGPE_HCODE_FUNCTION_ENABLE                                = 0xbb90f0a,
    ATTR_PM_GLOBAL_FIR_TRACE_EN                                    = 0xc315c52,
    ATTR_POUND_W_STATIC_DATA_ENABLE                                = 0xa24c56a,
    ATTR_POUND_V_STATIC_DATA_ENABLE                                = 0x7959bae,
    ATTR_AW_STATIC_DATA_ENABLE                                     = 0x8fe7d97,
    ATTR_IQ_STATIC_DATA_ENABLE                                     = 0xdca883d,
    ATTR_POUNDV_BUCKET_NUM                                         = 0x8d7f254,
    ATTR_POUNDV_BUCKET_NUM_OVERRIDE                                = 0x59b35d5,
    ATTR_SKIP_WAKEUP                                               = 0x6381afd,
    ATTR_SYS_VRT_STATIC_DATA_ENABLE                                = 0xfceb067,
    ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE                       = 0x5dd7e45,
    ATTR_SYSTEM_RING_DBG_MODE                                      = 0x4028d5e,
    ATTR_PM_MALF_ALERT_ENABLE                                      = 0xa3a830c,
    ATTR_PM_HALT_FFDC_ENABLE                                       = 0xdcf9224,
    ATTR_SYSTEM_DDS_DISABLE                                        = 0x4871927,
    ATTR_SYSTEM_DDS_FREQ_ENABLE                                    = 0x2f4ac23,
    ATTR_SYSTEM_AUXILLARY_MODE                                     = 0x7cfd099,
    ATTR_SYSTEM_PSTATES_MODE                                       = 0x8a7db83,
    ATTR_SYSTEM_SUSPEND_OCC_MODE                                   = 0x75576dc,
    ATTR_SYSTEM_RESCLK_DISABLE                                     = 0x1bc94b8,
    ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE                               = 0x1ca5b41,
    ATTR_SYSTEM_RVRM_DISABLE                                       = 0xf949e3a,
    ATTR_SYSTEM_WOF_DISABLE                                        = 0xd7e2c04,
    ATTR_SYSTEM_WOV_OVERV_DISABLE                                  = 0xb93929e,
    ATTR_SYSTEM_WOV_UNDERV_DISABLE                                 = 0x4d911fa,
    ATTR_WOF_INDEX_SELECT                                          = 0xa95efea,
    ATTR_SYSTEM_WOF_DISABLE_DIMENSION                              = 0x56efb21,
    ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE                         = 0x72f4865,
    ATTR_WOF_PITCH_ENABLE                                          = 0xd7c305f,
    ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE                            = 0x5e6c304,
    ATTR_WOF_THROTTLE_CONTROL_KP                                   = 0xc110745,
    ATTR_WOF_THROTTLE_CONTROL_KI                                   = 0x53beb18,
    ATTR_SYSTEM_OCS_DISABLE                                        = 0x2efe391,
    ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE                          = 0xf091dbc,
    ATTR_WOF_DCM_TRACKING_ENABLE                                   = 0x75ef2a9,
    ATTR_SYSTEM_WOF_VALIDATION_MODE                                = 0x0f373ad,
    ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE                            = 0xb2bacb2,
    ATTR_SYSTEM_PDV_VALIDATION_MODE                                = 0x4820f8b,
    ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE                            = 0x977494c,
    ATTR_SYSTEM_PDW_VALIDATION_MODE                                = 0xd099bb4,
    ATTR_SYSTEM_IQ_VALIDATION_MODE                                 = 0x8997fc6,
    ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE                    = 0x2dc6458,
    ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE                = 0x2e92774,
    ATTR_PBAX_BRDCST_ID_VECTOR                                     = 0x15c7694,
    ATTR_PBAX_CHIPID                                               = 0x7f199a1,
    ATTR_PBAX_GROUPID                                              = 0x955e6b7,
    ATTR_SPIPSS_FREQUENCY                                          = 0x9493ec3,
    ATTR_SPIPSS_SELECT                                             = 0x588aed6,
    ATTR_PROC_R_DISTLOSS_UOHM                                      = 0x4c51a2e,
    ATTR_PROC_R_LOADLINE_UOHM                                      = 0x9cb426e,
    ATTR_PROC_VRM_VOFFSET_UV                                       = 0xdbfb744,
    ATTR_CORE_THROTTLE_ASSERT_COUNT                                = 0x211648c,
    ATTR_CORE_THROTTLE_DEASSERT_COUNT                              = 0x6167a77,
    ATTR_AVSBUS_BUSNUM                                             = 0x2914dff,
    ATTR_AVSBUS_FREQUENCY                                          = 0xcc07b62,
    ATTR_AVSBUS_RAIL                                               = 0xcc8bf2b,
    ATTR_EXTERNAL_VRM_STEPSIZE                                     = 0x1a091ba,
    ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US                = 0x055981e,
    ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US                = 0x9dfa8e3,
    ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS             = 0x920e9b8,
    ATTR_EXTERNAL_VRM_TRANSITION_START_NS                          = 0xc8ab5a1,
    ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE                            = 0x4ebab49,
    ATTR_WOF_VRATIO_VDD_10THPCT                                    = 0x79c2dd2,
    ATTR_WOF_VRATIO_VCS_10THPCT                                    = 0x3519971,
    ATTR_WOF_TABLE_IO_POWER_BASE_W                                 = 0x3d57633,
    ATTR_WOF_IO_BASE_POWER_0P01W                                   = 0xef89eb6,
    ATTR_WOV_MAX_DROOP_10THPCT                                     = 0x58d355a,
    ATTR_WOV_OVERV_MAX_10THPCT                                     = 0x8be06f8,
    ATTR_WOV_OVERV_STEP_DECR_10THPCT                               = 0xa85a352,
    ATTR_WOV_OVERV_STEP_INCR_10THPCT                               = 0x1a4dca3,
    ATTR_WOV_OVERV_VMAX_SETPOINT_MV                                = 0x3b1ed0d,
    ATTR_WOV_UNDERV_MAX_10THPCT                                    = 0x668db70,
    ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE                         = 0xaa99dde,
    ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT                           = 0xf9d3311,
    ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT                            = 0x290257b,
    ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT                        = 0xed124b9,
    ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT                        = 0xe3b1a88,
    ATTR_WOV_UNDERV_STEP_DECR_10THPCT                              = 0xabb5e9c,
    ATTR_WOV_UNDERV_STEP_INCR_10THPCT                              = 0x95c569b,
    ATTR_WOV_UNDERV_VMIN_MV                                        = 0xa78eaae,
    ATTR_WOV_DIRTY_UNCURRENT_CONTROL                               = 0xe4e2b19,
    ATTR_OCS_WITH_DDS_DISABLE                                      = 0x2fc08c0,
    ATTR_WOV_OVERV_WITH_DDS_DISABLE                                = 0xd56672f,
    ATTR_DDS_DPLL_FMAX_FAST_DISABLE                                = 0x33a20f8,
    ATTR_DDS_DPLL_FMIN_FAST_DISABLE                                = 0xd5741a4,
    ATTR_DDS_FMAX_OVERRIDE_KHZ                                     = 0x987bc15,
    ATTR_DDS_FMIN_OVERRIDE_KHZ                                     = 0x2412cf9,
    ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK                               = 0xaa1d410,
    ATTR_SAFE_MODE_FREQUENCY_MHZ                                   = 0x39691ca,
    ATTR_SAFE_MODE_VOLTAGE_MV                                      = 0xad63b90,
    ATTR_VDN_UPLIFT_MV                                             = 0x0d8a911,
    ATTR_PMCR_MOST_RECENT_MODE                                     = 0x55bf804,
    ATTR_UNSECURE_HOMER_ADDRESS                                    = 0xef63d66,
    ATTR_UNSECURE_HOMER_SIZE                                       = 0x06e1416,
    ATTR_FUSED_CORE_PAIRED_MODE_ENABLED                            = 0x8eda99e,
    ATTR_SYSTEM_MMA_POWEROFF_DISABLE                               = 0x90885f2,
    ATTR_SYSTEM_MMA_POWERON_DISABLE                                = 0x219583a,
    ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS                     = 0xc687d1e,
    ATTR_RVRM_VID                                                  = 0x68b9d58,
    ATTR_RVRM_DEADZONE_MV                                          = 0x5e154c1,
    ATTR_STOP_LEVELS_SUPPORTED                                     = 0xfd41e04,
    ATTR_STOP_LEVELS_DISABLED                                      = 0xd463c27,
    ATTR_BOOT_VOLTAGE_BIAS_0P5PCT                                  = 0x4ec2278,
    ATTR_WOF_OMI_FORCE_FREQ_MHZ                                    = 0x2ef58ce,
    ATTR_SRAM_WRITE_ASSIST_MV                                      = 0x577af13,
    ATTR_DDS_THRESHOLD_PSTATE_ENABLE                               = 0x9ad35b5,
    ATTR_DDS_COARSE_THROTTLE_ENABLE                                = 0xa1f54ec,
    ATTR_DDS_FREQ_JUMP_ENABLE                                      = 0x7aabf03,
    ATTR_DDS_BIAS_ENABLE                                           = 0xd2942c8,
    ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT                       = 0x777f418,
    ATTR_THROTTLE_TABLE_OVERRIDE                                   = 0x9ddd63b,
    ATTR_THROTTLE_MODE                                             = 0xbc5137d,
    ATTR_DLR_LINKS_ENABLED                                         = 0x0041f25,
    ATTR_DLR_SAMPLE_TIME_MS                                        = 0x63546d5,
    ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE                        = 0xf3c3e44,
    ATTR_DLR_PLSF_OVERRIDE                                         = 0x2716b4f,
    ATTR_SAFE_MODE_XSTOP                                           = 0xf796610,
    ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT                              = 0xbfae9a6,
    ATTR_WOF_TDP_ALTITUDE_REFERENCE_M                              = 0x667e81e,
    ATTR_SYSTEM_FMAX_ENABLE                                        = 0xf811b59,
    ATTR_CURRENT_SCALING_FACTOR                                    = 0x5f1a686,
    ATTR_IO_GROUNDED_CONTROLLERS                                   = 0xbca8078,
    ATTR_IO_GROUNDED_LINKS                                         = 0xb697f6d,
    ATTR_WOF_IO_POWER_MODE                                         = 0x44a66ec,
    ATTR_EXTENDED_FREQ_MODE                                        = 0x26ecfec,
    ATTR_DVFS_ADJUSTMENT                                           = 0xa1ab2a1,
    ATTR_OCC_START_DISABLE                                         = 0x0e05a7c,
    ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY                       = 0xbbc3ceb,
    ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX                             = 0xc6cf6dd,
    ATTR_WTH_OVERRIDE_EFFICIENCY_ALG                               = 0x9e6ab5c,
    ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES                        = 0x3c0bdfa,
    ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH                       = 0x0dcd6cd,
    ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST                       = 0x06668e3,
    ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS                       = 0x609c749,
    ATTR_WTH_OVERRIDE_TEST_CORE_COUNT                              = 0xfe2fc3a,
    ATTR_RUNN_MODE                                                 = 0x71527f3,
    ATTR_RUNN_SRESET_THREADS_BVEC                                  = 0x832a26f,
    ATTR_RUNN_CYCLE_COUNT                                          = 0x13cd0a9,
    ATTR_RUNN_CHIP_CYCLE_OFFSET                                    = 0xeb223ec,
    ATTR_RUNN_QUAD_CYCLE_OFFSET                                    = 0x0220177,
    ATTR_RUNN_CORE_CYCLE_OFFSET                                    = 0x9b073da,
    ATTR_RUNN_DO_CONFIG_CHECKS                                     = 0xaf0dc82,
    ATTR_RUNN_USE_QME_TIMEBASE                                     = 0xf9f4fcc,
    ATTR_RUNN_STOP_ON_XSTOP                                        = 0x12b0629,
    ATTR_RUNN_MASTER_SEED                                          = 0x4222d51,
    ATTR_RUNN_CORE_SEED_SELECT                                     = 0xad742c1,
    ATTR_RUNN_THREAD_SEEDS                                         = 0x484fa88,
    ATTR_RUNN_STAGGER_DELAY                                        = 0x87e3ed0,
    ATTR_OMI_INBAND_BAR_ENABLE                                     = 0xe2457f8,
    ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET                           = 0xf0baf47,
    ATTR_EFF_DRAM_GEN                                              = 0x0d33633,
    ATTR_EFF_DIMM_TYPE                                             = 0xe35b4c7,
    ATTR_EFF_HYBRID_MEMORY_TYPE                                    = 0xa71dd22,
    ATTR_EFF_HYBRID                                                = 0x43cb904,
    ATTR_EFF_DRAM_DENSITY                                          = 0x07a9643,
    ATTR_EFF_DRAM_BANK_BITS                                        = 0x06d133f,
    ATTR_EFF_DRAM_BANK_GROUP_BITS                                  = 0x667433c,
    ATTR_EFF_DRAM_COLUMN_BITS                                      = 0x2f2f11c,
    ATTR_EFF_DRAM_ROW_BITS                                         = 0x1c28c5e,
    ATTR_EFF_PRIM_STACK_TYPE                                       = 0x4934fda,
    ATTR_EFF_DRAM_PPR                                              = 0x96494e2,
    ATTR_EFF_DRAM_SOFT_PPR                                         = 0x5534fbf,
    ATTR_EFF_DRAM_TRCD                                             = 0xc9b93c9,
    ATTR_EFF_DRAM_TRP                                              = 0x8b78d35,
    ATTR_EFF_DRAM_TRAS                                             = 0xa982f98,
    ATTR_EFF_DRAM_TRC                                              = 0x7461177,
    ATTR_EFF_DRAM_TRFC                                             = 0x878bcaf,
    ATTR_EFF_DRAM_TFAW                                             = 0xaf91cc7,
    ATTR_EFF_DRAM_TRRD_S                                           = 0xd6045da,
    ATTR_EFF_DRAM_TRRD_L                                           = 0x5ab71e7,
    ATTR_EFF_DRAM_TCCD_L                                           = 0x732fad3,
    ATTR_EFF_DRAM_TWR                                              = 0x05193dd,
    ATTR_EFF_DRAM_TWTR_S                                           = 0x440bec8,
    ATTR_EFF_DRAM_TWTR_L                                           = 0x8cd1455,
    ATTR_EFF_DRAM_TMAW                                             = 0x8196e7d,
    ATTR_EFF_DRAM_WIDTH                                            = 0xbcc0968,
    ATTR_EFF_DRAM_RANK_MIX                                         = 0x55fe8eb,
    ATTR_EFF_NUM_RANKS_PER_DIMM                                    = 0x88ba0c5,
    ATTR_EFF_REGISTER_TYPE                                         = 0x38313b7,
    ATTR_EFF_DRAM_MFG_ID                                           = 0x4bbfd53,
    ATTR_EFF_RCD_MFG_ID                                            = 0x43a0d7e,
    ATTR_EFF_REGISTER_REV                                          = 0x6cb15ee,
    ATTR_EFF_PACKAGE_RANK_MAP                                      = 0x208baa7,
    ATTR_EFF_NIBBLE_MAP                                            = 0x86feede,
    ATTR_ROW_REPAIR_SUPPORTED_MRW                                  = 0x6809efd,
    ATTR_MEMORY_BAR_REGS                                           = 0xf4f230f,
    ATTR_PROC_MEM_BASES                                            = 0x3849826,
    ATTR_PROC_MEM_SIZES                                            = 0x61d7f4f,
    ATTR_PROC_MIRROR_BASES                                         = 0xb9ee432,
    ATTR_PROC_MIRROR_SIZES                                         = 0x18128bb,
    ATTR_PROC_MEM_BASES_ACK                                        = 0x89b8414,
    ATTR_PROC_MEM_SIZES_ACK                                        = 0xc3e64a1,
    ATTR_PROC_MIRROR_BASES_ACK                                     = 0xb28a4f5,
    ATTR_MSS_MCC_GROUP_32                                          = 0x030e8ef,
    ATTR_HTM_QUEUES                                                = 0x0ea4707,
    ATTR_PROC_MIRROR_SIZES_ACK                                     = 0x4d787f5,
    ATTR_MSS_MEM_MC_IN_GROUP                                       = 0xc666c00,
    ATTR_MEM_MIRROR_PLACEMENT_POLICY                               = 0x1c0d755,
    ATTR_MAX_INTERLEAVE_GROUP_SIZE                                 = 0xe595eec,
    ATTR_MSS_INTERLEAVE_ENABLE                                     = 0x54fd267,
    ATTR_MSS_INTERLEAVE_GRANULARITY                                = 0x41ed7c4,
    ATTR_MSS_MEM_IPL_COMPLETE                                      = 0x647f6d0,
    ATTR_MRW_HW_MIRRORING_ENABLE                                   = 0xb7dddfb,
    ATTR_DYNAMIC_INIT_FEATURE_VEC                                  = 0x0942635,
    ATTR_DYNAMIC_INIT_FEATURE_COUNT                                = 0xc3c0eb5,
    ATTR_DYNAMIC_INIT_MODE_VEC                                     = 0x218e65f,
    ATTR_DYNAMIC_INIT_MODE_COUNT                                   = 0x57f72b2,
    ATTR_NHTM_TRACE_TYPE                                           = 0x85fcda1,
    ATTR_CHTM_TRACE_TYPE                                           = 0xa1e433c,
    ATTR_NHTM_HTMSC_MODE_CONTENT_SEL                               = 0x117c575,
    ATTR_NHTM_HTMSC_MODE_CAPTURE                                   = 0x464bfaf,
    ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE                          = 0x3ad5ca0,
    ATTR_NHTM_HTMSC_MODE_WRITETOIO                                 = 0xdb283e0,
    ATTR_HTMSC_FILT_STOP_ON_MATCH                                  = 0xd484fd1,
    ATTR_HTMSC_FILT_STOP_CYCLES                                    = 0xbd313d5,
    ATTR_HTMSC_TTYPEFILT_PAT                                       = 0xcde0848,
    ATTR_HTMSC_TSIZEFILT_PAT                                       = 0xefc5783,
    ATTR_HTMSC_TTYPEFILT_MASK                                      = 0xf91795a,
    ATTR_HTMSC_TSIZEFILT_MASK                                      = 0x172d7c5,
    ATTR_HTMSC_TTYPEFILT_INVERT                                    = 0x8b5ae6e,
    ATTR_HTMSC_CRESPFILT_INVERT                                    = 0xce3e5e5,
    ATTR_HTMSC_FILT_ADDR_PAT                                       = 0xb2b25f6,
    ATTR_HTMSC_FILT_ADDR_MASK                                      = 0xce7d97c,
    ATTR_HTMSC_FILT_TTAG_PAT                                       = 0x712e3fe,
    ATTR_HTMSC_FILT_OCC_PAT                                        = 0x2754e20,
    ATTR_HTMSC_FILT_SCOPE_PAT                                      = 0xb84e7b5,
    ATTR_HTMSC_FILT_SOURCE_PAT                                     = 0xe3b2a94,
    ATTR_HTMSC_FILT_PORT_PAT                                       = 0xd754024,
    ATTR_HTMSC_FILT_PORT1_PAT                                      = 0xa235b8b,
    ATTR_HTMSC_TTAGFILT_INVERT                                     = 0x47de4ea,
    ATTR_HTMSC_FILT_CRESP_PAT                                      = 0xea5d545,
    ATTR_HTMSC_FILT_TTAG_MASK                                      = 0xd7a3f4c,
    ATTR_HTMSC_FILT_OCC_MASK                                       = 0x92ff37a,
    ATTR_HTMSC_FILT_SCOPE_MASK                                     = 0x1d3faf3,
    ATTR_HTMSC_FILT_SOURCE_MASK                                    = 0x2c3dd0b,
    ATTR_HTMSC_FILT_PORT_MASK                                      = 0xe06e33e,
    ATTR_HTMSC_FILT_PORT1_MASK                                     = 0x2dae314,
    ATTR_HTMSC_FILT_CRESP_MASK                                     = 0xe356be6,
    ATTR_HTMSC_MEM_SCOPE                                           = 0xfdbc8b2,
    ATTR_HTMSC_MEM_PRIORITY                                        = 0x51dd309,
    ATTR_NHTM_CTRL_TRIG                                            = 0x65c995d,
    ATTR_NHTM_CTRL_MARK                                            = 0xb9cc761,
    ATTR_CHTM_CTRL_TRIG                                            = 0x16a3e9f,
    ATTR_CHTM_CTRL_MARK                                            = 0x970ff46,
    ATTR_HTMSC_CTRL_DBG0_STOP                                      = 0x5464e01,
    ATTR_HTMSC_CTRL_DBG1_STOP                                      = 0x5add085,
    ATTR_HTMSC_CTRL_RUN_STOP                                       = 0xc352d05,
    ATTR_HTMSC_CTRL_OTHER_DBG0_STOP                                = 0xecc42ef,
    ATTR_HTMSC_CTRL_XSTOP_STOP                                     = 0x472b4fc,
    ATTR_HTMSC_CTRL_CHIP0_STOP                                     = 0xdf6bde0,
    ATTR_HTMSC_CTRL_CHIP1_STOP                                     = 0x4a70af5,
    ATTR_HTMSC_IMA_PDBAR_SCOPE                                     = 0xe2556ce,
    ATTR_HTMSC_IMA_PDBAR_ADDR                                      = 0x833d2c7,
    ATTR_HTMSC_MODE_WRAP                                           = 0x5390d2b,
    ATTR_HTMSC_MODE_DIS_TSTAMP                                     = 0x90059b3,
    ATTR_HTMSC_MODE_SINGLE_TSTAMP                                  = 0x3d84c2e,
    ATTR_HTMSC_MODE_MARKERS_ONLY                                   = 0x5fa7892,
    ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE                          = 0xe3950d2,
    ATTR_HTMSC_MODE_VGTARGET                                       = 0x46a1caf,
    ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS                      = 0x60af368,
    ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS                          = 0x66c4d30,
    ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS                       = 0x9cedf5f,
    ATTR_CHTM_MODE_LLAT_IMBEDDED_TS                                = 0x25ef505,
    ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR                = 0x2e0dedf,
    ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE                             = 0x1e5007b,
    ATTR_CHTM_MODE_CORE_WRAP                                       = 0xcf85c28,
    ATTR_CHTM_MODE_DIS_TSTAMP                                      = 0x5223195,
    ATTR_CHTM_MODE_SINGLE_TIME_STAMP                               = 0xe9cec48,
    ATTR_CHTM_MODE_DIS_STALL                                       = 0xf5ac814,
    ATTR_CHTM_MODE_MARKERS_ONLY                                    = 0x7ec5eb9,
    ATTR_CHTM_MODE_DIS_GROUP                                       = 0x748298e,
    ATTR_CHTM_MODE_VGTARGET                                        = 0x0202831,
    ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL                          = 0x6e2352a,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP                          = 0x7584c35,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP                        = 0xa22aac4,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE                          = 0x2fcf5a5,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE                        = 0xa9e7355,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE                        = 0xa4d2323,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT                       = 0x5b7c99d,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID                      = 0x86695d0,
    ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT                    = 0x36b5355,
    ATTR_OMI_REFCLOCK_SWIZZLE                                      = 0xe96da20,
    ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE                             = 0xd6af0b6,
    ATTR_PROC_FABRIC_SL_DOMAIN                                     = 0x91b6902,
    ATTR_PROC_FABRIC_TSNOOP                                        = 0x9e66e24,
    ATTR_PROC_FABRIC_BROADCAST_MODE                                = 0xa5a748f,
    ATTR_PROC_FABRIC_PRESENT_GROUPS                                = 0x3883186,
    ATTR_PROC_FABRIC_TOPOLOGY_MODE                                 = 0x0432b91,
    ATTR_PROC_FABRIC_TOPOLOGY_ID                                   = 0xf24fe73,
    ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID                               = 0x482b817,
    ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP                            = 0xe831572,
    ATTR_PROC_FABRIC_GROUP_MASTER_CHIP                             = 0xa2c9bd2,
    ATTR_IOHS_CONFIG_MODE                                          = 0x4950959,
    ATTR_PROC_FABRIC_IOHS_BUS_WIDTH                                = 0x17f1548,
    ATTR_IOHS_DRAWER_INTERCONNECT                                  = 0xf9a81a2,
    ATTR_IOHS_SMP9_INTERCONNECT                                    = 0x628f4c8,
    ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG                              = 0x5401234,
    ATTR_IOHS_FABRIC_LANE_REVERSAL                                 = 0x9640d61,
    ATTR_PROC_FABRIC_LINK_ACTIVE                                   = 0x00116c3,
    ATTR_IOHS_LINK_TRAIN                                           = 0x94f0f3c,
    ATTR_IOHS_LINK_SPLIT                                           = 0xaa04632,
    ATTR_LINK_SPEED                                                = 0xc7a1d47,
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG                          = 0x0d40743,
    ATTR_PROC_FABRIC_X_LINKS_CNFG                                  = 0x6704d48,
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG                          = 0x9db3e24,
    ATTR_PROC_FABRIC_A_LINKS_CNFG                                  = 0x87ff43a,
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID                            = 0xa96afb3,
    ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID                        = 0xf033211,
    ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID                            = 0x56be955,
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID                            = 0x5f943d0,
    ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID                        = 0x76d2e17,
    ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID                            = 0x36e454b,
    ATTR_PROC_FABRIC_X_AGGREGATE                                   = 0xeada36c,
    ATTR_PROC_FABRIC_X_ADDR_DIS                                    = 0x1f2c617,
    ATTR_PROC_FABRIC_X_LINK_DELAY                                  = 0xd60cf0a,
    ATTR_PROC_FABRIC_A_AGGREGATE                                   = 0x23ad20f,
    ATTR_PROC_FABRIC_A_ADDR_DIS                                    = 0xa9a7c39,
    ATTR_PROC_FABRIC_A_INDIRECT                                    = 0x03ec4a4,
    ATTR_PROC_FABRIC_R_INDIRECT_EN                                 = 0x56ff0f8,
    ATTR_PROC_FABRIC_A_LINK_DELAY                                  = 0xc0bb633,
    ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE                        = 0xe2328b9,
    ATTR_PROC_FABRIC_ASYNC_MODE                                    = 0x421ef26,
    ATTR_PROC_FABRIC_DLR_PSAVE_MODE                                = 0x2eccc49,
    ATTR_PROC_FABRIC_CORE_FREQ_RATIO                               = 0xd84795a,
    ATTR_PROC_EPS_GB_PERCENTAGE                                    = 0x29081fa,
    ATTR_PROC_EPS_TABLE_TYPE                                       = 0x23c87d8,
    ATTR_PROC_EPS_READ_CYCLES_T0                                   = 0x21049e0,
    ATTR_PROC_EPS_READ_CYCLES_T1                                   = 0x4bf64b9,
    ATTR_PROC_EPS_READ_CYCLES_T2                                   = 0xa78e807,
    ATTR_PROC_EPS_WRITE_CYCLES_T1                                  = 0x948370e,
    ATTR_PROC_EPS_WRITE_CYCLES_T2                                  = 0xf104f67,
    ATTR_MRW_L2_INCREASE_JITTER                                    = 0xb9dc486,
    ATTR_MRW_P1PF_MIN_CONFIDENCE_3                                 = 0x5da8533,
    ATTR_MRW_CONVERT_DCBZ_TO_RWITM                                 = 0xe911abb,
    ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH                            = 0x55ddfeb,
    ATTR_PROC_LCO_MODE_DISABLE                                     = 0xe444f3b,
    ATTR_PROC_LCO_MODE_SETUP                                       = 0x5d59877,
    ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N                            = 0x6237f69,
    ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D                            = 0x8f50763,
    ATTR_PROC_LCO_TARGETS_COUNT                                    = 0xf88f412,
    ATTR_PROC_LCO_TARGETS_VECTOR                                   = 0xb069fed,
    ATTR_PROC_LCO_TARGETS_MIN                                      = 0xa56649e,
    ATTR_IOHS_PHY_TO_PAU_MAPPING                                   = 0x4c334cb,
    ATTR_PROC_L2_HASH_DISABLE                                      = 0xcfd9488,
    ATTR_PROC_L3_HASH_DISABLE                                      = 0xba10231,
    ATTR_PROC_SBE_MCS_SETUP_REG_STATES                             = 0x1ef2a04,
    ATTR_PROC_MEMORY_ENCRYPTION_ENABLED                            = 0xdee8fd0,
    ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC                            = 0x6c26bcb,
    ATTR_HW543384_WAR_MODE                                         = 0xa450ad9,
    ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE                          = 0x0a96a60,
    ATTR_QME_STATE_LOSS_CORES                                      = 0xce16d63,
    ATTR_PROC_DPLL_DIVIDER                                         = 0xde419d0,
    ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET                              = 0x2fd62ba,
    ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET                              = 0x08b7922,
    ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG                                = 0x4c1219d,
    ATTR_OCC_LFIRMASK                                              = 0x8d614de,
    ATTR_PBAO_LFIRMASK                                             = 0x36ebdf0,
    ATTR_QME_LFIRMASK                                              = 0x9209ebe,
    ATTR_PBAF_LFIRMASK                                             = 0xc2a8db1,
    ATTR_PM_FIRINIT_DONE_ONCE_FLAG                                 = 0x4851132,
    ATTR_L3_HASCLOCKS                                              = 0xe977d9f,
    ATTR_CORE_HASCLOCKS                                            = 0xd66b345,
    ATTR_L3_HASPOWER                                               = 0x5437d12,
    ATTR_CORE_HASPOWER                                             = 0x15f7d77,
    ATTR_PSTATES_ENABLED                                           = 0xa3a4736,
    ATTR_RESCLK_ENABLED                                            = 0xaa9080d,
    ATTR_DDS_ENABLED                                               = 0xe8a4ed4,
    ATTR_RVRM_ENABLED                                              = 0xe992285,
    ATTR_WOF_ENABLED                                               = 0xca00099,
    ATTR_OCS_ENABLED                                               = 0xb22f067,
    ATTR_WOV_UNDERV_ENABLED                                        = 0x244f3e1,
    ATTR_WOV_OVERV_ENABLED                                         = 0x931031c,
    ATTR_WOF_THROTTLE_CONTROL_DISABLED                             = 0x82f2d14,
    ATTR_XGPE_PHANTOM_HALT_ENABLE                                  = 0x7405667,
    ATTR_PGPE_PHANTOM_HALT_ENABLE                                  = 0x08f223c,
    ATTR_QME_STOP_PHANTOM_HALT_ENABLE                              = 0xc95df70,
    ATTR_CORE_INSIDE_SPECIAL_WAKEUP                                = 0xae5b915,
    ATTR_INITIATED_PM_HALT                                         = 0xaf6e256,
    ATTR_PM_RESTART_PHASE                                          = 0xed1a955,
    ATTR_PM_MALF_CYCLE                                             = 0x8b6b012,
    ATTR_BOOT_VOLTAGE                                              = 0x5c5498f,
    ATTR_QME_BROADSIDE_SCAN                                        = 0xd0ddacf,
    ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ                             = 0x0b391d7,
    ATTR_SYSTEM_PSTATE0_FREQ_MHZ                                   = 0x001189a,
    ATTR_HOMER_LOCATION                                            = 0xed4417b,
    ATTR_QME_BOOT_CONTROL                                          = 0xc7deda5,
    ATTR_PM_SPIPSS_FRAME_SIZE                                      = 0xb69562d,
    ATTR_PM_SPIPSS_IN_DELAY                                        = 0xae84e31,
    ATTR_PM_SPIPSS_CLOCK_POLARITY                                  = 0x0241bf2,
    ATTR_PM_SPIPSS_CLOCK_PHASE                                     = 0x82b807e,
    ATTR_PM_SPIPSS_CLOCK_DIVIDER                                   = 0x16824ac,
    ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING                       = 0x3e336e0,
    ATTR_INSIDE_SPECIAL_WAKEUP                                     = 0xc8bd195,
    ATTR_SOCKET_POWER_NOMINAL                                      = 0xe2ab0d2,
    ATTR_SYSTEM_COMPAT_FREQ_MHZ                                    = 0x3a9b8a6,
    ATTR_WOF_TABLE_OVERRIDE_UT                                     = 0x8f2e0ff,
    ATTR_WOF_TABLE_OVERRIDE_WB                                     = 0xaa89323,
    ATTR_WOF_TABLE_OVERRIDE_PS                                     = 0x3d086ed,
    ATTR_WOF_TABLE_OVERRIDE_FF                                     = 0xd53c70b,
    ATTR_WOF_TABLE_OVERRIDE_SP                                     = 0x9133f91,
    ATTR_WOF_TABLE_OVERRIDE_RC                                     = 0x3be1427,
    ATTR_WOF_IO_START                                              = 0x63c5ad2,
    ATTR_WOF_IO_STEP                                               = 0x07e49ed,
    ATTR_WOF_IO_COUNT                                              = 0xf995f8c,
    ATTR_VDN_VOLTAGE_MV                                            = 0x219028e,
    ATTR_WOF_TDP_IO_INDEX                                          = 0x6efcd46,
    ATTR_DEAD_CORE_MODE                                            = 0xcb1fddb,
    ATTR_SAFE_MODE_THROTTLE_IDX                                    = 0x37796c6,
    ATTR_PDW_TRACE_ENABLE                                          = 0x36b1670,
    ATTR_MIN_PROC_POWER_PER_CHIP                                   = 0x0db7587,
    ATTR_AVSBUS_VRM_FAIL_OVERRIDE                                  = 0x03622b1,
    ATTR_OMI_SPREAD_SPECTRUM                                       = 0xbdb2023,
    ATTR_IOHS_SPREAD_SPECTRUM                                      = 0xf4e4164,
    ATTR_IOHS_MNFG_BAD_LANE_MAX                                    = 0x49eb22a,
    ATTR_IOHS_MNFG_BAD_LANE_DURATION                               = 0x3eb05bb,
    ATTR_VIO_SET_POINT_MV                                          = 0xd7d9779,
    ATTR_IOHS_MFG_BAD_LANE_VEC                                     = 0xf0ccd74,
    ATTR_IOHS_MFG_BAD_LANE_VEC_VALID                               = 0x978723d,
    ATTR_IO_IOHS_XTALK                                             = 0x2d5e154,
    ATTR_IO_IOHS_CHANNEL_LOSS                                      = 0xbf1b8d3,
    ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND                      = 0x53689d6,
    ATTR_IO_OMI_CHANNEL_LOSS                                       = 0xb4bc1d3,
    ATTR_IO_OMI_PRE1                                               = 0x76d448e,
    ATTR_IO_OMI_PRE2                                               = 0x16ca47a,
    ATTR_IO_IOHS_PRE1                                              = 0x8ab374a,
    ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND                              = 0x85528b9,
    ATTR_IO_IOHS_PRE2                                              = 0x461601a,
    ATTR_OMI_DL_GROUP_POS                                          = 0xa59d641,
    ATTR_OMI_DL_NUM                                                = 0x38da24e,
    ATTR_OCMB_COUNTER                                              = 0x6c8bf3d,
    ATTR_VIO_RAILS_NOT_POWERED                                     = 0x9166bde,
    ATTR_SAVED_PB_PTL_FIR_MASK                                     = 0x93e688d,
    ATTR_SAVED_DLP_FIR_MASK                                        = 0x32cec3d,
    ATTR_INTERPOSER_REV                                            = 0x13fdcc3,
    ATTR_INTERPOSER_FEATURE_HW632898                               = 0xa687574,
    ATTR_PROC_PCIE_PHB_ACTIVE                                      = 0x763e8c5,
    ATTR_PROC_PCIE_LANE_REVERSAL                                   = 0x025b084,
    ATTR_PROC_PCIE_BAR_ENABLE                                      = 0xc03d18e,
    ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET                      = 0x998757c,
    ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET                      = 0x637e6da,
    ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET                   = 0xc2fdc31,
    ATTR_PROC_PCIE_BAR_SIZE                                        = 0x6a37320,
    ATTR_PROC_PCIE_FW_VERSION_0                                    = 0x84bd9ba,
    ATTR_PROC_PCIE_FW_VERSION_1                                    = 0xb397e66,
    ATTR_SYS0_REFCLOCK_RCVR_TERM                                   = 0x4b2ea2d,
    ATTR_SYS1_REFCLOCK_RCVR_TERM                                   = 0x7172b53,
    ATTR_PCI0_REFCLOCK_RCVR_TERM                                   = 0x4da870d,
    ATTR_PCI1_REFCLOCK_RCVR_TERM                                   = 0x0602310,
    ATTR_SYS_CLK_NE_TERMINATION_SITE                               = 0x8467756,
    ATTR_SYS_CLK_NE_TERMINATION_STRENGTH                           = 0x68de0ff,
    ATTR_CP_REFCLOCK_SELECT                                        = 0x8e2c3d7,
    ATTR_CLOCK_MUX0A_RCS_PLL_INPUT                                 = 0x18658a8,
    ATTR_CLOCK_MUX0B_RCS_PLL_INPUT                                 = 0x55f05dc,
    ATTR_CLOCK_MUX0C_RCS_PLL_INPUT                                 = 0xd94832a,
    ATTR_CLOCK_MUX0D_RCS_PLL_INPUT                                 = 0x597acd8,
    ATTR_CLOCK_MUX1_INPUT                                          = 0xf1dc314,
    ATTR_CLOCK_MUX2A_INPUT                                         = 0x69014fc,
    ATTR_CLOCK_MUX2B_INPUT                                         = 0x4313fe7,
    ATTR_CLOCK_MUX3_INPUT                                          = 0x010fb1f,
    ATTR_CLOCK_MUX10_PAU_DPLL_INPUT                                = 0xa45db0f,
    ATTR_CLOCK_MUX11_NEST_DPLL_INPUT                               = 0xac2958b,
    ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT                               = 0x06065ab,
    ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT                          = 0x133d3ca,
    ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT                          = 0xed6a4b4,
    ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT                                = 0x4b21c2c,
    ATTR_CLOCK_MUX23_PCI_INPUT                                     = 0xf1e3ebe,
    ATTR_CLOCK_MUX_PCI_LCPLL_INPUT                                 = 0x280b074,
    ATTR_CLOCK_PLL_MUX_TOD                                         = 0xc13aa28,
    ATTR_HW543822_WAR_MODE                                         = 0xb6ad76f,
    ATTR_DISABLE_TOD_SYNC_SPREAD                                   = 0x8f5a12c,
    ATTR_PROC_FORCE_MC_PLL_BANDSEL                                 = 0xaa74969,
    ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE                              = 0xd7aa47b,
    ATTR_SYSTEM_IPL_PHASE                                          = 0x6a47337,
    ATTR_PROC_CHIP_IPL_PHASE                                       = 0x84844ff,
    ATTR_IPL_TYPE                                                  = 0x2022c38,
    ATTR_CONTAINED_IPL_TYPE                                        = 0x46189b8,
    ATTR_CONTAINED_LOAD_PATH                                       = 0x32f9c30,
    ATTR_SBE_RUNTIME_MODE                                          = 0xbeb4dd6,
    ATTR_IS_SP_MODE                                                = 0x738ed86,
    ATTR_DISABLE_HBBL_VECTORS                                      = 0xb1c3653,
    ATTR_BACKUP_SEEPROM_SELECT                                     = 0xb812834,
    ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT                         = 0xad366df,
    ATTR_BOOT_FLAGS                                                = 0xc774921,
    ATTR_ALLOW_ATTR_OVERRIDES                                      = 0xf13ce5f,
    ATTR_NO_XSCOM_ENFORCEMENT                                      = 0x2eda5ab,
    ATTR_SECURITY_ENABLE                                           = 0x92913ca,
    ATTR_SBE_SELECT_EX_POLICY                                      = 0x96ed273,
    ATTR_MASTER_CORE                                               = 0xcd97b51,
    ATTR_ACTIVE_CORES_VEC                                          = 0x7a4868d,
    ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC                           = 0x852b409,
    ATTR_BACKING_CACHES_VEC                                        = 0x66919bb,
    ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC                         = 0xf466e86,
    ATTR_ACTIVE_CORES_NUM                                          = 0x8ee5f82,
    ATTR_BACKING_CACHES_NUM                                        = 0x219cef7,
    ATTR_CORE_LPAR_MODE_POLICY                                     = 0x3da9467,
    ATTR_CORE_LPAR_MODE                                            = 0xd990683,
    ATTR_ZERO_CORE_CHIP                                            = 0x2afc21f,
    ATTR_HB_FALLBACK_CORES                                         = 0x5b6809b,
    ATTR_PVR_82_MODE                                               = 0x9599693,
    ATTR_IS_IOSCM                                                  = 0xd7bebc5,
    ATTR_PG_MVPD                                                   = 0xf93274e,
    ATTR_ECO_MODE                                                  = 0x4916096,
    ATTR_PROC_SBE_MASTER_CHIP                                      = 0x4c42b9b,
    ATTR_SECTOR_BUFFER_STRENGTH                                    = 0x9761e43,
    ATTR_NDL_MESHCTRL_SETUP                                        = 0x8ad2e2a,
    ATTR_MC_PLL_BUCKET                                             = 0xb43f2fe,
    ATTR_IOHS_PLL_BUCKET                                           = 0xad86cfa,
    ATTR_FILTER_PLL_BUCKET                                         = 0x0a745be,
    ATTR_PCI_PLL_BUCKET                                            = 0x102dda7,
    ATTR_CP_PLLTODFLT_BYPASS                                       = 0x5ab3bbc,
    ATTR_CP_PLLNESTFLT_BYPASS                                      = 0x73da768,
    ATTR_CP_PLLIOFLT_BYPASS                                        = 0xce4b78c,
    ATTR_CP_PLLIOSSFLT_BYPASS                                      = 0x7d95979,
    ATTR_PAU_DPLL_BYPASS                                           = 0x8f2bd1d,
    ATTR_NEST_DPLL_BYPASS                                          = 0x2d603ab,
    ATTR_IO_TANK_PLL_BYPASS                                        = 0xcf1e319,
    ATTR_SKEWADJ_BYPASS                                            = 0x91dcae8,
    ATTR_SKEWADJ_CORE_PDLY_OVERRIDE                                = 0x84b3cfb,
    ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE                               = 0x31a8e4b,
    ATTR_DCADJ_BYPASS                                              = 0xc9cddc6,
    ATTR_DCADJ_DCC_OVERRIDE                                        = 0x8a9711e,
    ATTR_DCADJ_TARGET_OVERRIDE                                     = 0x7b36ccf,
    ATTR_ECID                                                      = 0x522a158,
    ATTR_INTERPOSER_ECID                                           = 0xa6640ef,
    ATTR_LPC_CONSOLE_CNFG                                          = 0x45149fa,
    ATTR_SBE_SYS_CONFIG                                            = 0xf64aeb7,
    ATTR_EC_GARD                                                   = 0x837f7ab,
    ATTR_CLOCKSTOP_ON_XSTOP                                        = 0xa26f1f9,
    ATTR_XSTOP_ON_SPATTN                                           = 0xcfcfb46,
    ATTR_BOOT_PAU_DPLL_BYPASS                                      = 0x36f90c5,
    ATTR_ORIG_FIR_SETTINGS_ACTION0                                 = 0x836d048,
    ATTR_ORIG_FIR_SETTINGS_ACTION1                                 = 0x9653ac9,
    ATTR_QME_HCODE_OFFSET                                          = 0x3b80bcf,
    ATTR_QME_HCODE_BLOCK_COUNT                                     = 0xca985e0,
    ATTR_FREQ_CP_REFCLOCK_KHZ                                      = 0xcab73ca,
    ATTR_FREQ_DPLL_REFCLOCK_KHZ                                    = 0x47b7017,
    ATTR_FREQ_IO_REFCLOCK_KHZ                                      = 0xbd6da05,
    ATTR_FREQ_CORE_FLOOR_MHZ                                       = 0x49b1d2e,
    ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ                                = 0xdc82830,
    ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ                            = 0x2c34124,
    ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ                              = 0x221fcbe,
    ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE                       = 0x0166494,
    ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE                     = 0xcc3d988,
    ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL                       = 0x3e38294,
    ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL                     = 0xacca48f,
    ATTR_FREQ_CORE_BOOT_MHZ                                        = 0x68dd522,
    ATTR_FREQ_MC_MHZ                                               = 0x02db547,
    ATTR_PLL_BUCKET_BUILD_INDEX                                    = 0x724e782,
    ATTR_FREQ_OMI_MHZ                                              = 0xa6c0769,
    ATTR_FREQ_IOHS_MHZ                                             = 0xdafb56e,
    ATTR_FREQ_IOHS_LINK_MHZ                                        = 0xc37b3da,
    ATTR_FREQ_PROC_IOHS_MHZ                                        = 0xd6007fa,
    ATTR_FREQ_PAU_MHZ                                              = 0x6f2adc3,
    ATTR_INCREASED_PAU_FREQ                                        = 0x9a2f3fb,
    ATTR_FREQ_PCIE_MHZ                                             = 0x82f58e6,
    ATTR_SPI_BUS_DIV_REF                                           = 0x3df05de,
    ATTR_TPM_SPI_BUS_DIV                                           = 0x9d0a4a8,
    ATTR_MAX_ALLOWED_DIMM_FREQ                                     = 0x01e31e8,
    ATTR_REQUIRED_SYNCH_MODE                                       = 0x83fe364,
    ATTR_NOMINAL_FREQ_MHZ                                          = 0x4e64981,
    ATTR_WOFBASE_FREQ_MHZ                                          = 0x7ce5ba8,
    ATTR_FREQ_PAU_VPD_MHZ                                          = 0x968f7cc,
    ATTR_SBE_BOOTLOADER_OFFSET                                     = 0x260fed1,
    ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET                          = 0xea3d478,
    ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE                             = 0xc4d3c24,
    ATTR_SBE_MASTER_HRMOR_ADDRESS                                  = 0x56cd34f,
    ATTR_HOSTBOOT_HRMOR_OFFSET                                     = 0x347eff6,
    ATTR_SBE_BOOT_SIDE                                             = 0xcd1457b,
    ATTR_LPC_CONSOLE_INITIALIZED                                   = 0x649a489,
    ATTR_SECURE_SETTINGS                                           = 0x0dfd293,
    ATTR_SBE_HBBL_EXCEPTION_INSTRUCT                               = 0xaa3176d,
    ATTR_SBE_ADDR_KEY_STASH_ADDR                                   = 0x8fc28b1,
    ATTR_NUM_KEY_ADDR_PAIR                                         = 0x29bcc00,
    ATTR_SBE_MEASUREMENT_SEEPROM_VERSION                           = 0x2dc6337,
    ATTR_SBE_HW_KEY_HASH_ADDR                                      = 0x806e2cd,
    ATTR_SBE_MINIMUM_SECURE_VERSION                                = 0xff6c8c6,
    ATTR_SBE_SECURE_BOOT_MODE                                      = 0x2641d60,
    ATTR_SBE_IMAGE_MINIMUM_VALID_ECS                               = 0xba8abbe,
    ATTR_MAX_SBE_SEEPROM_SIZE                                      = 0x97c0210,
    ATTR_SBE_CUST_FORCE_MVPD_ONLY                                  = 0xf991bc4,
    ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS                             = 0x5665717,
    ATTR_PROC_ENABLE_DL_TMPL_1                                     = 0x0dddcbc,
    ATTR_PROC_ENABLE_DL_TMPL_4                                     = 0xcd7be76,
    ATTR_PROC_ENABLE_DL_TMPL_7                                     = 0xe80bb76,
    ATTR_PROC_ENABLE_DL_TMPL_A                                     = 0x62e9ef2,
    ATTR_PROC_TMPL_0_PACING                                        = 0x0496af4,
    ATTR_PROC_TMPL_1_PACING                                        = 0x347b055,
    ATTR_PROC_TMPL_4_PACING                                        = 0xdf66855,
    ATTR_PROC_TMPL_7_PACING                                        = 0x078d31b,
    ATTR_PROC_TMPL_A_PACING                                        = 0xf9ab3cb,
    ATTR_SYS_DISABLE_MCU_TIMEOUTS                                  = 0x6f26f00,
    ATTR_SYS_DISABLE_HWFM                                          = 0x7bbb645,
    ATTR_SYS_ENABLE_MC_HW520600_X4CTR                              = 0x309917b,
    ATTR_PROC_OMI_OC_MAJOR_VER                                     = 0xf77c444,
    ATTR_PROC_OMI_OC_MINOR_VER                                     = 0xebb5b0c,
    ATTR_OMI_CHANNEL_FAIL_ACTION                                   = 0x89af58e,
    ATTR_MFG_SCREEN_OMI_CRC_ALLOWED                                = 0x650fda1,
    ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED                               = 0x2d47f25,
    ATTR_MSS_MNFG_EDPL_TIME                                        = 0x6a4f7bc,
    ATTR_MSS_MNFG_EDPL_THRESHOLD                                   = 0x2b21694,
    ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET                           = 0x3fe9f90,
    ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET                             = 0x57ab3c7,
    ATTR_PROC_FSP_BAR_ENABLE                                       = 0x8f1af9c,
    ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET                             = 0xe3352f1,
    ATTR_PROC_FSP_BAR_SIZE                                         = 0xf8dd85b,
    ATTR_PROC_FSP_MMIO_MASK_SIZE                                   = 0xbcf856d,
    ATTR_PROC_PAU_MMIO_BAR_ENABLE                                  = 0x8188de0,
    ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET                        = 0x3351ea6,
    ATTR_PROC_PSI_BRIDGE_BAR_ENABLE                                = 0x8883a11,
    ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET                      = 0x206be4b,
    ATTR_PROC_NX_RNG_BAR_ENABLE                                    = 0x928d6c3,
    ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET                          = 0x037feec,
    ATTR_PROC_NX_RNG_FAILED_INT_ENABLE                             = 0x6234fc5,
    ATTR_PROC_NX_RNG_FAILED_INT_ADDR                               = 0xeb5a690,
    ATTR_PROC_NHTM_BAR_BASE_ADDR                                   = 0xb65b981,
    ATTR_PROC_NHTM_BAR_SIZE                                        = 0xc4941e4,
    ATTR_PROC_CHTM_BAR_BASE_ADDR                                   = 0xf42d558,
    ATTR_PROC_CHTM_BAR_SIZES                                       = 0x4479a4c,
    ATTR_PROC_SMF_BAR_BASE_ADDR                                    = 0xf036277,
    ATTR_PROC_SMF_BAR_SIZE                                         = 0xa8672bd,
    ATTR_SMF_CONFIG                                                = 0x0056bc3,
    ATTR_PROC_OCC_SANDBOX_BASE_ADDR                                = 0x14625e7,
    ATTR_PROC_OCC_SANDBOX_SIZE                                     = 0x9f3cbef,
    ATTR_PROC_INT_IC_BAR_ENABLE                                    = 0x8cc8333,
    ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET                          = 0xe6a19c7,
    ATTR_PROC_INT_IC_BAR_PAGE_SIZE                                 = 0x06716dc,
    ATTR_PROC_INT_TM_BAR_ENABLE                                    = 0x6ba66f8,
    ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET                          = 0xa543693,
    ATTR_PROC_INT_TM_BAR_PAGE_SIZE                                 = 0x59d033d,
    ATTR_PROC_INT_NVPG_BAR_ENABLE                                  = 0x617e775,
    ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE                               = 0xeb1a81f,
    ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET                        = 0xb9270af,
    ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR                   = 0xbbb7d6f,
    ATTR_PROC_INT_NVPG_BAR_RANGE                                   = 0x343de3b,
    ATTR_PROC_INT_NVC_BAR_ENABLE                                   = 0x0f7ac8a,
    ATTR_PROC_INT_NVC_BAR_PAGE_SIZE                                = 0xc658f74,
    ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET                         = 0x18ba600,
    ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR                    = 0xb25cde0,
    ATTR_PROC_INT_NVC_BAR_RANGE                                    = 0x570ac35,
    ATTR_I2C_DEV_TYPE                                              = 0x177f39f,
    ATTR_I2C_SUB_POS                                               = 0x77c5cd3,
    ATTR_FAPI_POS                                                  = 0x80817dc,
    ATTR_BUS_POS                                                   = 0x506af1e,
    ATTR_IS_SIMULATION                                             = 0x4367508,
    ATTR_EXECUTION_PLATFORM                                        = 0x6134e50,
    ATTR_MFG_FLAGS                                                 = 0x2f0f359,
    ATTR_RECONFIGURE_LOOP                                          = 0x1b589a0,
    ATTR_MINI_EC                                                   = 0xb630402,
    ATTR_SCAN_CHIPLET_OVERRIDE                                     = 0xe802bb9,
    ATTR_SLOW_MEM_POOL_TEST                                        = 0x62195c1,
    ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL                          = 0xb36fcfa,
    ATTR_MSS_OCMB_HALF_DIMM_MODE                                   = 0x1a9b1f1,
    ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE                          = 0x5a56a24,
    ATTR_MEM_DRAM_CWL                                              = 0x641d0e3,
    ATTR_MEM_RDIMM_BUFFER_DELAY                                    = 0x8b58e8c,
    ATTR_MEM_REORDER_QUEUE_SETTING                                 = 0x6a83eea,
    ATTR_MEM_THERMAL_INIT_COMPLETE                                 = 0xb8d2a23,
    ATTR_MEM_2N_MODE                                               = 0x85b98d6,
    ATTR_MEM_VPD_DQ_MAP                                            = 0x552f904,
    ATTR_MEM_DIMM_DDR4_F0RC0F                                      = 0x32c01e3,
    ATTR_MEM_CS_CMD_LATENCY                                        = 0x92fced8,
    ATTR_MEM_CA_PARITY_LATENCY                                     = 0xea74580,
    ATTR_MEM_DIMM_DDR4_F0RC02                                      = 0x8ecc32e,
    ATTR_MEM_DIMM_DDR4_F0RC03                                      = 0xd82c5bd,
    ATTR_MEM_DIMM_DDR4_F0RC04                                      = 0x5921342,
    ATTR_MEM_DIMM_DDR4_F0RC05                                      = 0x50ba16b,
    ATTR_MEM_DIMM_DDR4_F0RC0B                                      = 0xe153bec,
    ATTR_MEM_DIMM_DDR4_F0RC1X                                      = 0xedc754f,
    ATTR_MEM_DIMM_DDR4_F0RC7X                                      = 0xbdd1f8c,
    ATTR_MEM_DIMM_DDR4_F1RC00                                      = 0x93af940,
    ATTR_MEM_DIMM_DDR4_F1RC02                                      = 0x107988d,
    ATTR_MEM_DIMM_DDR4_F1RC03                                      = 0x3f4dd16,
    ATTR_MEM_DIMM_DDR4_F1RC04                                      = 0x1dabb0c,
    ATTR_MEM_DIMM_DDR4_F1RC05                                      = 0xc46febc,
    ATTR_MEM_DIMM_POS_METADATA                                     = 0xb5623a6,
    ATTR_MEM_DRAM_GEN_METADATA                                     = 0x856b84d,
    ATTR_MEM_DIMM_TYPE_METADATA                                    = 0x0ec17cd,
    ATTR_MSS_OMI_EDPL_DISABLE                                      = 0x8990bb0,
    ATTR_MEM_OVERRIDE_FREQ_LIMITATION                              = 0xa0cb35b,
    ATTR_MEM_IGNORE_PLUG_RULES                                     = 0x4a72e5b,
    ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX                       = 0x8ec531c,
    ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX                     = 0xe756f73,
    ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK                       = 0x8b4f3ef,
    ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION                   = 0x1e53923,
    ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED                        = 0x703fb93,
    ATTR_OMI_X4_DEGRADE_ACTION                                     = 0x6992256,
    ATTR_OMI_CRC_DEBUG                                             = 0x6c0c2a9,
    ATTR_ENABLE_FIR_UNMASKING                                      = 0x39e6bbf,
    ATTR_MSS_IS_APOLLO                                             = 0x3c26b28,
    ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST                            = 0x5d966f9,
    ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR              = 0x5ed4258,
    ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL                            = 0xb5c4f8b,
    ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE                             = 0x203d77f,
    ATTR_MSS_OCMB_RECOV_OBJ_HANDLE                                 = 0xa432982,
    ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE                              = 0x09d1306,
    ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE                               = 0x448c629,
    ATTR_MEM_DRAM_ADDRESS_MIRRORING                                = 0x5cdae1e,
    ATTR_ECS_ERROR_COUNT_THRESHOLD                                 = 0x83950cf,
    ATTR_MSS_CONFIG_FREQ_LIMIT                                     = 0x8f2556b,
    ATTR_MSS_OMI_VDD_UPLIFT_APPLIED                                = 0x0157499,
    ATTR_MEM_SI_SIGNATURE_HASH                                     = 0x892eeb6,
    ATTR_MEM_SI_DIMM_RCD_IBT_CA                                    = 0xb0328d5,
    ATTR_MEM_SI_DIMM_RCD_IBT_CKE                                   = 0xaf98ef4,
    ATTR_MEM_SI_DIMM_RCD_IBT_CS                                    = 0xedd201c,
    ATTR_MEM_SI_DIMM_RCD_IBT_ODT                                   = 0xe7f65d8,
    ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS                                = 0xc68f5ea,
    ATTR_MEM_SI_DRAM_PREAMBLE                                      = 0x3b00047,
    ATTR_MEM_SI_DRAM_RTT_NOM                                       = 0x9238d54,
    ATTR_MEM_SI_DRAM_RTT_PARK                                      = 0x183c3a9,
    ATTR_MEM_SI_DRAM_RTT_WR                                        = 0xc20758d,
    ATTR_MEM_SI_GEARDOWN_MODE                                      = 0x9641a9b,
    ATTR_MEM_SI_MC_DRV_DQ_DQS                                      = 0x6040956,
    ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS                                   = 0xd969845,
    ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS                                   = 0x486d205,
    ATTR_MEM_SI_PHY_EQUALIZATION                                   = 0xf908b6e,
    ATTR_MEM_SI_MC_DRV_IMP_CLK                                     = 0x6ed9642,
    ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR                                = 0x98551c7,
    ATTR_MEM_SI_MC_DRV_IMP_CNTL                                    = 0x2e199fe,
    ATTR_MEM_SI_MC_DRV_IMP_CSCID                                   = 0x4354d61,
    ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN                        = 0x9688fe1,
    ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP                          = 0x22941b3,
    ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK                               = 0x2d6153f,
    ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR                          = 0x3371dc2,
    ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL                              = 0x944866d,
    ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID                             = 0x0202f28,
    ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS                            = 0xc3b3e7b,
    ATTR_MEM_SI_MC_RCV_IMP_ALERT_N                                 = 0x55a8aba,
    ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS                                  = 0x164477a,
    ATTR_MEM_SI_ODT_RD                                             = 0x6de3ae5,
    ATTR_MEM_SI_ODT_WR                                             = 0x71a31ad,
    ATTR_MEM_SI_VREF_DRAM_WR                                       = 0xd09f4f3,
    ATTR_MEM_SI_VREF_MC_RD                                         = 0x9cc78b8,
    ATTR_MEM_SI_WINDAGE_RD_CTR                                     = 0x048d1a2,
    ATTR_MEM_DIMM_DDR4_F1RC1X                                      = 0xa411747,
    ATTR_MEM_DIMM_DDR4_F1RC2X                                      = 0xbea907f,
    ATTR_MEM_DIMM_DDR4_F1RC3X                                      = 0xaa68a22,
    ATTR_MEM_DIMM_DDR4_F1RC4X                                      = 0xd415c67,
    ATTR_MEM_DIMM_DDR4_F1RC5X                                      = 0x314253a,
    ATTR_MEM_DIMM_DDR4_F1RC6X                                      = 0xcd35acb,
    ATTR_MEM_DIMM_DDR4_F1RC7X                                      = 0xcea118a,
    ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP                         = 0xa611583,
    ATTR_MEM_BURST_LENGTH                                          = 0x62e05e5,
    ATTR_MEM_MPSM                                                  = 0x28f86dd,
    ATTR_MEM_CS_ASSERT_IN_MPC                                      = 0x11db9be,
    ATTR_MEM_DEVICE15_MPSM                                         = 0xb07c927,
    ATTR_MEM_INTERNAL_WR_TIMING_MODE                               = 0x97bb3e7,
    ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT                           = 0x137d006,
    ATTR_MEM_REF_INTERVAL_RATE_INDIC                               = 0x231c430,
    ATTR_MEM_DDR5_MIN_REF_RATE                                     = 0x16ed83e,
    ATTR_MEM_REF_WIDE_RANGE                                        = 0x98a084e,
    ATTR_MEM_DDR5_REF_TUF                                          = 0x40202e1,
    ATTR_DRAM_PU_DRV_IMP                                           = 0x9a0cac6,
    ATTR_DDR5_DRAM_TEST_MODE                                       = 0x84f709a,
    ATTR_DRAM_PD_DRV_IMP                                           = 0x70d1f95,
    ATTR_DDR5_DRAM_RD_PREAMBLE                                     = 0x313a22a,
    ATTR_DDR5_DRAM_WR_PREAMBLE                                     = 0x58e0f72,
    ATTR_DDR5_DRAM_RD_POSTAMBLE                                    = 0x52f654c,
    ATTR_DDR5_DRAM_WR_POSTAMBLE                                    = 0x8dfd2fd,
    ATTR_DDR5_DRAM_WR_VREFDQ                                       = 0x399d463,
    ATTR_DDR5_DRAM_VREFCA                                          = 0xc18c43e,
    ATTR_DDR5_DRAM_VREFCS                                          = 0x8ffa8f1,
    ATTR_DDR5_DRAM_ECS_MODE                                        = 0x46304b2,
    ATTR_DDR5_DRAM_ECS_RESET_COUNTER                               = 0x05c88c6,
    ATTR_DDR5_DRAM_ECS_COUNT_MODE                                  = 0x58a1971,
    ATTR_DDR5_DRAM_ECS_SRANK_SELECT                                = 0x05d46e3,
    ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT                             = 0x85c31e5,
    ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH                             = 0xc6d6b45,
    ATTR_DDR5_DRAM_ECS_WRITEBACK                                   = 0xadddfcd,
    ATTR_DDR5_DRAM_ECS_X4_WRITES                                   = 0x5eb10a7,
    ATTR_DDR5_DRAM_CK_ODT                                          = 0xb0c96e5,
    ATTR_DDR5_DRAM_CS_ODT                                          = 0x4447a44,
    ATTR_DDR5_DRAM_CK_ODT_PER_DRAM                                 = 0xb20c6e2,
    ATTR_DDR5_DRAM_CS_ODT_PER_DRAM                                 = 0x1f722ba,
    ATTR_DDR5_DRAM_CA_ODT                                          = 0x7fe3065,
    ATTR_DDR5_DRAM_DQS_RTT_PARK                                    = 0xed4f5de,
    ATTR_DDR5_DRAM_CA_ODT_PER_DRAM                                 = 0x27a866f,
    ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM                           = 0x18d5136,
    ATTR_DDR5_DRAM_RTT_WR                                          = 0x159dbfd,
    ATTR_DDR5_DRAM_RTT_PARK                                        = 0x9c05f84,
    ATTR_DDR5_DRAM_RTT_NOM_WR                                      = 0x8dc9d7c,
    ATTR_DDR5_DRAM_RTT_NOM_RD                                      = 0xa42690f,
    ATTR_DDR5_DRAM_ODTLON_WR                                       = 0x16e4587,
    ATTR_DDR5_DRAM_ODTLOFF_WR                                      = 0x7b28a16,
    ATTR_DDR5_DRAM_ODTLON_WR_NT                                    = 0x949ac11,
    ATTR_DDR5_DRAM_ODTLOFF_WR_NT                                   = 0x295e3af,
    ATTR_DDR5_DRAM_ODTLON_RD_NT                                    = 0x263ef7e,
    ATTR_DDR5_DRAM_ODTLOFF_RD_NT                                   = 0xc60a499,
    ATTR_MEM_DDR5_WR_CRC_ERR_STATUS                                = 0xa232f81,
    ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE                        = 0xdf06b22,
    ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS                        = 0x66df8b2,
    ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD                     = 0xb9adbfd,
    ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW                        = 0x86917a6,
    ATTR_MEM_DDR5_GLOBAL_DFE_GAIN                                  = 0xe30fb00,
    ATTR_MEM_DDR5_GLOBAL_DFE_TAP1                                  = 0x4c3e08d,
    ATTR_MEM_DDR5_GLOBAL_DFE_TAP2                                  = 0xde7bca9,
    ATTR_MEM_DDR5_GLOBAL_DFE_TAP3                                  = 0xb1d0a53,
    ATTR_MEM_DDR5_GLOBAL_DFE_TAP4                                  = 0x465e7ca,
    ATTR_MEM_DDR5_DFE_GAIN_BIAS                                    = 0x04e2520,
    ATTR_MEM_DDR5_DFE_SIGN_BIT                                     = 0xdceaabb,
    ATTR_MEM_EFF_DRAM_GEN                                          = 0x9cf4fc4,
    ATTR_MEM_EFF_DIMM_TYPE                                         = 0xe3b5b79,
    ATTR_MEM_EFF_HYBRID_MEMORY_TYPE                                = 0xc08f9e2,
    ATTR_MEM_EFF_HYBRID                                            = 0x6cd872a,
    ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO                           = 0x9f7bd88,
    ATTR_MEM_EFF_DRAM_DENSITY                                      = 0x956902a,
    ATTR_MEM_EFF_DRAM_BANK_BITS                                    = 0x9ebf155,
    ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS                              = 0xc9dddb2,
    ATTR_MEM_EFF_DRAM_COLUMN_BITS                                  = 0x420ee16,
    ATTR_MEM_EFF_DRAM_ROW_BITS                                     = 0xdc339a7,
    ATTR_MEM_EFF_PRIM_DIE_COUNT                                    = 0xc278ed9,
    ATTR_MEM_EFF_PRIM_STACK_TYPE                                   = 0x888c903,
    ATTR_MEM_EFF_PRIM_BUS_WIDTH                                    = 0x5176174,
    ATTR_MEM_EFF_CHANNELS_PER_DIMM                                 = 0x7ac0e9a,
    ATTR_MEM_EFF_DRAM_PPR                                          = 0xb728460,
    ATTR_MEM_EFF_DRAM_SOFT_PPR                                     = 0x47d766c,
    ATTR_MEM_EFF_DRAM_TRCD                                         = 0x2d75ccd,
    ATTR_MEM_EFF_DRAM_TRP                                          = 0xdfbd498,
    ATTR_MEM_EFF_DRAM_TRAS                                         = 0xa147b1c,
    ATTR_MEM_EFF_DRAM_TRC                                          = 0xa31ee72,
    ATTR_MEM_EFF_DRAM_TRFC                                         = 0x2239266,
    ATTR_MEM_EFF_DRAM_TFAW                                         = 0xdf2b36c,
    ATTR_MEM_EFF_DRAM_TRRD_S                                       = 0xab82746,
    ATTR_MEM_EFF_DRAM_TRRD_L                                       = 0x63e1613,
    ATTR_MEM_EFF_DRAM_TRRD_DLR                                     = 0xf517753,
    ATTR_MEM_EFF_DRAM_TCCD_L                                       = 0x2b8523d,
    ATTR_MEM_EFF_DRAM_TCCD_L_WR                                    = 0xa1bd115,
    ATTR_MEM_EFF_DRAM_TWR                                          = 0x9dcade3,
    ATTR_MEM_EFF_DRAM_TWTR_S                                       = 0xcd0fc4e,
    ATTR_MEM_EFF_DRAM_TWTR_L                                       = 0x68ccec0,
    ATTR_MEM_EFF_DRAM_TMAW                                         = 0xa6c89f0,
    ATTR_MEM_EFF_DRAM_WIDTH                                        = 0x41415b6,
    ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM                            = 0xda95638,
    ATTR_MEM_3DS_HEIGHT                                            = 0x3f6b102,
    ATTR_MEM_EFF_REGISTER_TYPE                                     = 0x0b4a2fc,
    ATTR_MEM_EFF_MODULE_MFG_ID                                     = 0xc5bf44b,
    ATTR_MEM_EFF_DRAM_MFG_ID                                       = 0xc11b0c7,
    ATTR_MEM_EFF_DRAM_MODULE_HEIGHT                                = 0x2d07bed,
    ATTR_MEM_EFF_RCD_MFG_ID                                        = 0x603ef87,
    ATTR_MEM_EFF_REGISTER_REV                                      = 0xed9e25a,
    ATTR_MEM_EFF_PACKAGE_RANK_MAP                                  = 0xb28a8fb,
    ATTR_MEM_EFF_NIBBLE_MAP                                        = 0x6e3d1bf,
    ATTR_MEM_EFF_DIMM_SIZE                                         = 0xebd258e,
    ATTR_MEM_EFF_DIMM_SPARE                                        = 0x7631332,
    ATTR_MEM_EFF_DRAM_CL                                           = 0x268a991,
    ATTR_MEM_EFF_DRAM_MDS                                          = 0x68400ca,
    ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM                         = 0x0b12e9e,
    ATTR_MEM_EFF_DIMM_RANKS_CONFIGED                               = 0x486f50e,
    ATTR_MEM_EFF_DRAM_TREFI                                        = 0x95ec877,
    ATTR_MEM_EFF_DRAM_TRTP                                         = 0xa970ba4,
    ATTR_MEM_EFF_DRAM_TRFC_DLR                                     = 0x669e8d5,
    ATTR_MEM_EFF_FREQ                                              = 0x08a4518,
    ATTR_MEM_EFF_VOLT_VDDR                                         = 0xc406bf3,
    ATTR_MEM_EFF_VOLT_VDDQ                                         = 0x5e0f70a,
    ATTR_MEM_EFF_VOLT_VPP                                          = 0xbd8bf3c,
    ATTR_MEM_EFF_SPD_REVISION                                      = 0xd3704fd,
    ATTR_MEM_EFF_SPD_CONTENT_REVISION                              = 0x8e2a2e3,
    ATTR_MEM_EFF_SUPPORTED_RCD                                     = 0x12aa7fd,
    ATTR_MEM_EFF_BYTE_ENABLES                                      = 0x9c16ebb,
    ATTR_MEM_EFF_NIBBLE_ENABLES                                    = 0x5893c69,
    ATTR_MEM_EFF_Z_MODE                                            = 0xdcfdaa2,
    ATTR_MEM_EFF_DIMM_SERIAL_NUMBER                                = 0x4ea37f9,
    ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN                    = 0x34c35e2,
    ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION                     = 0xa8c5e49,
    ATTR_MEM_EFF_MODULE_THERMAL_SENSORS                            = 0xcfe5811,
    ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL                              = 0x8032442,
    ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL                       = 0x1a17aae,
    ATTR_MEM_EFF_THERM_SENSOR_0_TYPE                               = 0xef60a38,
    ATTR_MEM_EFF_THERM_SENSOR_0_USAGE                              = 0xb1987de,
    ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR                           = 0xc17a0dc,
    ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL                              = 0x72f340b,
    ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL                       = 0xc593c05,
    ATTR_MEM_EFF_THERM_SENSOR_1_TYPE                               = 0xc3f35bf,
    ATTR_MEM_EFF_THERM_SENSOR_1_USAGE                              = 0xf21023b,
    ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR                           = 0x38feb73,
    ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL                              = 0x8072646,
    ATTR_MEM_EFF_THERM_SENSOR_2_TYPE                               = 0xaa2e048,
    ATTR_MEM_EFF_THERM_SENSOR_2_USAGE                              = 0x0bf05d1,
    ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR                           = 0xdaf3379,
    ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL                              = 0x7130751,
    ATTR_MEM_EFF_THERM_SENSOR_3_TYPE                               = 0xfefe6c5,
    ATTR_MEM_EFF_THERM_SENSOR_3_USAGE                              = 0xc070edb,
    ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR                           = 0xa7fc90e,
    ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL                           = 0x0b14185,
    ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE                            = 0xa99637f,
    ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE                           = 0xeda695b,
    ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR                        = 0x079d52d,
    ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR                    = 0x3e8c6de,
    ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR                    = 0xdded48e,
    ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION                    = 0xde03ed3,
    ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION                    = 0x4028ad3,
    ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION                           = 0x856b2c4,
    ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION                           = 0xe5bb6b4,
    ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION                           = 0xf3d0e4c,
    ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION                           = 0x23e3fd9,
    ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE                        = 0x6e979d7,
    ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT                     = 0x3712d9f,
    ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT                     = 0x46af527,
    ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT             = 0x2e988c0,
    ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT             = 0xd9a9f4f,
    ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT                     = 0x97d528f,
    ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT                     = 0x198c24a,
    ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT             = 0xda376c3,
    ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT             = 0x0ad06df,
    ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT            = 0x2dd7524,
    ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS                             = 0x2ab46d8,
    ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE                         = 0x7c84367,
    ATTR_EXP_MEM_WATT_TARGET                                       = 0xddd3f7e,
    ATTR_EXP_TOTAL_PWR_SLOPE                                       = 0x071500e,
    ATTR_EXP_TOTAL_PWR_INTERCEPT                                   = 0xb50fc28,
    ATTR_EXP_PORT_MAXPOWER                                         = 0x7606944,
    ATTR_EXP_DIMM_THERMAL_LIMIT                                    = 0x3f2ddb0,
    ATTR_MEM_MRW_IS_PLANAR                                         = 0x8fe48a2,
    ATTR_MSS_MRW_CONFIG_FREQ_LIMIT                                 = 0x7d6c44c,
    ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT        = 0x5fd9713,
    ATTR_MSS_MRW_PWR_INTERCEPT                                     = 0xc0f9335,
    ATTR_MSS_MRW_PWR_SLOPE                                         = 0xb3e8ad9,
    ATTR_MSS_MRW_REFRESH_RATE_REQUEST                              = 0xbd13798,
    ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT                   = 0xd4bbddc,
    ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE              = 0x07bf802,
    ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS                                 = 0x0fb9e1f,
    ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL                             = 0x61d3421,
    ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL                        = 0x6cba771,
    ATTR_MSS_MRW_POWER_CONTROL_REQUESTED                           = 0x6d05234,
    ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED                      = 0x7f51090,
    ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE    = 0xe5e91b7,
    ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3       = 0x1949903,
    ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4       = 0x414abdc,
    ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR      = 0x3e06dcd,
    ATTR_MSS_MRW_AVDD_OFFSET_ENABLE                                = 0xfc9bdd9,
    ATTR_MSS_MRW_VDD_OFFSET_ENABLE                                 = 0xc62f1ae,
    ATTR_MSS_MRW_VCS_OFFSET_ENABLE                                 = 0xa15fc01,
    ATTR_MSS_MRW_VPP_OFFSET_ENABLE                                 = 0xf844545,
    ATTR_MSS_MRW_VDDR_OFFSET_ENABLE                                = 0xd7f8bcd,
    ATTR_MSS_MRW_FINE_REFRESH_MODE                                 = 0x87bdfb9,
    ATTR_MSS_MRW_TEMP_REFRESH_RANGE                                = 0x99f7795,
    ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL                            = 0x4f60a5e,
    ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS                      = 0x9c3a3d6,
    ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS                       = 0x1fddb6b,
    ATTR_MSS_MRW_DRAM_2N_MODE                                      = 0x2997eae,
    ATTR_MSS_MRW_DRAM_WRITE_CRC                                    = 0x7b7fc78,
    ATTR_MSS_MRW_DDR5_DRAM_READ_CRC                                = 0x452cbf0,
    ATTR_MSS_MRW_TEMP_REFRESH_MODE                                 = 0x4c3dbf1,
    ATTR_MSS_MRW_FORCE_BCMODE_OFF                                  = 0x86bad95,
    ATTR_MSS_MRW_NVDIMM_PLUG_RULES                                 = 0x424be69,
    ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW                             = 0x40bfda4,
    ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH                              = 0x72e61a8,
    ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT                   = 0x948b8b8,
    ATTR_MSS_MRW_OCMB_PWR_SLOPE                                    = 0xbc51273,
    ATTR_MSS_MRW_OCMB_PWR_INTERCEPT                                = 0x5c0af49,
    ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT                     = 0xafeb5ce,
    ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL                        = 0x2b5f6b7,
    ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD                     = 0x2b742a3,
    ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW                                 = 0x939f9be,
    ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE                             = 0x6b341e3,
    ATTR_MSS_MRW_OCMB_RESET_GROUP                                  = 0x464339e,
    ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY                         = 0x9f5b11a,
    ATTR_MSS_MRW_SUPPORTED_FREQ                                    = 0x23d66fa,
    ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT                        = 0xbe06c50,
    ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE                       = 0x3d77935,
    ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY                          = 0x2e9bbeb,
    ATTR_MSS_MRW_ALLOW_DDR5                                        = 0x4d2d908,
    ATTR_MRW_MAX_DDR_FREQ_PER_SLOT                                 = 0x8a18c2a,
    ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF   = 0x7dfffde,
    ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME                         = 0xf278a76,
    ATTR_MSS_MRW_ENTER_STR_TIME                                    = 0xd3b25a9,
    ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME             = 0x3f8999b,
    ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME                        = 0xc4be99d,
    ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM                                 = 0xa7b26cf,
    ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ                              = 0x7a1246a,
    ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ                              = 0x3cf621f,
    ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC                              = 0x169e135,
    ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC                              = 0xf349c89,
    ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK                              = 0x11b28b1,
    ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK                              = 0x3322c7e,
    ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0                         = 0x45769cb,
    ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1                         = 0x1737151,
    ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN                            = 0xbe9c5f4,
    ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0                            = 0x5cf9d4a,
    ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1                            = 0x483910a,
    ATTR_DDR5_TX_DM_PREAMBLE_PATTERN                               = 0x2925ef3,
    ATTR_MEM_EFF_REDUNDANT_CS_EN                                   = 0x987618b,
    ATTR_MEM_EFF_DDR5_RXEN_ADJ                                     = 0xde075fd,
    ATTR_MEM_EFF_DDR5_WL_ADJ_START                                 = 0x812d582,
    ATTR_MEM_EFF_DDR5_WL_ADJ_END                                   = 0x9dc1f05,
    ATTR_MEM_EFF_DDR5_PHY_VREF_RD                                  = 0x10c8327,
    ATTR_MEM_EFF_DDR5_RTT_PARK_RD                                  = 0x8b1986a,
    ATTR_MEM_EFF_DDR5_RTT_PARK_WR                                  = 0x5e7cb0a,
    ATTR_MEM_DDR5_SPD_CL_SUPPORTED                                 = 0xf669530,
    ATTR_MEM_EFF_DDR5_CHB_ACTIVE                                   = 0x82b8963,
    ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE                              = 0xbe0602d,
    ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH                            = 0x16d0d5a,
    ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN                             = 0x94d33d8,
    ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX                             = 0x158bb98,
    ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN                             = 0x01a8fc7,
    ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX                             = 0xe9d04d7,
    ATTR_RCW00_CHA_D0                                              = 0x44451f9,
    ATTR_RCW01_CHA_D0                                              = 0xb3b1e66,
    ATTR_RCW05_CHA_D0                                              = 0x7249ab4,
    ATTR_RCW08_CHA_D0                                              = 0xf169a2b,
    ATTR_RCW09_CHA_D0                                              = 0x34e5f5b,
    ATTR_RCW0A_CHA_D0                                              = 0x47770b9,
    ATTR_RCW0C_CHA_D0                                              = 0x4cb206d,
    ATTR_RCW0D_CHA_D0                                              = 0x5450c2f,
    ATTR_RCW0E_CHA_D0                                              = 0x6937db7,
    ATTR_RCW0F_CHA_D0                                              = 0x3e10c4b,
    ATTR_RCW40_CHA_D0                                              = 0xc11d96f,
    ATTR_RCW41_CHA_D0                                              = 0xe3db688,
    ATTR_RCW42_CHA_D0                                              = 0x9dd54f3,
    ATTR_RCW43_CHA_D0                                              = 0xed9fafb,
    ATTR_RCW44_CHA_D0                                              = 0xca20b66,
    ATTR_RCW45_CHA_D0                                              = 0x2af1514,
    ATTR_RCW46_CHA_D0                                              = 0x42aac82,
    ATTR_RCW47_CHA_D0                                              = 0xc2163fb,
    ATTR_RCW48_CHA_D0                                              = 0xa799fe9,
    ATTR_RCW49_CHA_D0                                              = 0xe79bdaf,
    ATTR_RCW00_CHA_D1                                              = 0xd7ed561,
    ATTR_RCW01_CHA_D1                                              = 0x0577bb4,
    ATTR_RCW05_CHA_D1                                              = 0xad8dd9f,
    ATTR_RCW08_CHA_D1                                              = 0xdf28a49,
    ATTR_RCW09_CHA_D1                                              = 0xaf7ed15,
    ATTR_RCW0A_CHA_D1                                              = 0xaf0a215,
    ATTR_RCW0C_CHA_D1                                              = 0x52aba1a,
    ATTR_RCW0D_CHA_D1                                              = 0x24dbd79,
    ATTR_RCW0E_CHA_D1                                              = 0xda1809c,
    ATTR_RCW0F_CHA_D1                                              = 0x033b23b,
    ATTR_RCW40_CHA_D1                                              = 0x90b16d2,
    ATTR_RCW41_CHA_D1                                              = 0xe9c4920,
    ATTR_RCW42_CHA_D1                                              = 0x21371e3,
    ATTR_RCW43_CHA_D1                                              = 0x671128a,
    ATTR_RCW44_CHA_D1                                              = 0x18ee29e,
    ATTR_RCW45_CHA_D1                                              = 0xf9e5235,
    ATTR_RCW46_CHA_D1                                              = 0x5d2467e,
    ATTR_RCW47_CHA_D1                                              = 0x9711cca,
    ATTR_RCW48_CHA_D1                                              = 0xdf5ac38,
    ATTR_RCW49_CHA_D1                                              = 0x63d094c,
    ATTR_RCW00_CHB_D0                                              = 0x913e3f3,
    ATTR_RCW01_CHB_D0                                              = 0x4b65c7e,
    ATTR_RCW05_CHB_D0                                              = 0xd304550,
    ATTR_RCW08_CHB_D0                                              = 0x4c3b83c,
    ATTR_RCW09_CHB_D0                                              = 0xe63e435,
    ATTR_RCW0A_CHB_D0                                              = 0xed8a03a,
    ATTR_RCW0C_CHB_D0                                              = 0x7b5c8b8,
    ATTR_RCW0D_CHB_D0                                              = 0xbfa8f5f,
    ATTR_RCW0E_CHB_D0                                              = 0xb3d7076,
    ATTR_RCW0F_CHB_D0                                              = 0x7f0a438,
    ATTR_RCW40_CHB_D0                                              = 0x5ced586,
    ATTR_RCW41_CHB_D0                                              = 0x9b2f9cf,
    ATTR_RCW42_CHB_D0                                              = 0x68c895f,
    ATTR_RCW43_CHB_D0                                              = 0x9ce2145,
    ATTR_RCW44_CHB_D0                                              = 0x81d308e,
    ATTR_RCW45_CHB_D0                                              = 0xd0b06da,
    ATTR_RCW46_CHB_D0                                              = 0x77ae7b1,
    ATTR_RCW47_CHB_D0                                              = 0x0a708ad,
    ATTR_RCW48_CHB_D0                                              = 0xea75a30,
    ATTR_RCW49_CHB_D0                                              = 0xeb40b74,
    ATTR_RCW00_CHB_D1                                              = 0x762c08b,
    ATTR_RCW01_CHB_D1                                              = 0xec7753d,
    ATTR_RCW05_CHB_D1                                              = 0x174a2ca,
    ATTR_RCW08_CHB_D1                                              = 0x999e613,
    ATTR_RCW09_CHB_D1                                              = 0xd07262c,
    ATTR_RCW0A_CHB_D1                                              = 0xdb3e968,
    ATTR_RCW0C_CHB_D1                                              = 0xec66ecd,
    ATTR_RCW0D_CHB_D1                                              = 0xaa8cfef,
    ATTR_RCW0E_CHB_D1                                              = 0x7fffb1b,
    ATTR_RCW0F_CHB_D1                                              = 0x2751df0,
    ATTR_RCW40_CHB_D1                                              = 0x0a9ad3f,
    ATTR_RCW41_CHB_D1                                              = 0x1e33fa9,
    ATTR_RCW42_CHB_D1                                              = 0x683ae9e,
    ATTR_RCW43_CHB_D1                                              = 0x6485e5d,
    ATTR_RCW44_CHB_D1                                              = 0x392c87c,
    ATTR_RCW45_CHB_D1                                              = 0x446e9d5,
    ATTR_RCW46_CHB_D1                                              = 0xf84a889,
    ATTR_RCW47_CHB_D1                                              = 0xde00084,
    ATTR_RCW48_CHB_D1                                              = 0x3e06229,
    ATTR_RCW49_CHB_D1                                              = 0x2ff4978,
    ATTR_EXPLR_ENABLE_US_TMPL_1                                    = 0x73cc90f,
    ATTR_EXPLR_ENABLE_US_TMPL_5                                    = 0x1865b64,
    ATTR_EXPLR_ENABLE_US_TMPL_9                                    = 0x50892df,
    ATTR_EXPLR_ENABLE_US_TMPL_A                                    = 0x8063772,
    ATTR_EXPLR_ENABLE_US_TMPL_B                                    = 0x0025f83,
    ATTR_EXPLR_TMPL_0_PACING                                       = 0x69ce066,
    ATTR_EXPLR_TMPL_1_PACING                                       = 0xde60dc4,
    ATTR_EXPLR_TMPL_5_PACING                                       = 0x0fd5c68,
    ATTR_EXPLR_TMPL_9_PACING                                       = 0x69fbe43,
    ATTR_EXPLR_TMPL_B_PACING                                       = 0x19bf475,
    ATTR_EXPLR_SHRT_BACKOFF_TIMER                                  = 0x1d2e7e8,
    ATTR_EXPLR_METADATA_ENABLE                                     = 0x47688d7,
    ATTR_EXPLR_PASID_BASE                                          = 0x515fe7b,
    ATTR_EXPLR_ACTAG_BASE                                          = 0x9a283f7,
    ATTR_EXPLR_AFU_ACTAG_LEN                                       = 0xe6f5561,
    ATTR_EXPLR_PASID_LEN                                           = 0xd3a4b37,
    ATTR_IS_IBM_SIMULATION                                         = 0x025f142,
    ATTR_MSS_OCMB_ENTERPRISE_MODE                                  = 0x326e0e2,
    ATTR_MSS_OCMB_ENTERPRISE_POLICY                                = 0x82cf1be,
    ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE                      = 0x4d84e76,
    ATTR_MEM_EXP_INIT_VREF_DQ                                      = 0xba62227,
    ATTR_MEM_EXP_INIT_PHY_VREF                                     = 0x5a2ffe9,
    ATTR_MEM_EXP_RCD_DIC                                           = 0x17dbf79,
    ATTR_MEM_EXP_RCD_VOLTAGE_CTRL                                  = 0x27bb801,
    ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING                            = 0x615ada9,
    ATTR_MEM_EXP_RCD_SLEW_RATE                                     = 0xae13b85,
    ATTR_MEM_EXP_SPD_CL_SUPPORTED                                  = 0x70d4d6d,
    ATTR_MEM_EXP_SPD_TAA_MIN                                       = 0xb52fb82,
    ATTR_MSS_EXP_REORDER_QUEUE_SETTING                             = 0x413ef1d,
    ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE                           = 0xc4230d1,
    ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL                      = 0x2851ca1,
    ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN                                = 0xb88d1cf,
    ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP                        = 0x00ea92e,
    ATTR_MSS_OCMB_ECID                                             = 0x96b7c4b,
    ATTR_MEM_EXP_DFIMRL_CLK                                        = 0xe3a87c3,
    ATTR_MEM_EFF_ATXDLY_A                                          = 0xd3dcb59,
    ATTR_MEM_EFF_ATXDLY_B                                          = 0x8d11dd8,
    ATTR_MSS_OCMB_PHY_INIT_MODE                                    = 0x423512e,
    ATTR_MSS_CHECK_FOR_READY_TIMEOUT                               = 0xc470648,
    ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ                          = 0xc87684a,
    ATTR_MSS_EXP_FW_API_VERSION                                    = 0x08765f3,
    ATTR_MSS_EXP_FW_VERSION_A                                      = 0x38a9ed0,
    ATTR_MSS_EXP_FW_VERSION_B                                      = 0x32ff12d,
    ATTR_MSS_EXP_FW_PARTITION_ID                                   = 0x9604985,
    ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A                        = 0xe31e711,
    ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B                        = 0xf21ca17,
    ATTR_MSS_EXP_COMM_STATE                                        = 0xc4be98e,
    ATTR_MSS_EXP_RESP_DDR4_F0RC00                                  = 0x53e9209,
    ATTR_MSS_EXP_RESP_DDR4_F0RC01                                  = 0xcced88f,
    ATTR_MSS_EXP_RESP_DDR4_F0RC03                                  = 0x69f97d1,
    ATTR_MSS_EXP_RESP_DDR4_F0RC04                                  = 0x8560487,
    ATTR_MSS_EXP_RESP_DDR4_F0RC05                                  = 0x3d3e8d5,
    ATTR_MSS_EXP_RESP_DDR4_F0RC0B                                  = 0x4eb8996,
    ATTR_MSS_EXP_RESP_DDR4_F0RC0E                                  = 0xd5c924a,
    ATTR_MSS_EXP_RESP_DDR4_F0RC0F                                  = 0x8b29691,
    ATTR_MSS_EXP_RESP_DDR4_F0RC1X                                  = 0x07ccc77,
    ATTR_MSS_EXP_RESP_DDR4_F0RC7X                                  = 0x42f81c1,
    ATTR_MSS_EXP_RESP_DDR4_F1RC00                                  = 0x52b38f3,
    ATTR_MSS_EXP_RESP_DDR4_F1RC02                                  = 0x7628329,
    ATTR_MSS_EXP_RESP_DDR4_F1RC03                                  = 0x017bc4f,
    ATTR_MSS_EXP_RESP_DDR4_F1RC04                                  = 0xec99916,
    ATTR_MSS_EXP_RESP_DDR4_F1RC05                                  = 0x9a3213c,
    ATTR_MSS_EXP_RESP_DRAM_RBT                                     = 0x232c72e,
    ATTR_MSS_EXP_RESP_DRAM_TM                                      = 0xe77b99f,
    ATTR_MSS_EXP_RESP_DRAM_DLL_RESET                               = 0x68495bc,
    ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH                            = 0xefe1a41,
    ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE                              = 0x3ca6acc,
    ATTR_MSS_EXP_RESP_DRAM_ODIC                                    = 0xb03f256,
    ATTR_MSS_EXP_RESP_DRAM_AL                                      = 0xaa54450,
    ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE                           = 0x9243579,
    ATTR_MSS_EXP_RESP_DRAM_RTT_NOM                                 = 0x3a53581,
    ATTR_MSS_EXP_RESP_DRAM_RTT_PARK                                = 0xd82d29a,
    ATTR_MSS_EXP_RESP_DRAM_TDQS                                    = 0x747f7a5,
    ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER                           = 0x2df5e4a,
    ATTR_MSS_EXP_RESP_DRAM_LPASR                                   = 0x8046daf,
    ATTR_MSS_EXP_RESP_DRAM_RTT_WR                                  = 0x25683a0,
    ATTR_MSS_EXP_RESP_MPR_PAGE                                     = 0x803a0ef,
    ATTR_MSS_EXP_RESP_MPR_MODE                                     = 0xc9c2d97,
    ATTR_MSS_EXP_RESP_GEARDOWN_MODE                                = 0x1f50813,
    ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS                              = 0x905ce7f,
    ATTR_MSS_EXP_RESP_TEMP_READOUT                                 = 0x5b0aae0,
    ATTR_MSS_EXP_RESP_CRC_WR_LATENCY                               = 0x36f124b,
    ATTR_MSS_EXP_RESP_MPR_RD_FORMAT                                = 0x2fae486,
    ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE                           = 0x3eda036,
    ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR                        = 0x571be23,
    ATTR_MSS_EXP_RESP_SELF_REF_ABORT                               = 0x0cf60f4,
    ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN                            = 0x310948f,
    ATTR_MSS_EXP_RESP_RD_PREAMBLE                                  = 0x36519d8,
    ATTR_MSS_EXP_RESP_WR_PREAMBLE                                  = 0x8ccc316,
    ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR                              = 0xc18acac,
    ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS                       = 0x37e48f5,
    ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF                               = 0x93f2355,
    ATTR_MSS_EXP_RESP_CA_PARITY                                    = 0xd86ab4c,
    ATTR_MSS_EXP_RESP_DATA_MASK                                    = 0xffba6d7,
    ATTR_MSS_EXP_RESP_WRITE_DBI                                    = 0x26a1129,
    ATTR_MSS_EXP_RESP_READ_DBI                                     = 0xc77c618,
    ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE                          = 0x0c63607,
    ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE                          = 0xdfb2703,
    ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE                         = 0xcac6a4c,
    ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE                            = 0xc9b42ea,
    ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE                             = 0xf7bb641,
    ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE                               = 0x501dc5e,
    ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT                              = 0xe8bc6dc,
    ATTR_MSS_EXP_OMI_CDR_OFFSET                                    = 0xebc1836,
    ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK                          = 0x0adf7aa,
    ATTR_MSS_EXP_INTR_MASK_DISABLE                                 = 0xb33ecf6,
    ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE                           = 0x3cedd73,
    ATTR_MSS_EXP_SERIAL_NUMBER                                     = 0x73ade63,
    ATTR_MEM_EFF_PSTATES                                           = 0x365d06b,
    ATTR_MEM_EFF_FOUR_RANK_MODE                                    = 0x6a61fce,
    ATTR_MEM_EFF_MRAM_SUPPORT                                      = 0x3b8b4a9,
    ATTR_MEM_EFF_DDP_COMPATIBILITY                                 = 0x2e48910,
    ATTR_MEM_EFF_TSV_8H_SUPPORT                                    = 0x1dbe9ca,
    ATTR_MEM_EFF_MDS_DDIMM                                         = 0xbec986e,
    ATTR_OMI_DL_PREIPL_PRBS_TIME                                   = 0x42af08e,
    ATTR_EXP_DATABUS_UTIL                                          = 0x1edce66,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE                          = 0x4a69bbd,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST           = 0x4c3ccba,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER                  = 0xd4a3c59,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE               = 0x45764b5,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE                      = 0xa31ec38,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE                        = 0x725d3a6,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY                 = 0x134e3f0,
    ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE                  = 0x7e23d04,
    ATTR_OMI_FFE_SETTINGS_COMMAND                                  = 0xcb9c4fa,
    ATTR_OMI_FFE_PRE_CURSOR                                        = 0xaa4803f,
    ATTR_OMI_FFE_POST_CURSOR                                       = 0x9c878db,
    ATTR_ODY_ENABLE_US_TMPL_1                                      = 0x326c7fd,
    ATTR_ODY_ENABLE_US_TMPL_5                                      = 0xc476bf6,
    ATTR_ODY_ENABLE_US_TMPL_9                                      = 0x0de7e70,
    ATTR_ODY_ENABLE_US_TMPL_A                                      = 0xd94ff32,
    ATTR_ODY_ENABLE_US_TMPL_B                                      = 0xce99337,
    ATTR_ODY_TMPL_0_PACING                                         = 0x3d6c66d,
    ATTR_ODY_TMPL_1_PACING                                         = 0xb6d7403,
    ATTR_ODY_TMPL_5_PACING                                         = 0x8f2a29b,
    ATTR_ODY_TMPL_9_PACING                                         = 0x7adbf9e,
    ATTR_ODY_TMPL_B_PACING                                         = 0x93b353c,
    ATTR_ODY_SHRT_BACKOFF_TIMER                                    = 0xd820de6,
    ATTR_ODY_METADATA_ENABLE                                       = 0xfacac31,
    ATTR_ODY_PASID_BASE                                            = 0x83a8012,
    ATTR_ODY_ACTAG_BASE                                            = 0x5910d31,
    ATTR_ODY_AFU_ACTAG_LEN                                         = 0x7e6967a,
    ATTR_ODY_PASID_LEN                                             = 0xf33f29f,
    ATTR_SPPE_TARGET_STATE                                         = 0xb541170,
    ATTR_SPPE_I2C_DEV_ADDR                                         = 0xd9b9ad9,
    ATTR_SPPE_I2C_ENGINE                                           = 0x841f53b,
    ATTR_SPPE_I2C_PORT                                             = 0xe1c520c,
    ATTR_SPPE_I2C_MAX_RETRY_COUNT                                  = 0x8fec09a,
    ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL                          = 0xaf57fed,
    ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT                             = 0xf620eaa,
    ATTR_MSS_ODY_PHY_IMAGE_SELECT                                  = 0x4aa1c38,
    ATTR_ODY_MSG_BLOCK_DATA_SOURCE                                 = 0x948775e,
    ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE                             = 0x434f057,
    ATTR_ODY_DRAMINIT_RECOVERY_ENABLE                              = 0x0bbbf7b,
    ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE                             = 0x216a1a7,
    ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE                             = 0x789ba7e,
    ATTR_ODY_DRAMINIT_STEP_ENABLE                                  = 0xdadf803,
    ATTR_ODY_SENSOR_POLLING_PERIOD_MS                              = 0xab67f8c,
    ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT                         = 0xe94e26a,
    ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET                         = 0xdbb83fc,
    ATTR_ODY_DQS_TRACKING_PERIOD                                   = 0xded6f91,
    ATTR_ODY_DQS_TRACKING_PERIOD_INIT                              = 0xb436d4f,
    ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD                           = 0xcbf6008,
    ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD                          = 0xcb72894,
    ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL                   = 0x5f877fa,
    ATTR_ODY_DQS_TRACKING_RECAL_COUNT                              = 0xaf60522,
    ATTR_ODY_DQS_TRACKING_LOG                                      = 0xe0cbfed,
    ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE                    = 0xec80f7c,
    ATTR_ODY_DQS_TRACKING_SUSPENDED                                = 0x785ff65,
    ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT                     = 0xdfa0ab1,
    ATTR_ODY_DQS_TRACKING_FAILED                                   = 0xd36e7f1,
    ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE                       = 0x5f4f64d,
    ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE                       = 0xddbc151,
    ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE                       = 0x6cd7f34,
    ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE                       = 0xaadf350,
    ATTR_ODY_SENSOR_READ_FIRST_FAIL                                = 0x10cd9ed,
    ATTR_ODY_DRAMINIT_VERBOSITY                                    = 0x12be307,
    ATTR_PHY_GET_MAIL_TIMEOUT                                      = 0x3952eeb,
    ATTR_DRAMINIT_TRAINING_TIMEOUT                                 = 0xa140a0e,
    ATTR_MAIL_MESSAGE_BITMAP                                       = 0xfafcbf2,
    ATTR_MEM_EFF_ARDPTRINITVAL                                     = 0xcbf1228,
    ATTR_MEM_EFF_ARDPTRINITVALOVR                                  = 0xc784cff,
    ATTR_ODY_DIS_PTRINITCLR_TXTRACKING                             = 0x2b1e162,
    ATTR_MEM_EFF_EXTCALRESVAL                                      = 0x158ad24,
    ATTR_MEM_EFF_MEMALERTEN                                        = 0xcf3611f,
    ATTR_ODY_PHY_MSTRTRAIN_INTERVAL                                = 0xee87648,
    ATTR_ODY_PHY_MSTRMAXREQTOACK                                   = 0x8a5e99e,
    ATTR_ODY_PHY_MSTRCTRLMODE                                      = 0x103f0e0,
    ATTR_ODY_PHY_CALINTERVAL                                       = 0x210fee7,
    ATTR_ODY_PHY_CALONCE                                           = 0x7c07477,
    ATTR_ODY_IS_HIGHVDD                                            = 0x6266c59,
    ATTR_ODY_EN_TDQS2DQ_TRACKING                                   = 0x65a01d5,
    ATTR_ODY_DQS_OSC_RUNTIME_SEL                                   = 0x17ca2c5,
    ATTR_ODY_EN_RXDQS_TRACKING                                     = 0x3f7b7e7,
    ATTR_ODY_DISABLE_PMU_ECC                                       = 0x22ecfb0,
    ATTR_ODY_ENABLE_MALERT_ASYNC                                   = 0x05cbd4d,
    ATTR_ODY_ALERT_RECOV_ENABLE                                    = 0x48dfadb,
    ATTR_ODY_RST_RXTRK_STATE                                       = 0x04bf0c7,
    ATTR_ODY_UPPERNIBBLE_OVERRIDE                                  = 0xdcc378b,
    ATTR_ODY_UPPERNIBBLE_TG                                        = 0xefa25a2,
    ATTR_ODY_DFIPHYUPDCNT                                          = 0xfcea8b7,
    ATTR_ODY_DFIPHYUPDRESP                                         = 0x0b347d3,
    ATTR_ODY_SIM_TDQS2DQ                                           = 0x9fae533,
    ATTR_ODY_SIM_TDQSCK                                            = 0x6b981a7,
    ATTR_ODY_SIM_TSTAOFF                                           = 0x9f8f049,
    ATTR_ODY_SIM_TPDM                                              = 0x6942ee4,
    ATTR_ODY_SIM_TCASL_OVERRIDE                                    = 0x726e42c,
    ATTR_ODY_SIM_TCASL_ADD                                         = 0x5297c70,
    ATTR_ODY_POWERDOWN_ANIBS                                       = 0x6fccada,
    ATTR_ODY_LP2_PWRSAVINGS                                        = 0x3bb3b7a,
    ATTR_ODY_SPECIAL_OFFSET_VALUE                                  = 0xc03336d,
    ATTR_ODY_ADV_TRAIN_OPT                                         = 0xa12ad5c,
    ATTR_ODY_MSG_MISC                                              = 0x5ee2cf9,
    ATTR_ODY_PLL_BYPASS_EN                                         = 0xfb84286,
    ATTR_ODY_RX2D_DFE_MISC                                         = 0x8dc56b6,
    ATTR_ODY_D5MISC                                                = 0x404b923,
    ATTR_ODY_WL_ADJ                                                = 0x4eee267,
    ATTR_ODY_SEQUENCE_CTRL                                         = 0xa186078,
    ATTR_ODY_PHY_CFG                                               = 0x6a08b4b,
    ATTR_ODY_PHY_DFIMRL_MARGIN                                     = 0xadb2ae7,
    ATTR_ODY_PHY_USE_BROADCAST_MR                                  = 0x2cb2b25,
    ATTR_ODY_PHY_DISABLED_DBYTE                                    = 0x2596df8,
    ATTR_ODY_PHY_CA_TRAIN_OPTIONS                                  = 0x2da9fc2,
    ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS                              = 0x6fb6b11,
    ATTR_ODY_PHY_TX2D_DFE_MISC                                     = 0x52de0d7,
    ATTR_ODY_PHY_RX2D_TRAIN_OPT                                    = 0x057bedc,
    ATTR_ODY_PHY_TX2D_TRAIN_OPT                                    = 0x6a84e01,
    ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS                               = 0xb089450,
    ATTR_ODY_PHY_CONFIG_OVERRIDE                                   = 0x285a024,
    ATTR_ODY_PHY_ENABLED_DQ_CHA                                    = 0x0999272,
    ATTR_ODY_PHY_ENABLED_DQ_CHB                                    = 0xd22cf5f,
    ATTR_ODY_TX_IMPEDANCE_CTRL1                                    = 0xf41ef0a,
    ATTR_ODY_TX_IMPEDANCE_CTRL2                                    = 0xf693e4d,
    ATTR_ODY_MRR_ODT_TERM                                          = 0x0f4af00,
    ATTR_ODY_DRAMINIT_FW_REVISION                                  = 0xc412634,
    ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0                        = 0xbbd2eef,
    ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1                        = 0xaf1aa7c,
    ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET                          = 0x5834bdd,
    ATTR_ODY_DMEM_FIRST_LOAD                                       = 0xfbef093,
    ATTR_ODY_PSRO                                                  = 0xa8ec5ac,
    ATTR_ODY_SETUP_SAFEMODE_THROTTLES                              = 0x2543532,
    ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0                             = 0xada1fc2,
    ATTR_OMI_RX_LANES                                              = 0x75b3b6d,
    ATTR_OMI_TX_LANES                                              = 0xe81aec2,
    ATTR_OMI_BIST_ESD_TEST                                         = 0x900fdc4,
    ATTR_OMI_BIST_DAC_TEST                                         = 0xc965d72,
    ATTR_OMI_BIST_TIMER                                            = 0x3332949,
    ATTR_OMI_CHANNEL_LENGTH                                        = 0x29bf0cb,
    ATTR_OMI_RX_LTEG                                               = 0x1e96f94,
    ATTR_OMI_RX_LTEZ                                               = 0x4523b41,
    ATTR_OMI_TX_PRE1                                               = 0x48e4bf5,
    ATTR_OMI_TX_PRE2                                               = 0x355e81c,
    ATTR_OMI_TX_POST                                               = 0xbc265b8,
    ATTR_OMI_RX_VERT_OFFSET                                        = 0xfc1f6d8,
    ATTR_OMI_RX_HORIZ_DATA_OFFSET                                  = 0x6902c81,
    ATTR_OMI_RX_HORIZ_EDGE_OFFSET                                  = 0xf5b42fe,
    ATTR_OMI_EDPL                                                  = 0x5b3b3c9,
    ATTR_HOTPLUG                                                   = 0xd8af594,
    ATTR_HOTPLUG_MASK                                              = 0xea8022a,
    ATTR_OCMB_REL_POS                                              = 0x35d5e3f,
    ATTR_OCMB_PLL_BUCKET                                           = 0xe862fae,
    ATTR_OCMB_PLL_BUCKET_SIM                                       = 0x1b37f43,
    ATTR_SIM_CHIPLET_MASK                                          = 0xbe4e0de,
    ATTR_SCAN0_SCAN_RATIO                                          = 0xd55e4f9,
    ATTR_SPPE_BOOT_SIDE                                            = 0x8804d03,
    ATTR_OCMB_BOOT_FLAGS                                           = 0x3ddbd96,
    ATTR_ENABLE_LBIST                                              = 0x7515d41,
    ATTR_ENABLE_ABIST                                              = 0x10e6b93,
    ATTR_SECURITY_LEVEL                                            = 0x4362604,
    ATTR_RTG_SCAN_ORDER                                            = 0xe712112,
    ATTR_MEM_PMIC_4U_N_MODE                                        = 0x69153a8,
    ATTR_MEM_PMIC_FORCE_N_MODE                                     = 0x7913dc5,
    ATTR_I2C_FAIL_COUNT                                            = 0x997b4ac,
    ATTR_MEM_EFF_PMIC0_MFG_ID                                      = 0x7bc6bec,
    ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING                         = 0x4ac8a0d,
    ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT                    = 0x1902629,
    ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET                          = 0x40aa7b9,
    ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET                   = 0x81e7c0c,
    ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY                          = 0x18bfacf,
    ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER                          = 0x729602f,
    ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40                           = 0xcca10d0,
    ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING                         = 0x2e3af06,
    ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT                    = 0x1ea2968,
    ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET                          = 0xb6cd941,
    ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET                   = 0x2601b9e,
    ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY                          = 0x7663ec5,
    ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER                          = 0xc6d3718,
    ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41                           = 0x9a8a800,
    ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING                         = 0x0cf02b5,
    ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT                    = 0xd881d9a,
    ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET                          = 0x24a0f92,
    ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET                   = 0xec20bac,
    ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY                          = 0x4e0385e,
    ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER                          = 0x8b159e0,
    ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42                           = 0x80964fa,
    ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING                         = 0xc0b9ce3,
    ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT                    = 0x070464c,
    ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET                          = 0xa5c1fbe,
    ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET                   = 0x8d2dc76,
    ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY                          = 0x40c76ee,
    ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER                          = 0xfcb8929,
    ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43                           = 0x64f3058,
    ATTR_MEM_EFF_PMIC1_MFG_ID                                      = 0x043e8e0,
    ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING                         = 0xdd84994,
    ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT                    = 0x89b9a48,
    ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET                          = 0xbfcaf43,
    ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET                   = 0x29e9ba8,
    ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY                          = 0x11f5010,
    ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER                          = 0xa3a1b06,
    ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40                           = 0x990d5ea,
    ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING                         = 0x926d37e,
    ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT                    = 0xa7e62d3,
    ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET                          = 0x94901ad,
    ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET                   = 0xcb12e02,
    ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY                          = 0x0036125,
    ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER                          = 0xf43e474,
    ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41                           = 0x20ee8fd,
    ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING                         = 0xb9c0fc3,
    ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT                    = 0x9df5889,
    ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET                          = 0x9e2f6b7,
    ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET                   = 0x815fdfc,
    ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY                          = 0x0310a49,
    ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER                          = 0x95a5499,
    ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42                           = 0x6a6a83d,
    ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING                         = 0xcd4cd7a,
    ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT                    = 0x65a19cd,
    ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET                          = 0x4ebecae,
    ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET                   = 0xc14452f,
    ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY                          = 0xeaacc79,
    ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER                          = 0x36db145,
    ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43                           = 0x6fd010f,
    ATTR_MEM_EFF_PMIC2_MFG_ID                                      = 0x55cb385,
    ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING                         = 0xf5ddeb3,
    ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT                    = 0x837c29b,
    ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET                          = 0x140ddc8,
    ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET                   = 0xa813135,
    ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY                          = 0xf3db67c,
    ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER                          = 0x57acb4d,
    ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40                           = 0xb63387a,
    ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING                         = 0x89937ca,
    ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT                    = 0xbf0610c,
    ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET                          = 0xd0c86c6,
    ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET                   = 0xd9976e1,
    ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY                          = 0x59daf6e,
    ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER                          = 0x91498cd,
    ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41                           = 0xf12ba3b,
    ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING                         = 0xd9da851,
    ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT                    = 0x148c185,
    ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET                          = 0xeb26033,
    ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET                   = 0xd940b8a,
    ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY                          = 0x42d226a,
    ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER                          = 0xc635854,
    ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42                           = 0x346c2dc,
    ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING                         = 0x9330425,
    ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT                    = 0x67fa3f7,
    ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET                          = 0x5164d0c,
    ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET                   = 0x7532644,
    ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY                          = 0x5d7eb9f,
    ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER                          = 0x94c8d08,
    ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43                           = 0x666532f,
    ATTR_MEM_EFF_PMIC3_MFG_ID                                      = 0x26a0f2c,
    ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING                         = 0x3b98454,
    ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT                    = 0x2354c19,
    ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET                          = 0xe83d6b0,
    ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET                   = 0x4971d0d,
    ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY                          = 0xea4c21f,
    ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER                          = 0x8e10b37,
    ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40                           = 0x45f1d0e,
    ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING                         = 0xd3087be,
    ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT                    = 0x920fc84,
    ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET                          = 0x359f511,
    ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET                   = 0x0f27151,
    ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY                          = 0x58e2a3d,
    ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER                          = 0x098c48e,
    ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41                           = 0x3342c24,
    ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING                         = 0x854b79b,
    ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT                    = 0xe98cc14,
    ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET                          = 0x8e6a027,
    ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET                   = 0xc6e1174,
    ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY                          = 0xdb65bdd,
    ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER                          = 0xb9ee451,
    ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42                           = 0x922a9c2,
    ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING                         = 0x2e226ad,
    ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT                    = 0x23b1510,
    ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET                          = 0xb5ade27,
    ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET                   = 0x284334b,
    ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY                          = 0x0f1b8e1,
    ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER                          = 0xa608b2e,
    ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43                           = 0xc122ecf,
    ATTR_MEM_EFF_PMIC0_REDUNDANCY                                  = 0x647869e,
    ATTR_MEM_EFF_PMIC0_REVISION                                    = 0x70d8395,
    ATTR_MEM_EFF_PMIC0_PHASE_COMB                                  = 0xeb660ee,
    ATTR_MEM_EFF_PMIC0_SEQUENCE                                    = 0xb5f758a,
    ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET                      = 0x17daf7d,
    ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET                      = 0x1587d89,
    ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET                      = 0xd77c5ad,
    ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET                      = 0xde2c10c,
    ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING                         = 0x579faa0,
    ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING                         = 0x0ca664f,
    ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING                         = 0xa35f85d,
    ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING                         = 0x8f00dcd,
    ATTR_MEM_EFF_PMIC1_REDUNDANCY                                  = 0x3126bb2,
    ATTR_MEM_EFF_PMIC1_REVISION                                    = 0x3565220,
    ATTR_MEM_EFF_PMIC1_PHASE_COMB                                  = 0xb9afeb8,
    ATTR_MEM_EFF_PMIC1_SEQUENCE                                    = 0x7e3a34b,
    ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET                      = 0x11f71fb,
    ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET                      = 0xa8e207c,
    ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET                      = 0xbdb835c,
    ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET                      = 0x42964ef,
    ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING                         = 0x8455d8c,
    ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING                         = 0x21889e5,
    ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING                         = 0xf46d0b9,
    ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING                         = 0x8e5a6f8,
    ATTR_MEM_EFF_PMIC2_REVISION                                    = 0xab8959f,
    ATTR_MEM_EFF_PMIC2_PHASE_COMB                                  = 0x3982c85,
    ATTR_MEM_EFF_PMIC2_SEQUENCE                                    = 0xe6dbaaf,
    ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET                      = 0x4611411,
    ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET                      = 0xfaf66cf,
    ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET                      = 0xd05f482,
    ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET                      = 0x32d9a77,
    ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING                         = 0x3fa5781,
    ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING                         = 0x776a736,
    ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING                         = 0x4b8ed0c,
    ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING                         = 0x67bf05e,
    ATTR_MEM_EFF_PMIC3_REVISION                                    = 0xcf18598,
    ATTR_MEM_EFF_PMIC3_PHASE_COMB                                  = 0x10d5dbc,
    ATTR_MEM_EFF_PMIC3_SEQUENCE                                    = 0xf64a675,
    ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET                      = 0x1b14ba7,
    ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET                      = 0x5bec079,
    ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET                      = 0xb6d6b39,
    ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET                      = 0x1fe3e53,
    ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING                         = 0x72c194d,
    ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING                         = 0x582dc2d,
    ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING                         = 0xf6aafcb,
    ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING                         = 0xa71ccac,
    ATTR_FREQ_PB_MHZ                                               = 0x69e5db1,
    ATTR_FREQ_X_MHZ                                                = 0x38a35a1,
    ATTR_MC_SYNC_MODE                                              = 0x241918a,
    ATTR_FREQ_CORE_NOMINAL_MHZ                                     = 0xc1598bd,
    ATTR_BOOT_FREQ_MHZ                                             = 0x61f8882,
    ATTR_RISK_LEVEL                                                = 0xb3adef2,
    ATTR_PM_RESET_FFDC_ENABLE                                      = 0x9bb1f90,
    ATTR_PROC_EFF_FABRIC_GROUP_ID                                  = 0xbb5d3e9,
    ATTR_HB_HRMOR_BYTES                                            = 0x29d3a9f,
    ATTR_PROC_EFF_FABRIC_CHIP_ID                                   = 0xb91f5de,
    ATTR_FREQ_O_MHZ                                                = 0x59a4fc1,
    ATTR_OPTICS_CONFIG_MODE                                        = 0xc0f898a,
    ATTR_MSS_RDVREF_CAL_ENABLE                                     = 0x7ce66ef,
    ATTR_SKIP_HW_VREF_CAL                                          = 0xd8add56,
    ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE                           = 0x4068890,
    ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE                              = 0xd34bb04,
    ATTR_PERF_24x7_INVOCATION_TIME_MS                              = 0xe226c94,
    ATTR_CME_INSTRUCTION_TRACE_ENABLE                              = 0xbe90420,
    ATTR_SYS_VFRT_STATIC_DATA_ENABLE                               = 0xa41ce38,
    ATTR_IO_OBUS_DCCAL_FLAGS                                       = 0xaa3902b,
    ATTR_IO_O_DEBUG                                                = 0x9ef1783,
    ATTR_IO_OBUS_TX_MARGIN_RATIO                                   = 0xd54b4ac,
    ATTR_IO_OBUS_TX_FFE_PRECURSOR                                  = 0xd0b5036,
    ATTR_IO_OBUS_TX_FFE_POSTCURSOR                                 = 0x1952ef4,
    ATTR_EFF_RANK_GROUP_OVERRIDE                                   = 0x18d405f,
    ATTR_IO_X_MFG_CHK                                              = 0x213ac30,
    ATTR_IO_X_MFG_MIN_EYE_WIDTH                                    = 0xbbf242e,
    ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN                            = 0x5121315,
    ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD                             = 0x1ca612d,
    ATTR_CME_CHTM_TRACE_ENABLE                                     = 0x2bfa1f9,
    ATTR_CME_CHTM_TRACE_MEMORY_CONFIG                              = 0xa030cff,
    ATTR_SYSTEM_VDM_DISABLE                                        = 0x36ea053,
    ATTR_VDM_ENABLED                                               = 0xd2ee0c7,
    ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA                            = 0xae90c41,
    ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA                            = 0xb78c1f9,
    ATTR_SYSTEM_IVRM_DISABLE                                       = 0x2996256,
    ATTR_IVRM_ENABLED                                              = 0x49b21cc,
    ATTR_WOF_ENABLE_FRATIO                                         = 0xa7a6601,
    ATTR_WOF_ENABLE_VRATIO                                         = 0x58a7917,
    ATTR_WOF_VRATIO_SELECT                                         = 0x93b8597,
    ATTR_NEST_LEAKAGE_PERCENT                                      = 0x787d424,
    ATTR_MSS_RUN_DCD_CALIBRATION                                   = 0x775e116,
    ATTR_MSS_EFF_WR_CRC                                            = 0x53b8bd1,
    ATTR_IO_O_MFG_CHK                                              = 0x5c4a180,
    ATTR_IO_O_MFG_MIN_EYE_WIDTH                                    = 0xd9db2d5,
    ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE                          = 0x655aa2b,
    ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE                            = 0xe8e795c,
    ATTR_EQ_INSIDE_SPECIAL_WAKEUP                                  = 0xcb7b544,
    ATTR_MSS_VPD_MT_MC_BIAS_TRIM                                   = 0x18dd068,
    ATTR_EX_INSIDE_SPECIAL_WAKEUP                                  = 0x2bf8757,
    ATTR_IO_XBUS_CHAN_EQ                                           = 0xa607f58,
    ATTR_IO_O_CHANNEL_TYPE                                         = 0x0d1a22c,
    ATTR_NEST_PLL_BUCKET                                           = 0x02190b7,
    ATTR_AFFINITY_PATH                                             = 0xb5afcd7,
    ATTR_ALLOW_EEPROM_WRITES                                       = 0x59c3ee2,
    ATTR_ALL_MCS_IN_INTERLEAVING_GROUP                             = 0x06e992f,
    ATTR_ALTFSI_MASTER_CHIP                                        = 0x9008e43,
    ATTR_ALTFSI_MASTER_PORT                                        = 0x3d7757a,
    ATTR_ASYNC_NEST_FREQ_MHZ                                       = 0xc794239,
    ATTR_ATTN_AREA_1_ADDR                                          = 0x2b044eb,
    ATTR_ATTN_AREA_2_ADDR                                          = 0xf43c049,
    ATTR_AVDD_ID                                                   = 0xc710685,
    ATTR_BLOCK_SPEC_DECONFIG                                       = 0xf873da7,
    ATTR_BMC_FRU_ID                                                = 0xe3947ec,
    ATTR_CDM_DOMAIN                                                = 0xb728b91,
    ATTR_CDM_POLICIES                                              = 0x6f11c24,
    ATTR_CEC_IPL_TYPE                                              = 0x1e1c64d,
    ATTR_CENTAUR_ECID_FRU_ID                                       = 0x957176b,
    ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS                              = 0xad171df,
    ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS                       = 0xc976513,
    ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS                               = 0x32d84bd,
    ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS                        = 0xb5913fd,
    ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS                              = 0xc73cd4e,
    ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS                       = 0x317b69f,
    ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS                               = 0x19c712c,
    ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS                        = 0xd55bf40,
    ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS                               = 0x2b00bff,
    ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS                        = 0xa6645a7,
    ATTR_CHASSIS_LOCATION_CODE                                     = 0x4b12a86,
    ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL                               = 0xad706f2,
    ATTR_CHIPLET_ID                                                = 0x2e5f49c,
    ATTR_CHIP_FAN_CFM                                              = 0xf113798,
    ATTR_CHIP_ID                                                   = 0x6d3696b,
    ATTR_CHIP_UNIT                                                 = 0x9615865,
    ATTR_CLASS                                                     = 0xc18e8f1,
    ATTR_COLLECT_SBE_SCRATCH_DATA                                  = 0x06b6027,
    ATTR_CORE_IS_SPARE                                             = 0x9d575cb,
    ATTR_CPU_ATTR                                                  = 0xd301294,
    ATTR_DATA_CACHE_LINE_SIZE                                      = 0xf4e0097,
    ATTR_DATA_CACHE_SIZE                                           = 0xd75007e,
    ATTR_DCACHE_ASSOC_SETS                                         = 0x0bce06b,
    ATTR_DCACHE_LINE_SIZE                                          = 0x9cb467b,
    ATTR_DEBUG_OCMB_LOGS                                           = 0xcfadec6,
    ATTR_DEBUG_ODY_HRESET_CONTROL                                  = 0x6bae177,
    ATTR_DECONFIG_GARDABLE                                         = 0x59253de,
    ATTR_DIMM_POWER                                                = 0xf1df866,
    ATTR_DIMM_POWER_UTIL                                           = 0xce6f012,
    ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS                       = 0x03744de,
    ATTR_DIMM_PREHEAT_POWER                                        = 0xed6c3e0,
    ATTR_DISABLE_PLD_WAIT                                          = 0x829cc6b,
    ATTR_DISABLE_PREDICTIVE_MEM_GUARD                              = 0x6b72984,
    ATTR_DUMMY_HEAP_ZERO_DEFAULT                                   = 0x9184d62,
    ATTR_DUMMY_RO                                                  = 0x7f95302,
    ATTR_DUMMY_RW                                                  = 0x6b5b079,
    ATTR_DUMMY_WO                                                  = 0x18849c5,
    ATTR_EC                                                        = 0x3fd6b69,
    ATTR_EECACHE_DISABLE_AUTO_RESET                                = 0x4a3e94f,
    ATTR_EECACHE_VPD_STATE                                         = 0xd60cfd7,
    ATTR_EEPROM_CONTENT_TYPE                                       = 0x4cb9215,
    ATTR_EEPROM_NV_INFO                                            = 0x428de15,
    ATTR_EEPROM_SBE_BACKUP_INFO                                    = 0xcba1600,
    ATTR_EEPROM_SBE_PRIMARY_INFO                                   = 0x9e4aac2,
    ATTR_EEPROM_VPD_ACCESSIBILITY                                  = 0xc538c17,
    ATTR_EEPROM_VPD_ACTIVE_COPY                                    = 0xf578144,
    ATTR_EEPROM_VPD_BACKUP_INFO                                    = 0x1fbf757,
    ATTR_EEPROM_VPD_PRIMARY_INFO                                   = 0xcdbfb30,
    ATTR_EEPROM_VPD_REDUNDANCY                                     = 0x0a8379a,
    ATTR_EFFECTIVE_EC                                              = 0x8ff8d9c,
    ATTR_ENABLED_THREADS                                           = 0xdf90286,
    ATTR_ENGINE_TYPE                                               = 0xa9d881f,
    ATTR_FABRIC_CHIP_ID                                            = 0x34eeb58,
    ATTR_FABRIC_GROUP_ID                                           = 0xdb4e40c,
    ATTR_FABRIC_PRESENT_GROUPS                                     = 0x1871395,
    ATTR_FABRIC_TO_PHYSICAL_NODE_MAP                               = 0x2d207b6,
    ATTR_FAPI_I2C_CONTROL_INFO                                     = 0x57cb1d1,
    ATTR_FAPI_NAME                                                 = 0x9dc28f2,
    ATTR_FIELD_CORE_OVERRIDE                                       = 0xaff2273,
    ATTR_FIELD_TH_L2_LINE_DELETES                                  = 0x7469e45,
    ATTR_FIELD_TH_L3_LINE_DELETES                                  = 0xe5e057a,
    ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION                         = 0x0dc047f,
    ATTR_FORCE_SERIAL_ISTEPS                                       = 0x9d169d9,
    ATTR_FORCE_SRAM_MMIO_OVER_I2C                                  = 0xeb2b814,
    ATTR_FOUND_PRESENT_BY_SP                                       = 0x48b4eb2,
    ATTR_FREQ_CORE_CEILING_MHZ                                     = 0xa3dc291,
    ATTR_FREQ_PROC_REFCLOCK                                        = 0xaac24d5,
    ATTR_FRU_ID                                                    = 0x278bc56,
    ATTR_FSI_MASTER_CHIP                                           = 0x25b0084,
    ATTR_FSI_MASTER_PORT                                           = 0xf4637bc,
    ATTR_FSI_MASTER_TYPE                                           = 0x116670c,
    ATTR_FSI_OPTION_FLAGS                                          = 0x3b6e39f,
    ATTR_FSI_SLAVE_CASCADE                                         = 0x21c70fd,
    ATTR_FSP_BAR_SIZE                                              = 0xd8dde00,
    ATTR_FSP_BASE_ADDR                                             = 0xfcfe1a6,
    ATTR_FUSED_CORE_MODE_HB                                        = 0xc7d9261,
    ATTR_FUSED_CORE_OPTION                                         = 0x9f670db,
    ATTR_HBRT_HYP_ID                                               = 0x891d6d1,
    ATTR_HB_HRMOR_NODAL_BASE                                       = 0x11a66f1,
    ATTR_HB_MIN_BACKING_CACHE_FC                                   = 0xec67366,
    ATTR_HB_RSV_MEM_SIZE_MB                                        = 0xbf11ec0,
    ATTR_HB_SETTINGS                                               = 0x19d1b7e,
    ATTR_HB_SETTINGS_OVERRIDE                                      = 0xe53583f,
    ATTR_HDAT_EC                                                   = 0x9f10191,
    ATTR_HDAT_HBRT_NUM_SECTIONS                                    = 0xc6dfefe,
    ATTR_HDAT_HBRT_SECTION_SIZE                                    = 0xd0167e2,
    ATTR_HDAT_RSV_MEM_NUM_SECTIONS                                 = 0x997e20e,
    ATTR_HDDW_ORDER                                                = 0x6a00c9c,
    ATTR_HOMER_PHYS_ADDR                                           = 0xcac816f,
    ATTR_HOSTSVC_PLID                                              = 0x0aa0ab1,
    ATTR_HOT_PLUG_POWER_CONTROLLER_INFO                            = 0x837b78a,
    ATTR_HUID                                                      = 0xf9fde6a,
    ATTR_HWAS_STATE                                                = 0x16fbd51,
    ATTR_HWAS_STATE_CHANGED_FLAG                                   = 0x1c5c585,
    ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK                      = 0x4a76d45,
    ATTR_HWAS_STATE_TESTSAVE                                       = 0xd1e26f4,
    ATTR_I2C_BUS_SPEED_ARRAY                                       = 0x5c75b22,
    ATTR_I2C_CONTROL_INFO                                          = 0x44f4167,
    ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A                     = 0xb973ab4,
    ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B                     = 0x15da8c9,
    ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C                     = 0xc667245,
    ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D                     = 0x22428b6,
    ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E                     = 0x5d36cba,
    ATTR_I2C_SWITCHES                                              = 0x442b881,
    ATTR_IBSCOM_MCS_BASE_ADDR                                      = 0x1983e2d,
    ATTR_IBSCOM_PROC_BASE_ADDR                                     = 0x06d3ba7,
    ATTR_ICACHE_ASSOC_SETS                                         = 0xacc8025,
    ATTR_ICACHE_BLOCK_SIZE                                         = 0x2c13580,
    ATTR_ICACHE_LINE_SIZE                                          = 0x934de01,
    ATTR_ICACHE_SIZE                                               = 0x7d275f0,
    ATTR_INIT_TO_AVAILABLE                                         = 0xed1d603,
    ATTR_INT_CQ_TM_BAR_ADDR                                        = 0x85ef6e9,
    ATTR_ISTEP_CALLOUT_INJECT_ACTION                               = 0x061c783,
    ATTR_ISTEP_CALLOUT_INJECT_ENABLE                               = 0x36cb5ff,
    ATTR_ISTEP_MODE                                                = 0x54d128f,
    ATTR_ISTEP_PAUSE_CONFIG                                        = 0x2cf6852,
    ATTR_ISTEP_PAUSE_ENABLE                                        = 0x5171c01,
    ATTR_IS_INTER_ENCLOSURE_BUS                                    = 0x56ef574,
    ATTR_IS_STANDALONE                                             = 0xe54bcd6,
    ATTR_KEY_CLEAR_REQUEST                                         = 0x9135ce2,
    ATTR_KEY_TRANSITION_STATE                                      = 0x8135b05,
    ATTR_L2_CACHE_ASSOC_SETS                                       = 0x8845c5b,
    ATTR_L2_CACHE_LINE_SIZE                                        = 0xfc7c1e8,
    ATTR_L2_CACHE_SIZE                                             = 0x07a2758,
    ATTR_L3_CACHE_LINE_SIZE                                        = 0xfc574bf,
    ATTR_L3_CACHE_SIZE                                             = 0xdbffc50,
    ATTR_LAST_IPLTIME_EID                                          = 0x99b51a5,
    ATTR_LMB_SIZE                                                  = 0xc44c3e5,
    ATTR_LOCATION_CODE                                             = 0xdeda910,
    ATTR_LPC_BUS_ADDR                                              = 0x1ffe3ce,
    ATTR_MAX_CHIPLETS_PER_PROC                                     = 0xfa1c9e6,
    ATTR_MAX_COMPUTE_NODES_PER_SYSTEM                              = 0x8105e72,
    ATTR_MAX_DIMMS_PER_MBA_PORT                                    = 0x9130cb8,
    ATTR_MAX_DIMM_POWER                                            = 0xfeeb8d6,
    ATTR_MAX_DMI_PER_PROC                                          = 0xa71e033,
    ATTR_MAX_EXS_PER_PROC_CHIP                                     = 0xa59a4fa,
    ATTR_MAX_MBAS_PER_MEMBUF_CHIP                                  = 0x90ddd8e,
    ATTR_MAX_MBA_PORTS_PER_MBA                                     = 0xeb1d539,
    ATTR_MAX_MCS_PER_SYSTEM                                        = 0x86e21ac,
    ATTR_MAX_POWER                                                 = 0x935d008,
    ATTR_MAX_PROC_CHIPS_PER_NODE                                   = 0x8dc78ef,
    ATTR_MBA_DIMM                                                  = 0x80b9cd7,
    ATTR_MBA_PORT                                                  = 0x5207f78,
    ATTR_MEM_AVDD_OFFSET_MILLIVOLTS                                = 0x80161a9,
    ATTR_MEM_BASE                                                  = 0x45a548d,
    ATTR_MEM_PORT                                                  = 0x929775e,
    ATTR_MEM_VCS_OFFSET_MILLIVOLTS                                 = 0xb7b1ac5,
    ATTR_MEM_VDDR_OFFSET_MILLIVOLTS                                = 0xe390ea6,
    ATTR_MEM_VDD_OFFSET_MILLIVOLTS                                 = 0xcc28df8,
    ATTR_MEM_VPP_OFFSET_MILLIVOLTS                                 = 0xd4a475d,
    ATTR_MFG_TRACE_ENABLE                                          = 0xb257082,
    ATTR_MGC_LOAD_SOURCE                                           = 0xce01813,
    ATTR_MIN_FREQ_MHZ                                              = 0x6f08f4b,
    ATTR_MIRROR_BASE_ADDRESS                                       = 0x6a258b6,
    ATTR_MMIO_PHYS_ADDR                                            = 0x0505dad,
    ATTR_MNFG_ABUS_MIN_EYE_HEIGHT                                  = 0xeaa3fa0,
    ATTR_MNFG_ABUS_MIN_EYE_WIDTH                                   = 0x0f9d926,
    ATTR_MNFG_DMI_MIN_EYE_HEIGHT                                   = 0xccc15e8,
    ATTR_MNFG_DMI_MIN_EYE_WIDTH                                    = 0x72b7486,
    ATTR_MNFG_TH_L2_CACHE_CES                                      = 0x882b99c,
    ATTR_MNFG_TH_L2_DIR_CES                                        = 0x10ae5b3,
    ATTR_MNFG_TH_L2_LINE_DELETES                                   = 0x16cbbfb,
    ATTR_MNFG_TH_L3_CACHE_CES                                      = 0x70e6a22,
    ATTR_MNFG_TH_L3_DIR_CES                                        = 0xa0dd16a,
    ATTR_MNFG_TH_L3_LINE_DELETES                                   = 0x1788780,
    ATTR_MNFG_TH_MEMORY_IMPES                                      = 0x1049d17,
    ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO                        = 0x1e8208b,
    ATTR_MNFG_TH_MEMORY_IUES                                       = 0x723f825,
    ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS                          = 0x96069bd,
    ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK                            = 0xf907441,
    ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO                         = 0xdb89c57,
    ATTR_MNFG_XBUS_MIN_EYE_WIDTH                                   = 0xcbd7ed0,
    ATTR_MODEL                                                     = 0x7a03bac,
    ATTR_MRU_ID                                                    = 0x639dd88,
    ATTR_MRW_DDR3_VDDR_MAX_LIMIT                                   = 0x6ac0905,
    ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT                    = 0xdde9311,
    ATTR_MRW_DDR4_VDDR_MAX_LIMIT                                   = 0x69b9e21,
    ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT                    = 0x7b5c147,
    ATTR_MRW_DEFAULT_RISK_LEVEL                                    = 0x3884378,
    ATTR_MRW_MEM_THROTTLE_DENOMINATOR                              = 0x8218c38,
    ATTR_MSL_FIELD_SUPPORTED                                       = 0x2fd4ceb,
    ATTR_MSL_MFG_ALLOW                                             = 0x596417a,
    ATTR_MSS_AVDD_PROGRAM                                          = 0xefb544c,
    ATTR_MSS_CENT_AVDD_INTERCEPT                                   = 0xbb0ac42,
    ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE                                = 0x0b207b3,
    ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE                              = 0xbaa5d46,
    ATTR_MSS_CENT_VCS_INTERCEPT                                    = 0x42b4fae,
    ATTR_MSS_CENT_VCS_SLOPE_ACTIVE                                 = 0xdfbb097,
    ATTR_MSS_CENT_VCS_SLOPE_INACTIVE                               = 0x0cbd3fd,
    ATTR_MSS_CENT_VDD_INTERCEPT                                    = 0xe54617c,
    ATTR_MSS_CENT_VDD_SLOPE_ACTIVE                                 = 0x9aef30c,
    ATTR_MSS_CENT_VDD_SLOPE_INACTIVE                               = 0x3e7ad0d,
    ATTR_MSS_DATABUS_UTIL_PER_MBA                                  = 0xa2f9494,
    ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT                               = 0x8ee2d89,
    ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE                         = 0x771b18e,
    ATTR_MSS_PHY_SEQ_REFRESH                                       = 0x13326ac,
    ATTR_MSS_VCS_PROGRAM                                           = 0xb4f1718,
    ATTR_MSS_VDDR_PROGRAM                                          = 0x51289c7,
    ATTR_MSS_VDD_PROGRAM                                           = 0x17228f8,
    ATTR_MSS_VOLT_AVDD_MILLIVOLTS                                  = 0x6f09c49,
    ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS                           = 0x4f0f469,
    ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT                              = 0xbdf333e,
    ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT               = 0x829fde2,
    ATTR_MSS_VOLT_DDR3_VDDR_SLOPE                                  = 0x10d2a3d,
    ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT                   = 0x420d32d,
    ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT                              = 0x56b3514,
    ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT               = 0x6129fe7,
    ATTR_MSS_VOLT_DDR4_VDDR_SLOPE                                  = 0x5d56393,
    ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT                   = 0xb11a217,
    ATTR_MSS_VOLT_VCS_MILLIVOLTS                                   = 0xc76fe71,
    ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS                            = 0x32d623a,
    ATTR_MSS_VOLT_VDDR_MILLIVOLTS                                  = 0x3317838,
    ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS                           = 0x666457d,
    ATTR_MSS_VOLT_VDD_MILLIVOLTS                                   = 0xdcbd688,
    ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS                            = 0x9a3b18e,
    ATTR_MSS_VOLT_VPP_INTERCEPT                                    = 0x3aa234f,
    ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT                     = 0xd513657,
    ATTR_MSS_VOLT_VPP_MILLIVOLTS                                   = 0x18a11eb,
    ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS                            = 0x1166570,
    ATTR_MSS_VOLT_VPP_SLOPE                                        = 0x72f49a4,
    ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT                         = 0xe2c64ec,
    ATTR_MSS_VPP_PROGRAM                                           = 0x2280840,
    ATTR_NEST_PLL_FREQ_BUCKETS                                     = 0xad3e4fe,
    ATTR_NEST_PLL_FREQ_I2CDIV_LIST                                 = 0x78c64c6,
    ATTR_NEST_PLL_FREQ_LIST                                        = 0x9b7099c,
    ATTR_NEST_VCS_ID                                               = 0xc498800,
    ATTR_NEST_VDDR_ID                                              = 0x6a22222,
    ATTR_NEST_VDD_ID                                               = 0x89224bc,
    ATTR_NEST_VDN_ID                                               = 0x61356e1,
    ATTR_NEST_VIO_ID                                               = 0xec8827a,
    ATTR_NO_RECONFIG_ON_DECONFIG                                   = 0xefb989b,
    ATTR_NPU_MMIO_BAR_BASE_ADDR                                    = 0xff18a73,
    ATTR_NPU_MMIO_BAR_SIZE                                         = 0x77da343,
    ATTR_NUMERIC_POD_TYPE_TEST                                     = 0xdbe5186,
    ATTR_NVDIMM_ARMED                                              = 0x3df34de,
    ATTR_NV_OPS_TIMEOUT_MSEC                                       = 0x19f4158,
    ATTR_NV_STATUS_FLAG                                            = 0x21d59a2,
    ATTR_OBUS_BRICK_LANE_MASK                                      = 0x2d9433b,
    ATTR_OBUS_SLOT_INDEX                                           = 0xc610fe3,
    ATTR_OCC_MASTER_CAPABLE                                        = 0xe7e15a5,
    ATTR_OCMB_BOOT_SIDE                                            = 0xa5113fc,
    ATTR_OCMB_CODE_LEVEL_SUMMARY                                   = 0x2b732f9,
    ATTR_OCMB_CODE_UPDATED                                         = 0x565ee7d,
    ATTR_OCMB_FORCE_IMAGE_SYNC                                     = 0xbdbbd24,
    ATTR_OCMB_FW_STATE                                             = 0x44eae3a,
    ATTR_OCMB_FW_UPDATE_OVERRIDE                                   = 0xab4c632,
    ATTR_OCMB_FW_UPDATE_STATUS                                     = 0x9717572,
    ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED                                = 0x0d7122c,
    ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE                            = 0xb8cb525,
    ATTR_OCMB_ISTEP_MODE                                           = 0x59d7ace,
    ATTR_OCMB_RESET_DELAY_SEC                                      = 0x829c075,
    ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE                         = 0x97999e4,
    ATTR_ODY_PNOR_COMBINED_IMAGES_HASH                             = 0xaa4ce6c,
    ATTR_ORDINAL_ID                                                = 0xe2df671,
    ATTR_PARENT_DECONFIG_RULES                                     = 0x0df4605,
    ATTR_PAYLOAD_BASE                                              = 0x020a135,
    ATTR_PAYLOAD_ENTRY                                             = 0x64b6d86,
    ATTR_PAYLOAD_IN_MIRROR_MEM                                     = 0x8c5fb5a,
    ATTR_PAYLOAD_KIND                                              = 0xa4d2083,
    ATTR_PCIE_32BIT_DMA_SIZE                                       = 0xe242d68,
    ATTR_PCIE_32BIT_MMIO_SIZE                                      = 0xb312257,
    ATTR_PCIE_64BIT_DMA_SIZE                                       = 0x7e1fa3b,
    ATTR_PCIE_64BIT_MMIO_SIZE                                      = 0x9487ddb,
    ATTR_PCIE_CAPABILITES                                          = 0x7f829da,
    ATTR_PCIE_NVME_CCIN                                            = 0xd4805eb,
    ATTR_PCIE_NVME_PHB_CONFIG                                      = 0x90e81d5,
    ATTR_PCI_REFCLOCK_RCVR_TERM                                    = 0x64e7e70,
    ATTR_PEC_IS_BIFURCATABLE                                       = 0xab70ca8,
    ATTR_PEC_PCIE_HX_KEYWORD_DATA                                  = 0x43ba247,
    ATTR_PEC_PCIE_IOP_REVERSAL                                     = 0x97e0876,
    ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED                          = 0x3322938,
    ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED                      = 0xebbaf50,
    ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED                              = 0x1d55f3f,
    ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED                          = 0x70406e6,
    ATTR_PEC_PCIE_LANE_MASK_BIFURCATED                             = 0xa258a52,
    ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED                         = 0x65a6fb3,
    ATTR_PEER_PATH                                                 = 0xae3bc8f,
    ATTR_PEER_TARGET                                               = 0x6f76a92,
    ATTR_PG                                                        = 0x49f38fe,
    ATTR_PG_SAVED                                                  = 0xf1d0ed1,
    ATTR_PHB_BASE_ADDRS                                            = 0xb6f0cd7,
    ATTR_PHYS_PATH                                                 = 0xf7abb7c,
    ATTR_PIB_I2C_NEST_PLL                                          = 0x19a4504,
    ATTR_PIB_I2C_REFCLOCK                                          = 0xa8b10e1,
    ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST                             = 0xba4cb42,
    ATTR_PMIC_CALLBACK_STAGGER_TIME                                = 0x2763107,
    ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER                              = 0x5097420,
    ATTR_PMIC_HEALTH_CHECK_TIMER                                   = 0xb57d3ee,
    ATTR_PNOR_FLASH_WORKAROUNDS                                    = 0x30c07c8,
    ATTR_POSITION                                                  = 0x90b4ba7,
    ATTR_POS_ON_MEM_PORT                                           = 0xf0961f9,
    ATTR_POWERVS_P10_FW_VER                                        = 0xea0b51a,
    ATTR_POWER_PATH                                                = 0xd43ef5c,
    ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE                            = 0x214b9d8,
    ATTR_PRD_HWP_PLID                                              = 0x38a7b13,
    ATTR_PREHEAT_PERCENT                                           = 0xa2ab303,
    ATTR_PRIMARY_CAPABILITIES                                      = 0xd84c572,
    ATTR_PROC_COMPATIBILITY_REQ                                    = 0x71d7b85,
    ATTR_PROC_DCM_INSTALLED                                        = 0x2b8d151,
    ATTR_PROC_MASTER_TYPE                                          = 0x68e1db7,
    ATTR_PROC_MODULE_TYPE                                          = 0x83cc1e9,
    ATTR_PROC_PCIE_IOP_CONFIG                                      = 0xeb604df,
    ATTR_PROC_PCIE_IOVALID_ENABLE                                  = 0x48a8902,
    ATTR_PROC_PCIE_IS_SLOT                                         = 0x69653af,
    ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3                          = 0x4b839c0,
    ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4                          = 0xdab5f58,
    ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5                          = 0x1c05310,
    ATTR_PROC_PCIE_LANE_MASK                                       = 0x1439e9f,
    ATTR_PROC_PCIE_LANE_REVERSAL_BASE                              = 0xcc9dffd,
    ATTR_PROC_PCIE_NUM_PEC                                         = 0xd837641,
    ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL                             = 0xa10bfc8,
    ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL                       = 0xc4fcb9a,
    ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL                              = 0xf2039e4,
    ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3                     = 0xae3040d,
    ATTR_PROC_PCIE_PHB_ACTIVE_BASE                                 = 0x5d3796a,
    ATTR_PROC_PCIE_REFCLOCK_ENABLE                                 = 0xe2cfa5e,
    ATTR_PROC_REFCLOCK_RCVR_TERM                                   = 0x5f9ce72,
    ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE                            = 0xdba3bba,
    ATTR_PROC_SELECT_SEEPROM_IMAGE                                 = 0x36ac7a5,
    ATTR_PSI_BRIDGE_BASE_ADDR                                      = 0x6508321,
    ATTR_PSI_HB_ESB_ADDR                                           = 0x4e64812,
    ATTR_RAW_MTM                                                   = 0x84a4edb,
    ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED                         = 0x3d1a60f,
    ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT                            = 0x5b0d3bc,
    ATTR_RECONFIG_LOOP_TESTS                                       = 0x4fe6548,
    ATTR_RECONFIG_LOOP_TESTS_ENABLE                                = 0x97d43be,
    ATTR_REDUNDANT_CLOCKS                                          = 0x706e27b,
    ATTR_REL_POS                                                   = 0x30c46b3,
    ATTR_REPLACED_BY_SPARE                                         = 0xb8b3f00,
    ATTR_RESOURCE_IS_CRITICAL                                      = 0xbfccf0c,
    ATTR_RISK_LEVEL_ORIGIN                                         = 0x45b1c68,
    ATTR_RNG_BAR_SIZE                                              = 0xe2bf285,
    ATTR_RNG_BASE_ADDR                                             = 0xafef4d7,
    ATTR_RUN_MAX_MEM_PATTERNS                                      = 0x778bcbb,
    ATTR_RUN_ODY_HWP_FROM_HOST                                     = 0xfff38c9,
    ATTR_SAVED_STATE_UINT8                                         = 0xc462253,
    ATTR_SBE_BOOTLOADER_CODELEVEL                                  = 0x03a7dcf,
    ATTR_SBE_BUILD_TAG                                             = 0xc1dab35,
    ATTR_SBE_COMMIT_ID                                             = 0xe63aed7,
    ATTR_SBE_EKB_BUILD_TAG                                         = 0xb2d229a,
    ATTR_SBE_FIFO_CAPABILITIES                                     = 0x63a4fd4,
    ATTR_SBE_HANDLES_SMP_TPM_EXTEND                                = 0xd7735da,
    ATTR_SBE_IS_STARTED                                            = 0xe926ea8,
    ATTR_SBE_NUM_CAPABILITIES                                      = 0xc8c5949,
    ATTR_SBE_NUM_IMAGES                                            = 0xc7b1e3f,
    ATTR_SBE_RELEASE_TAG                                           = 0x3baf9ca,
    ATTR_SBE_RUNTIME_CODELEVEL                                     = 0xd5dfc35,
    ATTR_SBE_UPDATE_DISABLE                                        = 0x2b23c7c,
    ATTR_SBE_VERSION_INFO                                          = 0xe20c541,
    ATTR_SCOM_SWITCHES                                             = 0xbc8d08b,
    ATTR_SCRATCH_UINT32_1                                          = 0x782c053,
    ATTR_SCRATCH_UINT32_2                                          = 0x002156b,
    ATTR_SCRATCH_UINT64_1                                          = 0xeee9926,
    ATTR_SCRATCH_UINT64_2                                          = 0x18a17a2,
    ATTR_SCRATCH_UINT8_1                                           = 0xc7bc372,
    ATTR_SCRATCH_UINT8_2                                           = 0xe93419a,
    ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM                       = 0x96f8bd3,
    ATTR_SECURE_VERSION_LOCKIN_POLICY                              = 0x335e006,
    ATTR_SECURE_VERSION_NUM                                        = 0x85a4a4b,
    ATTR_SECURE_VERSION_SEEPROM                                    = 0xf9eeb51,
    ATTR_SKIP_HBRT_ATTR_UPDATE                                     = 0x24a8d09,
    ATTR_SLOT_INDEX                                                = 0x51cc341,
    ATTR_SLOT_NAME                                                 = 0x5ef37d7,
    ATTR_SMF_MEM_AMT_REQUESTED                                     = 0x58f9cb3,
    ATTR_SOCKET_POWER_TURBO                                        = 0x8949e92,
    ATTR_SPARE_CORES                                               = 0xe831adc,
    ATTR_SPARE_CORES_DEPLOYED                                      = 0xd282763,
    ATTR_SPARE_CORE_ACTIONS_DISABLED                               = 0xd29c2de,
    ATTR_SPI_EEPROM_SPARE_INFO                                     = 0x33afdd0,
    ATTR_SPI_EEPROM_VPD_BACKUP_INFO                                = 0xba6f1c6,
    ATTR_SPI_EEPROM_VPD_PRIMARY_INFO                               = 0x1cfc587,
    ATTR_SPI_KEYSTORE_INFO_HOSTBOOT                                = 0x1a946e7,
    ATTR_SPI_KEYSTORE_INFO_OPAL_0                                  = 0xa90a6fa,
    ATTR_SPI_KEYSTORE_INFO_OPAL_1                                  = 0xf883c12,
    ATTR_SPI_KEYSTORE_INFO_OPAL_2                                  = 0x9eda982,
    ATTR_SPI_KEYSTORE_INFO_PHYP                                    = 0x5c61990,
    ATTR_SPI_MVPD_BACKUP_INFO                                      = 0x006e0bd,
    ATTR_SPI_MVPD_PRIMARY_INFO                                     = 0xe9af745,
    ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO                             = 0xa914ec9,
    ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO                            = 0x3a1816c,
    ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO                      = 0x4269836,
    ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO                     = 0x32adc69,
    ATTR_SPI_SWITCHES                                              = 0x3b039dc,
    ATTR_SPI_TPM_INFO                                              = 0x5c63b38,
    ATTR_SPI_WOF_DATA_INFO                                         = 0xf337a7a,
    ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH                          = 0xab1f0d1,
    ATTR_SPPE_RUNTIME_MEASUREMENT_HASH                             = 0x9e4ee59,
    ATTR_SP_FUNCTIONS                                              = 0xa82e8ff,
    ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN                   = 0x8dfa6d6,
    ATTR_STOP5_DISABLE                                             = 0x0ddfd25,
    ATTR_SUPPORTED_STOP_STATES                                     = 0xbc55176,
    ATTR_SUPPORTS_DYNAMIC_MEM_VOLT                                 = 0xf70279f,
    ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG                        = 0x0c8b64a,
    ATTR_SYNC_BETWEEN_STEPS                                        = 0x3761a65,
    ATTR_SYSTEM_FAMILY                                             = 0xc8c49e7,
    ATTR_SYSTEM_THERMAL_RESISTANCE                                 = 0x9a1b903,
    ATTR_SYSTEM_TYPE                                               = 0xa40efa1,
    ATTR_SYS_LOCATION_CODE                                         = 0x6c5ec9f,
    ATTR_TCE_START_TOKEN_FOR_HDAT                                  = 0x4194918,
    ATTR_TCE_START_TOKEN_FOR_PAYLOAD                               = 0x8944726,
    ATTR_TEMP_SENSOR_I2C_CONFIG                                    = 0xb1fab71,
    ATTR_TEST_MAX_STRING                                           = 0x428e6a8,
    ATTR_TEST_MIN_STRING                                           = 0xd2401e6,
    ATTR_TEST_NEGATIVE_FCN                                         = 0x30cbc29,
    ATTR_TEST_NO_DEFAULT_STRING                                    = 0xc5d939e,
    ATTR_TEST_NULL_STRING                                          = 0x6fd2aa7,
    ATTR_THREAD_COUNT                                              = 0x8ce790d,
    ATTR_TIME_BASE                                                 = 0x1192453,
    ATTR_TLB_DATA_ASSOC_SETS                                       = 0xfca622c,
    ATTR_TLB_DATA_ENTRIES                                          = 0xfb5ce79,
    ATTR_TLB_INSTR_ASSOC_SETS                                      = 0x134fdb0,
    ATTR_TLB_INSTR_ENTRIES                                         = 0x436dd94,
    ATTR_TLB_RESERVE_SIZE                                          = 0xeb0420c,
    ATTR_TOD_CPU_DATA                                              = 0xfaa68ab,
    ATTR_TOD_ROLE                                                  = 0x019e5ac,
    ATTR_TPM_ENABLED                                               = 0xcb749b3,
    ATTR_TPM_POISONED                                              = 0xa74c8da,
    ATTR_TPM_REQUIRED                                              = 0xe79c887,
    ATTR_TPM_UNUSABLE                                              = 0x3e2ad88,
    ATTR_TYPE                                                      = 0x9484951,
    ATTR_UCD_MFR_REVISION_OVERRIDE                                 = 0x62ad824,
    ATTR_ULTRA_TURBO_FREQ_MHZ                                      = 0xca2de0a,
    ATTR_USE_11S_SPD                                               = 0x2165e1d,
    ATTR_USE_PIPE_FIFO                                             = 0xbb36ec8,
    ATTR_USE_TCES_FOR_DMAS                                         = 0xbde3ab9,
    ATTR_VCS_ID                                                    = 0x780a573,
    ATTR_VDDR_ID                                                   = 0x3dbc21a,
    ATTR_VDD_ID                                                    = 0x2a9cfd3,
    ATTR_VENDOR_ID                                                 = 0x22d9035,
    ATTR_VPD_REC_NUM                                               = 0x03a8b72,
    ATTR_VPP_ID                                                    = 0xa5ccc9a,
    ATTR_WOF_POWER_LIMIT                                           = 0x4baf80d,
    ATTR_WOF_TABLE_LID_NUMBER                                      = 0xe1b47d7,
    ATTR_XIVE_CONTROLLER_BAR_ADDR                                  = 0x859437f,
    ATTR_XSCOM_BASE_ADDRESS                                        = 0x7803464,
    ATTR_I2C_CHIP_INFO                                             = 0x24a02c8,
    ATTR_SBE_STATE                                                 = 0x36fb870,
    ATTR_HCSI_CHIP_SBE_INTERFACE_PTR                               = 0x1e03c6f,
    ATTR_HCSI_CHIP_INTERFACE_PTR                                   = 0x47d4973,
    ATTR_SCANRING_FACTORY_PTR                                      = 0x053231c,
    ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER                           = 0xff69c2e,
    ATTR_ECMD_TARGET                                               = 0xf46d814,
    ATTR_RID                                                       = 0xa628606,
    ATTR_FSP_SCOM_DEVICE_PATH                                      = 0xcdf2144,
    ATTR_FSP_A_SCOM_DEVICE_PATH                                    = 0xf056e93,
    ATTR_FSP_B_SCOM_DEVICE_PATH                                    = 0xa098a7e,
    ATTR_FSP_SCAN_DEVICE_PATH                                      = 0x56566ef,
    ATTR_FSP_A_SCAN_DEVICE_PATH                                    = 0x09bf27c,
    ATTR_FSP_B_SCAN_DEVICE_PATH                                    = 0x4ee84c2,
    ATTR_FSP_MBOX_DEVICE_PATH                                      = 0xd9c2af0,
    ATTR_FSP_A_MBOX_DEVICE_PATH                                    = 0x03010e0,
    ATTR_FSP_B_MBOX_DEVICE_PATH                                    = 0x0eb9d5d,
    ATTR_FSP_SBEFIFO_DEVICE_PATH                                   = 0x5f1aa39,
    ATTR_FSP_A_SBEFIFO_DEVICE_PATH                                 = 0x71cc41c,
    ATTR_FSP_B_SBEFIFO_DEVICE_PATH                                 = 0x6a98d21,
    ATTR_MAX_MS_ADDR                                               = 0xc22853c,
    ATTR_PAYLOAD_STATE                                             = 0x5811f59,
    ATTR_PAYLOAD_STARTED                                           = 0x549cb5b,
    ATTR_HB_RUNNING                                                = 0xcd8f015,
    ATTR_RESUME_PAYLOAD                                            = 0x53f3625,
    ATTR_PSI_LINK_STATE                                            = 0x7bf34fc,
    ATTR_PSI_DEVICE_PATH                                           = 0xf1021f7,
    ATTR_HOST_MAILBOX_DEV_PATH                                     = 0x4386d3c,
    ATTR_FSP_MTD_DEVICE_PATH                                       = 0x0c55226,
    ATTR_FSP_MTDBLOCK_DEVICE_PATH                                  = 0xa1f38fc,
    ATTR_EFF_HOSTBOOT_IMG_OFFSET                                   = 0x28068b9,
    ATTR_PROC_HW_TOPOLOGY                                          = 0xa0bf6f9,
    ATTR_FSP_VMEM_DEVICE_PATH                                      = 0x6574e37,
    ATTR_FSP_VMEM_I2C_ADDR                                         = 0x6ff404d,
    ATTR_FSP_VDDR_DEVICE_PATH                                      = 0xc36bada,
    ATTR_FSP_VDDR_I2C_ADDR                                         = 0x326b38b,
    ATTR_FSP_VDD_DEVICE_PATH                                       = 0xc2278f4,
    ATTR_FSP_VDD_I2C_ADDR                                          = 0x9b2b581,
    ATTR_FSP_AVDD_DEVICE_PATH                                      = 0x7b20e9d,
    ATTR_FSP_AVDD_I2C_ADDR                                         = 0x92ddf6e,
    ATTR_FSP_VCS_DEVICE_PATH                                       = 0xdc5e368,
    ATTR_FSP_VCS_I2C_ADDR                                          = 0xd82ca0c,
    ATTR_FSP_VPP_DEVICE_PATH                                       = 0x473b72c,
    ATTR_FSP_VPP_I2C_ADDR                                          = 0xdc91e7c,
    ATTR_FSP_VIO_DEVICE_PATH                                       = 0x7222c88,
    ATTR_FSP_VIO_I2C_ADDR                                          = 0x992bab8,
    ATTR_FSP_VDN_DEVICE_PATH                                       = 0xd7851cd,
    ATTR_FSP_VDN_I2C_ADDR                                          = 0x95525f4,
    ATTR_IS_MPIPL                                                  = 0xbe0ba18,
    ATTR_MSL_CHECK                                                 = 0x00fabfe,
    ATTR_PRIMARY_SBE_SEEPROM_ADDRESS                               = 0xfc5f71e,
    ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS                         = 0x96ac2d1,
    ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS                         = 0x9b1338c,
    ATTR_SECONDARY_SBE_SEEPROM_ADDRESS                             = 0x80e11fa,
    ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS                       = 0xc2c35e5,
    ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS                       = 0xd7a919b,
    ATTR_PROC_SELECT_CLOCK_MUX_MODE                                = 0x74974ba,
    ATTR_POWERSAVE_FREQ_MHZ                                        = 0x470d34f,
    ATTR_TURBO_FREQ_MHZ                                            = 0xc9c1f1a,
    ATTR_FFO_FREQ_MHZ                                              = 0x401fdfd,
    ATTR_OCC_MIN_FREQ_MHZ                                          = 0xaf2e876,
    ATTR_MAX_NUM_PSI_LINKS_PER_FSP                                 = 0x558f98e,
    ATTR_MIN_NUM_PSI_LINKS_PER_FSP                                 = 0x2a4b620,
    ATTR_PRIORITY_PSI_LINK_SELECTION                               = 0x4d9c040,
    ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT                          = 0x2c12791,
    ATTR_MODEL_EC                                                  = 0xe281690,
    ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ                                = 0x76ca9d6,
    ATTR_IS_MASTER_NODE                                            = 0x1eb366d,
    ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS                          = 0x7836c10,
    ATTR_UPDATE_SLW_SCOM_TO_PHYP                                   = 0x6b84338,
    ATTR_FSP_PM_SPWUP_OHA_FLAG                                     = 0x1db941d,
    ATTR_SLW_IN_CHECKSTOP                                          = 0x2ab342e,
    ATTR_SPECIAL_WAKEUP_NEEDED                                     = 0xc1f79e8,
    ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM                          = 0xa4f1b0b,
    ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED                     = 0x15c8113,
    ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED                      = 0x6b48c0f,
    ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH                      = 0x5154cf0,
    ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH                      = 0x736309b,
    ATTR_MELTBOX_NEST_FREQ_MHZ                                     = 0xd950380,
    ATTR_MELTBOX_FREQ_PB                                           = 0x1b2a533,
    ATTR_MELTBOX_FREQ_X                                            = 0xc44fb48,
    ATTR_DEFAULT_NEST_FREQ_MHZ                                     = 0x2659dd9,
    ATTR_DEFAULT_FREQ_PB                                           = 0x925e5fc,
    ATTR_DEFAULT_FREQ_X                                            = 0x93430f7,
    ATTR_PROC_SLEEP_WINKLE_LID_ID                                  = 0xbcdda58,
    ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ                             = 0x2591cf9,
    ATTR_HW_DECONFIG                                               = 0xc3a80c1,
    ATTR_HB_HW_DECONFIG                                            = 0x65b4f2c,
    ATTR_HW_RECONFIG_CURRENT_ITR                                   = 0x1bcdba6,
    ATTR_FSP_HW_RECONFIG_MAX_COUNT                                 = 0x9fd70fb,
    ATTR_FMBX_DMA_STATE                                            = 0x6052228,
    ATTR_LOCK_SERVICE_LOCK                                         = 0x3c24379,
    ATTR_SBE_UPDATE                                                = 0xd6f5f46,
    ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB                         = 0x85bae1f,
    ATTR_PNOR_PARTITION_SIDE                                       = 0x2790722,
    ATTR_DEALLOCATED                                               = 0xf79b949,
    ATTR_BASE_PVR                                                  = 0x641e1d5,
    ATTR_IS_MASTER_EX                                              = 0xe6c4c3f,
    ATTR_OVERRIDE_FREQ_PROC_REFCLOCK                               = 0x2a254db,
    ATTR_PART_ID                                                   = 0x1e83d32,
    ATTR_I2C_SPEED                                                 = 0x1d1394c,
    ATTR_I2C_ADDRESS                                               = 0x8269cf5,
    ATTR_I2C_DEV_PATH                                              = 0xbaef615,
    ATTR_IS_IPL_DECONFIG_ALLOWED                                   = 0x9712229,
    ATTR_ISTEP_TIMEOUT                                             = 0xb846e46,
    ATTR_MAX_EID_ON_HBEL_FSP_A                                     = 0xd8793e4,
    ATTR_MAX_EID_ON_HBEL_FSP_B                                     = 0x630ca7e,
    ATTR_SPL_WAKEUP_STATE                                          = 0x5ef02dc,
    ATTR_FCO_SUPPORTED                                             = 0x317b181,
    ATTR_SMP_CONNECTION_STATE                                      = 0x69c6484,
    ATTR_TARGET_SCOMABLE                                           = 0x6766dce,
    ATTR_PROC_PCIE_CARD_WORKAROUND                                 = 0x097b409,
    ATTR_APPLY_PCIE_WORKAROUND                                     = 0x1c4fb0a,
    ATTR_PERST_CONTROL_PIN_NUMBERS                                 = 0xe00ac20,
    ATTR_PERST_CONTROL_DEVICE_PATHS                                = 0xdb6c503,
    ATTR_SYSTEM_CONFIG_TYPE                                        = 0xbf86bc1,
    ATTR_RT_DECONFIG_FAILED                                        = 0xb0b1979,
    ATTR_DECONFIG_BUT_NOT_GARDED                                   = 0x6311ded,
    ATTR_SPD_DRAM_DIMM_DEVICE_TYPE                                 = 0xa65395b,
    ATTR_CRITICAL_CORE_TEMP                                        = 0xc239aaf,
    ATTR_ENABLE_CORE_TEMP_CHECK                                    = 0x7a3283c,
    ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS                          = 0xf7f89d6,
    ATTR_IS_MASTER_CORE                                            = 0x0ed1fca,
    ATTR_FSP_SECURITY_MODE                                         = 0x6077b5a,
    ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH                       = 0x0596764,
    ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH                     = 0x81d3593,
    ATTR_FSP_DIMM_SPD_P0_PATH                                      = 0x01febfc,
    ATTR_FSP_DIMM_SPD_P1_PATH                                      = 0xf25be4a,
    ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH                     = 0x47f04dc,
    ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH                   = 0x32cf5cd,
    ATTR_FSP_A_DIMM_SPD_P0_PATH                                    = 0x2d95c98,
    ATTR_FSP_A_DIMM_SPD_P1_PATH                                    = 0x501a584,
    ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH                     = 0x1bd05b0,
    ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH                   = 0xd862f0b,
    ATTR_FSP_B_DIMM_SPD_P0_PATH                                    = 0xbe451d1,
    ATTR_FSP_B_DIMM_SPD_P1_PATH                                    = 0x238be14,
    ATTR_PRIMARY_SEEPROM_FAIL_COUNT                                = 0x2d75431,
    ATTR_SECONDARY_SEEPROM_FAIL_COUNT                              = 0xb7b2c40,
    ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT                    = 0xe551d52,
    ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT                  = 0xbdccc4d,
    ATTR_HOSTBOOT_TIME_OUT                                         = 0xf5f80be,
    ATTR_IS_TCES_MODE_ENABLE                                       = 0x8944ca8,
    ATTR_PRIMARY_MF_CLOCK                                          = 0xa780baa,
    ATTR_REDUNDANT_MF_CLOCKS                                       = 0x102ae5e,
    ATTR_TEMP_LOL_ERR_CNT                                          = 0xe9fe5d3,
    ATTR_DISABLE_SECURITY                                          = 0x945a086,
    ATTR_MAX_LOL_ERR_CNT                                           = 0xc4572fd,
    ATTR_DISABLE_SBE_RUNTIME_RECOVERY                              = 0xfd54264,
    ATTR_CLOCK_PLL_MUX                                             = 0xb441dca,
    ATTR_NVDIMM_AUTO_ARM                                           = 0x8ca929b,
    ATTR_NVDIMM_ENCRYPTION_ENABLE                                  = 0xe83f987,
    ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR                             = 0x8452e3a,
    ATTR_NVDIMM_ENCRYPTION_KEYS_FW                                 = 0xbdb2233,
    ATTR_LINK_TRAIN                                                = 0xa7ea6d2,
    ATTR_EFF_DIMM_SIZE                                             = 0xc1e40a4,
    ATTR_CEN_EFF_DIMM_SIZE                                         = 0x0e8df6e,
    ATTR_L2_HASCLOCKS                                              = 0xea7105b,
    ATTR_C0_EXEC_HASCLOCKS                                         = 0x46cca69,
    ATTR_C1_EXEC_HASCLOCKS                                         = 0xcadc29f,
    ATTR_C0_PC_HASCLOCKS                                           = 0xb639c30,
    ATTR_C1_PC_HASCLOCKS                                           = 0xae1e6c4,
    ATTR_L2_HASPOWER                                               = 0xdece9f6,
    ATTR_C0_HASPOWER                                               = 0x2010712,
    ATTR_C1_HASPOWER                                               = 0x5a8ea4b,
    ATTR_CEN_SPD_DRAM_DEVICE_TYPE                                  = 0xa8fffa4,
    ATTR_TARGET_IS_SCOMMABLE                                       = 0x7014d18,
    ATTR_PROC_PCIE_CACHE_INJ_MODE                                  = 0xa3e1a5f,
    ATTR_FREQ_A_MHZ                                                = 0x01204e8,
    ATTR_EFF_DIMM_RANKS_CONFIGED                                   = 0x092ecab,
    ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM                             = 0x0e715c8,
    ATTR_CEN_DQ_TO_DIMM_CONN_DQ                                    = 0xcd7817c,
    ATTR_MSS_FREQ                                                  = 0xe88d183,
    ATTR_CEN_MSS_FREQ_OVERRIDE                                     = 0x744b48b,
    ATTR_DD1_SLOW_PCI_REF_CLOCK                                    = 0xf4ac0bc,
    ATTR_CEN_MBA_PORT                                              = 0xacbf06c,
    ATTR_CEN_MBA_DIMM                                              = 0x9553606,
    ATTR_CEN_MSS_FREQ                                              = 0xe0cee5c,
    ATTR_VDN_BOOT_VOLTAGE                                          = 0xa2fea8f,
    ATTR_VDD_BOOT_VOLTAGE                                          = 0xbecf4b6,
    ATTR_VCS_BOOT_VOLTAGE                                          = 0xa68e8ba,
    ATTR_FREQ_BIAS_ULTRATURBO                                      = 0x0271124,
    ATTR_FREQ_BIAS_TURBO                                           = 0xd6ece64,
    ATTR_FREQ_BIAS_NOMINAL                                         = 0x1013c3d,
    ATTR_FREQ_BIAS_POWERSAVE                                       = 0xf99ae48,
    ATTR_COLLECT_ONLY_CLOCK_ON_DATA                                = 0xfded6f8,
};

/**
 *  @brief Digital Droop Sensors (DDS) Extreme Threshold Select Value per
 *	VPD point. a negative value below the DDS setting that will trigger
 *	droop event. This attibute overrides the Array of 9 entries-: 0:
 *	CF0; 1: CF1; 2: CF2; 3: CF3; 4: CF4; 5: CF5; 6: CF6; 7: CF7; 8:
 *	Enable If index 8 is non-zero, the other entries are considered
 *	valid. Producer: Override
 */
enum DDS_DROOP_EXTREME_OVERRIDE
{
    DDS_DROOP_EXTREME_OVERRIDE_OFF                              = 0x00000000,
    DDS_DROOP_EXTREME_OVERRIDE_8mV                              = 0x00000001,
    DDS_DROOP_EXTREME_OVERRIDE_16mV                             = 0x00000002,
    DDS_DROOP_EXTREME_OVERRIDE_24mV                             = 0x00000003,
    DDS_DROOP_EXTREME_OVERRIDE_32mV                             = 0x00000004,
    DDS_DROOP_EXTREME_OVERRIDE_40mV                             = 0x00000005,
    DDS_DROOP_EXTREME_OVERRIDE_48mV                             = 0x00000006,
    DDS_DROOP_EXTREME_OVERRIDE_56mV                             = 0x00000007,
    DDS_DROOP_EXTREME_OVERRIDE_64mV                             = 0x00000008,
    DDS_DROOP_EXTREME_OVERRIDE_72mV                             = 0x00000009,
    DDS_DROOP_EXTREME_OVERRIDE_80mV                             = 0x0000000A,
    DDS_DROOP_EXTREME_OVERRIDE_88mV                             = 0x0000000B,
    DDS_DROOP_EXTREME_OVERRIDE_92mV                             = 0x0000000C,
    DDS_DROOP_EXTREME_OVERRIDE_96mV                             = 0x0000000D,
    DDS_DROOP_EXTREME_OVERRIDE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Indicates the response of the DPLL frequency upon DDS events if
 *	the DDS is enabled. NONE -> DPLL Mode 2, JUMP_PROTECT -> DPLL Mode
 *	3, SLEW_MODE -> DPLL Mode 4 Producer: MRWB
 */
enum DDS_DPLL_SLEW_MODE
{
    DDS_DPLL_SLEW_MODE_NONE                                     = 0x00000000,
    DDS_DPLL_SLEW_MODE_JUMP_PROTECT                             = 0x00000001,
    DDS_DPLL_SLEW_MODE_SLEW_MODE                                = 0x00000002,
    DDS_DPLL_SLEW_MODE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Indicates whether to calculate trip offsets per core or per
 *	chip. Default is per chip. CHIP or CORE Producer: MRWB
 */
enum DDS_TRIP_MODE
{
    DDS_TRIP_MODE_CHIP                                          = 0x00000000,
    DDS_TRIP_MODE_CORE                                          = 0x00000001,
    DDS_TRIP_MODE_INVALID                                       = 0x000000FF,
};

/**
 *  @brief A bit vector to indicate which of FDCR items to interpolate.
 *	Multiple items can be set to be interpolated. Producer: MRWB
 */
enum DDS_TRIP_INTERPOLATION_CONTROL
{
    DDS_TRIP_INTERPOLATION_CONTROL_TRIP                         = 0x00000080,
    DDS_TRIP_INTERPOLATION_CONTROL_DATA0                        = 0x00000040,
    DDS_TRIP_INTERPOLATION_CONTROL_DATA1                        = 0x00000020,
    DDS_TRIP_INTERPOLATION_CONTROL_DATA2                        = 0x00000010,
    DDS_TRIP_INTERPOLATION_CONTROL_LARGE                        = 0x00000008,
    DDS_TRIP_INTERPOLATION_CONTROL_SMALL                        = 0x00000004,
    DDS_TRIP_INTERPOLATION_CONTROL_SLOPEA                       = 0x00000002,
    DDS_TRIP_INTERPOLATION_CONTROL_SLOPEB                       = 0x00000001,
    DDS_TRIP_INTERPOLATION_CONTROL_INVALID                      = 0x000000FF,
};

/**
 *  @brief Enables the PGPE Hcode to physically perform frequency and
 *	voltage based on parameters (eg #V VPD, system parameters, biases,
 *	VFRTs. etc). If OFF, PGPE provides an immedicate good response to
 *	Pstate/WOF IPC operations the OCC for firmware integration testing
 *	Consumer: p10_hcode_image_build.c -> PGPE Header field Platform
 *	default: ON
 */
enum PGPE_HCODE_FUNCTION_ENABLE
{
    PGPE_HCODE_FUNCTION_ENABLE_OFF                              = 0x00000000,
    PGPE_HCODE_FUNCTION_ENABLE_ON                               = 0x00000001,
    PGPE_HCODE_FUNCTION_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Enables pstate parameter block code to use the static #W data
 *	Consumer: p10_pstate_parameter_build.C Platform default:OFF
 */
enum POUND_W_STATIC_DATA_ENABLE
{
    POUND_W_STATIC_DATA_ENABLE_OFF                              = 0x00000000,
    POUND_W_STATIC_DATA_ENABLE_ON                               = 0x00000001,
    POUND_W_STATIC_DATA_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Enables pstate parameter block code to use the static #V data
 *	Consumer: p10_pstate_parameter_block.C Platform default:OFF
 */
enum POUND_V_STATIC_DATA_ENABLE
{
    POUND_V_STATIC_DATA_ENABLE_OFF                              = 0x00000000,
    POUND_V_STATIC_DATA_ENABLE_ON                               = 0x00000001,
    POUND_V_STATIC_DATA_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Enables pstate parameter block code to use the static AW data
 *	Consumer: p10_pstate_parameter_block.C Platform default:OFF
 */
enum AW_STATIC_DATA_ENABLE
{
    AW_STATIC_DATA_ENABLE_OFF                                   = 0x00000000,
    AW_STATIC_DATA_ENABLE_ON                                    = 0x00000001,
    AW_STATIC_DATA_ENABLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Enables pstate parameter block code to use the static IQ data
 *	Consumer: p10_pstate_parameter_block.C Platform default:OFF
 */
enum IQ_STATIC_DATA_ENABLE
{
    IQ_STATIC_DATA_ENABLE_OFF                                   = 0x00000000,
    IQ_STATIC_DATA_ENABLE_ON                                    = 0x00000001,
    IQ_STATIC_DATA_ENABLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Attribute in place to allow override of which POUNDV bucket to
 *	use to set data.
 */
enum POUNDV_BUCKET_NUM
{
    POUNDV_BUCKET_NUM_BUCKETA                                   = 0x00000001,
    POUNDV_BUCKET_NUM_BUCKETB                                   = 0x00000002,
    POUNDV_BUCKET_NUM_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Enables pstate parameter block code to use the static system vrt
 *	data Consumer: p10_pstate_parameter_build.C -> PGPE Hcode Platform
 *	default:OFF
 */
enum SYS_VRT_STATIC_DATA_ENABLE
{
    SYS_VRT_STATIC_DATA_ENABLE_OFF                              = 0x00000000,
    SYS_VRT_STATIC_DATA_ENABLE_ON                               = 0x00000001,
    SYS_VRT_STATIC_DATA_ENABLE_VDN_STEP_OFF                     = 0x00000002,
    SYS_VRT_STATIC_DATA_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Disables the validity checking of #V VPD content from causing
 *	IPL failures. OFF:Will enable PStates given all validity checks
 *	pass. If validity checks a failure is log and error reaction will
 *	occur (eg IPL failure) ON: Will #V validity checking of #V from
 *	causing IPL to halt. check failures will error logs and Pstates
 *	(including other functions) will be disabled. Producer: Override
 *	Consumers: p10_pstate_parameter_build
 */
enum SYSTEM_POUNDV_VALIDITY_HALT_DISABLE
{
    SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_OFF                     = 0x00000000,
    SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_ON                      = 0x00000001,
    SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_INVALID                 = 0x000000FF,
};

/**
 *  @brief Debug modes supported for QME Scan layout in HOMER.
 */
enum SYSTEM_RING_DBG_MODE
{
    SYSTEM_RING_DBG_MODE_SCAN_RING_NO_DEBUG                     = 0x00000000,
    SYSTEM_RING_DBG_MODE_SCAN_RING_TRACE_DEBUG                  = 0x00000001,
    SYSTEM_RING_DBG_MODE_SCAN_RING_DEEP_DEBUG                   = 0x00000002,
    SYSTEM_RING_DBG_MODE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Switch to enable or disable Power Management Malfunction Alert
 *	Handling on platform support. e.g. True for PHYP based systems and
 *	False for based depending on support available. Producer:
 *	Initialized by Hostboot firmware based on platform support Read by
 *	p10_pm_stop_gpe_init.C
 */
enum PM_MALF_ALERT_ENABLE
{
    PM_MALF_ALERT_ENABLE_FALSE                                  = 0x00000000,
    PM_MALF_ALERT_ENABLE_TRUE                                   = 0x00000001,
    PM_MALF_ALERT_ENABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Switch to enable or disable Power Management Complex FFDC
 *	collection during the PM Complex Halt flow to HOMER to assist with
 *	failure analysis and recovery. Producer: HB must set or reset this
 *	based on the platform use-case and p10_pm_halt.C, p10_pm_callout.C
 */
enum PM_HALT_FFDC_ENABLE
{
    PM_HALT_FFDC_ENABLE_FALSE                                   = 0x00000000,
    PM_HALT_FFDC_ENABLE_TRUE                                    = 0x00000001,
    PM_HALT_FFDC_ENABLE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Disables the enablement of Digital Droop Sensors (DDS) in the
 *	system. Producer:MRW Consumers:p10_pstate_parameter_build -> QME
 *	Pstate parameter block ????
 */
enum SYSTEM_DDS_DISABLE
{
    SYSTEM_DDS_DISABLE_OFF                                      = 0x00000000,
    SYSTEM_DDS_DISABLE_ON                                       = 0x00000001,
    SYSTEM_DDS_DISABLE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Producer:Override Consumers:p10_pstate_parameter_build -> QME
 *	Pstate parameter block ????
 */
enum SYSTEM_DDS_FREQ_ENABLE
{
    SYSTEM_DDS_FREQ_ENABLE_OFF                                  = 0x00000000,
    SYSTEM_DDS_FREQ_ENABLE_ON                                   = 0x00000001,
    SYSTEM_DDS_FREQ_ENABLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Control XGPE boot: ON : enable xgpe to boot OFF: disable xgpe
 *	boot Producer:Override Consumers: p10_pstate_parameter_build and
 *	p10_pm_xgpe_init
 */
enum SYSTEM_AUXILLARY_MODE
{
    SYSTEM_AUXILLARY_MODE_ON                                    = 0x00000000,
    SYSTEM_AUXILLARY_MODE_OFF                                   = 0x00000001,
    SYSTEM_AUXILLARY_MODE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Controls the mode of Pstate Protocol for testing. ON: Boots the
 *	PGPE in "OCC Mode" but does NOT start the Pstate protocol OFF: Does
 *	NOT boot the PGPE Boots the PGPE and automatically starts the
 *	Pstate protocol. PMCR to move Pstates are honored.
 *	Producer:Override Consumers: p10_pstate_parameter_build and
 *	p10_pm_pstate_gpe_init
 */
enum SYSTEM_PSTATES_MODE
{
    SYSTEM_PSTATES_MODE_ON                                      = 0x00000000,
    SYSTEM_PSTATES_MODE_OFF                                     = 0x00000001,
    SYSTEM_PSTATES_MODE_AUTO                                    = 0x00000002,
    SYSTEM_PSTATES_MODE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief pm_suspend_procedure will first put the system in safe mode and
 *	we have 2 methods to do that, one is thru occ and if that fails
 *	then will do thru pgpe. On awan/cronus if we want to test
 *	procedure, OCC won't be running, hence will use this attribute to
 *	disable occ method Producer:Override Consumers:
 *	p10_suspend_powman.C
 */
enum SYSTEM_SUSPEND_OCC_MODE
{
    SYSTEM_SUSPEND_OCC_MODE_OFF                                 = 0x00000000,
    SYSTEM_SUSPEND_OCC_MODE_ON                                  = 0x00000001,
    SYSTEM_SUSPEND_OCC_MODE_INVALID                             = 0x000000FF,
};

/**
 *  @brief Disables the enablement of resonant clocking in the system.
 *	Producer: Override Consumers: p10_pstate_parameter_build to clear
 *	the flag for PGPE reaction
 */
enum SYSTEM_RESCLK_DISABLE
{
    SYSTEM_RESCLK_DISABLE_OFF                                   = 0x00000000,
    SYSTEM_RESCLK_DISABLE_ON                                    = 0x00000001,
    SYSTEM_RESCLK_DISABLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Enables resonant clocks in the system at istep4 Producer:
 *	Override Consumers: p10_hcd_core_startclocks.C
 */
enum SYSTEM_RESCLK_ISTEP4_ENABLE
{
    SYSTEM_RESCLK_ISTEP4_ENABLE_OFF                             = 0x00000000,
    SYSTEM_RESCLK_ISTEP4_ENABLE_ON                              = 0x00000001,
    SYSTEM_RESCLK_ISTEP4_ENABLE_INVALID                         = 0x000000FF,
};

/**
 *  @brief Disables RVRM enablement in the system Producer: Override
 *	Consumers: p10_build_pstate_datablock -> Pstate Parameter Block
 *	(PPB)
 */
enum SYSTEM_RVRM_DISABLE
{
    SYSTEM_RVRM_DISABLE_OFF                                     = 0x00000000,
    SYSTEM_RVRM_DISABLE_ON                                      = 0x00000001,
    SYSTEM_RVRM_DISABLE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Disables Work Load Optimized Frequency (WOF) algorithms to
 *	modify frequency active core count and other inputs. OFF:Will
 *	enable WOF given all validity check pass. If validity checks fail,
 *	be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD:
 *	as but skips any validity checking of the design level (lab use
 *	Producer: Override Consumers: p10_build_pstate_datablock -> Pstate
 *	Parameter Block (PPB) for
 */
enum SYSTEM_WOF_DISABLE
{
    SYSTEM_WOF_DISABLE_OFF                                      = 0x00000000,
    SYSTEM_WOF_DISABLE_ON                                       = 0x00000001,
    SYSTEM_WOF_DISABLE_OFF_SKIP_DD                              = 0x00000002,
    SYSTEM_WOF_DISABLE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Disables Workload Optimized Voltage (WOV) overvolting algorithms
 *	to compensate for work-load induced droops. OFF: Will enable WOV
 *	overvolting given all validity check pass. If validity WOV
 *	overvolting will be disabled for the present IPL. ON:Will disable
 *	overvolting Producer: Override Consumers:
 *	p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
 */
enum SYSTEM_WOV_OVERV_DISABLE
{
    SYSTEM_WOV_OVERV_DISABLE_OFF                                = 0x00000000,
    SYSTEM_WOV_OVERV_DISABLE_ON                                 = 0x00000001,
    SYSTEM_WOV_OVERV_DISABLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Disables Workload Optimized Voltage (WOV) undervolting
 *	algorithms which voltage below the value calculated from VPD.
 *	OFF:Will enable WOV undervolting given all validity check pass. If
 *	validity WOV undervolting will be disabled for the present IPL. ON:
 *	Will disable undervolting Producer: Override Consumers:
 *	p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
 */
enum SYSTEM_WOV_UNDERV_DISABLE
{
    SYSTEM_WOV_UNDERV_DISABLE_OFF                               = 0x00000000,
    SYSTEM_WOV_UNDERV_DISABLE_ON                                = 0x00000001,
    SYSTEM_WOV_UNDERV_DISABLE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Disables Workload Optimized Frequency Throttle Control Loop
 *	OFF:Will enable WOF Throttle control loop is validity check pass.
 *	If validity check fails, then WOF Throttle control loop will be
 *	disabled for the present IPL. ON: Will disable throttle control
 *	loop Producer: Override Consumers: p10_build_pstate_datablock ->
 *	Pstate Parameter Block (PPB)
 */
enum WOF_THROTTLE_CONTROL_LOOP_DISABLE
{
    WOF_THROTTLE_CONTROL_LOOP_DISABLE_OFF                       = 0x00000000,
    WOF_THROTTLE_CONTROL_LOOP_DISABLE_ON                        = 0x00000001,
    WOF_THROTTLE_CONTROL_LOOP_DISABLE_INVALID                   = 0x000000FF,
};

/**
 *  @brief ON: Disables PGPE Throttle CI loop. Raw overage value written to
 *	WCOR. Bit in WCOR indicates the Overage has subsided and by how
 *	much. OFF: Allows PGPE Throttle Loop to be enabled. Producer:
 *	Override Consumers: p10_build_pstate_datablock -> Pstate Parameter
 *	Block (PPB)
 */
enum WOF_PITCH_ENABLE
{
    WOF_PITCH_ENABLE_OFF                                        = 0x00000000,
    WOF_PITCH_ENABLE_ON                                         = 0x00000001,
    WOF_PITCH_ENABLE_INVALID                                    = 0x000000FF,
};

/**
 *  @brief If WOF Throttle Control Loop is enabled, then selects the mode
 *	to update throttle control values. BINARY: Will update the throttle
 *	control values by half the current value of throttle. DECINC: Will
 *	update throttle control value by one in each step. Producer:
 *	Override Consumers: p10_build_pstate_datablock -> Pstate Parameter
 *	Block (PPB)
 */
enum WOF_THROTTLE_CONTROL_LOOP_MODE
{
    WOF_THROTTLE_CONTROL_LOOP_MODE_BINARY                       = 0x00000000,
    WOF_THROTTLE_CONTROL_LOOP_MODE_DECINC                       = 0x00000001,
    WOF_THROTTLE_CONTROL_LOOP_MODE_INVALID                      = 0x000000FF,
};

/**
 *  @brief Disables Over Current Sensor functions OFF:Will enable Over
 *	Current Sensor (OCS) given all validity check pass. If checks fail,
 *	WOV undervolting will be disabled for the present IPL. ON: Will
 *	disable OCS and WOF (TBD on the this phase in of validity)
 *	Producer: Override Consumers: p10_pstate_parameter_build -> PGPE
 *	Hcode
 */
enum SYSTEM_OCS_DISABLE
{
    SYSTEM_OCS_DISABLE_OFF                                      = 0x00000000,
    SYSTEM_OCS_DISABLE_ON                                       = 0x00000001,
    SYSTEM_OCS_DISABLE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Disables PGPE from reading the rail currents and populating
 *	content to the OCC. OFF:Will enable the PGPE Current reading
 *	function ON: Will disable the PGPE Current reading function. The
 *	OCC SRAM will NOT be updated with any readings. Producer: Override
 *	Consumers: p10_pstate_parameter_build -> PGPE Hcode
 */
enum SYSTEM_PGPE_CURRENT_READ_DISABLE
{
    SYSTEM_PGPE_CURRENT_READ_DISABLE_OFF                        = 0x00000000,
    SYSTEM_PGPE_CURRENT_READ_DISABLE_ON                         = 0x00000001,
    SYSTEM_PGPE_CURRENT_READ_DISABLE_INVALID                    = 0x000000FF,
};

/**
 *  @brief Enables the PGPE to clip Pstates based on the sibling Dual Chip
 *	Module (DCM) Pstate value to have the combination generally track.
 *	The DCM values are NOT interlocked as this is to aid in thermal
 *	management. Producer: p10_build_pstate_datablock Consumers: PGPE
 *	HCode
 */
enum WOF_DCM_TRACKING_ENABLE
{
    WOF_DCM_TRACKING_ENABLE_FALSE                               = 0x00000000,
    WOF_DCM_TRACKING_ENABLE_TRUE                                = 0x00000001,
    WOF_DCM_TRACKING_ENABLE_INVALID                             = 0x000000FF,
};

/**
 *  @brief Defines the mode of WOF checking in relationship to system
 *	reaction under firmware. FAIL - if not ATTR_SYSTEM_WOF_DISABLE,
 *	fails the IPL. INFO - if not ATTR_SYSTEM_WOF_DISABLE, Info error
 *	log; WOF is disabled; IPL continues. WARN - if not
 *	ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error logs,
 *	WOF is disabled; IPL continues. OFF - no checking performed; IPL
 *	continues. WOF is disabled;. Producer: Override Consumers:
 *	p10_pstate_parameter_build
 */
enum SYSTEM_WOF_VALIDATION_MODE
{
    SYSTEM_WOF_VALIDATION_MODE_FAIL                             = 0x00000000,
    SYSTEM_WOF_VALIDATION_MODE_INFO                             = 0x00000001,
    SYSTEM_WOF_VALIDATION_MODE_WARN                             = 0x00000002,
    SYSTEM_WOF_VALIDATION_MODE_OFF                              = 0x00000003,
    SYSTEM_WOF_VALIDATION_MODE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Defines the mode of WOF checking in relationship to system
 *	reaction under Cronus. FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails
 *	the IPL. INFO - if not ATTR_SYSTEM_WOF_DISABLE, Info error log; WOF
 *	is disabled; IPL continues. WARN - if not ATTR_SYSTEM_WOF_DISABLE,
 *	error messages to traces; no error logs, WOF is disabled; IPL
 *	continues. OFF - no checking performed; IPL continues. WOF is
 *	disabled;. Producer: Override Consumers: p10_pstate_parameter_build
 */
enum SYSTEM_WOF_LAB_VALIDATION_MODE
{
    SYSTEM_WOF_LAB_VALIDATION_MODE_FAIL                         = 0x00000000,
    SYSTEM_WOF_LAB_VALIDATION_MODE_INFO                         = 0x00000001,
    SYSTEM_WOF_LAB_VALIDATION_MODE_WARN                         = 0x00000002,
    SYSTEM_WOF_LAB_VALIDATION_MODE_OFF                          = 0x00000003,
    SYSTEM_WOF_LAB_VALIDATION_MODE_INVALID                      = 0x000000FF,
};

/**
 *  @brief Defines the mode of #V checking in relationship to system
 *	reaction under FW FAIL - Fails the IPL (product default). INFO -
 *	Info error log; Pstates are disabled; IPL continues. WARN - Error
 *	messages to traces; no error logs, Pstates are disabled (as #V is
 *	bad), IPL continues. OFF - no checking performed; IPL continues.
 *	Pstates are disabled. Producer: Override Consumers:
 *	p10_pstate_parameter_build
 */
enum SYSTEM_PDV_VALIDATION_MODE
{
    SYSTEM_PDV_VALIDATION_MODE_FAIL                             = 0x00000000,
    SYSTEM_PDV_VALIDATION_MODE_INFO                             = 0x00000001,
    SYSTEM_PDV_VALIDATION_MODE_WARN                             = 0x00000002,
    SYSTEM_PDV_VALIDATION_MODE_OFF                              = 0x00000003,
    SYSTEM_PDV_VALIDATION_MODE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Defines the mode of #V checking in relationship to system
 *	reaction under Cronus FAIL - Fails the IPL (product default). INFO
 *	- Info error log; Pstates are disabled; IPL continues. WARN - Error
 *	messages to traces; no error logs, Pstates are disabled (as #V is
 *	bad), IPL continues. OFF - no checking performed; IPL continues.
 *	Pstates are disabled. Producer: Override Consumers:
 *	p10_pstate_parameter_build
 */
enum SYSTEM_PDV_LAB_VALIDATION_MODE
{
    SYSTEM_PDV_LAB_VALIDATION_MODE_FAIL                         = 0x00000000,
    SYSTEM_PDV_LAB_VALIDATION_MODE_INFO                         = 0x00000001,
    SYSTEM_PDV_LAB_VALIDATION_MODE_WARN                         = 0x00000002,
    SYSTEM_PDV_LAB_VALIDATION_MODE_OFF                          = 0x00000003,
    SYSTEM_PDV_LAB_VALIDATION_MODE_INVALID                      = 0x000000FF,
};

/**
 *  @brief Defines the mode of #W checking in relationship to system
 *	reaction FAIL - if not ATTR_SYSTEM_DDS_DISABLE, fails the IPL
 *	(product default);. INFO - if not ATTR_SYSTEM_DDS_DISABLE, error
 *	messages to traces; Info error log; DDSs are disabled; IPL
 *	continues. WARN - if not ATTR_SYSTEM_DDS_DISABLE, error messages to
 *	traces; no error logs, DDS are disabled, IPL continues. OFF - no
 *	checking performed; IPL continues. DDS are disabled.
 */
enum SYSTEM_PDW_VALIDATION_MODE
{
    SYSTEM_PDW_VALIDATION_MODE_FAIL                             = 0x00000000,
    SYSTEM_PDW_VALIDATION_MODE_INFO                             = 0x00000001,
    SYSTEM_PDW_VALIDATION_MODE_WARN                             = 0x00000002,
    SYSTEM_PDW_VALIDATION_MODE_OFF                              = 0x00000003,
    SYSTEM_PDW_VALIDATION_MODE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Defines the mode of IQ checking in relationship to system
 *	reaction FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails the IPL
 *	(product default); INFO - if not ATTR_SYSTEM_WOF_DISABLE, error
 *	messages to traces; Info error log; WOF is disabled; IPL continues.
 *	WARN - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no
 *	error logs, WOF is disabled, IPL continues. OFF - no checking
 *	performed; IPL continues. WOF is disabled..
 */
enum SYSTEM_IQ_VALIDATION_MODE
{
    SYSTEM_IQ_VALIDATION_MODE_FAIL                              = 0x00000000,
    SYSTEM_IQ_VALIDATION_MODE_INFO                              = 0x00000001,
    SYSTEM_IQ_VALIDATION_MODE_WARN                              = 0x00000002,
    SYSTEM_IQ_VALIDATION_MODE_OFF                               = 0x00000003,
    SYSTEM_IQ_VALIDATION_MODE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Defines the mode of #V TDP current checking via Model Data(6) in
 *	relationship to system reaction under firmware. FAIL - if not
 *	ATTR_SYSTEM_WOF_DISABLE, fails the IPL INFO - if not
 *	ATTR_SYSTEM_WOF_DISABLE, error messages to traces; Info error log;
 *	WOF is disabled; IPL continues(product default) WARN - if not
 *	ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error logs,
 *	WOF is disabled, IPL continues. OFF - no checking performed.
 */
enum SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE
{
    SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_FAIL                 = 0x00000000,
    SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_INFO                 = 0x00000001,
    SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_WARN                 = 0x00000002,
    SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_OFF                  = 0x00000003,
    SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_INVALID              = 0x000000FF,
};

/**
 *  @brief Defines the mode of #V TDP current checking via Model Data(6) in
 *	relationship to system reaction under Cronus. FAIL - if not
 *	ATTR_SYSTEM_WOF_DISABLE, fails the IPL INFO - if not
 *	ATTR_SYSTEM_WOF_DISABLE, error messages to traces; Info error log;
 *	WOF is disabled; IPL continues WARN - if not
 *	ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error logs,
 *	WOF is disabled, IPL continues.(lab default) OFF - no checking
 *	performed.
 */
enum SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE
{
    SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_FAIL             = 0x00000000,
    SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_INFO             = 0x00000001,
    SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_WARN             = 0x00000002,
    SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_OFF              = 0x00000003,
    SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_INVALID          = 0x000000FF,
};

/**
 *  @brief Defines which of the PSS chip selects (0 or 1) that the APSS is
 *	connected Producer: Machine Readable Workbook Consumer:
 *	p10_pm_pss_init
 */
enum SPIPSS_SELECT
{
    SPIPSS_SELECT_NONE                                          = 0x000000FF,
    SPIPSS_SELECT_CS0                                           = 0x00000000,
    SPIPSS_SELECT_CS1                                           = 0x00000001,
};

/**
 *  @brief The percentage (in 0.1% units) of VDD power that is attributed
 *	to the indicated region associated with each core/cache set.
 *	[index] ->8 entries-: 0: CORE; 1: CACHE_BASE; // This includes both
 *	clock and snoop AC power 2: RACETRACK_PER_CORE; // Amount of
 *	racetrack allotment per coore 3: MMA; 4: Reserved; 5: Reserved; 6:
 *	Reserved; 7: Reserved; Consumer: p10_pstate_parameter_build -> PGPE
 *	Hcode
 */
enum WOF_VRATIO_VDD_10THPCT
{
    WOF_VRATIO_VDD_10THPCT_CORE                                 = 0x00000000,
    WOF_VRATIO_VDD_10THPCT_CACHE_BASE                           = 0x00000001,
    WOF_VRATIO_VDD_10THPCT_RACETRACK_PER_CORE                   = 0x00000002,
    WOF_VRATIO_VDD_10THPCT_MMA                                  = 0x00000003,
    WOF_VRATIO_VDD_10THPCT_RESERVED4                            = 0x00000004,
    WOF_VRATIO_VDD_10THPCT_RESERVED5                            = 0x00000005,
    WOF_VRATIO_VDD_10THPCT_RESERVED6                            = 0x00000006,
    WOF_VRATIO_VDD_10THPCT_RESERVED7                            = 0x00000007,
    WOF_VRATIO_VDD_10THPCT_INVALID                              = 0x0000FFFF,
};

/**
 *  @brief The percentage (in 0.1% units) of VCS power that is attributed
 *	to the indicated region associated with each core/cache set.
 *	[index] ->8 entries-: 0: CORE; 1: CACHE_BASE; // This includes both
 *	clock and snoop AC power 2: Reserved2; 3: Reserved3; 4: Reserved4;
 *	5: Reserved5; 6: Reserved6; 7: Reserved7; Consumer:
 *	p10_pstate_parameter_build -> PGPE Hcode
 */
enum WOF_VRATIO_VCS_10THPCT
{
    WOF_VRATIO_VCS_10THPCT_CORE                                 = 0x00000000,
    WOF_VRATIO_VCS_10THPCT_CACHE_BASE                           = 0x00000001,
    WOF_VRATIO_VCS_10THPCT_RESERVED2                            = 0x00000002,
    WOF_VRATIO_VCS_10THPCT_RESERVED3                            = 0x00000003,
    WOF_VRATIO_VCS_10THPCT_RESERVED4                            = 0x00000004,
    WOF_VRATIO_VCS_10THPCT_RESERVED5                            = 0x00000005,
    WOF_VRATIO_VCS_10THPCT_RESERVED6                            = 0x00000006,
    WOF_VRATIO_VCS_10THPCT_RESERVED7                            = 0x00000007,
    WOF_VRATIO_VCS_10THPCT_INVALID                              = 0x0000FFFF,
};

/**
 *  @brief Enables DDS calibration in creating the Pstate Parameter Block.
 *	In this mode, the following are inherently disabled: - PStates -
 *	DDS (as these are mangaged by other means in this mode) - WOF The
 *	functions that are enabled are: - AVSBus - Undervolting -
 *	Overvolting
 */
enum SYSTEM_WOV_DDS_CALIBRATION_ENABLE
{
    SYSTEM_WOV_DDS_CALIBRATION_ENABLE_OFF                       = 0x00000000,
    SYSTEM_WOV_DDS_CALIBRATION_ENABLE_ON                        = 0x00000001,
    SYSTEM_WOV_DDS_CALIBRATION_ENABLE_INVALID                   = 0x000000FF,
};

/**
 *  @brief Allows the OCS function to operate without real DDS enablement
 *	for unit testing purposes.
 */
enum OCS_WITH_DDS_DISABLE
{
    OCS_WITH_DDS_DISABLE_OFF                                    = 0x00000000,
    OCS_WITH_DDS_DISABLE_ON                                     = 0x00000001,
    OCS_WITH_DDS_DISABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Allows the WOV Overvolting function to operate without real DDS
 *	enablement for unit testing purposes.
 */
enum WOV_OVERV_WITH_DDS_DISABLE
{
    WOV_OVERV_WITH_DDS_DISABLE_OFF                              = 0x00000000,
    WOV_OVERV_WITH_DDS_DISABLE_ON                               = 0x00000001,
    WOV_OVERV_WITH_DDS_DISABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Disable the Fast Fmax Slewing function of the DPLL when in
 *	SLEW_MODE Producer: Override
 */
enum DDS_DPLL_FMAX_FAST_DISABLE
{
    DDS_DPLL_FMAX_FAST_DISABLE_OFF                              = 0x00000000,
    DDS_DPLL_FMAX_FAST_DISABLE_ON                               = 0x00000001,
    DDS_DPLL_FMAX_FAST_DISABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Disable the Fast Fmin Slewing function of the DPLL when in
 *	SLEW_MODE Producer: Override
 */
enum DDS_DPLL_FMIN_FAST_DISABLE
{
    DDS_DPLL_FMIN_FAST_DISABLE_OFF                              = 0x00000000,
    DDS_DPLL_FMIN_FAST_DISABLE_ON                               = 0x00000001,
    DDS_DPLL_FMIN_FAST_DISABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief The powerbus frequency that should be used to locate a valid #V
 *	bucket in Module VPD if the actual ATTR_FREQ_PB_MHZ value isn't
 *	present.
 */
enum FREQ_PB_MHZ_POUNDV_FALLBACK
{
    FREQ_PB_MHZ_POUNDV_FALLBACK_NO_FALLBACK                     = 0x00000000,
    FREQ_PB_MHZ_POUNDV_FALLBACK_1600                            = 0x00000640,
    FREQ_PB_MHZ_POUNDV_FALLBACK_1866                            = 0x0000074A,
    FREQ_PB_MHZ_POUNDV_FALLBACK_2000                            = 0x000007D0,
    FREQ_PB_MHZ_POUNDV_FALLBACK_2133                            = 0x00000855,
    FREQ_PB_MHZ_POUNDV_FALLBACK_2400                            = 0x00000960,
    FREQ_PB_MHZ_POUNDV_FALLBACK_INVALID                         = 0xFFFFFFFF,
};

/**
 *  @brief Enables the platform mode where the most recent PMCR update will
 *	be the controlling value for Pstate changes. If disabled, the
 *	legacy "fastest one wins" algorithm is used. Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header QME attribute
 */
enum PMCR_MOST_RECENT_MODE
{
    PMCR_MOST_RECENT_MODE_FALSE                                 = 0x00000000,
    PMCR_MOST_RECENT_MODE_TRUE                                  = 0x00000001,
    PMCR_MOST_RECENT_MODE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Set when QMCR[FUSED_CORE_PAIR_MODE] is to be set by QME Hcode
 */
enum FUSED_CORE_PAIRED_MODE_ENABLED
{
    FUSED_CORE_PAIRED_MODE_ENABLED_FALSE                        = 0x00000000,
    FUSED_CORE_PAIRED_MODE_ENABLED_TRUE                         = 0x00000001,
    FUSED_CORE_PAIRED_MODE_ENABLED_INVALID                      = 0x000000FF,
};

/**
 *  @brief Disables the MMA power-off function within the QME. OFF: Enables
 *	the QME MMA power-off funtion as further controlled by
 *	ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS. ON: Disables the
 *	dynamic MMA power-off function within the QME The MMA will be on if
 *	the core is powered on. Producer: Override Consumers: QME Hcode
 */
enum SYSTEM_MMA_POWEROFF_DISABLE
{
    SYSTEM_MMA_POWEROFF_DISABLE_OFF                             = 0x00000000,
    SYSTEM_MMA_POWEROFF_DISABLE_ON                              = 0x00000001,
    SYSTEM_MMA_POWEROFF_DISABLE_INVALID                         = 0x000000FF,
};

/**
 *  @brief Disables the MMA power-on function within the QME. This can be
 *	use for that will NEVER have MMA based applications running so as
 *	to save the MMA OFF: Enables the QME MMA power-on funtion. This
 *	will have the MMA powered on in istep 16 and then controlled by
 *	ATTR_SYSTEM_MMA_POWEROFF_DISABLE and thereafter. ON: Disables the
 *	MMA power-on function and leaves the MMA permenantly off. core will
 *	take illegal instruction interrupt on MMA instruction that are
 *	dispatched. Producer: Override Consumers: QME Hcode
 */
enum SYSTEM_MMA_POWERON_DISABLE
{
    SYSTEM_MMA_POWERON_DISABLE_OFF                              = 0x00000000,
    SYSTEM_MMA_POWERON_DISABLE_ON                               = 0x00000001,
    SYSTEM_MMA_POWERON_DISABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Enables the updating of the DDS threshold settings upon Pstate
 *	changes. Producer: Override/Lab Consumers:
 *	p10_build_pstate_datablock
 */
enum DDS_THRESHOLD_PSTATE_ENABLE
{
    DDS_THRESHOLD_PSTATE_ENABLE_OFF                             = 0x00000000,
    DDS_THRESHOLD_PSTATE_ENABLE_ON                              = 0x00000001,
    DDS_THRESHOLD_PSTATE_ENABLE_INVALID                         = 0x000000FF,
};

/**
 *  @brief Enables coarse throttle reaction to DDS events. Producer:
 *	Override/Lab Consumers: p10_build_pstate_datablock
 */
enum DDS_COARSE_THROTTLE_ENABLE
{
    DDS_COARSE_THROTTLE_ENABLE_OFF                              = 0x00000000,
    DDS_COARSE_THROTTLE_ENABLE_ON                               = 0x00000001,
    DDS_COARSE_THROTTLE_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Enables frequency jump reaction to DDS events. Producer:
 *	Override/Lab Consumers: p10_build_pstate_datablock
 */
enum DDS_FREQ_JUMP_ENABLE
{
    DDS_FREQ_JUMP_ENABLE_OFF                                    = 0x00000000,
    DDS_FREQ_JUMP_ENABLE_ON                                     = 0x00000001,
    DDS_FREQ_JUMP_ENABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enables DDS biasing through the use of the #W ALT frequency and
 *	voltage data. Producer: Override/Lab Consumers:
 *	p10_build_pstate_datablock
 */
enum DDS_BIAS_ENABLE
{
    DDS_BIAS_ENABLE_OFF                                         = 0x00000000,
    DDS_BIAS_ENABLE_ON                                          = 0x00000001,
    DDS_BIAS_ENABLE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Mode of the throttle control function. NONE - No throttling
 *	ICTMN - Instruction Core Throttle / M/N windows PP_PCT_RED - Power
 *	Proxy Percent Reduction PP_TARGET - Power Proxy Target Consumer:
 *	p10_pstate_parameter_build -> Local Parameter Block -> QME Hcode
 */
enum THROTTLE_MODE
{
    THROTTLE_MODE_NONE                                          = 0x00000000,
    THROTTLE_MODE_ICTMN                                         = 0x00000001,
    THROTTLE_MODE_PP_PCT_RED                                    = 0x00000002,
    THROTTLE_MODE_PP_TARGET                                     = 0x00000003,
    THROTTLE_MODE_INVALID                                       = 0xFFFFFFFF,
};

/**
 *  @brief Enables a system checkstop upon entering safe mode for debug.
 *	Producer: Override/Lab Consumers: p10_pm_pgpe_init
 */
enum SAFE_MODE_XSTOP
{
    SAFE_MODE_XSTOP_OFF                                         = 0x00000000,
    SAFE_MODE_XSTOP_ON                                          = 0x00000001,
    SAFE_MODE_XSTOP_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Enable the use of the #V Fmax value within each chip in the
 *	system. In this mode, Pstate 0 is determined by finding the
 *	maximimum of all #V FMax values. If this attribute is OFF, Pstate 0
 *	is set by the UltraTurbo value that is to be common across all
 *	parts in the system as they must be from the same sort. Default:
 *	OFF Producer: MRW Consumers: p10_pstate_parameter_block RTC:
 *	269546: remove the FMax Enable mode control Changing the default to
 *	ON until the RTC removes all support.
 */
enum SYSTEM_FMAX_ENABLE
{
    SYSTEM_FMAX_ENABLE_OFF                                      = 0x00000000,
    SYSTEM_FMAX_ENABLE_ON                                       = 0x00000001,
    SYSTEM_FMAX_ENABLE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Value of attribute determines if DLR is done or a static
 *	computation is done with updated dynamic configuration.
 */
enum WOF_IO_POWER_MODE
{
    WOF_IO_POWER_MODE_STATIC                                    = 0x00000000,
    WOF_IO_POWER_MODE_DYNAMIC                                   = 0x00000001,
    WOF_IO_POWER_MODE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Indicates whether to consider pstate to freq offset for p10 vs
 *	pnext systems Producer: MRWB
 */
enum EXTENDED_FREQ_MODE
{
    EXTENDED_FREQ_MODE_NEW_FREQ                                 = 0x00000001,
    EXTENDED_FREQ_MODE_OLD_FREQ                                 = 0x00000002,
    EXTENDED_FREQ_MODE_USE_RDP                                  = 0x00000003,
    EXTENDED_FREQ_MODE_INVALID                                  = 0xFFFFFFFF,
};

/**
 *  @brief Only applicable under Cronus If ON, the starting of the PPC405
 *	is skipped during PM Complex start. Producer:Override Consumers:
 *	p10_pm_start.C
 */
enum OCC_START_DISABLE
{
    OCC_START_DISABLE_OFF                                       = 0x00000000,
    OCC_START_DISABLE_ON                                        = 0x00000001,
    OCC_START_DISABLE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Defines how to intrepret
 *	ATTR_WTH_OVERRIDE_EFFICIENCY_MODE_IDLE_TIMES and
 *	EFFICIENCY_MODE_IDLE_THRESHOLDS attributes as a override for the
 *	WTH Flags[Efficiency Mode Algorithm] field. CEFF: Ceff based
 *	adjustment. UTIL: Utilization based adjustment. Producer: MRW to
 *	override the WOF Tables used for the matched core count. Consumer:
 *	p10_pm_utils.C
 */
enum WTH_OVERRIDE_EFFICIENCY_ALG
{
    WTH_OVERRIDE_EFFICIENCY_ALG_UTIL                            = 0x00000000,
    WTH_OVERRIDE_EFFICIENCY_ALG_CEFF                            = 0x00000001,
    WTH_OVERRIDE_EFFICIENCY_ALG_INVALID                         = 0x000000FF,
};

/**
 *  @brief Set to indicate clock-start/instruction execution in
 *	cache-contained or chip-contained mode will be managed by runn
 *	Provided by: platform (FW platforms init to OFF)
 */
enum RUNN_MODE
{
    RUNN_MODE_OFF                                               = 0x00000000,
    RUNN_MODE_ON                                                = 0x00000001,
    RUNN_MODE_INVALID                                           = 0x000000FF,
};

/**
 *  @brief Bitvector of which threads to sreset via decrementer in
 *	cache-contained or chip-contained mode Bitmap: 0bxxxx00000000 T0
 *	-------'||| T1 --------'|| T2 ---------'| T3 ----------'
 */
enum RUNN_SRESET_THREADS_BVEC
{
    RUNN_SRESET_THREADS_BVEC_T0                                 = 0x00000080,
    RUNN_SRESET_THREADS_BVEC_T1                                 = 0x00000040,
    RUNN_SRESET_THREADS_BVEC_T2                                 = 0x00000020,
    RUNN_SRESET_THREADS_BVEC_T3                                 = 0x00000010,
    RUNN_SRESET_THREADS_BVEC_INVALID                            = 0x000000FF,
};

/**
 *  @brief Number of clock cycles to offset each core within a quad in
 *	cache-contained Consumed by: p10_runn HWP (Cronus platform only,
 *	cache-contained mode) Provided by: platform (FW platforms init to
 *	0)
 */
enum RUNN_CORE_CYCLE_OFFSET
{
    RUNN_CORE_CYCLE_OFFSET_0_CYCLES                             = 0x00000000,
    RUNN_CORE_CYCLE_OFFSET_1_CYCLE                              = 0x00000001,
    RUNN_CORE_CYCLE_OFFSET_2_CYCLES                             = 0x00000002,
    RUNN_CORE_CYCLE_OFFSET_3_CYCLES                             = 0x00000003,
    RUNN_CORE_CYCLE_OFFSET_4_CYCLES                             = 0x00000004,
    RUNN_CORE_CYCLE_OFFSET_INVALID                              = 0x000000FF,
};

/**
 *  @brief Perform RUNN configuration checks after starting RUNN
 *	counter(s): - confirm RUNN clocks are running - (if chip-contained)
 *	confirm all clocks started in-phase by comparing clock controller
 *	phase-counter values captured at clock start Note: this may
 *	compromise cycle-reproduceability!
 */
enum RUNN_DO_CONFIG_CHECKS
{
    RUNN_DO_CONFIG_CHECKS_OFF                                   = 0x00000000,
    RUNN_DO_CONFIG_CHECKS_ON                                    = 0x00000001,
    RUNN_DO_CONFIG_CHECKS_INVALID                               = 0x000000FF,
};

/**
 *  @brief Use QME-sourced, cycle-reproducible timebase ("high-precision"
 *	mode) instead of PC-internal "standalone" mode timebase (also
 *	cycle-reproducible).
 */
enum RUNN_USE_QME_TIMEBASE
{
    RUNN_USE_QME_TIMEBASE_OFF                                   = 0x00000000,
    RUNN_USE_QME_TIMEBASE_ON                                    = 0x00000001,
    RUNN_USE_QME_TIMEBASE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Stop OPCG RUNN counter and clocks when a checkstop occurs.
 */
enum RUNN_STOP_ON_XSTOP
{
    RUNN_STOP_ON_XSTOP_OFF                                      = 0x00000000,
    RUNN_STOP_ON_XSTOP_ON                                       = 0x00000001,
    RUNN_STOP_ON_XSTOP_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Specify a core whose exerciser thread seeds should be duplicated
 *	across all other cores. Example: ATTR_RUNN_CORE_SEED_SELECT=CORE05,
 *	then when generating exerciser seeds, every other core would first
 *	seed the RNG w/ ATTR_RUNN_MASTER_SEED and then discard values until
 *	CORE05 before generating per-thread seeds. The default behavior is
 *	to randomize each core independently by using
 *	ATTR_RUNN_CORE_SEED_SELECT=RANDOM.
 */
enum RUNN_CORE_SEED_SELECT
{
    RUNN_CORE_SEED_SELECT_RANDOM                                = 0x000000FF,
    RUNN_CORE_SEED_SELECT_CORE00                                = 0x00000000,
    RUNN_CORE_SEED_SELECT_CORE08                                = 0x00000008,
    RUNN_CORE_SEED_SELECT_CORE16                                = 0x00000010,
    RUNN_CORE_SEED_SELECT_CORE24                                = 0x00000018,
    RUNN_CORE_SEED_SELECT_CORE01                                = 0x00000001,
    RUNN_CORE_SEED_SELECT_CORE09                                = 0x00000009,
    RUNN_CORE_SEED_SELECT_CORE17                                = 0x00000011,
    RUNN_CORE_SEED_SELECT_CORE25                                = 0x00000019,
    RUNN_CORE_SEED_SELECT_CORE02                                = 0x00000002,
    RUNN_CORE_SEED_SELECT_CORE10                                = 0x0000000A,
    RUNN_CORE_SEED_SELECT_CORE18                                = 0x00000012,
    RUNN_CORE_SEED_SELECT_CORE26                                = 0x0000001A,
    RUNN_CORE_SEED_SELECT_CORE03                                = 0x00000003,
    RUNN_CORE_SEED_SELECT_CORE11                                = 0x0000000B,
    RUNN_CORE_SEED_SELECT_CORE19                                = 0x00000013,
    RUNN_CORE_SEED_SELECT_CORE27                                = 0x0000001B,
    RUNN_CORE_SEED_SELECT_CORE04                                = 0x00000004,
    RUNN_CORE_SEED_SELECT_CORE12                                = 0x0000000C,
    RUNN_CORE_SEED_SELECT_CORE20                                = 0x00000014,
    RUNN_CORE_SEED_SELECT_CORE28                                = 0x0000001C,
    RUNN_CORE_SEED_SELECT_CORE05                                = 0x00000005,
    RUNN_CORE_SEED_SELECT_CORE13                                = 0x0000000D,
    RUNN_CORE_SEED_SELECT_CORE21                                = 0x00000015,
    RUNN_CORE_SEED_SELECT_CORE29                                = 0x0000001D,
    RUNN_CORE_SEED_SELECT_CORE06                                = 0x00000006,
    RUNN_CORE_SEED_SELECT_CORE14                                = 0x0000000E,
    RUNN_CORE_SEED_SELECT_CORE22                                = 0x00000016,
    RUNN_CORE_SEED_SELECT_CORE30                                = 0x0000001E,
    RUNN_CORE_SEED_SELECT_CORE07                                = 0x00000007,
    RUNN_CORE_SEED_SELECT_CORE15                                = 0x0000000F,
    RUNN_CORE_SEED_SELECT_CORE23                                = 0x00000017,
    RUNN_CORE_SEED_SELECT_CORE31                                = 0x0000001F,
};

/**
 *  @brief OMI inband BAR enable. Set by platform.
 */
enum OMI_INBAND_BAR_ENABLE
{
    OMI_INBAND_BAR_ENABLE_DISABLE                               = 0x00000000,
    OMI_INBAND_BAR_ENABLE_ENABLE                                = 0x00000001,
    OMI_INBAND_BAR_ENABLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief DRAM Device Type. Decodes SPD byte 2. Generation of memory:
 *	DDR3, DDR4. creator: mss_eff_config consumer: various firmware
 *	notes: none
 */
enum EFF_DRAM_GEN
{
    EFF_DRAM_GEN_EMPTY                                          = 0x00000000,
    EFF_DRAM_GEN_DDR3                                           = 0x00000001,
    EFF_DRAM_GEN_DDR4                                           = 0x00000002,
    EFF_DRAM_GEN_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM:
 *	RDIMM, UDIMM, LRDIMM as specified by the JEDEC standard. creator:
 *	mss_eff_config consumer: various firmware notes: none
 */
enum EFF_DIMM_TYPE
{
    EFF_DIMM_TYPE_EMPTY                                         = 0x00000000,
    EFF_DIMM_TYPE_RDIMM                                         = 0x00000001,
    EFF_DIMM_TYPE_UDIMM                                         = 0x00000002,
    EFF_DIMM_TYPE_LRDIMM                                        = 0x00000003,
    EFF_DIMM_TYPE_INVALID                                       = 0x000000FF,
};

/**
 *  @brief Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator:
 *	mss_eff_config consumer: various firmware notes: none
 */
enum EFF_HYBRID_MEMORY_TYPE
{
    EFF_HYBRID_MEMORY_TYPE_NONE                                 = 0x00000000,
    EFF_HYBRID_MEMORY_TYPE_NVDIMM                               = 0x00000001,
    EFF_HYBRID_MEMORY_TYPE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config
 *	consumer: various firmware notes: none
 */
enum EFF_HYBRID
{
    EFF_HYBRID_NOT_HYBRID                                       = 0x00000000,
    EFF_HYBRID_IS_HYBRID                                        = 0x00000001,
    EFF_HYBRID_INVALID                                          = 0x000000FF,
};

/**
 *  @brief DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM
 *	capacity per die. For multi-die stacks (DDP, QDP, or 3DS), this
 *	represents the capacity of each DRAM die in the stack. creator:
 *	mss_eff_config consumer: various firmware notes: none
 */
enum EFF_DRAM_DENSITY
{
    EFF_DRAM_DENSITY_4G                                         = 0x00000004,
    EFF_DRAM_DENSITY_8G                                         = 0x00000008,
    EFF_DRAM_DENSITY_16G                                        = 0x00000010,
    EFF_DRAM_DENSITY_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM
 *	column address bits. Actual number of DRAM rows is 2^N, where N is
 *	the number of row address bits creator: mss_eff_config consumer:
 *	various firmware notes: none
 */
enum EFF_DRAM_ROW_BITS
{
    EFF_DRAM_ROW_BITS_NUM14                                     = 0x0000000E,
    EFF_DRAM_ROW_BITS_NUM15                                     = 0x0000000F,
    EFF_DRAM_ROW_BITS_NUM16                                     = 0x00000010,
    EFF_DRAM_ROW_BITS_NUM17                                     = 0x00000011,
    EFF_DRAM_ROW_BITS_NUM18                                     = 0x00000012,
    EFF_DRAM_ROW_BITS_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Primary SDRAM Package Type. Decodes Byte 6. This byte defines
 *	the primary set of SDRAMs. Monolithic = SPD, Multi-load stack =
 *	DDP/QDP, Single-load stack = 3DS creator: mss_eff_config consumer:
 *	various firmware notes: none
 */
enum EFF_PRIM_STACK_TYPE
{
    EFF_PRIM_STACK_TYPE_SDP                                     = 0x00000000,
    EFF_PRIM_STACK_TYPE_DDP_QDP                                 = 0x00000001,
    EFF_PRIM_STACK_TYPE_3DS                                     = 0x00000002,
    EFF_PRIM_STACK_TYPE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Post Package Repair. Used in various locations and is evaluated
 *	in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware
 *	notes: none
 */
enum EFF_DRAM_PPR
{
    EFF_DRAM_PPR_NOT_SUPPORTED                                  = 0x00000000,
    EFF_DRAM_PPR_SUPPORTED                                      = 0x00000001,
    EFF_DRAM_PPR_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Soft Post Package Repair. Used in various locations and is
 *	evaluated in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various
 *	firmware notes: none
 */
enum EFF_DRAM_SOFT_PPR
{
    EFF_DRAM_SOFT_PPR_NOT_SUPPORTED                             = 0x00000000,
    EFF_DRAM_SOFT_PPR_SUPPORTED                                 = 0x00000001,
    EFF_DRAM_SOFT_PPR_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Minimum CAS to CAS Delay Time, same bank group in nck (number of
 *	clock cycles). Decodes SPD byte 40 (bits 7~0) and byte 117 (bits
 *	7~0). This is for DDR4 MRS6. Each memory channel will have a value.
 *	Creator: eff_config Consumer:various Firmware notes: none
 */
enum EFF_DRAM_TCCD_L
{
    EFF_DRAM_TCCD_L_4NCK                                        = 0x00000004,
    EFF_DRAM_TCCD_L_5NCK                                        = 0x00000005,
    EFF_DRAM_TCCD_L_6NCK                                        = 0x00000006,
    EFF_DRAM_TCCD_L_7NCK                                        = 0x00000007,
    EFF_DRAM_TCCD_L_8NCK                                        = 0x00000008,
    EFF_DRAM_TCCD_L_INVALID                                     = 0x000000FF,
};

/**
 *  @brief SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4
 *	(4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits). creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_WIDTH
{
    EFF_DRAM_WIDTH_X4                                           = 0x00000004,
    EFF_DRAM_WIDTH_X8                                           = 0x00000008,
    EFF_DRAM_WIDTH_X16                                          = 0x00000010,
    EFF_DRAM_WIDTH_X32                                          = 0x00000020,
    EFF_DRAM_WIDTH_INVALID                                      = 0x000000FF,
};

/**
 *  @brief DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_RANK_MIX
{
    EFF_DRAM_RANK_MIX_SYMMETRICAL                               = 0x00000000,
    EFF_DRAM_RANK_MIX_ASYMMETICAL                               = 0x00000001,
    EFF_DRAM_RANK_MIX_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Total number of ranks in each DIMM. For monolithic and
 *	multi-load stack modules (SDP/DDP) this is the same as the number
 *	of package ranks per DIMM (SPD Byte 12 bits 5~3). For single load
 *	stack (3DS) modules this value represents the number of logical
 *	ranks per DIMM. Logical rank refers the individually addressable
 *	die in a 3DS stack and has no meaning for monolithic or multi-load
 *	stacked SDRAMs. creator: mss_eff_cnfg consumer: various firmware
 *	notes: none
 */
enum EFF_NUM_RANKS_PER_DIMM
{
    EFF_NUM_RANKS_PER_DIMM_1R                                   = 0x00000001,
    EFF_NUM_RANKS_PER_DIMM_2R                                   = 0x00000002,
    EFF_NUM_RANKS_PER_DIMM_4R                                   = 0x00000004,
    EFF_NUM_RANKS_PER_DIMM_8R                                   = 0x00000008,
    EFF_NUM_RANKS_PER_DIMM_16R                                  = 0x00000010,
    EFF_NUM_RANKS_PER_DIMM_INVALID                              = 0x000000FF,
};

/**
 *  @brief Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg
 *	consumer: eff_dimm
 */
enum EFF_REGISTER_TYPE
{
    EFF_REGISTER_TYPE_RCD01                                     = 0x00000000,
    EFF_REGISTER_TYPE_RCD02                                     = 0x00000001,
    EFF_REGISTER_TYPE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator:
 *	mss_eff_cnfg consumer: power_thermal::decoder
 */
enum EFF_DRAM_MFG_ID
{
    EFF_DRAM_MFG_ID_MICRON                                      = 0x0000802C,
    EFF_DRAM_MFG_ID_SAMSUNG                                     = 0x000080CE,
    EFF_DRAM_MFG_ID_HYNIX                                       = 0x000080AD,
    EFF_DRAM_MFG_ID_INVALID                                     = 0x0000FFFF,
};

/**
 *  @brief Register Manufacturer ID Code Decodes SPD Byte 133 and 134
 *	creator: mss_eff_cnfg
 */
enum EFF_RCD_MFG_ID
{
    EFF_RCD_MFG_ID_INPHI                                        = 0x0000B304,
    EFF_RCD_MFG_ID_MONTAGE                                      = 0x00003286,
    EFF_RCD_MFG_ID_IDT                                          = 0x0000B380,
    EFF_RCD_MFG_ID_INVALID                                      = 0x0000FFFF,
};

/**
 *  @brief True or false whether row repair is supported MRW attribute
 */
enum ROW_REPAIR_SUPPORTED_MRW
{
    ROW_REPAIR_SUPPORTED_MRW_SUPPORTED                          = 0x00000001,
    ROW_REPAIR_SUPPORTED_MRW_UNSUPPORTED                        = 0x00000000,
    ROW_REPAIR_SUPPORTED_MRW_INVALID                            = 0x000000FF,
};

/**
 *  @brief Holds data and mask to be programmed into Memory
 *	BAR/configuration registers. These values are calculated by
 *	p10_mss_eff_grouping HWP. Array arrangements: 4 MIs x 10 registers
 *	x 2 entries (data/mask) [0][0][0] = [MI0][MCFGP0][data] ....
 *	[MI0][9][1] = [MI0][MCMODE2][mask] [1][0][0] = [MI1][MCFGP0][data]
 *	.... [MI1][9][1] = [MI1][MCMODE2][mask] [2][0][0] =
 *	[MI2][MCFGP0][data] .... [MI2][9][1] = [MI2][MCMODE2][mask]
 *	[3][0][0] = [MI3][MCFGP0][data] .... [MI3][9][1] =
 *	[MI3][MCMODE2][mask] The BARs will be written by
 *	p10_sbe_exit_cache_contained HWP when called by Hostboot. The mask
 *	value specifies which bits of the data should be written to the
 *	underlying HW register. Set by p10_mss_eff_grouping. Consumers: HB
 *	(p10_exit_cache_contaiend)
 */
enum MEMORY_BAR_REGS
{
    MEMORY_BAR_REGS_MCFGP0                                      = 0x00000000,
    MEMORY_BAR_REGS_MCFGP1                                      = 0x00000001,
    MEMORY_BAR_REGS_MCFGPM0                                     = 0x00000002,
    MEMORY_BAR_REGS_MCFGPM1                                     = 0x00000003,
    MEMORY_BAR_REGS_MCFGP0A                                     = 0x00000004,
    MEMORY_BAR_REGS_MCFGP1A                                     = 0x00000005,
    MEMORY_BAR_REGS_MCFGPM0A                                    = 0x00000006,
    MEMORY_BAR_REGS_MCFGPM1A                                    = 0x00000007,
    MEMORY_BAR_REGS_MCMODE2                                     = 0x00000008,
    MEMORY_BAR_REGS_NUM_BAR_REGS                                = 0x00000009,
    MEMORY_BAR_REGS_INVALID                                     = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief creator: p10_mss_eff_grouping consumer: mss_setup_bars Data
 *	Structure from eff grouping to setup bars to help determine
 *	different groups. Measured in GB. Non-Mirroring array[0-7][0.20]:
 *	0-- Port size; 1-- No of ports in group; 2-- Total group size of
 *	non-mirroring; 3-- Base address; 4-11-- PortID number in group;
 *	12-- Alt Memory valid(0); 13-- Alt Memory valid (1); 14-- Alt Group
 *	size (0); 15-- Alt Group size(1); 16-- Alt Base address (0); 17--
 *	Alt Base address (1); 18-- SMF Memory Valid 19-- SMF Group Size
 *	(size[22:35] in lower bits) 20-- SMF Base Address (addr[22:35] in
 *	lower bits) Mirroring array[8-15][0:20]: Same index description as
 *	above for mirror groups.
 */
enum MSS_MCC_GROUP_32
{
    MSS_MCC_GROUP_32_MCC_SIZE                                   = 0x00000000,
    MSS_MCC_GROUP_32_NUM_MCC_IN_GROUP                           = 0x00000001,
    MSS_MCC_GROUP_32_GROUP_SIZE                                 = 0x00000002,
    MSS_MCC_GROUP_32_BASE_ADDR                                  = 0x00000003,
    MSS_MCC_GROUP_32_MCC_ID_1                                   = 0x00000004,
    MSS_MCC_GROUP_32_MCC_ID_2                                   = 0x00000005,
    MSS_MCC_GROUP_32_MCC_ID_3                                   = 0x00000006,
    MSS_MCC_GROUP_32_MCC_ID_4                                   = 0x00000007,
    MSS_MCC_GROUP_32_MCC_ID_5                                   = 0x00000008,
    MSS_MCC_GROUP_32_MCC_ID_6                                   = 0x00000009,
    MSS_MCC_GROUP_32_MCC_ID_7                                   = 0x0000000A,
    MSS_MCC_GROUP_32_MCC_ID_8                                   = 0x0000000B,
    MSS_MCC_GROUP_32_ALT_VALID_0                                = 0x0000000C,
    MSS_MCC_GROUP_32_ALT_VALID_1                                = 0x0000000D,
    MSS_MCC_GROUP_32_ALT_SIZE_0                                 = 0x0000000E,
    MSS_MCC_GROUP_32_ALT_SIZE_1                                 = 0x0000000F,
    MSS_MCC_GROUP_32_ALT_BASE_ADDR_0                            = 0x00000010,
    MSS_MCC_GROUP_32_ALT_BASE_ADDR_1                            = 0x00000011,
    MSS_MCC_GROUP_32_SMF_VALID                                  = 0x00000012,
    MSS_MCC_GROUP_32_SMF_SIZE                                   = 0x00000013,
    MSS_MCC_GROUP_32_SMF_BASE_ADDR                              = 0x00000014,
    MSS_MCC_GROUP_32_INVALID                                    = 0xFFFFFFFF,
};

/**
 *  @brief Define placement policy/scheme for non-mirrored/mirrored memory
 *	layout NORMAL = non-mirrored start: 0, mirrored start: 1024TB
 *	FLIPPED = mirrored start: 0, non-mirrored start: 512TB Set by
 *	platform. Used by p10_mss_eff_grouping.
 */
enum MEM_MIRROR_PLACEMENT_POLICY
{
    MEM_MIRROR_PLACEMENT_POLICY_NORMAL                          = 0x00000000,
    MEM_MIRROR_PLACEMENT_POLICY_FLIPPED                         = 0x00000001,
    MEM_MIRROR_PLACEMENT_POLICY_INVALID                         = 0x000000FF,
};

/**
 *  @brief Determines the stride covered by each granule in an interleaving
 *	group. The default stride -- 128B -- is the only value intended for
 *	production FW use. All other combinations are for experimental
 *	performance evaluation. Regardless of this attribute value, groups
 *	of size 1, 3, and 6 will be forced to 128B stride based on the
 *	logic capabilities.
 */
enum MSS_INTERLEAVE_GRANULARITY
{
    MSS_INTERLEAVE_GRANULARITY_128_B                            = 0x00000000,
    MSS_INTERLEAVE_GRANULARITY_256_B                            = 0x00000001,
    MSS_INTERLEAVE_GRANULARITY_512_B                            = 0x00000002,
    MSS_INTERLEAVE_GRANULARITY_1_KB                             = 0x00000003,
    MSS_INTERLEAVE_GRANULARITY_2_KB                             = 0x00000004,
    MSS_INTERLEAVE_GRANULARITY_4_KB                             = 0x00000005,
    MSS_INTERLEAVE_GRANULARITY_8_KB                             = 0x00000006,
    MSS_INTERLEAVE_GRANULARITY_16_KB                            = 0x00000007,
    MSS_INTERLEAVE_GRANULARITY_32_KB                            = 0x00000008,
    MSS_INTERLEAVE_GRANULARITY_INVALID                          = 0x000000FF,
};

/**
 *  @brief Written when memory calculations are complete. If true, memory
 *	attributes are valid and can be reliably used. Note that this has
 *	no implications on the processor state or memory state. Set by
 *	p10_mss_eff_grouping. Used by p10_query_mssinfo.
 */
enum MSS_MEM_IPL_COMPLETE
{
    MSS_MEM_IPL_COMPLETE_FALSE                                  = 0x00000000,
    MSS_MEM_IPL_COMPLETE_TRUE                                   = 0x00000001,
    MSS_MEM_IPL_COMPLETE_INVALID                                = 0x000000FF,
};

/**
 *  @brief REQUIRED: HW mirroring is enabled, and all channels are required
 *	to be part of a mirrored group. REQUESTED: HW mirroring is enabled.
 *	Mirroring will be configured for groups which support it, but not
 *	all channels are required to be mirrored. OFF: HW mirroring is
 *	disabled. Provided by the MRW. If mirroring is REQUIRED, all MCCs'
 *	subchannels must be enabled in order for them to be all grouped.
 *	Otherwise, there will be an error results from the memory grouping
 *	process (RC_MSS_EFF_GROUPING_UNABLE_TO_GROUP).
 */
enum MRW_HW_MIRRORING_ENABLE
{
    MRW_HW_MIRRORING_ENABLE_OFF                                 = 0x00000000,
    MRW_HW_MIRRORING_ENABLE_REQUIRED                            = 0x00000001,
    MRW_HW_MIRRORING_ENABLE_REQUESTED                           = 0x00000002,
    MRW_HW_MIRRORING_ENABLE_INVALID                             = 0x000000FF,
};

/**
 *  @brief The Nest HTM trace type desired to be collected. This setting is
 *	applied to both NHTM0 and NHTM1.
 */
enum NHTM_TRACE_TYPE
{
    NHTM_TRACE_TYPE_DISABLE                                     = 0x00000000,
    NHTM_TRACE_TYPE_FABRIC                                      = 0x00000001,
    NHTM_TRACE_TYPE_EVENT                                       = 0x00000002,
    NHTM_TRACE_TYPE_OCC                                         = 0x00000003,
    NHTM_TRACE_TYPE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief The Core HTM trace type desired to be collected.
 */
enum CHTM_TRACE_TYPE
{
    CHTM_TRACE_TYPE_DISABLE                                     = 0x00000000,
    CHTM_TRACE_TYPE_CORE                                        = 0x00000001,
    CHTM_TRACE_TYPE_LLAT                                        = 0x00000002,
    CHTM_TRACE_TYPE_DMW                                         = 0x00000004,
    CHTM_TRACE_TYPE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Nest HTM: defines the NHTM trace mode. HTM Collection Mode
 *	Register (1:2). Only FABRIC is supported at this time.
 */
enum NHTM_HTMSC_MODE_CONTENT_SEL
{
    NHTM_HTMSC_MODE_CONTENT_SEL_FABRIC                          = 0x00000000,
    NHTM_HTMSC_MODE_CONTENT_SEL_EVENT                           = 0x00000001,
    NHTM_HTMSC_MODE_CONTENT_SEL_OCC                             = 0x00000002,
    NHTM_HTMSC_MODE_CONTENT_SEL_INVALID                         = 0x000000FF,
};

/**
 *  @brief Use space option. For NHTM only. HTM Collection Mode Register
 *	(22). 0 = Use HTM_CL_Write op to target system memory. Do
 *	pre-allocation sequence. (default) 1 = Use ci_pr_st op to target
 *	anywhere else. Dont do pre-allocate sequence.
 */
enum NHTM_HTMSC_MODE_WRITETOIO
{
    NHTM_HTMSC_MODE_WRITETOIO_DISABLE                           = 0x00000000,
    NHTM_HTMSC_MODE_WRITETOIO_ENABLE                            = 0x00000001,
    NHTM_HTMSC_MODE_WRITETOIO_INVALID                           = 0x000000FF,
};

/**
 *  @brief Nest HTM: enable stop on match and program stop PAT and MASK.
 */
enum HTMSC_FILT_STOP_ON_MATCH
{
    HTMSC_FILT_STOP_ON_MATCH_DISABLE                            = 0x00000000,
    HTMSC_FILT_STOP_ON_MATCH_ENABLE                             = 0x00000001,
    HTMSC_FILT_STOP_ON_MATCH_INVALID                            = 0x000000FF,
};

/**
 *  @brief Nest HTM: TTYPE/TSIZE Capture Invert. HTM Ttype Filter Control
 *	Register (32). This bit controls the inversion of the ttype/tsize
 *	filter. 0 : Capture record based on ttype/tsize pattern matching 1
 *	: Capture record based on ttype/tsize pattern NOT matching
 */
enum HTMSC_TTYPEFILT_INVERT
{
    HTMSC_TTYPEFILT_INVERT_MATCH                                = 0x00000000,
    HTMSC_TTYPEFILT_INVERT_NOT_MATCH                            = 0x00000001,
    HTMSC_TTYPEFILT_INVERT_INVALID                              = 0x000000FF,
};

/**
 *  @brief Nest HTM: CRESP Filter Capture Invert. HTM Ttype Filter Control
 *	Register (33). This bit controls the inversion of the cresp filter.
 *	0: Capture record based on cresp filter pattern/mask match 1:
 *	Capture record based on cresp filter pattern/mask NOT matching.
 */
enum HTMSC_CRESPFILT_INVERT
{
    HTMSC_CRESPFILT_INVERT_MATCH                                = 0x00000000,
    HTMSC_CRESPFILT_INVERT_NOT_MATCH                            = 0x00000001,
    HTMSC_CRESPFILT_INVERT_INVALID                              = 0x000000FF,
};

/**
 *  @brief Nest HTM: Filter Pattern invert. HTM Filter Control Register
 *	(26:26). In Fabric trace mode, invert ttag filter meaning (invert
 *	match signal)
 */
enum HTMSC_TTAGFILT_INVERT
{
    HTMSC_TTAGFILT_INVERT_MATCH                                 = 0x00000000,
    HTMSC_TTAGFILT_INVERT_NOT_MATCH                             = 0x00000001,
    HTMSC_TTAGFILT_INVERT_INVALID                               = 0x000000FF,
};

/**
 *  @brief Setting of memory scope for HTM collection. HTM Memory
 *	Configuration Register (1:3)
 */
enum HTMSC_MEM_SCOPE
{
    HTMSC_MEM_SCOPE_LOCAL                                       = 0x00000000,
    HTMSC_MEM_SCOPE_NEARNODE                                    = 0x00000002,
    HTMSC_MEM_SCOPE_GROUP                                       = 0x00000003,
    HTMSC_MEM_SCOPE_REMOTE                                      = 0x00000004,
    HTMSC_MEM_SCOPE_VECTORED                                    = 0x00000005,
    HTMSC_MEM_SCOPE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Setting of memory priority for HTM collection. HTM Memory
 *	Configuration Register (4)
 */
enum HTMSC_MEM_PRIORITY
{
    HTMSC_MEM_PRIORITY_LOW                                      = 0x00000000,
    HTMSC_MEM_PRIORITY_HIGH                                     = 0x00000001,
    HTMSC_MEM_PRIORITY_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Setting of Trigger control for NHTM. HTM Trigger Control
 *	Register (0:1) 00 local triggers are not forwarded to the PowerBus,
 *	it is inserted into the trace when tracing. Both local and global
 *	triggers control the HTM 01 local triggers are not forwarded to the
 *	PowerBus, it is inserted into the traCe when tracing. Only local
 *	triggers control the HTM 1x local triggers are forwarded to the
 *	PowerBus, it is not inserted into the trace when tracing. Only
 *	global triggers control the HTM
 */
enum NHTM_CTRL_TRIG
{
    NHTM_CTRL_TRIG_LOCAL_GLOBAL                                 = 0x00000000,
    NHTM_CTRL_TRIG_LOCAL                                        = 0x00000001,
    NHTM_CTRL_TRIG_GLOBAL                                       = 0x00000002,
    NHTM_CTRL_TRIG_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Setting of Mark control for NHTM. HTM Trigger Control Register
 *	(4:5) 00 local markers are not forwarded to the PowerBus. Both
 *	local and global markers are inserted into the trace 01 local
 *	markers are not forwarded to the PowerBus. Only local markers are
 *	inserted into the trace 10 local markers are forwarded to the
 *	PowerBus. Only global markers are inserted into the trace 11 local
 *	markers are forwarded to the PowerBus. Markers are not inserted
 *	into the trace (Fabric Trace Mode)
 */
enum NHTM_CTRL_MARK
{
    NHTM_CTRL_MARK_LOCAL_GLOBAL                                 = 0x00000000,
    NHTM_CTRL_MARK_LOCAL_MARK                                   = 0x00000001,
    NHTM_CTRL_MARK_GLOBAL_MARK                                  = 0x00000002,
    NHTM_CTRL_MARK_NO_MARK                                      = 0x00000003,
    NHTM_CTRL_MARK_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Setting of Trigger control. HTM Trigger Control Register (0:1)
 *	00 local triggers are not forwarded to the PowerBus, it is inserted
 *	into the trace when tracing. Both local and global triggers control
 *	the HTM 01 local triggers are not forwarded to the PowerBus, it is
 *	inserted into the traCe when tracing. Only local triggers control
 *	the HTM 1x local triggers are forwarded to the PowerBus, it is not
 *	inserted into the trace when tracing. Only global triggers control
 *	the HTM
 */
enum CHTM_CTRL_TRIG
{
    CHTM_CTRL_TRIG_LOCAL_GLOBAL                                 = 0x00000000,
    CHTM_CTRL_TRIG_LOCAL                                        = 0x00000001,
    CHTM_CTRL_TRIG_GLOBAL                                       = 0x00000002,
    CHTM_CTRL_TRIG_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Setting of Mark control. HTM Trigger Control Register (4:5) 00
 *	local markers are not forwarded to the PowerBus. Both local and
 *	global markers are inserted into the trace 01 local markers are not
 *	forwarded to the PowerBus. Only local markers are inserted into the
 *	trace 10 local markers are forwarded to the PowerBus. Only global
 *	markers are inserted into the trace 11 local markers are forwarded
 *	to the PowerBus. Markers are not inserted into the trace (Fabric
 *	Trace Mode)
 */
enum CHTM_CTRL_MARK
{
    CHTM_CTRL_MARK_LOCAL_GLOBAL                                 = 0x00000000,
    CHTM_CTRL_MARK_LOCAL_MARK                                   = 0x00000001,
    CHTM_CTRL_MARK_GLOBAL_MARK                                  = 0x00000002,
    CHTM_CTRL_MARK_NO_MARK                                      = 0x00000003,
    CHTM_CTRL_MARK_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Enable Stop on PB Chiplet Debug Trigger 0. HTM Trigger Control
 *	Register (6)
 */
enum HTMSC_CTRL_DBG0_STOP
{
    HTMSC_CTRL_DBG0_STOP_DISABLE                                = 0x00000000,
    HTMSC_CTRL_DBG0_STOP_ENABLE                                 = 0x00000001,
    HTMSC_CTRL_DBG0_STOP_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enable Stop on PB Chiplet Debug Trigger 1. HTM Trigger Control
 *	Register (7)
 */
enum HTMSC_CTRL_DBG1_STOP
{
    HTMSC_CTRL_DBG1_STOP_DISABLE                                = 0x00000000,
    HTMSC_CTRL_DBG1_STOP_ENABLE                                 = 0x00000001,
    HTMSC_CTRL_DBG1_STOP_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enable trace stop on falling edge of PB chiplet trace run. HTM
 *	Trigger Control Register (8)
 */
enum HTMSC_CTRL_RUN_STOP
{
    HTMSC_CTRL_RUN_STOP_DISABLE                                 = 0x00000000,
    HTMSC_CTRL_RUN_STOP_ENABLE                                  = 0x00000001,
    HTMSC_CTRL_RUN_STOP_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Enable Stop using OCC Control. HTM Trigger Control Register (9)
 */
enum HTMSC_CTRL_OTHER_DBG0_STOP
{
    HTMSC_CTRL_OTHER_DBG0_STOP_DISABLE                          = 0x00000000,
    HTMSC_CTRL_OTHER_DBG0_STOP_ENABLE                           = 0x00000001,
    HTMSC_CTRL_OTHER_DBG0_STOP_INVALID                          = 0x000000FF,
};

/**
 *  @brief Enable Stop on chiplet XSTOP. HTM Trigger Control Register (13)
 *	Platform to default to 0x1
 */
enum HTMSC_CTRL_XSTOP_STOP
{
    HTMSC_CTRL_XSTOP_STOP_ENABLE                                = 0x00000000,
    HTMSC_CTRL_XSTOP_STOP_DISABLE                               = 0x00000001,
    HTMSC_CTRL_XSTOP_STOP_INVALID                               = 0x000000FF,
};

/**
 *  @brief Stop on PC_TC_DBG_Trigger0 1 = stop trigger Core Debug Trigger 0
 *	0 = ignore Core Debug Trigger 0
 */
enum HTMSC_CTRL_CHIP0_STOP
{
    HTMSC_CTRL_CHIP0_STOP_DISABLE                               = 0x00000000,
    HTMSC_CTRL_CHIP0_STOP_ENABLE                                = 0x00000001,
    HTMSC_CTRL_CHIP0_STOP_INVALID                               = 0x000000FF,
};

/**
 *  @brief Stop on PC_TC_DBG_Trigger1 1 = stop trigger Core Debug Trigger 1
 *	0 = ignore Core Debug Trigger 1
 */
enum HTMSC_CTRL_CHIP1_STOP
{
    HTMSC_CTRL_CHIP1_STOP_DISABLE                               = 0x00000000,
    HTMSC_CTRL_CHIP1_STOP_ENABLE                                = 0x00000001,
    HTMSC_CTRL_CHIP1_STOP_INVALID                               = 0x000000FF,
};

/**
 *  @brief This register defines the starting Scope of the PowerBus
 *	operation. The Scope will be increased if necessary however it is
 *	more efficient to have the request issued according to where the
 *	target memory is located. 000 LOCAL scope 001 Reserved 010 NEAR
 *	NODE scope (Nn) 011 GROUP scope (G). 100 REMOTE scope (Rn). 101
 *	VECTORED group scope (Vg). 110 Reserved 111 Reserved Note 1: Since
 *	P10 uses a Group Class MCD, the HTM will always force a 'Nodal'
 *	scope to 'Group' scope. If the scope is initialized to 'Vectored
 *	Group Scope', the HTM_MODE[Vg_Target] bits must also be
 *	initialized.
 */
enum HTMSC_IMA_PDBAR_SCOPE
{
    HTMSC_IMA_PDBAR_SCOPE_LOCAL                                 = 0x00000000,
    HTMSC_IMA_PDBAR_SCOPE_NEARNODE                              = 0x00000002,
    HTMSC_IMA_PDBAR_SCOPE_GROUP                                 = 0x00000003,
    HTMSC_IMA_PDBAR_SCOPE_REMOTE                                = 0x00000004,
    HTMSC_IMA_PDBAR_SCOPE_VECTORED                              = 0x00000005,
    HTMSC_IMA_PDBAR_SCOPE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Trace Wrap mode, used for both NHTM and CHTM HTM Collection Mode
 *	Register (13). 0 = Wrap trace to beginning of Trace Memory 1 = Stop
 *	trace when top of Trace Memory is reached
 */
enum HTMSC_MODE_WRAP
{
    HTMSC_MODE_WRAP_ENABLE                                      = 0x00000000,
    HTMSC_MODE_WRAP_DISABLE                                     = 0x00000001,
    HTMSC_MODE_WRAP_INVALID                                     = 0x000000FF,
};

/**
 *  @brief TimeStamp Writes option, used for both NHTM and CHTM HTM
 *	Collection Mode Register (14). 0 = Write of timestamps enabled to
 *	indicate elapsed time between records. 1 = Timestamps written only
 *	to indicate record loss
 */
enum HTMSC_MODE_DIS_TSTAMP
{
    HTMSC_MODE_DIS_TSTAMP_ENABLE                                = 0x00000000,
    HTMSC_MODE_DIS_TSTAMP_DISABLE                               = 0x00000001,
    HTMSC_MODE_DIS_TSTAMP_INVALID                               = 0x000000FF,
};

/**
 *  @brief Overflow Timestamps option, used for both NHTM and CHTM. HTM
 *	Collection Mode Register (15). 0 = Timestamp written to indicate
 *	elapsed time overflow. 1 = Only one timestamp is written between
 *	entries, overflow indication is lost
 */
enum HTMSC_MODE_SINGLE_TSTAMP
{
    HTMSC_MODE_SINGLE_TSTAMP_DISABLE                            = 0x00000000,
    HTMSC_MODE_SINGLE_TSTAMP_ENABLE                             = 0x00000001,
    HTMSC_MODE_SINGLE_TSTAMP_INVALID                            = 0x000000FF,
};

/**
 *  @brief Nest HTM: Stamp/Marker only mode. HTM Collection Mode Register
 *	(17). 0 = Normal trace 1 = Ignore incoming trace data and save only
 *	markers caused by HTM_TRIG writes,
 */
enum HTMSC_MODE_MARKERS_ONLY
{
    HTMSC_MODE_MARKERS_ONLY_DISABLE                             = 0x00000000,
    HTMSC_MODE_MARKERS_ONLY_ENABLE                              = 0x00000001,
    HTMSC_MODE_MARKERS_ONLY_INVALID                             = 0x000000FF,
};

/**
 *  @brief Nest HTM: Group scope option. HTM Collection Mode Register (18).
 *	This is a powerbus debug bit 0 = htm write ops sent with group
 *	scope 1 = htm write ops sent with Vg scope using programmed target
 *	bits.
 */
enum HTMSC_MODE_DIS_FORCE_GROUP_SCOPE
{
    HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_DISABLE                    = 0x00000000,
    HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_ENABLE                     = 0x00000001,
    HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_INVALID                    = 0x000000FF,
};

/**
 *  @brief If disabled (0): Allow capture of all dispatches
 */
enum CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS
{
    CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_DISABLE                = 0x00000000,
    CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_ENABLE                 = 0x00000001,
    CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_INVALID                = 0x000000FF,
};

/**
 *  @brief If disabled (0): Allow capture of stores
 */
enum CHTM_MODE_LLAT_CAPTURE_STORE_DIS
{
    CHTM_MODE_LLAT_CAPTURE_STORE_DIS_DISABLE                    = 0x00000000,
    CHTM_MODE_LLAT_CAPTURE_STORE_DIS_ENABLE                     = 0x00000001,
    CHTM_MODE_LLAT_CAPTURE_STORE_DIS_INVALID                    = 0x000000FF,
};

/**
 *  @brief If disabled (0): Allow capture of l3 hits
 */
enum CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS
{
    CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_ENABLE                  = 0x00000000,
    CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_DISABLE                 = 0x00000001,
    CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_INVALID                 = 0x000000FF,
};

/**
 *  @brief Enables embedded timestamps for LLAT tracing
 */
enum CHTM_MODE_LLAT_IMBEDDED_TS
{
    CHTM_MODE_LLAT_IMBEDDED_TS_DISABLE                          = 0x00000000,
    CHTM_MODE_LLAT_IMBEDDED_TS_ENABLE                           = 0x00000001,
    CHTM_MODE_LLAT_IMBEDDED_TS_INVALID                          = 0x000000FF,
};

/**
 *  @brief Prevent the core from writing to the HTM when in error state
 */
enum CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR
{
    CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_DISABLE          = 0x00000000,
    CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_ENABLE           = 0x00000001,
    CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_INVALID          = 0x000000FF,
};

/**
 *  @brief If asserted: LLAT tracing will insert a stop marker in the trace
 *	when a purge is requested from pervasive
 */
enum CHTM_MODE_LLAT_PAUSE_ON_PURGE
{
    CHTM_MODE_LLAT_PAUSE_ON_PURGE_DISABLE                       = 0x00000000,
    CHTM_MODE_LLAT_PAUSE_ON_PURGE_ENABLE                        = 0x00000001,
    CHTM_MODE_LLAT_PAUSE_ON_PURGE_INVALID                       = 0x000000FF,
};

/**
 *  @brief Allow cHTM to "wrap" in memory, otherwise stop when top of
 *	memory is reached
 */
enum CHTM_MODE_CORE_WRAP
{
    CHTM_MODE_CORE_WRAP_DISABLE                                 = 0x00000000,
    CHTM_MODE_CORE_WRAP_ENABLE                                  = 0x00000001,
    CHTM_MODE_CORE_WRAP_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Disable time stamps between records that exceed the embeded time
 *	stamp. Recommended to disable for LLAT tracing.
 */
enum CHTM_MODE_DIS_TSTAMP
{
    CHTM_MODE_DIS_TSTAMP_ENABLE                                 = 0x00000000,
    CHTM_MODE_DIS_TSTAMP_DISABLE                                = 0x00000001,
    CHTM_MODE_DIS_TSTAMP_INVALID                                = 0x000000FF,
};

/**
 *  @brief Allow only a single time stamp to be written between records.
 */
enum CHTM_MODE_SINGLE_TIME_STAMP
{
    CHTM_MODE_SINGLE_TIME_STAMP_DISABLE                         = 0x00000000,
    CHTM_MODE_SINGLE_TIME_STAMP_ENABLE                          = 0x00000001,
    CHTM_MODE_SINGLE_TIME_STAMP_INVALID                         = 0x000000FF,
};

/**
 *  @brief If disabled (0): the core will stop executing instructions when
 *	the trace buffer is full. Core trace only.
 */
enum CHTM_MODE_DIS_STALL
{
    CHTM_MODE_DIS_STALL_DISABLE                                 = 0x00000000,
    CHTM_MODE_DIS_STALL_ENABLE                                  = 0x00000001,
    CHTM_MODE_DIS_STALL_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Only print markers to trace.
 */
enum CHTM_MODE_MARKERS_ONLY
{
    CHTM_MODE_MARKERS_ONLY_DISABLE                              = 0x00000000,
    CHTM_MODE_MARKERS_ONLY_ENABLE                               = 0x00000001,
    CHTM_MODE_MARKERS_ONLY_INVALID                              = 0x000000FF,
};

/**
 *  @brief Force scope to VG if group or nodal scope requested
 */
enum CHTM_MODE_DIS_GROUP
{
    CHTM_MODE_DIS_GROUP_DISABLE                                 = 0x00000000,
    CHTM_MODE_DIS_GROUP_ENABLE                                  = 0x00000001,
    CHTM_MODE_DIS_GROUP_INVALID                                 = 0x000000FF,
};

/**
 *  @brief For CHTM only. 0: Core execution is stalled whenever the data
 *	buffers are almost full to prevent losing records. 1: Core
 *	execution is never stalled and entries may be discarded when buffer
 *	is full
 */
enum CHTM_HTMSC_MODE_CORE_INSTR_STALL
{
    CHTM_HTMSC_MODE_CORE_INSTR_STALL_ENABLE                     = 0x00000000,
    CHTM_HTMSC_MODE_CORE_INSTR_STALL_DISABLE                    = 0x00000001,
    CHTM_HTMSC_MODE_CORE_INSTR_STALL_INVALID                    = 0x000000FF,
};

/**
 *  @brief For CHTM only. Prevent trace from wrapping. Only collect one
 *	round and then disable this trace.
 */
enum CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP
{
    CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_ENABLE                   = 0x00000000,
    CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_DISABLE                  = 0x00000001,
    CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_INVALID                  = 0x000000FF,
};

/**
 *  @brief For CHTM only. Prevent IMA from posting by freezing counters
 */
enum CHTM_HTMSC_IMA_EVENT_MASK_FREEZE
{
    CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_DISABLE                    = 0x00000000,
    CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_ENABLE                     = 0x00000001,
    CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_INVALID                    = 0x000000FF,
};

/**
 *  @brief For CHTM only. Allow the IMA to count L1 data prefetches
 */
enum CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE
{
    CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_DISABLE                  = 0x00000000,
    CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_ENABLE                   = 0x00000001,
    CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_INVALID                  = 0x000000FF,
};

/**
 *  @brief For CHTM only. Allow the IMA to count L1 instruction prefetches
 */
enum CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE
{
    CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_DISABLE                  = 0x00000000,
    CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_ENABLE                   = 0x00000001,
    CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_INVALID                  = 0x000000FF,
};

/**
 *  @brief For CHTM only. Only sample one event and one thread
 */
enum CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT
{
    CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_DISABLE                 = 0x00000000,
    CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_ENABLE                  = 0x00000001,
    CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_INVALID                 = 0x000000FF,
};

/**
 *  @brief Processor fabric topology id table. Index is the value of
 *	RA[15:19] and the value stored is the 4-bit topology id of the
 *	owning chip (of that space).
 */
enum PROC_FABRIC_TOPOLOGY_ID_TABLE
{
    PROC_FABRIC_TOPOLOGY_ID_TABLE_INVALID                       = 0x000000FF,
};

/**
 *  @brief Processor fabric SL domain (proxime) configuration.
 */
enum PROC_FABRIC_SL_DOMAIN
{
    PROC_FABRIC_SL_DOMAIN_HEMISPHERE                            = 0x00000000,
    PROC_FABRIC_SL_DOMAIN_CHIP                                  = 0x00000001,
    PROC_FABRIC_SL_DOMAIN_INVALID                               = 0x000000FF,
};

/**
 *  @brief Processor fabric broadcast scope configuration. Provided by the
 *	MRW.
 */
enum PROC_FABRIC_BROADCAST_MODE
{
    PROC_FABRIC_BROADCAST_MODE_1HOP_CHIP_IS_GROUP               = 0x00000000,
    PROC_FABRIC_BROADCAST_MODE_1HOP_CHIP_IS_NODE                = 0x00000001,
    PROC_FABRIC_BROADCAST_MODE_RESERVED                         = 0x00000002,
    PROC_FABRIC_BROADCAST_MODE_2HOP_CHIP_IS_NODE                = 0x00000003,
    PROC_FABRIC_BROADCAST_MODE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Processor fabric topology mode, determines format of the
 *	topology ID. MODE0 = GGG_C (max 8x2) MODE1 = GG_CC (max 4x4)
 *	Provided by the MRW.
 */
enum PROC_FABRIC_TOPOLOGY_MODE
{
    PROC_FABRIC_TOPOLOGY_MODE_MODE0                             = 0x00000000,
    PROC_FABRIC_TOPOLOGY_MODE_MODE1                             = 0x00000001,
    PROC_FABRIC_TOPOLOGY_MODE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Indicates if the given chip should serve as the fabric system
 *	master.
 */
enum PROC_FABRIC_SYSTEM_MASTER_CHIP
{
    PROC_FABRIC_SYSTEM_MASTER_CHIP_FALSE                        = 0x00000000,
    PROC_FABRIC_SYSTEM_MASTER_CHIP_TRUE                         = 0x00000001,
    PROC_FABRIC_SYSTEM_MASTER_CHIP_INVALID                      = 0x000000FF,
};

/**
 *  @brief Indicates if the given chip should serve as the fabric group
 *	master.
 */
enum PROC_FABRIC_GROUP_MASTER_CHIP
{
    PROC_FABRIC_GROUP_MASTER_CHIP_FALSE                         = 0x00000000,
    PROC_FABRIC_GROUP_MASTER_CHIP_TRUE                          = 0x00000001,
    PROC_FABRIC_GROUP_MASTER_CHIP_INVALID                       = 0x000000FF,
};

/**
 *  @brief Per-link optics configuration OPT0 = SMPA/SMPX/OCAPI OPT1 =
 *	SMPA/SMPX OPT2 = SMPA/SMPX OPT3 = SMPA/SMPX/OCAPI OPT4 =
 *	SMPA/SMPX/OCAPI OPT5 = SMPA/SMPX/OCAPI OPT6 = SMPA/SMPX/OCAPI OPT7
 *	= SMPA/SMPX/OCAPI Provided by the MRW.
 */
enum IOHS_CONFIG_MODE
{
    IOHS_CONFIG_MODE_SMPX                                       = 0x00000000,
    IOHS_CONFIG_MODE_SMPA                                       = 0x00000001,
    IOHS_CONFIG_MODE_OCAPI                                      = 0x00000002,
    IOHS_CONFIG_MODE_UNUSED                                     = 0x00000003,
    IOHS_CONFIG_MODE_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Processor optics bus width per logical link. Set by
 *	p10_fbc_eff_config.
 */
enum PROC_FABRIC_IOHS_BUS_WIDTH
{
    PROC_FABRIC_IOHS_BUS_WIDTH_1_BYTE                           = 0x00000001,
    PROC_FABRIC_IOHS_BUS_WIDTH_2_BYTE                           = 0x00000002,
    PROC_FABRIC_IOHS_BUS_WIDTH_INVALID                          = 0x000000FF,
};

/**
 *  @brief Indicates if the link is used to connect between drawers. Should
 *	be considered valid only if ATTR_IOHS_CONFIG_MODE for the given
 *	link is configured as an SMPX or SMPA. Provided by the MRW.
 */
enum IOHS_DRAWER_INTERCONNECT
{
    IOHS_DRAWER_INTERCONNECT_FALSE                              = 0x00000000,
    IOHS_DRAWER_INTERCONNECT_TRUE                               = 0x00000001,
    IOHS_DRAWER_INTERCONNECT_INVALID                            = 0x000000FF,
};

/**
 *  @brief Indicates if the link is reliant on SMP9 cabling to to connect
 *	between drawers. Should be considered valid only if
 *	ATTR_IOHS_CONFIG_MODE for the given link is configured as an SMPX
 *	or SMPA. Provided by the MRW.
 */
enum IOHS_SMP9_INTERCONNECT
{
    IOHS_SMP9_INTERCONNECT_FALSE                                = 0x00000000,
    IOHS_SMP9_INTERCONNECT_TRUE                                 = 0x00000001,
    IOHS_SMP9_INTERCONNECT_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enable DL TOD cross-configuration to drive the TOD signal from
 *	the other link pair in the corner.
 */
enum IOHS_FABRIC_TOD_CROSS_CONFIG
{
    IOHS_FABRIC_TOD_CROSS_CONFIG_OFF                            = 0x00000000,
    IOHS_FABRIC_TOD_CROSS_CONFIG_ON                             = 0x00000001,
    IOHS_FABRIC_TOD_CROSS_CONFIG_INVALID                        = 0x000000FF,
};

/**
 *  @brief Indicates if the endpoint target is actively being used as a
 *	fabric link
 */
enum PROC_FABRIC_LINK_ACTIVE
{
    PROC_FABRIC_LINK_ACTIVE_FALSE                               = 0x00000000,
    PROC_FABRIC_LINK_ACTIVE_TRUE                                = 0x00000001,
    PROC_FABRIC_LINK_ACTIVE_INVALID                             = 0x000000FF,
};

/**
 *  @brief Indicates which physical sublinks should be initialized/trained
 */
enum IOHS_LINK_TRAIN
{
    IOHS_LINK_TRAIN_BOTH                                        = 0x00000000,
    IOHS_LINK_TRAIN_EVEN_ONLY                                   = 0x00000001,
    IOHS_LINK_TRAIN_ODD_ONLY                                    = 0x00000002,
    IOHS_LINK_TRAIN_NONE                                        = 0x00000003,
    IOHS_LINK_TRAIN_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Indicates whether sublinks are statically intended to be split
 *	to service endpoints on distinctly different remote chips
 */
enum IOHS_LINK_SPLIT
{
    IOHS_LINK_SPLIT_FALSE                                       = 0x00000000,
    IOHS_LINK_SPLIT_TRUE                                        = 0x00000001,
    IOHS_LINK_SPLIT_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Indicates the bitrate for the link.
 */
enum LINK_SPEED
{
    LINK_SPEED_25G                                              = 0x00000019,
    LINK_SPEED_32G                                              = 0x00000020,
    LINK_SPEED_50G                                              = 0x00000032,
    LINK_SPEED_INVALID                                          = 0x0000FFFF,
};

/**
 *  @brief For each fabric X link on this chip, specifies whether or not
 *	the chip at the receiving end of the link is present and configured
 */
enum PROC_FABRIC_X_ATTACHED_CHIP_CNFG
{
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_FALSE                      = 0x00000000,
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_TRUE                       = 0x00000001,
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_EVEN_ONLY                  = 0x00000002,
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_ODD_ONLY                   = 0x00000003,
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_INVALID                    = 0x000000FF,
};

/**
 *  @brief For each fabric A link on this chip, specifies whether or not
 *	the chip at the receiving end of the link is present and configured
 */
enum PROC_FABRIC_A_ATTACHED_CHIP_CNFG
{
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_FALSE                      = 0x00000000,
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_TRUE                       = 0x00000001,
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_EVEN_ONLY                  = 0x00000002,
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_ODD_ONLY                   = 0x00000003,
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_INVALID                    = 0x000000FF,
};

/**
 *  @brief Indicates if X links on this chip should be configured in
 *	aggregate mode.
 */
enum PROC_FABRIC_X_AGGREGATE
{
    PROC_FABRIC_X_AGGREGATE_OFF                                 = 0x00000000,
    PROC_FABRIC_X_AGGREGATE_ON                                  = 0x00000001,
    PROC_FABRIC_X_AGGREGATE_INVALID                             = 0x000000FF,
};

/**
 *  @brief Indicates if link should be used to carry data only (in
 *	aggregate configurations). Should be considered valid only if
 *	corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
 */
enum PROC_FABRIC_X_ADDR_DIS
{
    PROC_FABRIC_X_ADDR_DIS_OFF                                  = 0x00000000,
    PROC_FABRIC_X_ADDR_DIS_ON                                   = 0x00000001,
    PROC_FABRIC_X_ADDR_DIS_INVALID                              = 0x000000FF,
};

/**
 *  @brief Indicates if A links on this chip should be configured in
 *	aggregate mode.
 */
enum PROC_FABRIC_A_AGGREGATE
{
    PROC_FABRIC_A_AGGREGATE_OFF                                 = 0x00000000,
    PROC_FABRIC_A_AGGREGATE_ON                                  = 0x00000001,
    PROC_FABRIC_A_AGGREGATE_INVALID                             = 0x000000FF,
};

/**
 *  @brief Indicates if link should be used to carry data only (in
 *	aggregate configurations). Should be considered valid only if
 *	corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
 */
enum PROC_FABRIC_A_ADDR_DIS
{
    PROC_FABRIC_A_ADDR_DIS_OFF                                  = 0x00000000,
    PROC_FABRIC_A_ADDR_DIS_ON                                   = 0x00000001,
    PROC_FABRIC_A_ADDR_DIS_INVALID                              = 0x000000FF,
};

/**
 *  @brief Set indirect data routing on A links
 */
enum PROC_FABRIC_A_INDIRECT
{
    PROC_FABRIC_A_INDIRECT_OFF                                  = 0x00000000,
    PROC_FABRIC_A_INDIRECT_ON                                   = 0x00000001,
    PROC_FABRIC_A_INDIRECT_INVALID                              = 0x000000FF,
};

/**
 *  @brief Set state of PB_CFG_INDIRECT_R_EN
 */
enum PROC_FABRIC_R_INDIRECT_EN
{
    PROC_FABRIC_R_INDIRECT_EN_OFF                               = 0x00000000,
    PROC_FABRIC_R_INDIRECT_EN_ON                                = 0x00000001,
    PROC_FABRIC_R_INDIRECT_EN_INVALID                           = 0x000000FF,
};

/**
 *  @brief Fabric topology ID table configuration for smp links. Used to
 *	represent the corresponding ID for each topology ID table entry.
 *	Each topology ID table entry is programmed with the A/X link ID
 *	that routes this chip to the target chip identified by the topology
 *	ID table index.
 */
enum PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE
{
    PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE_INVALID                  = 0x000000FF,
};

/**
 *  @brief Configuration for fabric asynchronous boundary crossings that
 *	exist between the fabric and the MC/PAU/IOHS units.
 */
enum PROC_FABRIC_ASYNC_MODE
{
    PROC_FABRIC_ASYNC_MODE_PERF_MODE                            = 0x00000000,
    PROC_FABRIC_ASYNC_MODE_SAFE_MODE                            = 0x00000001,
    PROC_FABRIC_ASYNC_MODE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Fabric dynamic lane reduction psave mode. Disabled => psave
 *	disabled, same as forcing full width. Quarter => force
 *	quarter-width links. Half => force half-width links. Full/quarter
 *	=> start full width, can drop into quarter-width mode. Full/half =>
 *	start full width, can drop into half-wdith mode.
 */
enum PROC_FABRIC_DLR_PSAVE_MODE
{
    PROC_FABRIC_DLR_PSAVE_MODE_DISABLED                         = 0x00000000,
    PROC_FABRIC_DLR_PSAVE_MODE_QUARTER                          = 0x00000002,
    PROC_FABRIC_DLR_PSAVE_MODE_HALF                             = 0x00000004,
    PROC_FABRIC_DLR_PSAVE_MODE_FULL_QUARTER                     = 0x0000000A,
    PROC_FABRIC_DLR_PSAVE_MODE_FULL_HALF                        = 0x0000000C,
    PROC_FABRIC_DLR_PSAVE_MODE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Processor core floor/ceiling frequency ratio used for epsilon
 *	calculations.
 */
enum PROC_FABRIC_CORE_FREQ_RATIO
{
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_16_16                     = 0x00000000,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_15_16                     = 0x00000001,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_14_16                     = 0x00000002,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_13_16                     = 0x00000003,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_12_16                     = 0x00000004,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_11_16                     = 0x00000005,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_10_16                     = 0x00000006,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_09_16                     = 0x00000007,
    PROC_FABRIC_CORE_FREQ_RATIO_RATIO_08_16                     = 0x00000008,
    PROC_FABRIC_CORE_FREQ_RATIO_INVALID                         = 0x000000FF,
};

/**
 *  @brief Increase the L2 re-request jitter for larger systems
 */
enum MRW_L2_INCREASE_JITTER
{
    MRW_L2_INCREASE_JITTER_FALSE                                = 0x00000000,
    MRW_L2_INCREASE_JITTER_TRUE                                 = 0x00000001,
    MRW_L2_INCREASE_JITTER_INVALID                              = 0x000000FF,
};

/**
 *  @brief Set plus1-prefetch confidence to 3 based on system type, subject
 *	to code enforced core configuration limit
 */
enum MRW_P1PF_MIN_CONFIDENCE_3
{
    MRW_P1PF_MIN_CONFIDENCE_3_FALSE                             = 0x00000000,
    MRW_P1PF_MIN_CONFIDENCE_3_TRUE                              = 0x00000001,
    MRW_P1PF_MIN_CONFIDENCE_3_INVALID                           = 0x000000FF,
};

/**
 *  @brief Convert dcbz operations into read within to modify transactions
 *	in L2
 */
enum MRW_CONVERT_DCBZ_TO_RWITM
{
    MRW_CONVERT_DCBZ_TO_RWITM_FALSE                             = 0x00000000,
    MRW_CONVERT_DCBZ_TO_RWITM_TRUE                              = 0x00000001,
    MRW_CONVERT_DCBZ_TO_RWITM_INVALID                           = 0x000000FF,
};

/**
 *  @brief Adjust core, cache, memory controller dials to favor agressive
 *	prefetch
 */
enum PROC_FAVOR_AGGRESSIVE_PREFETCH
{
    PROC_FAVOR_AGGRESSIVE_PREFETCH_FALSE                        = 0x00000000,
    PROC_FAVOR_AGGRESSIVE_PREFETCH_TRUE                         = 0x00000001,
    PROC_FAVOR_AGGRESSIVE_PREFETCH_INVALID                      = 0x000000FF,
};

/**
 *  @brief Disable Lateral CastOut mode in the caches
 */
enum PROC_LCO_MODE_DISABLE
{
    PROC_LCO_MODE_DISABLE_FALSE                                 = 0x00000000,
    PROC_LCO_MODE_DISABLE_TRUE                                  = 0x00000001,
    PROC_LCO_MODE_DISABLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Controls lateral castout target set formation. ALL: all cores
 *	included in LCO target set ADAPTIVE: base target set selection on
 *	percentage of ECO cores relative to all functional L3s. If the
 *	percentage of ECO cores is greater than or equal to
 *	ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N /
 *	ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D, restrict LCO target set to ECO
 *	cores only. Else, use all cores. ECO_ONLY: only ECO cores included
 *	in LCO target set
 */
enum PROC_LCO_MODE_SETUP
{
    PROC_LCO_MODE_SETUP_ADAPTIVE                                = 0x00000000,
    PROC_LCO_MODE_SETUP_ALL                                     = 0x00000001,
    PROC_LCO_MODE_SETUP_ECO_ONLY                                = 0x00000002,
    PROC_LCO_MODE_SETUP_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Number of eligible L3 LCO targets.
 */
enum PROC_LCO_TARGETS_COUNT
{
    PROC_LCO_TARGETS_COUNT_CHIP                                 = 0x00000000,
    PROC_LCO_TARGETS_COUNT_WEST                                 = 0x00000001,
    PROC_LCO_TARGETS_COUNT_EAST                                 = 0x00000002,
    PROC_LCO_TARGETS_COUNT_INVALID                              = 0x000000FF,
};

/**
 *  @brief Bit vector of eligible L3 LCO targets. Bit 0 = EC0 Bit 1 = EC1
 *	... Bit 30 = EC30 Bit 31 = EC31
 */
enum PROC_LCO_TARGETS_VECTOR
{
    PROC_LCO_TARGETS_VECTOR_CHIP                                = 0x00000000,
    PROC_LCO_TARGETS_VECTOR_WEST                                = 0x00000001,
    PROC_LCO_TARGETS_VECTOR_EAST                                = 0x00000002,
    PROC_LCO_TARGETS_VECTOR_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Minimum number of eligible L3 LCO targets.
 */
enum PROC_LCO_TARGETS_MIN
{
    PROC_LCO_TARGETS_MIN_CHIP                                   = 0x00000000,
    PROC_LCO_TARGETS_MIN_WEST                                   = 0x00000001,
    PROC_LCO_TARGETS_MIN_EAST                                   = 0x00000002,
    PROC_LCO_TARGETS_MIN_NUM_DOMAINS                            = 0x00000003,
    PROC_LCO_TARGETS_MIN_INVALID                                = 0x000000FF,
};

/**
 *  @brief Effective physical link to PAU mapping (given as unit ID).
 *	Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the
 *	given link is configured as OCAPI.
 */
enum IOHS_PHY_TO_PAU_MAPPING
{
    IOHS_PHY_TO_PAU_MAPPING_INVALID                             = 0x000000FF,
};

/**
 *  @brief Disables the L2's address hashing
 */
enum PROC_L2_HASH_DISABLE
{
    PROC_L2_HASH_DISABLE_OFF                                    = 0x00000000,
    PROC_L2_HASH_DISABLE_ON                                     = 0x00000001,
    PROC_L2_HASH_DISABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Disables the L3's address hashing
 */
enum PROC_L3_HASH_DISABLE
{
    PROC_L3_HASH_DISABLE_OFF                                    = 0x00000000,
    PROC_L3_HASH_DISABLE_ON                                     = 0x00000001,
    PROC_L3_HASH_DISABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Stores the state of registers affected by p10_sbe_mcs_setup To
 *	be restored in p10_revert_sbe_mcs_setup. Set by p10_sbe_mcs_setup.
 */
enum PROC_SBE_MCS_SETUP_REG_STATES
{
    PROC_SBE_MCS_SETUP_REG_STATES_MCFGP0                        = 0x00000000,
    PROC_SBE_MCS_SETUP_REG_STATES_MCMODE0                       = 0x00000001,
    PROC_SBE_MCS_SETUP_REG_STATES_MCMODE1                       = 0x00000002,
    PROC_SBE_MCS_SETUP_REG_STATES_MCMODE2                       = 0x00000003,
    PROC_SBE_MCS_SETUP_REG_STATES_MCPERF1                       = 0x00000004,
    PROC_SBE_MCS_SETUP_REG_STATES_MCFIRMASK                     = 0x00000005,
    PROC_SBE_MCS_SETUP_REG_STATES_MCFIRACT0                     = 0x00000006,
    PROC_SBE_MCS_SETUP_REG_STATES_MCFIRACT1                     = 0x00000007,
    PROC_SBE_MCS_SETUP_REG_STATES_MCTO                          = 0x00000008,
    PROC_SBE_MCS_SETUP_REG_STATES_INVALID                       = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief Attribute Indicating if Memory Encryption is enabled and what
 *	type
 */
enum PROC_MEMORY_ENCRYPTION_ENABLED
{
    PROC_MEMORY_ENCRYPTION_ENABLED_DISABLED                     = 0x00000000,
    PROC_MEMORY_ENCRYPTION_ENABLED_XTS                          = 0x00000001,
    PROC_MEMORY_ENCRYPTION_ENABLED_CTR                          = 0x00000002,
    PROC_MEMORY_ENCRYPTION_ENABLED_INVALID                      = 0x000000FF,
};

/**
 *  @brief Select workaround type to be applied if HW543384 is present
 */
enum HW543384_WAR_MODE
{
    HW543384_WAR_MODE_NONE                                      = 0x00000000,
    HW543384_WAR_MODE_TIE_NEST_TO_PAU                           = 0x00000001,
    HW543384_WAR_MODE_FBC_FLOW_CONTROL                          = 0x00000002,
    HW543384_WAR_MODE_BOTH                                      = 0x00000003,
    HW543384_WAR_MODE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Controls whether QMCR[FUSED_CORE_PAIR_MODE] gets set
 */
enum SYSTEM_FUSED_CORE_PAIRED_DISABLE
{
    SYSTEM_FUSED_CORE_PAIRED_DISABLE_FALSE                      = 0x00000000,
    SYSTEM_FUSED_CORE_PAIRED_DISABLE_TRUE                       = 0x00000001,
    SYSTEM_FUSED_CORE_PAIRED_DISABLE_INVALID                    = 0x000000FF,
};

/**
 *  @brief 0 = OCC has never been loaded and FIR Masks have never been
 *	initialized, 1 = FIR masks have been initialized and the hardware
 *	should reflect correct 2 = FIR masks have been initialized but the
 *	current hardware state is the value This should be deprecated. For
 *	now will retain to avoid HB compilation error.
 */
enum PM_FIRINIT_DONE_ONCE_FLAG
{
    PM_FIRINIT_DONE_ONCE_FLAG_NO_INIT                           = 0x00000000,
    PM_FIRINIT_DONE_ONCE_FLAG_FIRS_INITED                       = 0x00000001,
    PM_FIRINIT_DONE_ONCE_FLAG_FIRS_INITED_IN_RESET              = 0x00000002,
    PM_FIRINIT_DONE_ONCE_FLAG_FIRS_RESET_IN_HB                  = 0x00000003,
    PM_FIRINIT_DONE_ONCE_FLAG_INVALID                           = 0x000000FF,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Pstates to be enabled is present and valid Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header, p10_pm_pgpe_init
 */
enum PSTATES_ENABLED
{
    PSTATES_ENABLED_FALSE                                       = 0x00000000,
    PSTATES_ENABLED_TRUE                                        = 0x00000001,
    PSTATES_ENABLED_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Resonant to be enabled is present and valid Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header
 */
enum RESCLK_ENABLED
{
    RESCLK_ENABLED_FALSE                                        = 0x00000000,
    RESCLK_ENABLED_TRUE                                         = 0x00000001,
    RESCLK_ENABLED_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Digital Droop (DDS) to be enabled is present and valid Producer:
 *	proc_build_pstate_datablock Consumers: p10_hcode_image_build ->
 *	PGPE Header QME Header
 */
enum DDS_ENABLED
{
    DDS_ENABLED_FALSE                                           = 0x00000000,
    DDS_ENABLED_TRUE                                            = 0x00000001,
    DDS_ENABLED_INVALID                                         = 0x000000FF,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Retention Regulator Macros (RVRMs) to be enabled is present and
 *	valid Producer: proc_build_pstate_datablock Consumers:
 *	p10_hcode_image_build -> PGPE Header QME Header
 */
enum RVRM_ENABLED
{
    RVRM_ENABLED_FALSE                                          = 0x00000000,
    RVRM_ENABLED_TRUE                                           = 0x00000001,
    RVRM_ENABLED_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Indicator that all relevent attributes and required data for WOF
 *	to be enabled is present and valid Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header
 */
enum WOF_ENABLED
{
    WOF_ENABLED_FALSE                                           = 0x00000000,
    WOF_ENABLED_TRUE                                            = 0x00000001,
    WOF_ENABLED_FORCE_DISABLED                                  = 0x00000002,
    WOF_ENABLED_INVALID                                         = 0x000000FF,
};

/**
 *  @brief Indicator that all relevent attributes and required data for OCS
 *	(Over Current Sensor) to be enabled is present and valid Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header
 */
enum OCS_ENABLED
{
    OCS_ENABLED_FALSE                                           = 0x00000000,
    OCS_ENABLED_TRUE                                            = 0x00000001,
    OCS_ENABLED_INVALID                                         = 0x000000FF,
};

/**
 *  @brief Indicator that all relevent attributes and required data for WOV
 *	Undervolting to be enabled is present and valid Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header
 */
enum WOV_UNDERV_ENABLED
{
    WOV_UNDERV_ENABLED_FALSE                                    = 0x00000000,
    WOV_UNDERV_ENABLED_TRUE                                     = 0x00000001,
    WOV_UNDERV_ENABLED_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Indicator that all relevent attributes and required data for WOV
 *	Overvolting to be enabled is present and valid Producer:
 *	p10_build_pstate_datablock Consumers: p10_hcode_image_build -> PGPE
 *	Header
 */
enum WOV_OVERV_ENABLED
{
    WOV_OVERV_ENABLED_FALSE                                     = 0x00000000,
    WOV_OVERV_ENABLED_TRUE                                      = 0x00000001,
    WOV_OVERV_ENABLED_INVALID                                   = 0x000000FF,
};

/**
 *  @brief This attribute is set to ON (disabled) if ATTR_WOF_PITCH_ENABLE
 *	= ON. and on WOF_ENABLED = ON. Producer: p10_build_pstate_datablock
 *	Consumers: p10_hcode_image_build -> PGPE Header
 */
enum WOF_THROTTLE_CONTROL_DISABLED
{
    WOF_THROTTLE_CONTROL_DISABLED_FALSE                         = 0x00000000,
    WOF_THROTTLE_CONTROL_DISABLED_TRUE                          = 0x00000001,
    WOF_THROTTLE_CONTROL_DISABLED_INVALID                       = 0x000000FF,
};

/**
 *  @brief Enable debug halt function upon XGPE Phantom interrupts
 *	Consumers: p10_hcode_image_build -> XGPE Header
 */
enum XGPE_PHANTOM_HALT_ENABLE
{
    XGPE_PHANTOM_HALT_ENABLE_FALSE                              = 0x00000000,
    XGPE_PHANTOM_HALT_ENABLE_TRUE                               = 0x00000001,
    XGPE_PHANTOM_HALT_ENABLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Enable debug halt function upon PGPE Phantom interrupts
 *	Consumers: p10_hcode_image_build -> PGPE Header
 */
enum PGPE_PHANTOM_HALT_ENABLE
{
    PGPE_PHANTOM_HALT_ENABLE_FALSE                              = 0x00000000,
    PGPE_PHANTOM_HALT_ENABLE_TRUE                               = 0x00000001,
    PGPE_PHANTOM_HALT_ENABLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Enable debug halt function upon QME Stop Phantom stop interrupts
 *	Consumers: p10_hcode_image_build -> QME Header
 */
enum QME_STOP_PHANTOM_HALT_ENABLE
{
    QME_STOP_PHANTOM_HALT_ENABLE_FALSE                          = 0x00000000,
    QME_STOP_PHANTOM_HALT_ENABLE_TRUE                           = 0x00000001,
    QME_STOP_PHANTOM_HALT_ENABLE_INVALID                        = 0x000000FF,
};

/**
 *  @brief Indicates that a special wakeup is in progress for a core.
 *	Producer: proc_cpu_special_wakeup_core.C Consumers:
 *	proc_cpu_special_wakeup_core.C
 */
enum CORE_INSIDE_SPECIAL_WAKEUP
{
    CORE_INSIDE_SPECIAL_WAKEUP_FALSE                            = 0x00000000,
    CORE_INSIDE_SPECIAL_WAKEUP_TRUE                             = 0x00000001,
    CORE_INSIDE_SPECIAL_WAKEUP_INVALID                          = 0x000000FF,
};

/**
 *  @brief Attribute is set at the start of PM halt and cleared at the end.
 *	It allows underlying HWPS that don't have mode indicators to know
 *	that they are being executed during a PM Halt.
 */
enum INITIATED_PM_HALT
{
    INITIATED_PM_HALT_INACTIVE                                  = 0x00000000,
    INITIATED_PM_HALT_ACTIVE                                    = 0x00000001,
    INITIATED_PM_HALT_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Attribute is set in PM Reset and cleared in the immediate
 *	subsequent PM when handling a PM Malfunction related PM Complex
 *	restart cycle.
 */
enum PM_MALF_CYCLE
{
    PM_MALF_CYCLE_INACTIVE                                      = 0x00000000,
    PM_MALF_CYCLE_ACTIVE                                        = 0x00000001,
    PM_MALF_CYCLE_INVALID                                       = 0x000000FF,
};

/**
 *  @brief Enable trap function upon broadside scan Consumers:
 *	p10_hcd_core/cache_*_initf
 */
enum QME_BROADSIDE_SCAN
{
    QME_BROADSIDE_SCAN_FALSE                                    = 0x00000000,
    QME_BROADSIDE_SCAN_TRUE                                     = 0x00000001,
    QME_BROADSIDE_SCAN_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Defines the location where HOMER is located. Producer:
 *	Override/Lab Consumers: p10_pm_pba_init
 */
enum HOMER_LOCATION
{
    HOMER_LOCATION_MEMORY                                       = 0x00000000,
    HOMER_LOCATION_CACHE                                        = 0x00000001,
    HOMER_LOCATION_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Control the mode of QME booting: HCODE_ALLSCAN_BC: image length
 *	is Hcode and all scan rings; load via block copy (product mode)
 *	HCODE_ALLSCAN_NOBC: image length is Hcode and all scan rings; load
 *	via block copy HCODE_CMNSCAN_NOBC: image length is Hcode and common
 *	scan rings; load via direct SRAM insertion HCODE_ONLY_NOBC: image
 *	length is Hcode with no scan rings; loaded via direct SRAM
 *	insertion HCODE_ONLY_BC: image length is Hcode with no scan rings;
 *	loaded via block copy Producer: Override/Lab Consumers:
 *	p10_hcode_image_build; p10_pm_qme_init
 */
enum QME_BOOT_CONTROL
{
    QME_BOOT_CONTROL_HCODE_ALLSCAN_BC                           = 0x00000000,
    QME_BOOT_CONTROL_HCODE_ALLSCAN_NOBC                         = 0x00000001,
    QME_BOOT_CONTROL_HCODE_CMNSCAN_NOBC                         = 0x00000002,
    QME_BOOT_CONTROL_HCODE_ONLY_NOBC                            = 0x00000003,
    QME_BOOT_CONTROL_HCODE_ONLY_BC                              = 0x00000004,
    QME_BOOT_CONTROL_INVALID                                    = 0x000000FF,
};

/**
 *  @brief SPIPSS Clock Polarity CPOL=0 means that clk idle is deasserted,
 *	CPOH=1 means that clk idle is asserted
 */
enum PM_SPIPSS_CLOCK_POLARITY
{
    PM_SPIPSS_CLOCK_POLARITY_CPOL                               = 0x00000000,
    PM_SPIPSS_CLOCK_POLARITY_CPOH                               = 0x00000001,
    PM_SPIPSS_CLOCK_POLARITY_INVALID                            = 0x000000FF,
};

/**
 *  @brief SPIPSS clock phase CPHA=0 means to change/sample values of data
 *	signals on first edge, otherwise on 2nd
 */
enum PM_SPIPSS_CLOCK_PHASE
{
    PM_SPIPSS_CLOCK_PHASE_FIRSTEDGE                             = 0x00000000,
    PM_SPIPSS_CLOCK_PHASE_SECONDEDGE                            = 0x00000001,
    PM_SPIPSS_CLOCK_PHASE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Indicates that a special wakeup is in progress for a core.
 *	Producer: p10_special_wakeup_core.C Consumers:
 *	p10_special_wakeup_core.C
 */
enum INSIDE_SPECIAL_WAKEUP
{
    INSIDE_SPECIAL_WAKEUP_FALSE                                 = 0x00000000,
    INSIDE_SPECIAL_WAKEUP_TRUE                                  = 0x00000001,
    INSIDE_SPECIAL_WAKEUP_INVALID                               = 0x000000FF,
};

/**
 *  @brief This tells core is dead or not. if it is dead, then this core
 *	shouldn't be used in any of bringup activity DISABLED: Not a dead
 *	core ENABLED: Phyp marked dead core
 */
enum DEAD_CORE_MODE
{
    DEAD_CORE_MODE_DISABLED                                     = 0x00000000,
    DEAD_CORE_MODE_ENABLED                                      = 0x00000001,
    DEAD_CORE_MODE_INVALID                                      = 0x000000FF,
};

/**
 *  @brief This attr is used to inject VRM fail to verify VRM callouts
 *	Consumer: p10_avsbus_lib.C
 */
enum AVSBUS_VRM_FAIL_OVERRIDE
{
    AVSBUS_VRM_FAIL_OVERRIDE_NO_ERROR                           = 0x00000000,
    AVSBUS_VRM_FAIL_OVERRIDE_ZERO_RESP_ERR                      = 0x00000001,
    AVSBUS_VRM_FAIL_OVERRIDE_NO_RESP_ERROR                      = 0x00000002,
    AVSBUS_VRM_FAIL_OVERRIDE_MASTER_BAD_CRC_ERROR               = 0x00000003,
    AVSBUS_VRM_FAIL_OVERRIDE_SLAVE_BAD_CRC_ERROR                = 0x00000004,
    AVSBUS_VRM_FAIL_OVERRIDE_UNAVAILABLE_RESOURCE_ERROR         = 0x00000005,
    AVSBUS_VRM_FAIL_OVERRIDE_INVALID_DATA_ERROR                 = 0x00000006,
};

/**
 *  @brief Specifies if spread spectrum is enabled for the OMI links
 */
enum OMI_SPREAD_SPECTRUM
{
    OMI_SPREAD_SPECTRUM_ENABLED                                 = 0x00000001,
    OMI_SPREAD_SPECTRUM_DISABLED                                = 0x00000000,
    OMI_SPREAD_SPECTRUM_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Specifies if spread spectrum is enabled for the iohs links
 */
enum IOHS_SPREAD_SPECTRUM
{
    IOHS_SPREAD_SPECTRUM_ENABLED                                = 0x00000001,
    IOHS_SPREAD_SPECTRUM_DISABLED                               = 0x00000000,
    IOHS_SPREAD_SPECTRUM_INVALID                                = 0x000000FF,
};

/**
 *  @brief Indicates bad lane vector information is valid
 */
enum IOHS_MFG_BAD_LANE_VEC_VALID
{
    IOHS_MFG_BAD_LANE_VEC_VALID_FALSE                           = 0x00000000,
    IOHS_MFG_BAD_LANE_VEC_VALID_TRUE                            = 0x00000001,
    IOHS_MFG_BAD_LANE_VEC_VALID_INVALID                         = 0x000000FF,
};

/**
 *  @brief Unique Mode to help with high xtalk - SW547515
 */
enum IO_IOHS_XTALK
{
    IO_IOHS_XTALK_NO_XTALK                                      = 0x00000000,
    IO_IOHS_XTALK_HI_XTALK                                      = 0x00000001,
    IO_IOHS_XTALK_INVALID                                       = 0x000000FF,
};

/**
 *  @brief Specifies the channel loss
 */
enum IO_IOHS_CHANNEL_LOSS
{
    IO_IOHS_CHANNEL_LOSS_HIGH_LOSS                              = 0x00000000,
    IO_IOHS_CHANNEL_LOSS_MID_LOSS                               = 0x00000001,
    IO_IOHS_CHANNEL_LOSS_LOW_LOSS                               = 0x00000002,
    IO_IOHS_CHANNEL_LOSS_INVALID                                = 0x000000FF,
};

/**
 *  @brief Specifies the channel loss for P11 ISC1
 */
enum IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND
{
    IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_HIGH_LOSS              = 0x00000000,
    IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_MID_LOSS               = 0x00000001,
    IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_LOW_LOSS               = 0x00000002,
    IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_INVALID                = 0x000000FF,
};

/**
 *  @brief Specifies the channel loss
 */
enum IO_OMI_CHANNEL_LOSS
{
    IO_OMI_CHANNEL_LOSS_HIGH_LOSS                               = 0x00000000,
    IO_OMI_CHANNEL_LOSS_MID_LOSS                                = 0x00000001,
    IO_OMI_CHANNEL_LOSS_LOW_LOSS                                = 0x00000002,
    IO_OMI_CHANNEL_LOSS_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Specifies the interposer revision for P11 level
 */
enum INTERPOSER_REV
{
    INTERPOSER_REV_NONE                                         = 0x00000000,
    INTERPOSER_REV_REV1                                         = 0x00000001,
    INTERPOSER_REV_REV2                                         = 0x00000002,
    INTERPOSER_REV_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Specifies if the P11 ISC Defect is present
 */
enum INTERPOSER_FEATURE_HW632898
{
    INTERPOSER_FEATURE_HW632898_FALSE                           = 0x00000000,
    INTERPOSER_FEATURE_HW632898_TRUE                            = 0x00000001,
    INTERPOSER_FEATURE_HW632898_INVALID                         = 0x000000FF,
};

/**
 *  @brief This attribute controls the latches required to configure the
 *	PEC as a x16, x8x8, or x8x4x4 based on what PHBs are active defined
 *	from the MRW. creator: platform consumer: p10_pcie_scominit
 *	firmware notes: These are config dependent attributes based on PCIe
 *	Lane/sideband signal routing and PCIe endpoints attached. Attribute
 *	Name Definition Example Comments Targeted Register Latches
 *	ATTR_PROC_PCIE_PHB_ACTIVE (Stack0, Stack1, Stack2) (1, 0, 0) PHB0
 *	enabled TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H PHB1 disabled
 *	PHB2 disabled Register Latch Definition: PCI0 / PCI1 Register
 *	Address Register Name Bit Signal Name Bit Description 8000009 /
 *	9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE
 *	CFG in the logic that configures x16, x8x8, x8x4x4 1
 *	TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures
 *	x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0
 *	3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4
 *	TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8
 *	TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9
 *	TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10
 *	TC_PCI_IOVALID_DC_10H IOVALID control for Stack2
 */
enum PROC_PCIE_PHB_ACTIVE
{
    PROC_PCIE_PHB_ACTIVE_DISABLE                                = 0x00000000,
    PROC_PCIE_PHB_ACTIVE_ENABLE                                 = 0x00000001,
    PROC_PCIE_PHB_ACTIVE_INVALID                                = 0x000000FF,
};

/**
 *  @brief This attribute controls the latches required to configure the
 *	PHBs to swap its lanes if wiring to the connector/device is
 *	straight or reverse. creator: platform consumer: p10_pcie_scominit
 *	firmware notes: These are config dependent attributes based on PCIe
 *	Lane/sideband signal routing and PCIe endpoints attached. Attribute
 *	Name Definition Example Comments Targeted HWP Attributes
 *	ATTR_PROC_PCIE_LANE_REVERSAL (Stack0, Stack1, Stack2) (1, 0, 0)
 *	Reverse lanes on PHB0. TC_PCI_LANE_CFG_DC_2H Do not reverse lanes
 *	on PHB1. TC_PCI_LANE_CFG_DC_3H Do not reverse lanes on PHB2.
 *	TC_PCI_LANE_CFG_DC_4H Register Address Register Name Bit Signal
 *	Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0
 *	TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures
 *	x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the
 *	logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE
 *	SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for
 *	Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8
 *	TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9
 *	TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10
 *	TC_PCI_IOVALID_DC_10H IOVALID control for Stack2
 */
enum PROC_PCIE_LANE_REVERSAL
{
    PROC_PCIE_LANE_REVERSAL_DISABLE                             = 0x00000000,
    PROC_PCIE_LANE_REVERSAL_ENABLE                              = 0x00000001,
    PROC_PCIE_LANE_REVERSAL_INVALID                             = 0x000000FF,
};

/**
 *  @brief PCIE MMIO BAR enable creator: platform consumer: p10_pcie_config
 *	firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO
 *	BAR0/1 index 2 for PHB register space
 */
enum PROC_PCIE_BAR_ENABLE
{
    PROC_PCIE_BAR_ENABLE_DISABLE                                = 0x00000000,
    PROC_PCIE_BAR_ENABLE_ENABLE                                 = 0x00000001,
    PROC_PCIE_BAR_ENABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief PCIE MMIO BAR size values creator: platform consumer:
 *	p10_pcie_config firmware notes: Array index: BAR number (0:2) NOTE:
 *	supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported
 *	PHB register size is 16KB
 */
enum PROC_PCIE_BAR_SIZE
{
    PROC_PCIE_BAR_SIZE_32_PB                                    = 0x8000000000000000ULL,
    PROC_PCIE_BAR_SIZE_16_PB                                    = 0xC000000000000000ULL,
    PROC_PCIE_BAR_SIZE_8_PB                                     = 0xE000000000000000ULL,
    PROC_PCIE_BAR_SIZE_4_PB                                     = 0xF000000000000000ULL,
    PROC_PCIE_BAR_SIZE_2_PB                                     = 0xF800000000000000ULL,
    PROC_PCIE_BAR_SIZE_1_PB                                     = 0xFC00000000000000ULL,
    PROC_PCIE_BAR_SIZE_512_TB                                   = 0xFE00000000000000ULL,
    PROC_PCIE_BAR_SIZE_256_TB                                   = 0xFF00000000000000ULL,
    PROC_PCIE_BAR_SIZE_128_TB                                   = 0xFF80000000000000ULL,
    PROC_PCIE_BAR_SIZE_64_TB                                    = 0xFFC0000000000000ULL,
    PROC_PCIE_BAR_SIZE_32_TB                                    = 0xFFE0000000000000ULL,
    PROC_PCIE_BAR_SIZE_16_TB                                    = 0xFFF0000000000000ULL,
    PROC_PCIE_BAR_SIZE_8_TB                                     = 0xFFF8000000000000ULL,
    PROC_PCIE_BAR_SIZE_4_TB                                     = 0xFFFC000000000000ULL,
    PROC_PCIE_BAR_SIZE_2_TB                                     = 0xFFFE000000000000ULL,
    PROC_PCIE_BAR_SIZE_1_TB                                     = 0xFFFF000000000000ULL,
    PROC_PCIE_BAR_SIZE_512_GB                                   = 0xFFFF800000000000ULL,
    PROC_PCIE_BAR_SIZE_256_GB                                   = 0xFFFFC00000000000ULL,
    PROC_PCIE_BAR_SIZE_128_GB                                   = 0xFFFFE00000000000ULL,
    PROC_PCIE_BAR_SIZE_64_GB                                    = 0xFFFFF00000000000ULL,
    PROC_PCIE_BAR_SIZE_32_GB                                    = 0xFFFFF80000000000ULL,
    PROC_PCIE_BAR_SIZE_16_GB                                    = 0xFFFFFC0000000000ULL,
    PROC_PCIE_BAR_SIZE_8_GB                                     = 0xFFFFFE0000000000ULL,
    PROC_PCIE_BAR_SIZE_4_GB                                     = 0xFFFFFF0000000000ULL,
    PROC_PCIE_BAR_SIZE_2_GB                                     = 0xFFFFFF8000000000ULL,
    PROC_PCIE_BAR_SIZE_1_GB                                     = 0xFFFFFFC000000000ULL,
    PROC_PCIE_BAR_SIZE_512_MB                                   = 0xFFFFFFE000000000ULL,
    PROC_PCIE_BAR_SIZE_256_MB                                   = 0xFFFFFFF000000000ULL,
    PROC_PCIE_BAR_SIZE_128_MB                                   = 0xFFFFFFF800000000ULL,
    PROC_PCIE_BAR_SIZE_64_MB                                    = 0xFFFFFFFC00000000ULL,
    PROC_PCIE_BAR_SIZE_32_MB                                    = 0xFFFFFFFE00000000ULL,
    PROC_PCIE_BAR_SIZE_16_MB                                    = 0xFFFFFFFF00000000ULL,
    PROC_PCIE_BAR_SIZE_8_MB                                     = 0xFFFFFFFF80000000ULL,
    PROC_PCIE_BAR_SIZE_4_MB                                     = 0xFFFFFFFFC0000000ULL,
    PROC_PCIE_BAR_SIZE_2_MB                                     = 0xFFFFFFFFE0000000ULL,
    PROC_PCIE_BAR_SIZE_1_MB                                     = 0xFFFFFFFFF0000000ULL,
    PROC_PCIE_BAR_SIZE_512_KB                                   = 0xFFFFFFFFF8000000ULL,
    PROC_PCIE_BAR_SIZE_256_KB                                   = 0xFFFFFFFFFC000000ULL,
    PROC_PCIE_BAR_SIZE_128_KB                                   = 0xFFFFFFFFFE000000ULL,
    PROC_PCIE_BAR_SIZE_64_KB                                    = 0xFFFFFFFFFF000000ULL,
    PROC_PCIE_BAR_SIZE_16_KB                                    = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief Defines system specific value of SYS0 refclock receiver
 *	termination
 */
enum SYS0_REFCLOCK_RCVR_TERM
{
    SYS0_REFCLOCK_RCVR_TERM_NONE                                = 0x00000003,
    SYS0_REFCLOCK_RCVR_TERM_FIFTY_OHM                           = 0x00000002,
    SYS0_REFCLOCK_RCVR_TERM_ONE_HUNDRED_OHM                     = 0x00000000,
    SYS0_REFCLOCK_RCVR_TERM_INVALID                             = 0x000000FF,
};

/**
 *  @brief Defines system specific value of SYS1 refclock receiver
 *	termination
 */
enum SYS1_REFCLOCK_RCVR_TERM
{
    SYS1_REFCLOCK_RCVR_TERM_NONE                                = 0x00000003,
    SYS1_REFCLOCK_RCVR_TERM_FIFTY_OHM                           = 0x00000002,
    SYS1_REFCLOCK_RCVR_TERM_ONE_HUNDRED_OHM                     = 0x00000000,
    SYS1_REFCLOCK_RCVR_TERM_INVALID                             = 0x000000FF,
};

/**
 *  @brief Defines system specific value of PCI0 refclock receiver
 *	termination
 */
enum PCI0_REFCLOCK_RCVR_TERM
{
    PCI0_REFCLOCK_RCVR_TERM_NONE                                = 0x00000003,
    PCI0_REFCLOCK_RCVR_TERM_FIFTY_OHM                           = 0x00000002,
    PCI0_REFCLOCK_RCVR_TERM_ONE_HUNDRED_OHM                     = 0x00000000,
    PCI0_REFCLOCK_RCVR_TERM_INVALID                             = 0x000000FF,
};

/**
 *  @brief Defines system specific value of PCI1 refclock receiver
 *	termination
 */
enum PCI1_REFCLOCK_RCVR_TERM
{
    PCI1_REFCLOCK_RCVR_TERM_NONE                                = 0x00000003,
    PCI1_REFCLOCK_RCVR_TERM_FIFTY_OHM                           = 0x00000002,
    PCI1_REFCLOCK_RCVR_TERM_ONE_HUNDRED_OHM                     = 0x00000000,
    PCI1_REFCLOCK_RCVR_TERM_INVALID                             = 0x000000FF,
};

/**
 *  @brief Determine whether planar or processor should take care of
 *	outgoing refclock near-end termination.
 */
enum SYS_CLK_NE_TERMINATION_SITE
{
    SYS_CLK_NE_TERMINATION_SITE_PLANAR                          = 0x00000000,
    SYS_CLK_NE_TERMINATION_SITE_PROC                            = 0x00000001,
    SYS_CLK_NE_TERMINATION_SITE_INVALID                         = 0x000000FF,
};

/**
 *  @brief Per-region drive strength selection for near-end termination.
 *	Drive strength can be selected between 20 mA and 40 mA for all
 *	optics clocks as a group, and for almost each PCIe slot clock
 *	individually (PCI1 slot B+C are grouped together).
 */
enum SYS_CLK_NE_TERMINATION_STRENGTH
{
    SYS_CLK_NE_TERMINATION_STRENGTH_20MA                        = 0x00000000,
    SYS_CLK_NE_TERMINATION_STRENGTH_OP_40MA                     = 0x00000080,
    SYS_CLK_NE_TERMINATION_STRENGTH_PCI0A_40MA                  = 0x00000040,
    SYS_CLK_NE_TERMINATION_STRENGTH_PCI0B_40MA                  = 0x00000020,
    SYS_CLK_NE_TERMINATION_STRENGTH_PCI0C_40MA                  = 0x00000010,
    SYS_CLK_NE_TERMINATION_STRENGTH_PCI1A_40MA                  = 0x00000008,
    SYS_CLK_NE_TERMINATION_STRENGTH_PCI1BC_40MA                 = 0x00000004,
    SYS_CLK_NE_TERMINATION_STRENGTH_INVALID                     = 0x000000FF,
};

/**
 *  @brief Osc refclock configurations: OSCx - Set up single oscillator
 *	BOTH_OSCx - Set up for redundant oscillators, OSCx as primary, both
 *	must be good BOTH_OSCx_NORED - Same but without redundancy: Set up
 *	for redundant oscillators, OSCx as primary, secondary osc may be
 *	bad
 */
enum CP_REFCLOCK_SELECT
{
    CP_REFCLOCK_SELECT_OSC0                                     = 0x00000000,
    CP_REFCLOCK_SELECT_OSC1                                     = 0x00000001,
    CP_REFCLOCK_SELECT_BOTH_OSC0                                = 0x00000002,
    CP_REFCLOCK_SELECT_BOTH_OSC1                                = 0x00000003,
    CP_REFCLOCK_SELECT_BOTH_OSC0_NORED                          = 0x00000004,
    CP_REFCLOCK_SELECT_BOTH_OSC1_NORED                          = 0x00000005,
    CP_REFCLOCK_SELECT_INVALID                                  = 0x000000FF,
};

/**
 *  @brief RCS PLL input for TOD Filter PLL
 */
enum CLOCK_MUX0A_RCS_PLL_INPUT
{
    CLOCK_MUX0A_RCS_PLL_INPUT_SYS_REFCLOCK0                     = 0x00000000,
    CLOCK_MUX0A_RCS_PLL_INPUT_RCS_ASYNC_OUT                     = 0x00000002,
    CLOCK_MUX0A_RCS_PLL_INPUT_RCS_SYNC_OUT                      = 0x00000001,
    CLOCK_MUX0A_RCS_PLL_INPUT_INVALID                           = 0x000000FF,
};

/**
 *  @brief RCS PLL input for Nest Filter PLL
 */
enum CLOCK_MUX0B_RCS_PLL_INPUT
{
    CLOCK_MUX0B_RCS_PLL_INPUT_SYS_REFCLOCK0                     = 0x00000000,
    CLOCK_MUX0B_RCS_PLL_INPUT_RCS_ASYNC_OUT                     = 0x00000002,
    CLOCK_MUX0B_RCS_PLL_INPUT_RCS_SYNC_OUT                      = 0x00000001,
    CLOCK_MUX0B_RCS_PLL_INPUT_INVALID                           = 0x000000FF,
};

/**
 *  @brief RCS PLL input for IO Filter PLL
 */
enum CLOCK_MUX0C_RCS_PLL_INPUT
{
    CLOCK_MUX0C_RCS_PLL_INPUT_SYS_REFCLOCK0                     = 0x00000000,
    CLOCK_MUX0C_RCS_PLL_INPUT_RCS_ASYNC_OUT                     = 0x00000002,
    CLOCK_MUX0C_RCS_PLL_INPUT_RCS_SYNC_OUT                      = 0x00000001,
    CLOCK_MUX0C_RCS_PLL_INPUT_INVALID                           = 0x000000FF,
};

/**
 *  @brief RCS PLL input for IO Spread Spectrum Filter PLL
 */
enum CLOCK_MUX0D_RCS_PLL_INPUT
{
    CLOCK_MUX0D_RCS_PLL_INPUT_SYS_REFCLOCK0                     = 0x00000000,
    CLOCK_MUX0D_RCS_PLL_INPUT_RCS_ASYNC_OUT                     = 0x00000002,
    CLOCK_MUX0D_RCS_PLL_INPUT_RCS_SYNC_OUT                      = 0x00000001,
    CLOCK_MUX0D_RCS_PLL_INPUT_INVALID                           = 0x000000FF,
};

/**
 *  @brief MUX 1 input
 */
enum CLOCK_MUX1_INPUT
{
    CLOCK_MUX1_INPUT_MUX10                                      = 0x00000000,
    CLOCK_MUX1_INPUT_TCK                                        = 0x00000001,
    CLOCK_MUX1_INPUT_INVALID                                    = 0x000000FF,
};

/**
 *  @brief MUX 2a input
 */
enum CLOCK_MUX2A_INPUT
{
    CLOCK_MUX2A_INPUT_PAU_DPLL                                  = 0x00000000,
    CLOCK_MUX2A_INPUT_MUX1                                      = 0x00000001,
    CLOCK_MUX2A_INPUT_INVALID                                   = 0x000000FF,
};

/**
 *  @brief MUX 2b input
 */
enum CLOCK_MUX2B_INPUT
{
    CLOCK_MUX2B_INPUT_PAU_DPLL                                  = 0x00000000,
    CLOCK_MUX2B_INPUT_MUX1                                      = 0x00000001,
    CLOCK_MUX2B_INPUT_INVALID                                   = 0x000000FF,
};

/**
 *  @brief MUX 3 input
 */
enum CLOCK_MUX3_INPUT
{
    CLOCK_MUX3_INPUT_NEST_DPLL                                  = 0x00000000,
    CLOCK_MUX3_INPUT_MUX2B                                      = 0x00000001,
    CLOCK_MUX3_INPUT_INVALID                                    = 0x000000FF,
};

/**
 *  @brief PAU DPLL input from Filter PLLs
 */
enum CLOCK_MUX10_PAU_DPLL_INPUT
{
    CLOCK_MUX10_PAU_DPLL_INPUT_PLLIOSSFLT                       = 0x00000000,
    CLOCK_MUX10_PAU_DPLL_INPUT_PLLIOFLT                         = 0x00000001,
    CLOCK_MUX10_PAU_DPLL_INPUT_INVALID                          = 0x000000FF,
};

/**
 *  @brief NEST DPLL input from Filter PLLs
 */
enum CLOCK_MUX11_NEST_DPLL_INPUT
{
    CLOCK_MUX11_NEST_DPLL_INPUT_PLLIOSSFLT                      = 0x00000000,
    CLOCK_MUX11_NEST_DPLL_INPUT_PLLIOFLT                        = 0x00000001,
    CLOCK_MUX11_NEST_DPLL_INPUT_INVALID                         = 0x000000FF,
};

/**
 *  @brief OMI LCPLL input
 */
enum CLOCK_MUX12_OMI_LCPLL_INPUT
{
    CLOCK_MUX12_OMI_LCPLL_INPUT_PLLTODFLT                       = 0x00000000,
    CLOCK_MUX12_OMI_LCPLL_INPUT_PLLNESTFLT                      = 0x00000002,
    CLOCK_MUX12_OMI_LCPLL_INPUT_PLLIOFLT                        = 0x00000001,
    CLOCK_MUX12_OMI_LCPLL_INPUT_INVALID                         = 0x000000FF,
};

/**
 *  @brief Mux 13 input
 */
enum CLOCK_MUX13_OPT_133_SOURCE_INPUT
{
    CLOCK_MUX13_OPT_133_SOURCE_INPUT_PLLTODFLT                  = 0x00000000,
    CLOCK_MUX13_OPT_133_SOURCE_INPUT_PLLNESTFLT                 = 0x00000002,
    CLOCK_MUX13_OPT_133_SOURCE_INPUT_PLLIOFLT                   = 0x00000001,
    CLOCK_MUX13_OPT_133_SOURCE_INPUT_INVALID                    = 0x000000FF,
};

/**
 *  @brief Mux 14 input
 */
enum CLOCK_MUX14_OPT_156_SOURCE_INPUT
{
    CLOCK_MUX14_OPT_156_SOURCE_INPUT_PLLNESTFLT                 = 0x00000000,
    CLOCK_MUX14_OPT_156_SOURCE_INPUT_PLLIOFLT                   = 0x00000001,
    CLOCK_MUX14_OPT_156_SOURCE_INPUT_INVALID                    = 0x000000FF,
};

/**
 *  @brief IOHS LCPLL input IOHS0: Mux15 IOHS1: Mux16 (no Mux13 input)
 *	IOHS2: Mux17 (no Mux13 input) IOHS3: Mux18 IOHS4: Mux19 IOHS5:
 *	Mux20 IOHS6: Mux21 IOHS7: Mux22
 */
enum CLOCK_MUX_IOHS_LCPLL_INPUT
{
    CLOCK_MUX_IOHS_LCPLL_INPUT_PLLTODFLT                        = 0x00000000,
    CLOCK_MUX_IOHS_LCPLL_INPUT_MUX14                            = 0x00000002,
    CLOCK_MUX_IOHS_LCPLL_INPUT_MUX13                            = 0x00000001,
    CLOCK_MUX_IOHS_LCPLL_INPUT_INVALID                          = 0x000000FF,
};

/**
 *  @brief Mux 23 input from FPLL
 */
enum CLOCK_MUX23_PCI_INPUT
{
    CLOCK_MUX23_PCI_INPUT_PLLTODFLT                             = 0x00000000,
    CLOCK_MUX23_PCI_INPUT_PLLIOSSFLT                            = 0x00000002,
    CLOCK_MUX23_PCI_INPUT_MUX0D                                 = 0x00000001,
    CLOCK_MUX23_PCI_INPUT_INVALID                               = 0x000000FF,
};

/**
 *  @brief PCI LCPLL input mux control PCI0: Mux24 PCI1: Mux25
 */
enum CLOCK_MUX_PCI_LCPLL_INPUT
{
    CLOCK_MUX_PCI_LCPLL_INPUT_MUX23                             = 0x00000000,
    CLOCK_MUX_PCI_LCPLL_INPUT_PCI_REFCLOCK0                     = 0x00000002,
    CLOCK_MUX_PCI_LCPLL_INPUT_PCI_REFCLOCK1                     = 0x00000001,
    CLOCK_MUX_PCI_LCPLL_INPUT_INVALID                           = 0x000000FF,
};

/**
 *  @brief setup clock mux settings for TOD Refclock input 0b0 = 32 MHz LPC
 *	reference clock 0b1 = 16 MHz I/O Filter PLL Output
 */
enum CLOCK_PLL_MUX_TOD
{
    CLOCK_PLL_MUX_TOD_LPC_REFCLOCK                              = 0x00000000,
    CLOCK_PLL_MUX_TOD_PLLTODFLT                                 = 0x00000001,
    CLOCK_PLL_MUX_TOD_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Select workaround type to be applied if HW543822 is present
 */
enum HW543822_WAR_MODE
{
    HW543822_WAR_MODE_FORCE_HUNDRED_OHM_DIFF                    = 0x00000000,
    HW543822_WAR_MODE_FORCE_NO_TERM                             = 0x00000001,
    HW543822_WAR_MODE_FORCE_FIFTY_OHM_SE                        = 0x00000002,
    HW543822_WAR_MODE_NONE                                      = 0x00000003,
    HW543822_WAR_MODE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Set to TRUE to install ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE values
 *	into MC PLLs directly, skipping HWP controlled sequence to resolve
 *	PLL
 */
enum PROC_FORCE_MC_PLL_BANDSEL
{
    PROC_FORCE_MC_PLL_BANDSEL_FALSE                             = 0x00000000,
    PROC_FORCE_MC_PLL_BANDSEL_TRUE                              = 0x00000001,
    PROC_FORCE_MC_PLL_BANDSEL_INVALID                           = 0x000000FF,
};

/**
 *  @brief Define context for current phase of system IPL
 */
enum SYSTEM_IPL_PHASE
{
    SYSTEM_IPL_PHASE_HB_IPL                                     = 0x00000001,
    SYSTEM_IPL_PHASE_HB_RUNTIME                                 = 0x00000002,
    SYSTEM_IPL_PHASE_CONTAINED_IPL                              = 0x00000004,
    SYSTEM_IPL_PHASE_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Define context for current phase of chip IPL for use in
 *	contained_ipl only
 */
enum PROC_CHIP_IPL_PHASE
{
    PROC_CHIP_IPL_PHASE_PRE_CONTAINED_IPL                       = 0x00000001,
    PROC_CHIP_IPL_PHASE_CONTAINED_IPL                           = 0x00000002,
    PROC_CHIP_IPL_PHASE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Indicate if performing SQUBA or LEGACY IPL flow.
 */
enum IPL_TYPE
{
    IPL_TYPE_HP_IPL                                             = 0x00000001,
    IPL_TYPE_CRO_SQUBA                                          = 0x00000002,
    IPL_TYPE_CRO_LEGACY                                         = 0x00000004,
    IPL_TYPE_INVALID                                            = 0x000000FF,
};

/**
 *  @brief Indicate if performing a contained system IPL and if so the type
 *	of contained IPL.
 */
enum CONTAINED_IPL_TYPE
{
    CONTAINED_IPL_TYPE_NONE                                     = 0x00000000,
    CONTAINED_IPL_TYPE_CACHE                                    = 0x00000001,
    CONTAINED_IPL_TYPE_CHIP                                     = 0x00000002,
    CONTAINED_IPL_TYPE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Define mechanism used to load contained testcase
 */
enum CONTAINED_LOAD_PATH
{
    CONTAINED_LOAD_PATH_PBA                                     = 0x00000000,
    CONTAINED_LOAD_PATH_L2SQ                                    = 0x00000001,
    CONTAINED_LOAD_PATH_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Indicates if current IPL is memory-preserving
 */
enum IS_MPIPL
{
    IS_MPIPL_FALSE                                              = 0x00000000,
    IS_MPIPL_TRUE                                               = 0x00000001,
    IS_MPIPL_INVALID                                            = 0x000000FF,
};

/**
 *  @brief Indicates whether IPL should be done by stepping through the
 *	isteps (true) or continuously executing all steps end-to-end
 *	(false).
 */
enum ISTEP_MODE
{
    ISTEP_MODE_FALSE                                            = 0x00000000,
    ISTEP_MODE_TRUE                                             = 0x00000001,
    ISTEP_MODE_INVALID                                          = 0x000000FF,
};

/**
 *  @brief Indicates that SBE should go directly to runtime functionality
 */
enum SBE_RUNTIME_MODE
{
    SBE_RUNTIME_MODE_FALSE                                      = 0x00000000,
    SBE_RUNTIME_MODE_TRUE                                       = 0x00000001,
    SBE_RUNTIME_MODE_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Indicates whether we are connected to FSP or not
 */
enum IS_SP_MODE
{
    IS_SP_MODE_FSP_LESS                                         = 0x00000000,
    IS_SP_MODE_FSP                                              = 0x00000001,
    IS_SP_MODE_INVALID                                          = 0x000000FF,
};

/**
 *  @brief BootLoader HWP flag to not place 12K exception vectors. This
 *	flag is only applicable when security is disabled.
 */
enum DISABLE_HBBL_VECTORS
{
    DISABLE_HBBL_VECTORS_FALSE                                  = 0x00000000,
    DISABLE_HBBL_VECTORS_TRUE                                   = 0x00000001,
    DISABLE_HBBL_VECTORS_INVALID                                = 0x000000FF,
};

/**
 *  @brief Select Primary or Backup Boot SEEPROM
 */
enum BACKUP_SEEPROM_SELECT
{
    BACKUP_SEEPROM_SELECT_PRIMARY                               = 0x00000000,
    BACKUP_SEEPROM_SELECT_SECONDARY                             = 0x00000001,
    BACKUP_SEEPROM_SELECT_INVALID                               = 0x000000FF,
};

/**
 *  @brief Select Primary or Backup Measurement SEEPROM
 */
enum BACKUP_MEASUREMENT_SEEPROM_SELECT
{
    BACKUP_MEASUREMENT_SEEPROM_SELECT_PRIMARY                   = 0x00000000,
    BACKUP_MEASUREMENT_SEEPROM_SELECT_SECONDARY                 = 0x00000001,
    BACKUP_MEASUREMENT_SEEPROM_SELECT_INVALID                   = 0x000000FF,
};

/**
 *  @brief Holds the state of Security Access Bit (SAB)
 */
enum SECURITY_ENABLE
{
    SECURITY_ENABLE_ENABLE                                      = 0x00000001,
    SECURITY_ENABLE_DISABLE                                     = 0x00000000,
    SECURITY_ENABLE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Consumed by p10_sbe_select_ex. Dictates policy for selection of
 *	active cores and backing caches CRONUS_MAX_ACTIVE -- request
 *	maximum set of active cores possible (use case for Cronus istep 4
 *	to establish run state on all functional cores), no backing caches
 *	HB_DEFAULT -- request minset of active cores (2 in fused core mode,
 *	1 otherwise) and backing caches (2) HB_MAX_FOOTPRINT -- request the
 *	maximum set of backing caches possible (maintaining a power of 2
 *	size, and guaranteeing minset of active cores) HB_MAX_THREADS --
 *	request the maximum set of active cores possible, logically applied
 *	after processing HB_MAX_FOOTPRINT directive if set For memory
 *	preserving IPLs, the attribute will be honored in the calcuation of
 *	active cores, but no backing caches will be requested For
 *	cache-contained IPL types, the selection policy is fixed in code --
 *	request maximum set of active cores possible, no backing caches For
 *	chip-contained IPL types, the selection policy is fixed in code --
 *	request based on contents of ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC,
 *	ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC
 */
enum SBE_SELECT_EX_POLICY
{
    SBE_SELECT_EX_POLICY_HB_DEFAULT                             = 0x00000000,
    SBE_SELECT_EX_POLICY_CRONUS_MAX_ACTIVE                      = 0x00000001,
    SBE_SELECT_EX_POLICY_HB_MAX_FOOTPRINT                       = 0x00000002,
    SBE_SELECT_EX_POLICY_HB_MAX_THREADS                         = 0x00000004,
    SBE_SELECT_EX_POLICY_HB_MAX_FOOTPRINT_MAX_THREADS           = 0x00000006,
    SBE_SELECT_EX_POLICY_INVALID                                = 0x000000FF,
};

/**
 *  @brief Summarizes the fused status of cores. This is same for all p10
 *	chips in the system. If a core is in a fused state, attribute
 *	should read 1 else zero. It needs to be populated during ipl but
 *	before istep 15.
 */
enum FUSED_CORE_MODE
{
    FUSED_CORE_MODE_CORE_UNFUSED                                = 0x00000000,
    FUSED_CORE_MODE_CORE_FUSED                                  = 0x00000001,
    FUSED_CORE_MODE_INVALID                                     = 0xFFFFFFFF,
};

/**
 *  @brief Sets policy for core LPAR configuration
 */
enum CORE_LPAR_MODE_POLICY
{
    CORE_LPAR_MODE_POLICY_FOLLOW_FUSED_STATE                    = 0x00000000,
    CORE_LPAR_MODE_POLICY_LPAR_PER_CORE                         = 0x00000001,
    CORE_LPAR_MODE_POLICY_LPAR_PER_THREAD                       = 0x00000002,
    CORE_LPAR_MODE_POLICY_INVALID                               = 0x000000FF,
};

/**
 *  @brief Sets policy for IPL time core LPAR configuration
 */
enum CORE_LPAR_MODE
{
    CORE_LPAR_MODE_LPAR_PER_THREAD                              = 0x00000000,
    CORE_LPAR_MODE_LPAR_PER_CORE                                = 0x00000001,
    CORE_LPAR_MODE_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Set if the MVPD PG keyword indicates that there are no good
 *	cores on the chip.
 */
enum ZERO_CORE_CHIP
{
    ZERO_CORE_CHIP_FALSE                                        = 0x00000000,
    ZERO_CORE_CHIP_TRUE                                         = 0x00000001,
    ZERO_CORE_CHIP_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Enable PVR 82
 */
enum PVR_82_MODE
{
    PVR_82_MODE_OFF                                             = 0x00000000,
    PVR_82_MODE_ON                                              = 0x00000001,
    PVR_82_MODE_INVALID                                         = 0x000000FF,
};

/**
 *  @brief Set to true if the processor chip is part of an ioSCM.
 */
enum IS_IOSCM
{
    IS_IOSCM_FALSE                                              = 0x00000000,
    IS_IOSCM_TRUE                                               = 0x00000001,
    IS_IOSCM_INVALID                                            = 0x000000FF,
};

/**
 *  @brief Dictates whether core target should be configured as an extended
 *	cache only DISABLED - core + MMA/L2/L3 enabled, target supports
 *	instruction execution ENABLED - only L3 enabled, target supports
 *	extended cache operation only
 */
enum ECO_MODE
{
    ECO_MODE_DISABLED                                           = 0x00000000,
    ECO_MODE_ENABLED                                            = 0x00000001,
    ECO_MODE_INVALID                                            = 0x000000FF,
};

/**
 *  @brief Indicates if SBE on this chip is serving as hostboot drawer
 *	master
 */
enum PROC_SBE_MASTER_CHIP
{
    PROC_SBE_MASTER_CHIP_FALSE                                  = 0x00000000,
    PROC_SBE_MASTER_CHIP_TRUE                                   = 0x00000001,
    PROC_SBE_MASTER_CHIP_INVALID                                = 0x000000FF,
};

/**
 *  @brief To skip the locking sequence and check for lock of CP TOD Filter
 *	PLL
 */
enum CP_PLLTODFLT_BYPASS
{
    CP_PLLTODFLT_BYPASS_BYPASS                                  = 0x00000001,
    CP_PLLTODFLT_BYPASS_NO_BYPASS                               = 0x00000000,
    CP_PLLTODFLT_BYPASS_INVALID                                 = 0x000000FF,
};

/**
 *  @brief To skip the locking sequence and check for lock of CP Nest
 *	Filter PLL
 */
enum CP_PLLNESTFLT_BYPASS
{
    CP_PLLNESTFLT_BYPASS_BYPASS                                 = 0x00000001,
    CP_PLLNESTFLT_BYPASS_NO_BYPASS                              = 0x00000000,
    CP_PLLNESTFLT_BYPASS_INVALID                                = 0x000000FF,
};

/**
 *  @brief To skip the locking sequence and check for lock of CP IO Filter
 *	PLL
 */
enum CP_PLLIOFLT_BYPASS
{
    CP_PLLIOFLT_BYPASS_BYPASS                                   = 0x00000001,
    CP_PLLIOFLT_BYPASS_NO_BYPASS                                = 0x00000000,
    CP_PLLIOFLT_BYPASS_INVALID                                  = 0x000000FF,
};

/**
 *  @brief To skip the locking sequence and check for lock of CP IO Spread
 *	Spectrum Filter PLL
 */
enum CP_PLLIOSSFLT_BYPASS
{
    CP_PLLIOSSFLT_BYPASS_BYPASS                                 = 0x00000001,
    CP_PLLIOSSFLT_BYPASS_NO_BYPASS                              = 0x00000000,
    CP_PLLIOSSFLT_BYPASS_INVALID                                = 0x000000FF,
};

/**
 *  @brief Skip locking sequence and check for lock of PAU DPLL
 */
enum PAU_DPLL_BYPASS
{
    PAU_DPLL_BYPASS_BYPASS                                      = 0x00000001,
    PAU_DPLL_BYPASS_NO_BYPASS                                   = 0x00000000,
    PAU_DPLL_BYPASS_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Skip locking sequence and check for lock of NEST DPLL
 */
enum NEST_DPLL_BYPASS
{
    NEST_DPLL_BYPASS_BYPASS                                     = 0x00000001,
    NEST_DPLL_BYPASS_NO_BYPASS                                  = 0x00000000,
    NEST_DPLL_BYPASS_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Skip locking sequence and check for lock of IO PLLs
 */
enum IO_TANK_PLL_BYPASS
{
    IO_TANK_PLL_BYPASS_BYPASS                                   = 0x00000001,
    IO_TANK_PLL_BYPASS_NO_BYPASS                                = 0x00000000,
    IO_TANK_PLL_BYPASS_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Keep skew adjust logic between nest, cores and caches bypassed
 */
enum SKEWADJ_BYPASS
{
    SKEWADJ_BYPASS_BYPASS                                       = 0x00000001,
    SKEWADJ_BYPASS_NO_BYPASS                                    = 0x00000000,
    SKEWADJ_BYPASS_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Keep core duty cycle adjust logic bypassed
 */
enum DCADJ_BYPASS
{
    DCADJ_BYPASS_BYPASS                                         = 0x00000001,
    DCADJ_BYPASS_NO_BYPASS                                      = 0x00000000,
    DCADJ_BYPASS_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Indicates if LPC console is enabled on system
 */
enum LPC_CONSOLE_CNFG
{
    LPC_CONSOLE_CNFG_ENABLE                                     = 0x00000001,
    LPC_CONSOLE_CNFG_DISABLE                                    = 0x00000000,
    LPC_CONSOLE_CNFG_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Set up the chip so that all chiplet clocks are automatically
 *	stopped in case of a checkstop. Possible enum values: DISABLED -
 *	Don't stop clocks on any error STOP_ON_XSTOP - Stop on either an
 *	xstop in the local chiplet or on a system xstop coming in from
 *	outside the chiplet STOP_ON_XSTOP_AND_SPATTN - Like above, plus
 *	special attentions STOP_ON_STAGED_XSTOP - Stop _only_ on an
 *	incoming staged system xstop to ensure that all chiplets stop in
 *	the same instant. This will result in a longer delay between the
 *	original error and the clocks stopping.
 */
enum CLOCKSTOP_ON_XSTOP
{
    CLOCKSTOP_ON_XSTOP_DISABLED                                 = 0x00000000,
    CLOCKSTOP_ON_XSTOP_STOP_ON_XSTOP                            = 0x0000007B,
    CLOCKSTOP_ON_XSTOP_STOP_ON_XSTOP_AND_SPATTN                 = 0x0000005B,
    CLOCKSTOP_ON_XSTOP_STOP_ON_STAGED_XSTOP                     = 0x000000FD,
    CLOCKSTOP_ON_XSTOP_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Setup the option to checkstop on special attentions.
 */
enum XSTOP_ON_SPATTN
{
    XSTOP_ON_SPATTN_DISABLED                                    = 0x00000000,
    XSTOP_ON_SPATTN_ENABLED                                     = 0x00000001,
    XSTOP_ON_SPATTN_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Force the SBE to boot with PAU DPLL in bypass
 */
enum BOOT_PAU_DPLL_BYPASS
{
    BOOT_PAU_DPLL_BYPASS_BYPASS                                 = 0x00000001,
    BOOT_PAU_DPLL_BYPASS_NO_BYPASS                              = 0x00000000,
    BOOT_PAU_DPLL_BYPASS_INVALID                                = 0x000000FF,
};

/**
 *  @brief The frequency of the memory controller mesh clock, in MHz. This
 *	clock is asynchronous to the nest and drives the MCU queues, and
 *	all the associated logic that drives the inputs to the OMI. This
 *	can be set differently for each memory controller in the chip. This
 *	frequency is 1/16 of the OMI frequency.
 */
enum FREQ_MC_MHZ
{
    FREQ_MC_MHZ_1333                                            = 0x00000535,
    FREQ_MC_MHZ_1466                                            = 0x000005BA,
    FREQ_MC_MHZ_1600                                            = 0x00000640,
    FREQ_MC_MHZ_2000                                            = 0x000007D0,
    FREQ_MC_MHZ_2400                                            = 0x00000960,
    FREQ_MC_MHZ_INVALID                                         = 0xFFFFFFFF,
};

/**
 *  @brief The frequency of the OMI channel.
 */
enum FREQ_OMI_MHZ
{
    FREQ_OMI_MHZ_21330                                          = 0x00005352,
    FREQ_OMI_MHZ_23460                                          = 0x00005BA4,
    FREQ_OMI_MHZ_25600                                          = 0x00006400,
    FREQ_OMI_MHZ_32000                                          = 0x00007D00,
    FREQ_OMI_MHZ_38400                                          = 0x00009600,
    FREQ_OMI_MHZ_INVALID                                        = 0xFFFFFFFF,
};

/**
 *  @brief The frequency of a processor's IOHS mesh clocks, in MHz. This
 *	can be set differently on a by-link basis.
 */
enum FREQ_IOHS_MHZ
{
    FREQ_IOHS_MHZ_1611                                          = 0x0000064B,
    FREQ_IOHS_MHZ_1992                                          = 0x000007C8,
    FREQ_IOHS_MHZ_2000                                          = 0x000007D0,
    FREQ_IOHS_MHZ_2031                                          = 0x000007EF,
    FREQ_IOHS_MHZ_2067                                          = 0x00000813,
    FREQ_IOHS_MHZ_2109                                          = 0x0000083D,
    FREQ_IOHS_MHZ_INVALID                                       = 0xFFFFFFFF,
};

/**
 *  @brief The frequency of a processor's IOHS link clock, in MHz. This can
 *	be set differently on a by-link basis.
 */
enum FREQ_IOHS_LINK_MHZ
{
    FREQ_IOHS_LINK_MHZ_25781                                    = 0x000064B5,
    FREQ_IOHS_LINK_MHZ_31875                                    = 0x00007C83,
    FREQ_IOHS_LINK_MHZ_32000                                    = 0x00007D00,
    FREQ_IOHS_LINK_MHZ_32500                                    = 0x00007EF4,
    FREQ_IOHS_LINK_MHZ_33067                                    = 0x0000812B,
    FREQ_IOHS_LINK_MHZ_33750                                    = 0x000083D6,
    FREQ_IOHS_LINK_MHZ_INVALID                                  = 0xFFFFFFFF,
};

/**
 *  @brief Defines IOHS frequency of AX link, accessible on proc-scoped
 *	attribute. Index is logical fabric link number Set in
 *	p10_fbc_eff_config / p10_fbc_eff_config_links Used by fabric
 *	initfiles.
 */
enum FREQ_PROC_IOHS_MHZ
{
    FREQ_PROC_IOHS_MHZ_1611                                     = 0x0000064B,
    FREQ_PROC_IOHS_MHZ_1992                                     = 0x000007C8,
    FREQ_PROC_IOHS_MHZ_2000                                     = 0x000007D0,
    FREQ_PROC_IOHS_MHZ_2031                                     = 0x000007EF,
    FREQ_PROC_IOHS_MHZ_2067                                     = 0x00000813,
    FREQ_PROC_IOHS_MHZ_2109                                     = 0x0000083D,
    FREQ_PROC_IOHS_MHZ_INVALID                                  = 0xFFFFFFFF,
};

/**
 *  @brief Select alternative (higher) PAU frequency setpoint.
 */
enum INCREASED_PAU_FREQ
{
    INCREASED_PAU_FREQ_DISABLE                                  = 0x00000000,
    INCREASED_PAU_FREQ_ENABLE                                   = 0x00000001,
    INCREASED_PAU_FREQ_INVALID                                  = 0x000000FF,
};

/**
 *  @brief The frequency of a processor's PCIe bus in MHz. This is the same
 *	for all PCIe buses in the system. Provided by the MRW.
 */
enum FREQ_PCIE_MHZ
{
    FREQ_PCIE_MHZ_2000                                          = 0x000007D0,
    FREQ_PCIE_MHZ_INVALID                                       = 0xFFFFFFFF,
};

/**
 *  @brief Specify the system policy to enforce synchronous mode between
 *	memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE.
 *	UNDETERMINED : Run synchronously if the dimm and nest freq matches
 *	ALWAYS : Require matching frequencies and deconfigure memory that
 *	does not match the nest NEVER : Do not run synchronously, even if
 *	the frequencies match
 */
enum REQUIRED_SYNCH_MODE
{
    REQUIRED_SYNCH_MODE_UNDETERMINED                            = 0x00000000,
    REQUIRED_SYNCH_MODE_ALWAYS                                  = 0x00000001,
    REQUIRED_SYNCH_MODE_NEVER                                   = 0x00000002,
    REQUIRED_SYNCH_MODE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Enable proc downstream transmit template 1. Should be enabled by
 *	default.
 */
enum PROC_ENABLE_DL_TMPL_1
{
    PROC_ENABLE_DL_TMPL_1_DISABLED                              = 0x00000000,
    PROC_ENABLE_DL_TMPL_1_ENABLED                               = 0x00000001,
    PROC_ENABLE_DL_TMPL_1_INVALID                               = 0x000000FF,
};

/**
 *  @brief Enable proc downstream transmit template 4. Should be enabled by
 *	default.
 */
enum PROC_ENABLE_DL_TMPL_4
{
    PROC_ENABLE_DL_TMPL_4_DISABLED                              = 0x00000000,
    PROC_ENABLE_DL_TMPL_4_ENABLED                               = 0x00000001,
    PROC_ENABLE_DL_TMPL_4_INVALID                               = 0x000000FF,
};

/**
 *  @brief Enable proc downstream transmit template 7. Should be disabled
 *	by default.
 */
enum PROC_ENABLE_DL_TMPL_7
{
    PROC_ENABLE_DL_TMPL_7_DISABLED                              = 0x00000000,
    PROC_ENABLE_DL_TMPL_7_ENABLED                               = 0x00000001,
    PROC_ENABLE_DL_TMPL_7_INVALID                               = 0x000000FF,
};

/**
 *  @brief Enable proc downstream transmit template A. Should be disabled
 *	by default.
 */
enum PROC_ENABLE_DL_TMPL_A
{
    PROC_ENABLE_DL_TMPL_A_DISABLED                              = 0x00000000,
    PROC_ENABLE_DL_TMPL_A_ENABLED                               = 0x00000001,
    PROC_ENABLE_DL_TMPL_A_INVALID                               = 0x000000FF,
};

/**
 *  @brief Selects the settings for DSTLFIR and USTLFIR channel fail FIRs
 *	Default: LOCAL_XSTOP (channel based FIRs will cause local
 *	checkstop) Note that this will get overridden by
 *	ATTR_CHIP_EC_FEATURE_OMI_CHANNEL_FIRS on DD1 unless set as CONST.
 *	Affects the following FIRs: DSTLFIR_SUBCHANNEL_A/B_COUNTER_ERROR
 *	DSTLFIR_SUBCHANNEL_A/B_BUFFER_OVERUSE_ERROR
 *	DSTLFIR_SUBCHANNEL_A/B_CHANNEL_TIMEOUT
 *	DSTLFIR_SUBCHANNEL_A/B_PARITY_ERROR
 *	DSTLFIR_SUBCHANNEL_A/B_TLX_CHECKSTOP USTLFIR_CHANA/B_UNEXP_DATA_ERR
 *	USTLFIR_CHANA/B_INVALID_TEMPLATE_ERROR
 *	USTLFIR_CHANA/B_FAIL_RESP_CHECKSTOP
 *	USTLFIR_CHANA/B_FLIT_PARITY_ERROR
 *	USTLFIR_CHANA/B_FATAL_PARITY_ERROR USTLFIR_CHANA/B_BAD_RESP_LOG_VAL
 *	USTLFIR_CHANA/B_EXCESS_BAD_DATA_BITS
 *	USTLFIR_CHANA/B_COMP_TMPL0_DATA_NOT_MMIO
 *	USTLFIR_CHANA/B_EXCESS_DATA_ERROR
 *	USTLFIR_CHANA/B_BADCRC_DATA_NOT_VALID_ERROR
 *	USTLFIR_CHANA/B_FIFO_OVERFLOW_ERROR
 *	USTLFIR_CHANA/B_INVALID_CMD_ERROR
 *	USTLFIR_CHANA/B_INVALID_DL_DP_COMBO MC_OMI_FIR_REG_DL0_FATAL_ERROR
 *	(LOCAL_XSTOP will set to recoverable)
 *	MC_OMI_FIR_REG_DL1_FATAL_ERROR (LOCAL_XSTOP will set to
 *	recoverable)
 */
enum OMI_CHANNEL_FAIL_ACTION
{
    OMI_CHANNEL_FAIL_ACTION_MASKED                              = 0x00000000,
    OMI_CHANNEL_FAIL_ACTION_XSTOP                               = 0x00000001,
    OMI_CHANNEL_FAIL_ACTION_LOCAL_XSTOP                         = 0x00000002,
    OMI_CHANNEL_FAIL_ACTION_RECOVERABLE                         = 0x00000003,
    OMI_CHANNEL_FAIL_ACTION_INVALID                             = 0x000000FF,
};

/**
 *  @brief Time window value for OMI EDPL fails during MFG screen per
 *	channel. This value will be set in DL0_CONFIG1[CFG_EDPL_TIME] when
 *	MFG_FLAG 'Activate CRC and EDPL counters' is set.
 */
enum MSS_MNFG_EDPL_TIME
{
    MSS_MNFG_EDPL_TIME_NONE                                     = 0x00000000,
    MSS_MNFG_EDPL_TIME_4US                                      = 0x00000001,
    MSS_MNFG_EDPL_TIME_32US                                     = 0x00000002,
    MSS_MNFG_EDPL_TIME_256US                                    = 0x00000003,
    MSS_MNFG_EDPL_TIME_2MS                                      = 0x00000004,
    MSS_MNFG_EDPL_TIME_16MS                                     = 0x00000005,
    MSS_MNFG_EDPL_TIME_128MS                                    = 0x00000006,
    MSS_MNFG_EDPL_TIME_1S                                       = 0x00000007,
    MSS_MNFG_EDPL_TIME_8S                                       = 0x00000008,
    MSS_MNFG_EDPL_TIME_64S                                      = 0x00000009,
    MSS_MNFG_EDPL_TIME_512S                                     = 0x0000000A,
    MSS_MNFG_EDPL_TIME_4KS                                      = 0x0000000B,
    MSS_MNFG_EDPL_TIME_32KS                                     = 0x0000000C,
    MSS_MNFG_EDPL_TIME_256KS                                    = 0x0000000D,
    MSS_MNFG_EDPL_TIME_2MGS                                     = 0x0000000E,
    MSS_MNFG_EDPL_TIME_16MGS                                    = 0x0000000F,
    MSS_MNFG_EDPL_TIME_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Threshold value for OMI EDPL fails during MFG screen per
 *	channel. This value will be set in DL0_CONFIG1[CFG_EDPL_THRESHOLD]
 *	when MFG_FLAG 'Activate CRC and EDPL counters' is set.
 */
enum MSS_MNFG_EDPL_THRESHOLD
{
    MSS_MNFG_EDPL_THRESHOLD_NONE                                = 0x00000000,
    MSS_MNFG_EDPL_THRESHOLD_2_ERRORS                            = 0x00000001,
    MSS_MNFG_EDPL_THRESHOLD_4_ERRORS                            = 0x00000002,
    MSS_MNFG_EDPL_THRESHOLD_8_ERRORS                            = 0x00000003,
    MSS_MNFG_EDPL_THRESHOLD_16_ERRORS                           = 0x00000004,
    MSS_MNFG_EDPL_THRESHOLD_32_ERRORS                           = 0x00000005,
    MSS_MNFG_EDPL_THRESHOLD_64_ERRORS                           = 0x00000006,
    MSS_MNFG_EDPL_THRESHOLD_128_ERRORS                          = 0x00000007,
    MSS_MNFG_EDPL_THRESHOLD_INVALID                             = 0x000000FF,
};

/**
 *  @brief creator: platform consumer: p10_setup_mmio_bars firmware notes:
 *	none
 */
enum PROC_FSP_BAR_ENABLE
{
    PROC_FSP_BAR_ENABLE_DISABLE                                 = 0x00000000,
    PROC_FSP_BAR_ENABLE_ENABLE                                  = 0x00000001,
    PROC_FSP_BAR_ENABLE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief creator: platform consumer: p10_setup_mmio_bars firmware notes:
 *	none
 */
enum PROC_FSP_BAR_SIZE
{
    PROC_FSP_BAR_SIZE_4_GB                                      = 0xFFFFF000FFFFFFFFULL,
    PROC_FSP_BAR_SIZE_2_GB                                      = 0xFFFFF0007FFFFFFFULL,
    PROC_FSP_BAR_SIZE_1_GB                                      = 0xFFFFF0003FFFFFFFULL,
    PROC_FSP_BAR_SIZE_512_MB                                    = 0xFFFFF0001FFFFFFFULL,
    PROC_FSP_BAR_SIZE_256_MB                                    = 0xFFFFF0000FFFFFFFULL,
    PROC_FSP_BAR_SIZE_128_MB                                    = 0xFFFFF00007FFFFFFULL,
    PROC_FSP_BAR_SIZE_64_MB                                     = 0xFFFFF00003FFFFFFULL,
    PROC_FSP_BAR_SIZE_32_MB                                     = 0xFFFFF00001FFFFFFULL,
    PROC_FSP_BAR_SIZE_16_MB                                     = 0xFFFFF00000FFFFFFULL,
    PROC_FSP_BAR_SIZE_8_MB                                      = 0xFFFFF000007FFFFFULL,
    PROC_FSP_BAR_SIZE_4_MB                                      = 0xFFFFF000003FFFFFULL,
    PROC_FSP_BAR_SIZE_2_MB                                      = 0xFFFFF000001FFFFFULL,
    PROC_FSP_BAR_SIZE_1_MB                                      = 0xFFFFF000000FFFFFULL,
    PROC_FSP_BAR_SIZE_INVALID                                   = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief creator: platform consumer: p10_setup_mmio_bars firmware notes:
 *	AND mask applied to RA 32:35 when transmitting address to FSP NOTE:
 *	RA 8:31 are always replaced with zero
 */
enum PROC_FSP_MMIO_MASK_SIZE
{
    PROC_FSP_MMIO_MASK_SIZE_4_GB                                = 0x0000000F,
    PROC_FSP_MMIO_MASK_SIZE_2_GB                                = 0x00000007,
    PROC_FSP_MMIO_MASK_SIZE_1_GB                                = 0x00000003,
    PROC_FSP_MMIO_MASK_SIZE_512_MB                              = 0x00000001,
    PROC_FSP_MMIO_MASK_SIZE_256_MB                              = 0x00000000,
    PROC_FSP_MMIO_MASK_SIZE_INVALID                             = 0x000000FF,
};

/**
 *  @brief creator: platform consumer: p10_setup_mmio_bars firmware notes:
 *	none
 */
enum PROC_PAU_MMIO_BAR_ENABLE
{
    PROC_PAU_MMIO_BAR_ENABLE_DISABLE                            = 0x00000000,
    PROC_PAU_MMIO_BAR_ENABLE_ENABLE                             = 0x00000001,
    PROC_PAU_MMIO_BAR_ENABLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief creator: platform consumer: p10_setup_mmio_bars firmware notes:
 *	none
 */
enum PROC_PSI_BRIDGE_BAR_ENABLE
{
    PROC_PSI_BRIDGE_BAR_ENABLE_DISABLE                          = 0x00000000,
    PROC_PSI_BRIDGE_BAR_ENABLE_ENABLE                           = 0x00000001,
    PROC_PSI_BRIDGE_BAR_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief creator: platform consumer: p10_rng_init_phase2 firmware notes:
 *	none
 */
enum PROC_NX_RNG_BAR_ENABLE
{
    PROC_NX_RNG_BAR_ENABLE_DISABLE                              = 0x00000000,
    PROC_NX_RNG_BAR_ENABLE_ENABLE                               = 0x00000001,
    PROC_NX_RNG_BAR_ENABLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief creator: platform consumer: p10_rng_init_phase2 firmware notes:
 *	Enables optional post of interrupt when both NX RNG voice sources
 *	have failed
 */
enum PROC_NX_RNG_FAILED_INT_ENABLE
{
    PROC_NX_RNG_FAILED_INT_ENABLE_DISABLE                       = 0x00000000,
    PROC_NX_RNG_FAILED_INT_ENABLE_ENABLE                        = 0x00000001,
    PROC_NX_RNG_FAILED_INT_ENABLE_INVALID                       = 0x000000FF,
};

/**
 *  @brief The amount of memory a user can reserve to store NHTM traces.
 *	This amount will be used to store both NHTM0 and NHTM1 traces. Used
 *	by p10_mss_eff_grouping.
 */
enum PROC_NHTM_BAR_SIZE
{
    PROC_NHTM_BAR_SIZE_256_GB                                   = 0x4000000000ULL,
    PROC_NHTM_BAR_SIZE_128_GB                                   = 0x2000000000ULL,
    PROC_NHTM_BAR_SIZE_64_GB                                    = 0x1000000000ULL,
    PROC_NHTM_BAR_SIZE_32_GB                                    = 0x800000000ULL,
    PROC_NHTM_BAR_SIZE_16_GB                                    = 0x400000000ULL,
    PROC_NHTM_BAR_SIZE_8_GB                                     = 0x200000000ULL,
    PROC_NHTM_BAR_SIZE_4_GB                                     = 0x100000000ULL,
    PROC_NHTM_BAR_SIZE_2_GB                                     = 0x80000000,
    PROC_NHTM_BAR_SIZE_1_GB                                     = 0x40000000,
    PROC_NHTM_BAR_SIZE_512_MB                                   = 0x20000000,
    PROC_NHTM_BAR_SIZE_256_MB                                   = 0x10000000,
    PROC_NHTM_BAR_SIZE_128_MB                                   = 0x08000000,
    PROC_NHTM_BAR_SIZE_64_MB                                    = 0x04000000,
    PROC_NHTM_BAR_SIZE_32_MB                                    = 0x02000000,
    PROC_NHTM_BAR_SIZE_16_MB                                    = 0x01000000,
    PROC_NHTM_BAR_SIZE_ZERO                                     = 0x00000000,
    PROC_NHTM_BAR_SIZE_INVALID                                  = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief The amount of memory a user can reserve to store CHTM traces.
 *	There are 32 cores, thus 32 different sizes. Used by
 *	p10_mss_eff_grouping.
 */
enum PROC_CHTM_BAR_SIZES
{
    PROC_CHTM_BAR_SIZES_256_GB                                  = 0x4000000000ULL,
    PROC_CHTM_BAR_SIZES_128_GB                                  = 0x2000000000ULL,
    PROC_CHTM_BAR_SIZES_64_GB                                   = 0x1000000000ULL,
    PROC_CHTM_BAR_SIZES_32_GB                                   = 0x800000000ULL,
    PROC_CHTM_BAR_SIZES_16_GB                                   = 0x400000000ULL,
    PROC_CHTM_BAR_SIZES_8_GB                                    = 0x200000000ULL,
    PROC_CHTM_BAR_SIZES_4_GB                                    = 0x100000000ULL,
    PROC_CHTM_BAR_SIZES_2_GB                                    = 0x80000000,
    PROC_CHTM_BAR_SIZES_1_GB                                    = 0x40000000,
    PROC_CHTM_BAR_SIZES_512_MB                                  = 0x20000000,
    PROC_CHTM_BAR_SIZES_256_MB                                  = 0x10000000,
    PROC_CHTM_BAR_SIZES_128_MB                                  = 0x08000000,
    PROC_CHTM_BAR_SIZES_64_MB                                   = 0x04000000,
    PROC_CHTM_BAR_SIZES_32_MB                                   = 0x02000000,
    PROC_CHTM_BAR_SIZES_16_MB                                   = 0x01000000,
    PROC_CHTM_BAR_SIZES_ZERO                                    = 0x00000000,
    PROC_CHTM_BAR_SIZES_INVALID                                 = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief The total amount of memory a user has requested to reserve for
 *	secure memory functions. Minimum requirement of 256MB. Used by
 *	p10_mss_eff_grouping.
 */
enum PROC_SMF_BAR_SIZE
{
    PROC_SMF_BAR_SIZE_256_GB                                    = 0x4000000000ULL,
    PROC_SMF_BAR_SIZE_128_GB                                    = 0x2000000000ULL,
    PROC_SMF_BAR_SIZE_64_GB                                     = 0x1000000000ULL,
    PROC_SMF_BAR_SIZE_32_GB                                     = 0x800000000ULL,
    PROC_SMF_BAR_SIZE_16_GB                                     = 0x400000000ULL,
    PROC_SMF_BAR_SIZE_8_GB                                      = 0x200000000ULL,
    PROC_SMF_BAR_SIZE_4_GB                                      = 0x100000000ULL,
    PROC_SMF_BAR_SIZE_2_GB                                      = 0x80000000,
    PROC_SMF_BAR_SIZE_1_GB                                      = 0x40000000,
    PROC_SMF_BAR_SIZE_512_MB                                    = 0x20000000,
    PROC_SMF_BAR_SIZE_256_MB                                    = 0x10000000,
    PROC_SMF_BAR_SIZE_ZERO                                      = 0x00000000,
    PROC_SMF_BAR_SIZE_INVALID                                   = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief Controls the enabling and disabling of smf. Used by unit
 *	initfiles, p10_mss_eff_grouping.
 */
enum SMF_CONFIG
{
    SMF_CONFIG_DISABLED                                         = 0x00000000,
    SMF_CONFIG_ENABLED                                          = 0x00000001,
    SMF_CONFIG_INVALID                                          = 0x000000FF,
};

/**
 *  @brief The amount of memory a user can reserve to store OCC sandbox
 *	functions. Used by p10_mss_eff_grouping.
 */
enum PROC_OCC_SANDBOX_SIZE
{
    PROC_OCC_SANDBOX_SIZE_256_GB                                = 0x4000000000ULL,
    PROC_OCC_SANDBOX_SIZE_128_GB                                = 0x2000000000ULL,
    PROC_OCC_SANDBOX_SIZE_64_GB                                 = 0x1000000000ULL,
    PROC_OCC_SANDBOX_SIZE_32_GB                                 = 0x800000000ULL,
    PROC_OCC_SANDBOX_SIZE_16_GB                                 = 0x400000000ULL,
    PROC_OCC_SANDBOX_SIZE_8_GB                                  = 0x200000000ULL,
    PROC_OCC_SANDBOX_SIZE_4_GB                                  = 0x100000000ULL,
    PROC_OCC_SANDBOX_SIZE_2_GB                                  = 0x80000000,
    PROC_OCC_SANDBOX_SIZE_1_GB                                  = 0x40000000,
    PROC_OCC_SANDBOX_SIZE_512_MB                                = 0x20000000,
    PROC_OCC_SANDBOX_SIZE_256_MB                                = 0x10000000,
    PROC_OCC_SANDBOX_SIZE_128_MB                                = 0x08000000,
    PROC_OCC_SANDBOX_SIZE_64_MB                                 = 0x04000000,
    PROC_OCC_SANDBOX_SIZE_32_MB                                 = 0x02000000,
    PROC_OCC_SANDBOX_SIZE_16_MB                                 = 0x01000000,
    PROC_OCC_SANDBOX_SIZE_ZERO                                  = 0x00000000,
    PROC_OCC_SANDBOX_SIZE_INVALID                               = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief INT IC (Interrupt Controller) BAR enable creator: platform
 *	consumer: p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_IC_BAR_ENABLE
{
    PROC_INT_IC_BAR_ENABLE_DISABLE                              = 0x00000000,
    PROC_INT_IC_BAR_ENABLE_ENABLE                               = 0x00000001,
    PROC_INT_IC_BAR_ENABLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief INT IC (Interrupt Controller) BAR page size creator: platform
 *	consumer: p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_IC_BAR_PAGE_SIZE
{
    PROC_INT_IC_BAR_PAGE_SIZE_4K                                = 0x00000000,
    PROC_INT_IC_BAR_PAGE_SIZE_64K                               = 0x00000001,
    PROC_INT_IC_BAR_PAGE_SIZE_INVALID                           = 0x000000FF,
};

/**
 *  @brief INT TM BAR enable creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_TM_BAR_ENABLE
{
    PROC_INT_TM_BAR_ENABLE_DISABLE                              = 0x00000000,
    PROC_INT_TM_BAR_ENABLE_ENABLE                               = 0x00000001,
    PROC_INT_TM_BAR_ENABLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief INT TM BAR page size creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_TM_BAR_PAGE_SIZE
{
    PROC_INT_TM_BAR_PAGE_SIZE_4K                                = 0x00000000,
    PROC_INT_TM_BAR_PAGE_SIZE_64K                               = 0x00000001,
    PROC_INT_TM_BAR_PAGE_SIZE_INVALID                           = 0x000000FF,
};

/**
 *  @brief INT NVPG BAR enable creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVPG_BAR_ENABLE
{
    PROC_INT_NVPG_BAR_ENABLE_DISABLE                            = 0x00000000,
    PROC_INT_NVPG_BAR_ENABLE_ENABLE                             = 0x00000001,
    PROC_INT_NVPG_BAR_ENABLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief INT NVPG BAR page size creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVPG_BAR_PAGE_SIZE
{
    PROC_INT_NVPG_BAR_PAGE_SIZE_4K                              = 0x00000000,
    PROC_INT_NVPG_BAR_PAGE_SIZE_64K                             = 0x00000001,
    PROC_INT_NVPG_BAR_PAGE_SIZE_INVALID                         = 0x000000FF,
};

/**
 *  @brief INT NVPG BAR set division selector creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR
{
    PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_1_SET               = 0x00000000,
    PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_2_SET               = 0x00000001,
    PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_4_SET               = 0x00000002,
    PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_8_SET               = 0x00000003,
    PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_16_SET              = 0x00000004,
    PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_INVALID             = 0x000000FF,
};

/**
 *  @brief INT NVPG BAR range selection creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVPG_BAR_RANGE
{
    PROC_INT_NVPG_BAR_RANGE_16_TB                               = 0x00000014,
    PROC_INT_NVPG_BAR_RANGE_8_TB                                = 0x00000013,
    PROC_INT_NVPG_BAR_RANGE_4_TB                                = 0x00000012,
    PROC_INT_NVPG_BAR_RANGE_2_TB                                = 0x00000011,
    PROC_INT_NVPG_BAR_RANGE_1_TB                                = 0x00000010,
    PROC_INT_NVPG_BAR_RANGE_512_GB                              = 0x0000000F,
    PROC_INT_NVPG_BAR_RANGE_256_GB                              = 0x0000000E,
    PROC_INT_NVPG_BAR_RANGE_128_GB                              = 0x0000000D,
    PROC_INT_NVPG_BAR_RANGE_64_GB                               = 0x0000000C,
    PROC_INT_NVPG_BAR_RANGE_32_GB                               = 0x0000000B,
    PROC_INT_NVPG_BAR_RANGE_16_GB                               = 0x0000000A,
    PROC_INT_NVPG_BAR_RANGE_8_GB                                = 0x00000009,
    PROC_INT_NVPG_BAR_RANGE_4_GB                                = 0x00000008,
    PROC_INT_NVPG_BAR_RANGE_2_GB                                = 0x00000007,
    PROC_INT_NVPG_BAR_RANGE_1_GB                                = 0x00000006,
    PROC_INT_NVPG_BAR_RANGE_512_MB                              = 0x00000005,
    PROC_INT_NVPG_BAR_RANGE_256_MB                              = 0x00000004,
    PROC_INT_NVPG_BAR_RANGE_128_MB                              = 0x00000003,
    PROC_INT_NVPG_BAR_RANGE_64_MB                               = 0x00000002,
    PROC_INT_NVPG_BAR_RANGE_32_MB                               = 0x00000001,
    PROC_INT_NVPG_BAR_RANGE_16_MB                               = 0x00000000,
    PROC_INT_NVPG_BAR_RANGE_INVALID                             = 0x000000FF,
};

/**
 *  @brief INT NVC BAR enable creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVC_BAR_ENABLE
{
    PROC_INT_NVC_BAR_ENABLE_DISABLE                             = 0x00000000,
    PROC_INT_NVC_BAR_ENABLE_ENABLE                              = 0x00000001,
    PROC_INT_NVC_BAR_ENABLE_INVALID                             = 0x000000FF,
};

/**
 *  @brief INT NVC BAR page size creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVC_BAR_PAGE_SIZE
{
    PROC_INT_NVC_BAR_PAGE_SIZE_4K                               = 0x00000000,
    PROC_INT_NVC_BAR_PAGE_SIZE_64K                              = 0x00000001,
    PROC_INT_NVC_BAR_PAGE_SIZE_INVALID                          = 0x000000FF,
};

/**
 *  @brief INT NVC BAR set division selector creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR
{
    PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_1_SET                = 0x00000000,
    PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_2_SET                = 0x00000001,
    PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_4_SET                = 0x00000002,
    PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_8_SET                = 0x00000003,
    PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_16_SET               = 0x00000004,
    PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_INVALID              = 0x000000FF,
};

/**
 *  @brief INT NVC BAR range selection creator: platform consumer:
 *	p10_setup_mmio_bars firmware notes: none
 */
enum PROC_INT_NVC_BAR_RANGE
{
    PROC_INT_NVC_BAR_RANGE_16_TB                                = 0x00000014,
    PROC_INT_NVC_BAR_RANGE_8_TB                                 = 0x00000013,
    PROC_INT_NVC_BAR_RANGE_4_TB                                 = 0x00000012,
    PROC_INT_NVC_BAR_RANGE_2_TB                                 = 0x00000011,
    PROC_INT_NVC_BAR_RANGE_1_TB                                 = 0x00000010,
    PROC_INT_NVC_BAR_RANGE_512_GB                               = 0x0000000F,
    PROC_INT_NVC_BAR_RANGE_256_GB                               = 0x0000000E,
    PROC_INT_NVC_BAR_RANGE_128_GB                               = 0x0000000D,
    PROC_INT_NVC_BAR_RANGE_64_GB                                = 0x0000000C,
    PROC_INT_NVC_BAR_RANGE_32_GB                                = 0x0000000B,
    PROC_INT_NVC_BAR_RANGE_16_GB                                = 0x0000000A,
    PROC_INT_NVC_BAR_RANGE_8_GB                                 = 0x00000009,
    PROC_INT_NVC_BAR_RANGE_4_GB                                 = 0x00000008,
    PROC_INT_NVC_BAR_RANGE_2_GB                                 = 0x00000007,
    PROC_INT_NVC_BAR_RANGE_1_GB                                 = 0x00000006,
    PROC_INT_NVC_BAR_RANGE_512_MB                               = 0x00000005,
    PROC_INT_NVC_BAR_RANGE_256_MB                               = 0x00000004,
    PROC_INT_NVC_BAR_RANGE_128_MB                               = 0x00000003,
    PROC_INT_NVC_BAR_RANGE_64_MB                                = 0x00000002,
    PROC_INT_NVC_BAR_RANGE_32_MB                                = 0x00000001,
    PROC_INT_NVC_BAR_RANGE_16_MB                                = 0x00000000,
    PROC_INT_NVC_BAR_RANGE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Device type of I2C slave device
 */
enum I2C_DEV_TYPE
{
    I2C_DEV_TYPE_ADS7138_ADC                                    = 0x00000000,
    I2C_DEV_TYPE_PCA9554A_GPIO_EXPANDER                         = 0x00000001,
    I2C_DEV_TYPE_INVALID                                        = 0x000000FF,
};

/**
 *  @brief 1 if the target is functional, else 0. Set by the platform.
 */
enum FUNCTIONAL
{
    FUNCTIONAL_NON_FUNCTIONAL                                   = 0x00000000,
    FUNCTIONAL_FUNCTIONAL                                       = 0x00000001,
    FUNCTIONAL_INVALID                                          = 0xFFFFFFFF,
};

/**
 *  @brief Returns the type of simics environment that the code is
 *	executing inside. 0 = RealHW/AWAN. 1 = Simics. 2 = SUET.
 */
enum IS_SIMICS
{
    IS_SIMICS_REALHW                                            = 0x00000000,
    IS_SIMICS_SIMICS                                            = 0x00000001,
    IS_SIMICS_SUET                                              = 0x00000002,
    IS_SIMICS_INVALID                                           = 0xFFFFFFFF,
};

/**
 *  @brief Which execution platform the HW Procedure is running on Some
 *	HWPs (e.g. special wakeup) use different registers for different
 *	platforms to avoid arbitration problems when multiple platforms do
 *	the same thing concurrently
 */
enum EXECUTION_PLATFORM
{
    EXECUTION_PLATFORM_HOST                                     = 0x00000001,
    EXECUTION_PLATFORM_FSP                                      = 0x00000002,
    EXECUTION_PLATFORM_OCC                                      = 0x00000003,
    EXECUTION_PLATFORM_INVALID                                  = 0x000000FF,
};

/**
 *  @brief The manufacturing flags. These enums represent which bit/flag to
 *	set in numeric form, NOT binary form. These values/policies can no
 *	longer be bit wised together. These numeric values match the flags
 *	as found in the PDF document: 'Hypervisor Interface Data
 *	Specifications v10.5o-1.pdf', section 6.1.9 and should stay in sync
 *	with this document and updated when said document gets updated.
 */
enum MFG_FLAGS
{
    MFG_FLAGS_MNFG_PHYP_VAPI                                    = 0x00000000,
    MFG_FLAGS_MNFG_PHYP_FAPI                                    = 0x00000001,
    MFG_FLAGS_MNFG_PHYP_NO_THRESHOLD                            = 0x00000002,
    MFG_FLAGS_MNFG_PHYP_TEST_RUN                                = 0x00000003,
    MFG_FLAGS_MNFG_PHYP_TERM                                    = 0x00000004,
    MFG_FLAGS_MNFG_PHYP_NO_RR                                   = 0x00000005,
    MFG_FLAGS_MNFG_PHYP_ANCHOR                                  = 0x00000006,
    MFG_FLAGS_MNFG_PHYP_IGNORE_SPCN_ERROR                       = 0x00000007,
    MFG_FLAGS_MNFG_PHYP_NO_OS400_DUMP                           = 0x00000008,
    MFG_FLAGS_MNFG_PHYP_RUN_COMPU_GARD                          = 0x00000009,
    MFG_FLAGS_MNFG_PHYP_UNDEFINED_2                             = 0x0000000A,
    MFG_FLAGS_MNFG_PHYP_UNDEFINED_1                             = 0x0000000B,
    MFG_FLAGS_MNFG_CORONA_FBIST                                 = 0x0000000F,
    MFG_FLAGS_MNFG_VERIFY_DMA_DATA                              = 0x00000010,
    MFG_FLAGS_MNFG_SVPD_USE_ONLY                                = 0x00000011,
    MFG_FLAGS_MNFG_TERM_FSP_RR                                  = 0x00000012,
    MFG_FLAGS_MNFG_NO_RBOT                                      = 0x00000013,
    MFG_FLAGS_MNFG_NO_CAPTURE_VPD                               = 0x00000014,
    MFG_FLAGS_MNFG_DO_NOT_PASS_TO_OS                            = 0x00000015,
    MFG_FLAGS_MNFG_TEST_RBS                                     = 0x00000016,
    MFG_FLAGS_MNFG_NO_AP                                        = 0x00000017,
    MFG_FLAGS_MNFG_NO_SYS_DUMP                                  = 0x00000018,
    MFG_FLAGS_MNFG_TEST_ALL_SPARE_DRAM_ROWS                     = 0x00000019,
    MFG_FLAGS_MNFG_SRC_TERM                                     = 0x0000001A,
    MFG_FLAGS_MNFG_SPCN_USE_NVS_IP                              = 0x0000001B,
    MFG_FLAGS_MNFG_NO_RBS                                       = 0x0000001C,
    MFG_FLAGS_MNFG_THRESHOLDS                                   = 0x0000001D,
    MFG_FLAGS_MNFG_NO_GARD                                      = 0x0000001E,
    MFG_FLAGS_MNFG_ABIST_VPD_DATA                               = 0x0000001F,
    MFG_FLAGS_MNFG_GORM_MODE                                    = 0x00000020,
    MFG_FLAGS_MNFG_FAST_RDT                                     = 0x00000021,
    MFG_FLAGS_MNFG_AVP_COMPLETE                                 = 0x00000022,
    MFG_FLAGS_MNFG_DISABLE_MEM_FAST_IPL_SCRUB                   = 0x00000023,
    MFG_FLAGS_MNFG_DISABLE_L3_FAST_IPL_SCRUB                    = 0x00000024,
    MFG_FLAGS_MNFG_DISABLE_MEM_PATTERN                          = 0x00000025,
    MFG_FLAGS_MNFG_DISABLE_L3_PATTERN                           = 0x00000026,
    MFG_FLAGS_MNFG_DISABLE_WIRE_RDT                             = 0x00000027,
    MFG_FLAGS_MNFG_DISABLE_WIRE_CST                             = 0x00000028,
    MFG_FLAGS_MNFG_DISABLE_ABIST                                = 0x00000029,
    MFG_FLAGS_MNFG_DISABLE_LBIST                                = 0x0000002A,
    MFG_FLAGS_MNFG_DISABLE_CHKRING                              = 0x0000002B,
    MFG_FLAGS_MNFG_MSL_CHECK                                    = 0x0000002F,
    MFG_FLAGS_MNFG_DISABLE_RWRAP                                = 0x00000030,
    MFG_FLAGS_MNFG_ENABLE_PRBS_CMDLINE                          = 0x00000031,
    MFG_FLAGS_MNFG_ENABLE_DIMM_SCREEN                           = 0x00000032,
    MFG_FLAGS_MNFG_ENABLE_TORRENT_PRBS                          = 0x00000033,
    MFG_FLAGS_MNFG_ENABLE_TORRENT_ELCT                          = 0x00000034,
    MFG_FLAGS_MNFG_MR_EXT_AB_WRAPTEST_TWO                       = 0x00000035,
    MFG_FLAGS_MNFG_MORE_MEMORY_PATTERNS                         = 0x00000036,
    MFG_FLAGS_MNFG_AVP_ENABLE                                   = 0x00000037,
    MFG_FLAGS_MNFG_FAST_BACKGROUND_SCRUB                        = 0x00000038,
    MFG_FLAGS_MNFG_CLICK_TO_ACCEPT                              = 0x00000039,
    MFG_FLAGS_MNFG_DISABLE_MEMORY_eREPAIR                       = 0x0000003A,
    MFG_FLAGS_MNFG_DISABLE_FABRIC_eREPAIR                       = 0x0000003B,
    MFG_FLAGS_MNFG_INFINIBAND_WRAP                              = 0x0000003C,
    MFG_FLAGS_MNFG_SMA_LINK                                     = 0x0000003D,
    MFG_FLAGS_MNFG_SYS_DUMP_TERM                                = 0x0000003E,
    MFG_FLAGS_MNFG_PSI_DIAGNOSTIC                               = 0x0000003F,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_30                         = 0x00000040,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_31                         = 0x00000041,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_32                         = 0x00000042,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_33                         = 0x00000043,
    MFG_FLAGS_MNFG_CHKRING_ENABLE                               = 0x00000044,
    MFG_FLAGS_MNFG_RUN_CUSTOMER_IPL                             = 0x00000045,
    MFG_FLAGS_MNFG_ABIST_VIASCREEN                              = 0x00000046,
    MFG_FLAGS_MNFG_CLEAR_VPD_ARRAY_REPAIR_DATA                  = 0x00000047,
    MFG_FLAGS_MNFG_POWER_SAVE_CAPABLE                           = 0x00000048,
    MFG_FLAGS_MNFG_PREVENT_REDUNDANCY_AUTO_ENABLE               = 0x00000049,
    MFG_FLAGS_MNFG_IB_FREQ_BIAS_HIGH                            = 0x0000004A,
    MFG_FLAGS_MNFG_IB_FREQ_BIAS_LOW                             = 0x0000004B,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_34                         = 0x0000004F,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_35                         = 0x00000050,
    MFG_FLAGS_MNFG_DISABLE_TWO_SYMBOL_CORRECTION                = 0x00000051,
    MFG_FLAGS_MNFG_TEST_SPARE_CORES                             = 0x00000052,
    MFG_FLAGS_MNFG_DDR5_ECS_TEST                                = 0x00000053,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_39                         = 0x00000054,
    MFG_FLAGS_MNFG_ENABLE_DMIGB                                 = 0x00000055,
    MFG_FLAGS_MNFG_FABRIC_DEPLOY_LANE_SPARES                    = 0x00000056,
    MFG_FLAGS_MNFG_DMI_DEPLOY_LANE_SPARES                       = 0x00000057,
    MFG_FLAGS_MNFG_ENERGYSCALE_SPECIAL_POLICIES                 = 0x00000058,
    MFG_FLAGS_MNFG_DISABLE_PHYBIST                              = 0x00000059,
    MFG_FLAGS_MNFG_HDAT_AVP_COMPLETE                            = 0x0000005A,
    MFG_FLAGS_MNFG_HDAT_AVP_ENABLE                              = 0x0000005B,
    MFG_FLAGS_MNFG_IPL_MEMORY_CE_CHECKING                       = 0x0000005C,
    MFG_FLAGS_MNFG_ENABLE_MINIMUM_PATTERN_TEST                  = 0x0000005D,
    MFG_FLAGS_MNFG_ENABLE_STANDARD_PATTERN_TEST                 = 0x0000005E,
    MFG_FLAGS_MNFG_ENABLE_EXHAUSTIVE_PATTERN_TEST               = 0x0000005F,
    MFG_FLAGS_MNFG_DIMM_SPI_FLASH_SCREEN                        = 0x00000060,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_02                         = 0x00000061,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_03                         = 0x00000062,
    MFG_FLAGS_MNFG_SEEPROM_SECURITY_CHECKS                      = 0x00000063,
    MFG_FLAGS_MNFG_OMI_CRC_EDPL_SCREEN                          = 0x00000064,
    MFG_FLAGS_MNFG_ODY_ENABLE_HSS_BIST                          = 0x00000065,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_07                         = 0x00000066,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_08                         = 0x00000067,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_09                         = 0x00000068,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_10                         = 0x00000069,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_11                         = 0x0000006A,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_12                         = 0x0000006B,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_13                         = 0x0000006F,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_14                         = 0x00000070,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_15                         = 0x00000071,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_16                         = 0x00000072,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_17                         = 0x00000073,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_18                         = 0x00000074,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_19                         = 0x00000075,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_20                         = 0x00000076,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_21                         = 0x00000077,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_22                         = 0x00000078,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_23                         = 0x00000079,
    MFG_FLAGS_MNFG_UPDATE_BOTH_SIDES_OF_SBE                     = 0x0000007A,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_25                         = 0x0000007B,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_26                         = 0x0000007C,
    MFG_FLAGS_MNFG_FSP_UPDATE_SBE_IMAGE                         = 0x0000007D,
    MFG_FLAGS_MNFG_SMP_WRAP_CONFIG                              = 0x0000007E,
    MFG_FLAGS_MNFG_POLICY_FLAG_AVAIL_29                         = 0x0000007F,
    MFG_FLAGS_INVALID                                           = 0xFFFFFFFF,
};

/**
 *  @brief Used to indicate the reason a reconfigure loop is needed.
 */
enum RECONFIGURE_LOOP
{
    RECONFIGURE_LOOP_DECONFIGURE                                = 0x00000001,
    RECONFIGURE_LOOP_BAD_DQ_BIT_SET                             = 0x00000002,
    RECONFIGURE_LOOP_RCD_PARITY_ERROR                           = 0x00000004,
    RECONFIGURE_LOOP_OCMB_FW_UPDATE                             = 0x00000008,
    RECONFIGURE_LOOP_TOPOLOGY_SWAP                              = 0x00000010,
    RECONFIGURE_LOOP_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Product name of a chip target. Provided by the MRW.
 */
enum NAME
{
    NAME_NONE                                                   = 0x00000000,
    NAME_EXPLORER                                               = 0x00000008,
    NAME_ODYSSEY                                                = 0x0000000B,
    NAME_GEMINI                                                 = 0x00000009,
    NAME_P10                                                    = 0x0000000A,
    NAME_INVALID                                                = 0xFFFFFFFF,
};

/**
 *  @brief Specifies target chiplet ID for scan operations via
 *	fapi2::putRing. If set, this attribute will override the chiplet ID
 *	present in the RS4 encoded scan ring image.
 */
enum SCAN_CHIPLET_OVERRIDE
{
    SCAN_CHIPLET_OVERRIDE_NONE                                  = 0x00000000,
    SCAN_CHIPLET_OVERRIDE_TP                                    = 0x00000001,
    SCAN_CHIPLET_OVERRIDE_N0                                    = 0x00000002,
    SCAN_CHIPLET_OVERRIDE_N1                                    = 0x00000003,
    SCAN_CHIPLET_OVERRIDE_PCI0                                  = 0x00000008,
    SCAN_CHIPLET_OVERRIDE_PCI1                                  = 0x00000009,
    SCAN_CHIPLET_OVERRIDE_MC0                                   = 0x0000000C,
    SCAN_CHIPLET_OVERRIDE_MC1                                   = 0x0000000D,
    SCAN_CHIPLET_OVERRIDE_MC2                                   = 0x0000000E,
    SCAN_CHIPLET_OVERRIDE_MC3                                   = 0x0000000F,
    SCAN_CHIPLET_OVERRIDE_PAU0                                  = 0x00000010,
    SCAN_CHIPLET_OVERRIDE_PAU1                                  = 0x00000011,
    SCAN_CHIPLET_OVERRIDE_PAU2                                  = 0x00000012,
    SCAN_CHIPLET_OVERRIDE_PAU3                                  = 0x00000013,
    SCAN_CHIPLET_OVERRIDE_IOHS0                                 = 0x00000018,
    SCAN_CHIPLET_OVERRIDE_IOHS1                                 = 0x00000019,
    SCAN_CHIPLET_OVERRIDE_IOHS2                                 = 0x0000001A,
    SCAN_CHIPLET_OVERRIDE_IOHS3                                 = 0x0000001B,
    SCAN_CHIPLET_OVERRIDE_IOHS4                                 = 0x0000001C,
    SCAN_CHIPLET_OVERRIDE_IOHS5                                 = 0x0000001D,
    SCAN_CHIPLET_OVERRIDE_IOHS6                                 = 0x0000001E,
    SCAN_CHIPLET_OVERRIDE_IOHS7                                 = 0x0000001F,
    SCAN_CHIPLET_OVERRIDE_EQ0                                   = 0x00000020,
    SCAN_CHIPLET_OVERRIDE_EQ1                                   = 0x00000021,
    SCAN_CHIPLET_OVERRIDE_EQ2                                   = 0x00000022,
    SCAN_CHIPLET_OVERRIDE_EQ3                                   = 0x00000023,
    SCAN_CHIPLET_OVERRIDE_EQ4                                   = 0x00000024,
    SCAN_CHIPLET_OVERRIDE_EQ5                                   = 0x00000025,
    SCAN_CHIPLET_OVERRIDE_EQ6                                   = 0x00000026,
    SCAN_CHIPLET_OVERRIDE_EQ7                                   = 0x00000027,
    SCAN_CHIPLET_OVERRIDE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Force frequency and throttles of all memory below the target to
 *	operate as "slow" memory for performance testing. NOTE: Do not set
 *	with DDR5 DIMMs, as this will result in failures in mss_freq.
 */
enum SLOW_MEM_POOL_TEST
{
    SLOW_MEM_POOL_TEST_DISABLE                                  = 0x00000000,
    SLOW_MEM_POOL_TEST_ENABLE                                   = 0x00000001,
    SLOW_MEM_POOL_TEST_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Controls whether OMI CFG reg accesses are considered big or
 *	little endian.
 */
enum MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL
{
    MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_LITTLE_ENDIAN              = 0x00000000,
    MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_BIG_ENDIAN                 = 0x00000001,
    MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_INVALID                    = 0x000000FF,
};

/**
 *  @brief Indicates whether the OCMB should be run in half DIMM mode or
 *	not
 */
enum MSS_OCMB_HALF_DIMM_MODE
{
    MSS_OCMB_HALF_DIMM_MODE_FULL_DIMM                           = 0x00000000,
    MSS_OCMB_HALF_DIMM_MODE_HALF_DIMM                           = 0x00000001,
    MSS_OCMB_HALF_DIMM_MODE_INVALID                             = 0x000000FF,
};

/**
 *  @brief An override that allows the user to control full or half DIMM
 *	mode
 */
enum MSS_OCMB_HALF_DIMM_MODE_OVERRIDE
{
    MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_NO_OVERRIDE                = 0x00000000,
    MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_OVERRIDE_FULL_DIMM         = 0x00000001,
    MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_OVERRIDE_HALF_DIMM         = 0x00000002,
    MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_INVALID                    = 0x000000FF,
};

/**
 *  @brief Contains the settings for write/read reorder queue
 */
enum MEM_REORDER_QUEUE_SETTING
{
    MEM_REORDER_QUEUE_SETTING_REORDER                           = 0x00000000,
    MEM_REORDER_QUEUE_SETTING_FIFO                              = 0x00000001,
    MEM_REORDER_QUEUE_SETTING_INVALID                           = 0x000000FF,
};

/**
 *  @brief Set to '1' after the ody_thermal_init HWP/chip-op has completed.
 *	Used to suppress certain behavior (mainly SBE chip-op) that should
 *	not be run before this IPL step.
 */
enum MEM_THERMAL_INIT_COMPLETE
{
    MEM_THERMAL_INIT_COMPLETE_NO                                = 0x00000000,
    MEM_THERMAL_INIT_COMPLETE_YES                               = 0x00000001,
    MEM_THERMAL_INIT_COMPLETE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Default value for 2N Mode from Signal Integrity. 0x0 = Invalid
 *	Mode, 0x01 = 1N Mode , 0x02 = 2N Mode If value is set to 0x0 this
 *	indicate value was never initialized correctly.
 */
enum MEM_2N_MODE
{
    MEM_2N_MODE_1N                                              = 0x00000001,
    MEM_2N_MODE_2N                                              = 0x00000002,
    MEM_2N_MODE_INVALID                                         = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] CS to CMD/ADDR Latency. This is for DDR4 MRS4.
 *	Computed in mss_eff_cnfg. Each memory channel will have a value.
 */
enum MEM_CS_CMD_LATENCY
{
    MEM_CS_CMD_LATENCY_DISABLE                                  = 0x00000000,
    MEM_CS_CMD_LATENCY_3CYC                                     = 0x00000003,
    MEM_CS_CMD_LATENCY_4CYC                                     = 0x00000004,
    MEM_CS_CMD_LATENCY_5CYC                                     = 0x00000005,
    MEM_CS_CMD_LATENCY_6CYC                                     = 0x00000006,
    MEM_CS_CMD_LATENCY_8CYC                                     = 0x00000008,
    MEM_CS_CMD_LATENCY_INVALID                                  = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] C/A Parity Latency Mode. This is for DDR4 MRS5.
 *	Computed in mss_eff_cnfg. Each memory channel will have a value.
 */
enum MEM_CA_PARITY_LATENCY
{
    MEM_CA_PARITY_LATENCY_DISABLE                               = 0x00000000,
    MEM_CA_PARITY_LATENCY_PL4                                   = 0x00000004,
    MEM_CA_PARITY_LATENCY_PL5                                   = 0x00000005,
    MEM_CA_PARITY_LATENCY_PL6                                   = 0x00000006,
    MEM_CA_PARITY_LATENCY_PL8                                   = 0x00000008,
    MEM_CA_PARITY_LATENCY_INVALID                               = 0x000000FF,
};

/**
 *  @brief DRAM Device Type. Decodes SPD byte 2. Created for use by
 *	attributes that need this data earlier than eff_config, such as
 *	c_str and the hypervisor. Not meant for direct HWP use. This is
 *	just an abstraction of any chip specific EFF_DRAM_GEN attribute.
 */
enum MEM_DRAM_GEN_METADATA
{
    MEM_DRAM_GEN_METADATA_EMPTY                                 = 0x00000000,
    MEM_DRAM_GEN_METADATA_DDR3                                  = 0x00000001,
    MEM_DRAM_GEN_METADATA_DDR4                                  = 0x00000002,
    MEM_DRAM_GEN_METADATA_INVALID                               = 0x000000FF,
};

/**
 *  @brief Base Module Type. Decodes SPD Byte 3 (bits 3~0). Created for use
 *	by attributes that need this data earlier than eff_config, such as
 *	c_str and the hypervisor. Not meant for direct HWP use. This is
 *	just an abstraction of any chip specific EFF_DIMM_TYPE attribute.
 */
enum MEM_DIMM_TYPE_METADATA
{
    MEM_DIMM_TYPE_METADATA_EMPTY                                = 0x00000000,
    MEM_DIMM_TYPE_METADATA_RDIMM                                = 0x00000001,
    MEM_DIMM_TYPE_METADATA_UDIMM                                = 0x00000002,
    MEM_DIMM_TYPE_METADATA_LRDIMM                               = 0x00000003,
    MEM_DIMM_TYPE_METADATA_DDIMM                                = 0x00000004,
    MEM_DIMM_TYPE_METADATA_INVALID                              = 0x000000FF,
};

/**
 *  @brief EDPL (Error Detection Per Lane) is a feature in the DL that adds
 *	some additional checks to the traffic going across the OpenCAPI
 *	link in order to better track which lanes are having issues. Note:
 *	EDPL must be set the same on both sides of the link. This attribute
 *	affects both the proc/mc side and the OCMB side.
 */
enum MSS_OMI_EDPL_DISABLE
{
    MSS_OMI_EDPL_DISABLE_FALSE                                  = 0x00000000,
    MSS_OMI_EDPL_DISABLE_TRUE                                   = 0x00000001,
    MSS_OMI_EDPL_DISABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Set to YES if you want to override processor-driven memory
 *	frequency limitations.
 */
enum MEM_OVERRIDE_FREQ_LIMITATION
{
    MEM_OVERRIDE_FREQ_LIMITATION_NO                             = 0x00000000,
    MEM_OVERRIDE_FREQ_LIMITATION_YES                            = 0x00000001,
    MEM_OVERRIDE_FREQ_LIMITATION_INVALID                        = 0x000000FF,
};

/**
 *  @brief Set to YES if you want to ignore the plug rules. Sometimes this
 *	is needed in a partial-good configuration or on a test board.
 */
enum MEM_IGNORE_PLUG_RULES
{
    MEM_IGNORE_PLUG_RULES_NO                                    = 0x00000000,
    MEM_IGNORE_PLUG_RULES_YES                                   = 0x00000001,
    MEM_IGNORE_PLUG_RULES_INVALID                               = 0x000000FF,
};

/**
 *  @brief Set to YES if you want to ignore the DIMM size plug rules.
 *	Sometimes this maybe required for characterization testing or on a
 *	test board.
 */
enum MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX
{
    MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_NO                      = 0x00000000,
    MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_YES                     = 0x00000001,
    MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_INVALID                 = 0x000000FF,
};

/**
 *  @brief Set to YES if you want to ignore the DIMM height plug rules.
 *	Sometimes this maybe required for characterization testing or on a
 *	test board.
 */
enum MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX
{
    MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_NO                    = 0x00000000,
    MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_YES                   = 0x00000001,
    MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_INVALID               = 0x000000FF,
};

/**
 *  @brief Set to YES if you want to ignore the plug rule checking of DDR5
 *	DIMM's SPD minimum revision requirement. Sometimes this maybe
 *	required for characterization testing or on a test board.
 */
enum MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK
{
    MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_NO                      = 0x00000000,
    MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_YES                     = 0x00000001,
    MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_INVALID                 = 0x000000FF,
};

/**
 *  @brief This attribute is used to avoid duplicate SPD revision plug rule
 *	testing. Set internally by HWP code.
 */
enum MEM_DDR5_PLUG_RULES_SPD_REV_TESTED
{
    MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_NO                       = 0x00000000,
    MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_YES                      = 0x00000001,
    MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_INVALID                  = 0x000000FF,
};

/**
 *  @brief Selects the settings for Host and Explorer FIRs for when x4
 *	channel degrade occurs. Default: RECOVERABLE (channel degrade will
 *	cause recoverable error) Performance team request is to XSTOP when
 *	degrade occurs
 */
enum OMI_X4_DEGRADE_ACTION
{
    OMI_X4_DEGRADE_ACTION_MASKED                                = 0x00000000,
    OMI_X4_DEGRADE_ACTION_XSTOP                                 = 0x00000001,
    OMI_X4_DEGRADE_ACTION_LOCAL_XSTOP                           = 0x00000002,
    OMI_X4_DEGRADE_ACTION_RECOVERABLE                           = 0x00000003,
    OMI_X4_DEGRADE_ACTION_INVALID                               = 0x000000FF,
};

/**
 *  @brief Selects the settings for Host and Explorer FIRs for CRC and NACK
 *	errors. Default: MASKED
 */
enum OMI_CRC_DEBUG
{
    OMI_CRC_DEBUG_MASKED                                        = 0x00000000,
    OMI_CRC_DEBUG_XSTOP                                         = 0x00000001,
    OMI_CRC_DEBUG_LOCAL_XSTOP                                   = 0x00000002,
    OMI_CRC_DEBUG_RECOVERABLE                                   = 0x00000003,
    OMI_CRC_DEBUG_INVALID                                       = 0x000000FF,
};

/**
 *  @brief Enable FIR Unmasking for HWPs, applies to functions that are
 *	specifically referencing this attribute.
 */
enum ENABLE_FIR_UNMASKING
{
    ENABLE_FIR_UNMASKING_DISABLED                               = 0x00000000,
    ENABLE_FIR_UNMASKING_ENABLED                                = 0x00000001,
    ENABLE_FIR_UNMASKING_INVALID                                = 0x000000FF,
};

/**
 *  @brief Indicates if the target system is an Apollo system. Will be set
 *	automatically in Cronus based on SYSTEM_TYPE
 */
enum MSS_IS_APOLLO
{
    MSS_IS_APOLLO_FALSE                                         = 0x00000000,
    MSS_IS_APOLLO_TRUE                                          = 0x00000001,
    MSS_IS_APOLLO_INVALID                                       = 0x000000FF,
};

/**
 *  @brief Whether to run post-memdiags read-only subtest
 */
enum MSS_POST_MEMDIAGS_READ_SUBTEST
{
    MSS_POST_MEMDIAGS_READ_SUBTEST_DISABLE                      = 0x00000000,
    MSS_POST_MEMDIAGS_READ_SUBTEST_ENABLE                       = 0x00000001,
    MSS_POST_MEMDIAGS_READ_SUBTEST_INVALID                      = 0x000000FF,
};

/**
 *  @brief Behvaior to perform if read subtest post-memdiags does not get a
 *	good result. EXIT = fapi_try_exit out with error code TRACE =
 *	FAPI_ERR that test failed, return success code
 */
enum MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR
{
    MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_EXIT           = 0x00000000,
    MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_TRACE          = 0x00000001,
    MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_INVALID        = 0x000000FF,
};

/**
 *  @brief Limits the frequency based upon the plugged in DIMM
 *	configuration This is set after the code is run to limit the
 *	frequency is run to avoid running the algorithm multiple times
 *	Initialized to NOT_RUN Set to NO_LIMIT if there is no limit
 *	Otherwise, set to the frequency limit by the algorithm
 */
enum MSS_CONFIG_FREQ_LIMIT
{
    MSS_CONFIG_FREQ_LIMIT_NOT_RUN                               = 0x00000000,
    MSS_CONFIG_FREQ_LIMIT_NO_LIMIT                              = 0xFFFFFFFF,
};

/**
 *  @brief This attribute will be set when uplift to VDD is applied for
 *	fixing OMI degrade. PRD would be able to read this attribute and
 *	return a new word 8 to reflect that uplift was applied
 */
enum MSS_OMI_VDD_UPLIFT_APPLIED
{
    MSS_OMI_VDD_UPLIFT_APPLIED_NO                               = 0x00000000,
    MSS_OMI_VDD_UPLIFT_APPLIED_YES                              = 0x00000001,
    MSS_OMI_VDD_UPLIFT_APPLIED_INVALID                          = 0x000000FF,
};

/**
 *  @brief Array[DIMM] Register Clock Driver, Input Bus Termination for
 *	Command/Address in tens of Ohms.
 */
enum MEM_SI_DIMM_RCD_IBT_CA
{
    MEM_SI_DIMM_RCD_IBT_CA_IBT_OFF                              = 0x00000000,
    MEM_SI_DIMM_RCD_IBT_CA_IBT_100                              = 0x0000000A,
    MEM_SI_DIMM_RCD_IBT_CA_IBT_150                              = 0x0000000F,
    MEM_SI_DIMM_RCD_IBT_CA_IBT_300                              = 0x0000001E,
    MEM_SI_DIMM_RCD_IBT_CA_INVALID                              = 0x000000FF,
};

/**
 *  @brief Array[DIMM] Register Clock Driver, Input Bus Termination for
 *	Clock Enable in tens of Ohms.
 */
enum MEM_SI_DIMM_RCD_IBT_CKE
{
    MEM_SI_DIMM_RCD_IBT_CKE_IBT_OFF                             = 0x00000000,
    MEM_SI_DIMM_RCD_IBT_CKE_IBT_100                             = 0x0000000A,
    MEM_SI_DIMM_RCD_IBT_CKE_IBT_150                             = 0x0000000F,
    MEM_SI_DIMM_RCD_IBT_CKE_IBT_300                             = 0x0000001E,
    MEM_SI_DIMM_RCD_IBT_CKE_INVALID                             = 0x000000FF,
};

/**
 *  @brief Array[DIMM] Register Clock Driver, Input Bus Termination for
 *	Chip Select in tens of Ohms.
 */
enum MEM_SI_DIMM_RCD_IBT_CS
{
    MEM_SI_DIMM_RCD_IBT_CS_IBT_OFF                              = 0x00000000,
    MEM_SI_DIMM_RCD_IBT_CS_IBT_100                              = 0x0000000A,
    MEM_SI_DIMM_RCD_IBT_CS_IBT_150                              = 0x0000000F,
    MEM_SI_DIMM_RCD_IBT_CS_IBT_300                              = 0x0000001E,
    MEM_SI_DIMM_RCD_IBT_CS_INVALID                              = 0x000000FF,
};

/**
 *  @brief Array[DIMM] Register Clock Driver, Input Bus Termination for On
 *	Die Termination in tens of Ohms.
 */
enum MEM_SI_DIMM_RCD_IBT_ODT
{
    MEM_SI_DIMM_RCD_IBT_ODT_IBT_OFF                             = 0x00000000,
    MEM_SI_DIMM_RCD_IBT_ODT_IBT_100                             = 0x0000000A,
    MEM_SI_DIMM_RCD_IBT_ODT_IBT_150                             = 0x0000000F,
    MEM_SI_DIMM_RCD_IBT_ODT_IBT_300                             = 0x0000001E,
    MEM_SI_DIMM_RCD_IBT_ODT_INVALID                             = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] DQ and DQS Drive Impedance.
 */
enum MEM_SI_DRAM_DRV_IMP_DQ_DQS
{
    MEM_SI_DRAM_DRV_IMP_DQ_DQS_DISABLE                          = 0x00000000,
    MEM_SI_DRAM_DRV_IMP_DQ_DQS_OHM34                            = 0x00000022,
    MEM_SI_DRAM_DRV_IMP_DQ_DQS_OHM48                            = 0x00000030,
    MEM_SI_DRAM_DRV_IMP_DQ_DQS_INVALID                          = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Number of clocks used for read/write preamble.
 *	Calibration only uses 1 nCK preamble (DEFAULT). Mainline has both 1
 *	nCK and 2 nCK preamble option. The value of "0" means 1 nCK
 *	preamble, the value of "1" means 2 nCK preamble. Bit 3 for READ
 *	preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
 *	preamble for both READ and WRITE
 */
enum MEM_SI_DRAM_PREAMBLE
{
    MEM_SI_DRAM_PREAMBLE_READ_PREAMBLE_BIT                      = 0x00000003,
    MEM_SI_DRAM_PREAMBLE_WRITE_PREAMBLE_BIT                     = 0x00000007,
    MEM_SI_DRAM_PREAMBLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] DRAM side Nominal Termination Resistance in
 *	Ohms.
 */
enum MEM_SI_DRAM_RTT_NOM
{
    MEM_SI_DRAM_RTT_NOM_DISABLE                                 = 0x00000000,
    MEM_SI_DRAM_RTT_NOM_OHM34                                   = 0x00000022,
    MEM_SI_DRAM_RTT_NOM_OHM40                                   = 0x00000028,
    MEM_SI_DRAM_RTT_NOM_OHM60                                   = 0x0000003C,
    MEM_SI_DRAM_RTT_NOM_OHM80                                   = 0x00000050,
    MEM_SI_DRAM_RTT_NOM_OHM120                                  = 0x00000078,
    MEM_SI_DRAM_RTT_NOM_OHM240                                  = 0x000000F0,
    MEM_SI_DRAM_RTT_NOM_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] DRAM side Park Termination Resistance in Ohms.
 */
enum MEM_SI_DRAM_RTT_PARK
{
    MEM_SI_DRAM_RTT_PARK_DISABLE                                = 0x00000000,
    MEM_SI_DRAM_RTT_PARK_OHM34                                  = 0x00000022,
    MEM_SI_DRAM_RTT_PARK_OHM40                                  = 0x00000028,
    MEM_SI_DRAM_RTT_PARK_OHM48                                  = 0x00000030,
    MEM_SI_DRAM_RTT_PARK_OHM60                                  = 0x0000003C,
    MEM_SI_DRAM_RTT_PARK_OHM80                                  = 0x00000050,
    MEM_SI_DRAM_RTT_PARK_OHM120                                 = 0x00000078,
    MEM_SI_DRAM_RTT_PARK_OHM240                                 = 0x000000F0,
    MEM_SI_DRAM_RTT_PARK_INVALID                                = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] DRAM side Write Termination Resistance in
 *	Ohms. Note: This attr is for DDR4 ONLY
 */
enum MEM_SI_DRAM_RTT_WR
{
    MEM_SI_DRAM_RTT_WR_DISABLE                                  = 0x00000000,
    MEM_SI_DRAM_RTT_WR_OHM80                                    = 0x00000050,
    MEM_SI_DRAM_RTT_WR_OHM120                                   = 0x00000078,
    MEM_SI_DRAM_RTT_WR_OHM240                                   = 0x000000F0,
    MEM_SI_DRAM_RTT_WR_INVALID                                  = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM][RANK] Gear Down Mode. This is for DDR4 MRS3. Each
 *	memory channel will have a value.
 */
enum MEM_SI_GEARDOWN_MODE
{
    MEM_SI_GEARDOWN_MODE_HALF                                   = 0x00000000,
    MEM_SI_GEARDOWN_MODE_QUARTER                                = 0x00000001,
    MEM_SI_GEARDOWN_MODE_INVALID                                = 0x000000FF,
};

/**
 *  @brief (DEPRECATED) Superceded by ATTR_MEM_SI_PHY_EQUALIZATION Left in
 *	as a workaround to hostboot CI failing due to removal of attribute
 *	Array[DIMM][RANK] Memory Controller side Receiver Equalization for
 *	Data and Data Strobe Lines.
 */
enum MEM_SI_MC_RCV_EQ_DQ_DQS
{
    MEM_SI_MC_RCV_EQ_DQ_DQS_DISABLE                             = 0x00000000,
    MEM_SI_MC_RCV_EQ_DQ_DQS_ENABLE                              = 0x00000001,
    MEM_SI_MC_RCV_EQ_DQ_DQS_INVALID                             = 0x000000FF,
};

/**
 *  @brief (DEPRECATED) Superceded by ATTR_MEM_SI_PHY_EQUALIZATION Left in
 *	as a workaround to hostboot CI failing due to removal of attribute
 *	Array[DIMM][RANK] Memory Controller side Drive Equalization for
 *	Data and Data Strobe Lines.
 */
enum MEM_SI_MC_DRV_EQ_DQ_DQS
{
    MEM_SI_MC_DRV_EQ_DQ_DQS_DISABLE                             = 0x00000000,
    MEM_SI_MC_DRV_EQ_DQ_DQS_FFE                                 = 0x00000001,
    MEM_SI_MC_DRV_EQ_DQ_DQS_INVALID                             = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Impedance for
 *	Clock in Ohms.
 */
enum MEM_SI_MC_DRV_IMP_CLK
{
    MEM_SI_MC_DRV_IMP_CLK_DISABLE                               = 0x00000000,
    MEM_SI_MC_DRV_IMP_CLK_OHM_20                                = 0x00000014,
    MEM_SI_MC_DRV_IMP_CLK_OHM_24                                = 0x00000018,
    MEM_SI_MC_DRV_IMP_CLK_OHM_30                                = 0x0000001E,
    MEM_SI_MC_DRV_IMP_CLK_OHM_40                                = 0x00000028,
    MEM_SI_MC_DRV_IMP_CLK_OHM_60                                = 0x0000003C,
    MEM_SI_MC_DRV_IMP_CLK_OHM_120                               = 0x00000078,
    MEM_SI_MC_DRV_IMP_CLK_INVALID                               = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Impedance for
 *	Address, Bank Address, Bank Group and Activate Lines in Ohms. DDR4
 *	configs values are in Ohms. For DDR5 this byte still represents SPD
 *	EFD byte 32, but it is unused by the procedure code
 */
enum MEM_SI_MC_DRV_IMP_CMD_ADDR
{
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DISABLE                          = 0x00000000,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_SDR_OHM_10                       = 0x00000001,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_SDR_OHM_15A                      = 0x00000002,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_SDR_OHM_15B                      = 0x00000003,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_SDR_OHM_20                       = 0x00000004,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_SDR_OHM_24                       = 0x00000005,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_SDR_OHM_30                       = 0x00000006,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DDR_OHM_10                       = 0x00000009,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DDR_OHM_15A                      = 0x0000000A,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DDR_OHM_15B                      = 0x0000000B,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DDR_OHM_20                       = 0x0000000C,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DDR_OHM_24                       = 0x0000000D,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_DDR_OHM_30                       = 0x0000000E,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_OHM_20                           = 0x00000014,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_OHM_24                           = 0x00000018,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_OHM_30                           = 0x0000001E,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_OHM_40                           = 0x00000028,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_OHM_60                           = 0x0000003C,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_OHM_120                          = 0x00000078,
    MEM_SI_MC_DRV_IMP_CMD_ADDR_RESERVED                         = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Impedance for
 *	Clock Enable, ODT, Parity, and Reset Lines in Ohms.
 */
enum MEM_SI_MC_DRV_IMP_CNTL
{
    MEM_SI_MC_DRV_IMP_CNTL_DISABLE                              = 0x00000000,
    MEM_SI_MC_DRV_IMP_CNTL_INVALID                              = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Impedance for
 *	Chip Select and Chip ID Lines in Ohms.
 */
enum MEM_SI_MC_DRV_IMP_CSCID
{
    MEM_SI_MC_DRV_IMP_CSCID_DISABLE                             = 0x00000000,
    MEM_SI_MC_DRV_IMP_CSCID_INVALID                             = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Impedance Pull
 *	Down for Data and Data Strobe Lines in Ohms.
 */
enum MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN
{
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_DISABLE                  = 0x00000000,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_28                   = 0x0000001C,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_30                   = 0x0000001E,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_32                   = 0x00000020,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_34                   = 0x00000022,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_36                   = 0x00000024,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_40                   = 0x00000028,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_43                   = 0x0000002B,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_48                   = 0x00000030,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_53                   = 0x00000035,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_60                   = 0x0000003C,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_68                   = 0x00000044,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_80                   = 0x00000050,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_96                   = 0x00000060,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_120                  = 0x00000078,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_160                  = 0x000000A0,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_240                  = 0x000000F0,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_OHM_480                  = 0x000001E0,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_INVALID                  = 0x0000FFFF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Impedance Pull Up
 *	for Data and Data Strobe Lines in Ohms.
 */
enum MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP
{
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_DISABLE                    = 0x00000000,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_28                     = 0x0000001C,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_30                     = 0x0000001E,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_32                     = 0x00000020,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_34                     = 0x00000022,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_36                     = 0x00000024,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_40                     = 0x00000028,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_43                     = 0x0000002B,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_48                     = 0x00000030,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_53                     = 0x00000035,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_60                     = 0x0000003C,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_68                     = 0x00000044,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_80                     = 0x00000050,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_96                     = 0x00000060,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_120                    = 0x00000078,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_160                    = 0x000000A0,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_240                    = 0x000000F0,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_OHM_480                    = 0x000001E0,
    MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_INVALID                    = 0x0000FFFF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Slew Rate for
 *	Clock in Ohms.
 */
enum MEM_SI_MC_DRV_SLEW_RATE_CLK
{
    MEM_SI_MC_DRV_SLEW_RATE_CLK_DISABLE                         = 0x00000000,
    MEM_SI_MC_DRV_SLEW_RATE_CLK_INVALID                         = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Slew Rate for
 *	Address, Bank Address, Bank Group and Activate Lines in Ohms.
 */
enum MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR
{
    MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_DISABLE                    = 0x00000000,
    MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_INVALID                    = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Slew Rate for
 *	Clock Enable, ODT, Parity, and Reset Lines in Ohms.
 */
enum MEM_SI_MC_DRV_SLEW_RATE_CNTL
{
    MEM_SI_MC_DRV_SLEW_RATE_CNTL_DISABLE                        = 0x00000000,
    MEM_SI_MC_DRV_SLEW_RATE_CNTL_INVALID                        = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Slew Rate for
 *	Chip Select and Chip ID Lines in Ohms.
 */
enum MEM_SI_MC_DRV_SLEW_RATE_CSCID
{
    MEM_SI_MC_DRV_SLEW_RATE_CSCID_DISABLE                       = 0x00000000,
    MEM_SI_MC_DRV_SLEW_RATE_CSCID_INVALID                       = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Drive Slew Rate for
 *	Data and Data Strobe Lines in Ohms.
 */
enum MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS
{
    MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_DISABLE                      = 0x00000000,
    MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_INVALID                      = 0x000000FF,
};

/**
 *  @brief Memory Controller side Receiver Impedance. Alert_N line in Ohms.
 */
enum MEM_SI_MC_RCV_IMP_ALERT_N
{
    MEM_SI_MC_RCV_IMP_ALERT_N_DISABLE                           = 0x00000000,
    MEM_SI_MC_RCV_IMP_ALERT_N_OHM_40                            = 0x00000028,
    MEM_SI_MC_RCV_IMP_ALERT_N_OHM_48                            = 0x00000030,
    MEM_SI_MC_RCV_IMP_ALERT_N_OHM_60                            = 0x0000003C,
    MEM_SI_MC_RCV_IMP_ALERT_N_OHM_80                            = 0x00000050,
    MEM_SI_MC_RCV_IMP_ALERT_N_OHM_120                           = 0x00000078,
    MEM_SI_MC_RCV_IMP_ALERT_N_OHM_240                           = 0x000000F0,
    MEM_SI_MC_RCV_IMP_ALERT_N_INVALID                           = 0x000000FF,
};

/**
 *  @brief Array[DIMM][RANK] Memory Controller side Receiver Impedance.
 *	Data and Data Strobe Lines in Ohms.
 */
enum MEM_SI_MC_RCV_IMP_DQ_DQS
{
    MEM_SI_MC_RCV_IMP_DQ_DQS_DISABLE                            = 0x00000000,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_40                             = 0x00000028,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_48                             = 0x00000030,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_60                             = 0x0000003C,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_80                             = 0x00000050,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_120                            = 0x00000078,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_240                            = 0x000000F0,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_25                             = 0x00000019,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_27                             = 0x0000001B,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_28                             = 0x0000001C,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_30                             = 0x0000001E,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_32                             = 0x00000020,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_34                             = 0x00000022,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_36                             = 0x00000024,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_43                             = 0x0000002B,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_53                             = 0x00000035,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_68                             = 0x00000044,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_96                             = 0x00000060,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_160                            = 0x000000A0,
    MEM_SI_MC_RCV_IMP_DQ_DQS_OHM_480                            = 0x000001E0,
    MEM_SI_MC_RCV_IMP_DQ_DQS_INVALID                            = 0x0000FFFF,
};

/**
 *  @brief Memory Controller side Read Vref setting. Dividing by 1000 gives
 *	you percentage of Vdd. Disable = 0, defined as no HW adjustment or
 *	Vdd/2 if possible.
 */
enum MEM_SI_VREF_MC_RD
{
    MEM_SI_VREF_MC_RD_DISABLE                                   = 0x00000000,
    MEM_SI_VREF_MC_RD_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief PHY Drive Impedance Pull Up for Data and Data Strobe Lines when
 *	equalization is enabled (in Ohms). Used only for DDR5.
 */
enum MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP
{
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_HIGH_IMP                  = 0x00000000,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_25                    = 0x00000019,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_27                    = 0x0000001B,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_28                    = 0x0000001C,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_30                    = 0x0000001E,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_32                    = 0x00000020,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_34                    = 0x00000022,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_36                    = 0x00000024,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_40                    = 0x00000028,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_43                    = 0x0000002B,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_48                    = 0x00000030,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_53                    = 0x00000035,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_60                    = 0x0000003C,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_68                    = 0x00000044,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_80                    = 0x00000050,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_96                    = 0x00000060,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_120                   = 0x00000078,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_160                   = 0x000000A0,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_240                   = 0x000000F0,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_OHM_480                   = 0x000001E0,
    MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_INVALID                   = 0x0000FFFF,
};

/**
 *  @brief DRAM burst length Note: OTF in the enums stands for On The Fly.
 *	Acronym is used to correspond with JEDEC
 */
enum MEM_BURST_LENGTH
{
    MEM_BURST_LENGTH_BL16                                       = 0x00000000,
    MEM_BURST_LENGTH_BC8_OTF                                    = 0x00000001,
    MEM_BURST_LENGTH_BL32                                       = 0x00000002,
    MEM_BURST_LENGTH_BL32_OTF                                   = 0x00000003,
    MEM_BURST_LENGTH_INVALID                                    = 0x000000FF,
};

/**
 *  @brief DRAM Max Power Saving Mode
 */
enum MEM_MPSM
{
    MEM_MPSM_DISABLE                                            = 0x00000000,
    MEM_MPSM_ENABLE                                             = 0x00000001,
    MEM_MPSM_INVALID                                            = 0x000000FF,
};

/**
 *  @brief DRAM Chip Select assertion mode for MPC commands
 */
enum MEM_CS_ASSERT_IN_MPC
{
    MEM_CS_ASSERT_IN_MPC_MULTI_CYCLE                            = 0x00000000,
    MEM_CS_ASSERT_IN_MPC_SINGLE_CYCLE                           = 0x00000001,
    MEM_CS_ASSERT_IN_MPC_INVALID                                = 0x000000FF,
};

/**
 *  @brief DRAM Setting for device 15's Max Power Saving Mode
 */
enum MEM_DEVICE15_MPSM
{
    MEM_DEVICE15_MPSM_DISABLE                                   = 0x00000000,
    MEM_DEVICE15_MPSM_ENABLE                                    = 0x00000001,
    MEM_DEVICE15_MPSM_INVALID                                   = 0x000000FF,
};

/**
 *  @brief DRAM setting to enable or disable internal WR timing offsets
 */
enum MEM_INTERNAL_WR_TIMING_MODE
{
    MEM_INTERNAL_WR_TIMING_MODE_DISABLE                         = 0x00000000,
    MEM_INTERNAL_WR_TIMING_MODE_ENABLE                          = 0x00000001,
    MEM_INTERNAL_WR_TIMING_MODE_INVALID                         = 0x000000FF,
};

/**
 *  @brief Indicates refresh wide range support
 */
enum MEM_REF_WIDE_RANGE
{
    MEM_REF_WIDE_RANGE_UNSUPPORTED                              = 0x00000000,
    MEM_REF_WIDE_RANGE_SUPPORTED                                = 0x00000001,
    MEM_REF_WIDE_RANGE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief DRAM pull up drive impedance ARRAY[DIMM][RANK]
 */
enum DRAM_PU_DRV_IMP
{
    DRAM_PU_DRV_IMP_OHM_34                                      = 0x00000022,
    DRAM_PU_DRV_IMP_OHM_40                                      = 0x00000028,
    DRAM_PU_DRV_IMP_OHM_48                                      = 0x00000030,
    DRAM_PU_DRV_IMP_RESERVED                                    = 0x000000FF,
};

/**
 *  @brief Notes if the DRAM supports test mode
 */
enum DDR5_DRAM_TEST_MODE
{
    DDR5_DRAM_TEST_MODE_UNSUPPORTED                             = 0x00000000,
    DDR5_DRAM_TEST_MODE_SUPPORTED                               = 0x00000001,
    DDR5_DRAM_TEST_MODE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief DRAM pull down drive impedance ARRAY[DIMM][RANK]
 */
enum DRAM_PD_DRV_IMP
{
    DRAM_PD_DRV_IMP_OHM_34                                      = 0x00000022,
    DRAM_PD_DRV_IMP_OHM_40                                      = 0x00000028,
    DRAM_PD_DRV_IMP_OHM_48                                      = 0x00000030,
    DRAM_PD_DRV_IMP_RESERVED                                    = 0x000000FF,
};

/**
 *  @brief RD Preamble settings
 */
enum DDR5_DRAM_RD_PREAMBLE
{
    DDR5_DRAM_RD_PREAMBLE_TCK1                                  = 0x00000000,
    DDR5_DRAM_RD_PREAMBLE_TCK2_OPT1                             = 0x00000001,
    DDR5_DRAM_RD_PREAMBLE_TCK2_OPT2                             = 0x00000002,
    DDR5_DRAM_RD_PREAMBLE_TCK3                                  = 0x00000003,
    DDR5_DRAM_RD_PREAMBLE_TCK4                                  = 0x00000004,
    DDR5_DRAM_RD_PREAMBLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief WR Preamble settings
 */
enum DDR5_DRAM_WR_PREAMBLE
{
    DDR5_DRAM_WR_PREAMBLE_TCK2                                  = 0x00000001,
    DDR5_DRAM_WR_PREAMBLE_TCK3                                  = 0x00000002,
    DDR5_DRAM_WR_PREAMBLE_TCK4                                  = 0x00000003,
    DDR5_DRAM_WR_PREAMBLE_RESERVED                              = 0x000000FF,
};

/**
 *  @brief RD Postamble settings
 */
enum DDR5_DRAM_RD_POSTAMBLE
{
    DDR5_DRAM_RD_POSTAMBLE_TCK0P5                               = 0x00000000,
    DDR5_DRAM_RD_POSTAMBLE_TCK1P5                               = 0x00000001,
    DDR5_DRAM_RD_POSTAMBLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief WR Postamble settings
 */
enum DDR5_DRAM_WR_POSTAMBLE
{
    DDR5_DRAM_WR_POSTAMBLE_TCK0P5                               = 0x00000000,
    DDR5_DRAM_WR_POSTAMBLE_TCK1P5                               = 0x00000001,
    DDR5_DRAM_WR_POSTAMBLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub operation mode
 */
enum DDR5_DRAM_ECS_MODE
{
    DDR5_DRAM_ECS_MODE_DISABLED                                 = 0x00000000,
    DDR5_DRAM_ECS_MODE_ENABLED                                  = 0x00000001,
    DDR5_DRAM_ECS_MODE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub reset counter mode
 */
enum DDR5_DRAM_ECS_RESET_COUNTER
{
    DDR5_DRAM_ECS_RESET_COUNTER_NORMAL                          = 0x00000000,
    DDR5_DRAM_ECS_RESET_COUNTER_RESET                           = 0x00000001,
    DDR5_DRAM_ECS_RESET_COUNTER_INVALID                         = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub count mode: Rows or Code words
 */
enum DDR5_DRAM_ECS_COUNT_MODE
{
    DDR5_DRAM_ECS_COUNT_MODE_ROWS                               = 0x00000000,
    DDR5_DRAM_ECS_COUNT_MODE_CODE_WORDS                         = 0x00000001,
    DDR5_DRAM_ECS_COUNT_MODE_INVALID                            = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub Error Threshold Count
 */
enum DDR5_DRAM_ECS_THRESHOLD_COUNT
{
    DDR5_DRAM_ECS_THRESHOLD_COUNT_4                             = 0x00000000,
    DDR5_DRAM_ECS_THRESHOLD_COUNT_16                            = 0x00000001,
    DDR5_DRAM_ECS_THRESHOLD_COUNT_64                            = 0x00000002,
    DDR5_DRAM_ECS_THRESHOLD_COUNT_256                           = 0x00000003,
    DDR5_DRAM_ECS_THRESHOLD_COUNT_1024                          = 0x00000004,
    DDR5_DRAM_ECS_THRESHOLD_COUNT_4096                          = 0x00000005,
    DDR5_DRAM_ECS_THRESHOLD_COUNT_INVALID                       = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub mode while in self refresh
 */
enum DDR5_DRAM_ECS_IN_SELF_REFRESH
{
    DDR5_DRAM_ECS_IN_SELF_REFRESH_DISABLED                      = 0x00000000,
    DDR5_DRAM_ECS_IN_SELF_REFRESH_ENABLED                       = 0x00000001,
    DDR5_DRAM_ECS_IN_SELF_REFRESH_INVALID                       = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub writeback mode: allowed or suppressed
 */
enum DDR5_DRAM_ECS_WRITEBACK
{
    DDR5_DRAM_ECS_WRITEBACK_ALLOWED                             = 0x00000000,
    DDR5_DRAM_ECS_WRITEBACK_SUPRESSED                           = 0x00000001,
    DDR5_DRAM_ECS_WRITEBACK_INVALID                             = 0x000000FF,
};

/**
 *  @brief DRAM Error Check Scrub RMW mode
 */
enum DDR5_DRAM_ECS_X4_WRITES
{
    DDR5_DRAM_ECS_X4_WRITES_ALLOWED                             = 0x00000000,
    DDR5_DRAM_ECS_X4_WRITES_SUPRESSED                           = 0x00000001,
    DDR5_DRAM_ECS_X4_WRITES_INVALID                             = 0x000000FF,
};

/**
 *  @brief DDR5 clock ODT value. ARRAY[DIMM][RANK][STRAP]
 */
enum DDR5_DRAM_CK_ODT
{
    DDR5_DRAM_CK_ODT_DISABLE                                    = 0x00000000,
    DDR5_DRAM_CK_ODT_OHM480                                     = 0x000001E0,
    DDR5_DRAM_CK_ODT_OHM240                                     = 0x000000F0,
    DDR5_DRAM_CK_ODT_OHM120                                     = 0x00000078,
    DDR5_DRAM_CK_ODT_OHM80                                      = 0x00000050,
    DDR5_DRAM_CK_ODT_OHM60                                      = 0x0000003C,
    DDR5_DRAM_CK_ODT_OHM40                                      = 0x00000028,
    DDR5_DRAM_CK_ODT_RESERVED                                   = 0x000000FF,
    DDR5_DRAM_CK_ODT_INVALID                                    = 0x0000FFFF,
};

/**
 *  @brief DDR5 chip select ODT value. ARRAY[DIMM][RANK][STRAP]
 */
enum DDR5_DRAM_CS_ODT
{
    DDR5_DRAM_CS_ODT_DISABLE                                    = 0x00000000,
    DDR5_DRAM_CS_ODT_OHM480                                     = 0x000001E0,
    DDR5_DRAM_CS_ODT_OHM240                                     = 0x000000F0,
    DDR5_DRAM_CS_ODT_OHM120                                     = 0x00000078,
    DDR5_DRAM_CS_ODT_OHM80                                      = 0x00000050,
    DDR5_DRAM_CS_ODT_OHM60                                      = 0x0000003C,
    DDR5_DRAM_CS_ODT_OHM40                                      = 0x00000028,
    DDR5_DRAM_CS_ODT_RESERVED                                   = 0x000000FF,
    DDR5_DRAM_CS_ODT_INVALID                                    = 0x0000FFFF,
};

/**
 *  @brief DDR5 clock ODT value. ARRAY[DIMM][RANK][DRAM]
 */
enum DDR5_DRAM_CK_ODT_PER_DRAM
{
    DDR5_DRAM_CK_ODT_PER_DRAM_DISABLE                           = 0x00000000,
    DDR5_DRAM_CK_ODT_PER_DRAM_OHM480                            = 0x000001E0,
    DDR5_DRAM_CK_ODT_PER_DRAM_OHM240                            = 0x000000F0,
    DDR5_DRAM_CK_ODT_PER_DRAM_OHM120                            = 0x00000078,
    DDR5_DRAM_CK_ODT_PER_DRAM_OHM80                             = 0x00000050,
    DDR5_DRAM_CK_ODT_PER_DRAM_OHM60                             = 0x0000003C,
    DDR5_DRAM_CK_ODT_PER_DRAM_OHM40                             = 0x00000028,
    DDR5_DRAM_CK_ODT_PER_DRAM_INVALID                           = 0x0000FFFF,
};

/**
 *  @brief DDR5 chip select ODT value. ARRAY[DIMM][RANK][DRAM]
 */
enum DDR5_DRAM_CS_ODT_PER_DRAM
{
    DDR5_DRAM_CS_ODT_PER_DRAM_DISABLE                           = 0x00000000,
    DDR5_DRAM_CS_ODT_PER_DRAM_OHM480                            = 0x000001E0,
    DDR5_DRAM_CS_ODT_PER_DRAM_OHM240                            = 0x000000F0,
    DDR5_DRAM_CS_ODT_PER_DRAM_OHM120                            = 0x00000078,
    DDR5_DRAM_CS_ODT_PER_DRAM_OHM80                             = 0x00000050,
    DDR5_DRAM_CS_ODT_PER_DRAM_OHM60                             = 0x0000003C,
    DDR5_DRAM_CS_ODT_PER_DRAM_OHM40                             = 0x00000028,
    DDR5_DRAM_CS_ODT_PER_DRAM_INVALID                           = 0x0000FFFF,
};

/**
 *  @brief DDR5 clock ODT value. ARRAY[DIMM][RANK][STRAP]
 */
enum DDR5_DRAM_CA_ODT
{
    DDR5_DRAM_CA_ODT_DISABLE                                    = 0x00000000,
    DDR5_DRAM_CA_ODT_OHM480                                     = 0x000001E0,
    DDR5_DRAM_CA_ODT_OHM240                                     = 0x000000F0,
    DDR5_DRAM_CA_ODT_OHM120                                     = 0x00000078,
    DDR5_DRAM_CA_ODT_OHM80                                      = 0x00000050,
    DDR5_DRAM_CA_ODT_OHM60                                      = 0x0000003C,
    DDR5_DRAM_CA_ODT_OHM40                                      = 0x00000028,
    DDR5_DRAM_CA_ODT_INVALID                                    = 0x0000FFFF,
};

/**
 *  @brief DRAM DQS RTT Park Termination Resistance in Ohms.
 *	ARRAY[DIMM][RANK][STRAP]
 */
enum DDR5_DRAM_DQS_RTT_PARK
{
    DDR5_DRAM_DQS_RTT_PARK_DISABLE                              = 0x00000000,
    DDR5_DRAM_DQS_RTT_PARK_OHM34                                = 0x00000022,
    DDR5_DRAM_DQS_RTT_PARK_OHM40                                = 0x00000028,
    DDR5_DRAM_DQS_RTT_PARK_OHM48                                = 0x00000030,
    DDR5_DRAM_DQS_RTT_PARK_OHM60                                = 0x0000003C,
    DDR5_DRAM_DQS_RTT_PARK_OHM80                                = 0x00000050,
    DDR5_DRAM_DQS_RTT_PARK_OHM120                               = 0x00000078,
    DDR5_DRAM_DQS_RTT_PARK_OHM240                               = 0x000000F0,
    DDR5_DRAM_DQS_RTT_PARK_INVALID                              = 0x000000FF,
};

/**
 *  @brief DDR5 clock ODT value. ARRAY[DIMM][RANK][DRAM]
 */
enum DDR5_DRAM_CA_ODT_PER_DRAM
{
    DDR5_DRAM_CA_ODT_PER_DRAM_DISABLE                           = 0x00000000,
    DDR5_DRAM_CA_ODT_PER_DRAM_OHM480                            = 0x000001E0,
    DDR5_DRAM_CA_ODT_PER_DRAM_OHM240                            = 0x000000F0,
    DDR5_DRAM_CA_ODT_PER_DRAM_OHM120                            = 0x00000078,
    DDR5_DRAM_CA_ODT_PER_DRAM_OHM80                             = 0x00000050,
    DDR5_DRAM_CA_ODT_PER_DRAM_OHM60                             = 0x0000003C,
    DDR5_DRAM_CA_ODT_PER_DRAM_OHM40                             = 0x00000028,
    DDR5_DRAM_CA_ODT_PER_DRAM_INVALID                           = 0x0000FFFF,
};

/**
 *  @brief DRAM DQS RTT Park Termination Resistance in Ohms.
 *	ARRAY[DIMM][RANK][DRAM]
 */
enum DDR5_DRAM_DQS_RTT_PARK_PER_DRAM
{
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_DISABLE                     = 0x00000000,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM34                       = 0x00000022,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM40                       = 0x00000028,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM48                       = 0x00000030,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM60                       = 0x0000003C,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM80                       = 0x00000050,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM120                      = 0x00000078,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_OHM240                      = 0x000000F0,
    DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_INVALID                     = 0x000000FF,
};

/**
 *  @brief DRAM RTT PARK for writes Termination Resistance in Ohms.
 *	ARRAY[DIMM][RANK][CHANNEL]
 */
enum DDR5_DRAM_RTT_WR
{
    DDR5_DRAM_RTT_WR_RTT_OFF                                    = 0x00000000,
    DDR5_DRAM_RTT_WR_OHM34                                      = 0x00000022,
    DDR5_DRAM_RTT_WR_OHM40                                      = 0x00000028,
    DDR5_DRAM_RTT_WR_OHM48                                      = 0x00000030,
    DDR5_DRAM_RTT_WR_OHM60                                      = 0x0000003C,
    DDR5_DRAM_RTT_WR_OHM80                                      = 0x00000050,
    DDR5_DRAM_RTT_WR_OHM120                                     = 0x00000078,
    DDR5_DRAM_RTT_WR_OHM240                                     = 0x000000F0,
    DDR5_DRAM_RTT_WR_INVALID                                    = 0x000000FF,
};

/**
 *  @brief DRAM RTT PARK for reads Termination Resistance in Ohms.
 *	ARRAY[DIMM][RANK][CHANNEL]
 */
enum DDR5_DRAM_RTT_PARK
{
    DDR5_DRAM_RTT_PARK_RTT_OFF                                  = 0x00000000,
    DDR5_DRAM_RTT_PARK_OHM34                                    = 0x00000022,
    DDR5_DRAM_RTT_PARK_OHM40                                    = 0x00000028,
    DDR5_DRAM_RTT_PARK_OHM48                                    = 0x00000030,
    DDR5_DRAM_RTT_PARK_OHM60                                    = 0x0000003C,
    DDR5_DRAM_RTT_PARK_OHM80                                    = 0x00000050,
    DDR5_DRAM_RTT_PARK_OHM120                                   = 0x00000078,
    DDR5_DRAM_RTT_PARK_OHM240                                   = 0x000000F0,
    DDR5_DRAM_RTT_PARK_INVALID                                  = 0x000000FF,
};

/**
 *  @brief DRAM RTT NOM for writes Termination Resistance in Ohms.
 *	ARRAY[DIMM][RANK][CHANNEL]
 */
enum DDR5_DRAM_RTT_NOM_WR
{
    DDR5_DRAM_RTT_NOM_WR_DISABLE                                = 0x00000000,
    DDR5_DRAM_RTT_NOM_WR_OHM34                                  = 0x00000022,
    DDR5_DRAM_RTT_NOM_WR_OHM40                                  = 0x00000028,
    DDR5_DRAM_RTT_NOM_WR_OHM48                                  = 0x00000030,
    DDR5_DRAM_RTT_NOM_WR_OHM60                                  = 0x0000003C,
    DDR5_DRAM_RTT_NOM_WR_OHM80                                  = 0x00000050,
    DDR5_DRAM_RTT_NOM_WR_OHM120                                 = 0x00000078,
    DDR5_DRAM_RTT_NOM_WR_OHM240                                 = 0x000000F0,
    DDR5_DRAM_RTT_NOM_WR_INVALID                                = 0x000000FF,
};

/**
 *  @brief DRAM RTT NOM for reads Termination Resistance in Ohms.
 *	ARRAY[DIMM][RANK][CHANNEL]
 */
enum DDR5_DRAM_RTT_NOM_RD
{
    DDR5_DRAM_RTT_NOM_RD_DISABLE                                = 0x00000000,
    DDR5_DRAM_RTT_NOM_RD_OHM34                                  = 0x00000022,
    DDR5_DRAM_RTT_NOM_RD_OHM40                                  = 0x00000028,
    DDR5_DRAM_RTT_NOM_RD_OHM48                                  = 0x00000030,
    DDR5_DRAM_RTT_NOM_RD_OHM60                                  = 0x0000003C,
    DDR5_DRAM_RTT_NOM_RD_OHM80                                  = 0x00000050,
    DDR5_DRAM_RTT_NOM_RD_OHM120                                 = 0x00000078,
    DDR5_DRAM_RTT_NOM_RD_OHM240                                 = 0x000000F0,
    DDR5_DRAM_RTT_NOM_RD_INVALID                                = 0x000000FF,
};

/**
 *  @brief DDR5 DRAM's Write CRC error status
 */
enum MEM_DDR5_WR_CRC_ERR_STATUS
{
    MEM_DDR5_WR_CRC_ERR_STATUS_CLEAR                            = 0x00000000,
    MEM_DDR5_WR_CRC_ERR_STATUS_ERROR                            = 0x00000001,
    MEM_DDR5_WR_CRC_ERR_STATUS_INVALID                          = 0x000000FF,
};

/**
 *  @brief DDR5 DRAM's Write CRC auto-disable enable
 */
enum MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE
{
    MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_DISABLE                  = 0x00000000,
    MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_ENABLE                   = 0x00000001,
    MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_INVALID                  = 0x000000FF,
};

/**
 *  @brief DDR5 DRAM's Write CRC auto-disable status
 */
enum MEM_DDR5_WR_CRC_AUTODISABLE_STATUS
{
    MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_NOT_TRIGGERED            = 0x00000000,
    MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_TRIGGERED                = 0x00000001,
    MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_INVALID                  = 0x000000FF,
};

/**
 *  @brief DDR5 DFE Gain enable/disable
 */
enum MEM_DDR5_GLOBAL_DFE_GAIN
{
    MEM_DDR5_GLOBAL_DFE_GAIN_ENABLE                             = 0x00000000,
    MEM_DDR5_GLOBAL_DFE_GAIN_DISABLE                            = 0x00000001,
    MEM_DDR5_GLOBAL_DFE_GAIN_INVALID                            = 0x000000FF,
};

/**
 *  @brief DDR5 DFE TAP-1 enable/disable
 */
enum MEM_DDR5_GLOBAL_DFE_TAP1
{
    MEM_DDR5_GLOBAL_DFE_TAP1_ENABLE                             = 0x00000000,
    MEM_DDR5_GLOBAL_DFE_TAP1_DISABLE                            = 0x00000001,
    MEM_DDR5_GLOBAL_DFE_TAP1_INVALID                            = 0x000000FF,
};

/**
 *  @brief DDR5 DFE TAP-2 enable/disable
 */
enum MEM_DDR5_GLOBAL_DFE_TAP2
{
    MEM_DDR5_GLOBAL_DFE_TAP2_ENABLE                             = 0x00000000,
    MEM_DDR5_GLOBAL_DFE_TAP2_DISABLE                            = 0x00000001,
    MEM_DDR5_GLOBAL_DFE_TAP2_INVALID                            = 0x000000FF,
};

/**
 *  @brief DDR5 DFE TAP-3 enable/disable
 */
enum MEM_DDR5_GLOBAL_DFE_TAP3
{
    MEM_DDR5_GLOBAL_DFE_TAP3_ENABLE                             = 0x00000000,
    MEM_DDR5_GLOBAL_DFE_TAP3_DISABLE                            = 0x00000001,
    MEM_DDR5_GLOBAL_DFE_TAP3_INVALID                            = 0x000000FF,
};

/**
 *  @brief DDR5 DFE TAP-4 enable/disable
 */
enum MEM_DDR5_GLOBAL_DFE_TAP4
{
    MEM_DDR5_GLOBAL_DFE_TAP4_ENABLE                             = 0x00000000,
    MEM_DDR5_GLOBAL_DFE_TAP4_DISABLE                            = 0x00000001,
    MEM_DDR5_GLOBAL_DFE_TAP4_INVALID                            = 0x000000FF,
};

/**
 *  @brief DDR5 DFE gain bias ARRAY[DIMM][RANK]
 */
enum MEM_DDR5_DFE_GAIN_BIAS
{
    MEM_DDR5_DFE_GAIN_BIAS_STEP0                                = 0x00000000,
    MEM_DDR5_DFE_GAIN_BIAS_STEP1                                = 0x00000001,
    MEM_DDR5_DFE_GAIN_BIAS_STEP2                                = 0x00000002,
    MEM_DDR5_DFE_GAIN_BIAS_STEP3                                = 0x00000003,
    MEM_DDR5_DFE_GAIN_BIAS_INVALID                              = 0x000000FF,
};

/**
 *  @brief DDR5 DFE sign bit ARRAY[DIMM][RANK]
 */
enum MEM_DDR5_DFE_SIGN_BIT
{
    MEM_DDR5_DFE_SIGN_BIT_POSITIVE                              = 0x00000000,
    MEM_DDR5_DFE_SIGN_BIT_NEGATIVE                              = 0x00000001,
    MEM_DDR5_DFE_SIGN_BIT_INVALID                               = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] DRAM Device Type. Decodes SPD byte 2. Generation of
 *	memory: DDR3, DDR4, DDR5
 */
enum MEM_EFF_DRAM_GEN
{
    MEM_EFF_DRAM_GEN_EMPTY                                      = 0x00000000,
    MEM_EFF_DRAM_GEN_DDR3                                       = 0x00000001,
    MEM_EFF_DRAM_GEN_DDR4                                       = 0x00000002,
    MEM_EFF_DRAM_GEN_DDR5                                       = 0x00000003,
    MEM_EFF_DRAM_GEN_INVALID                                    = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Base Module Type. Decodes SPD Byte 3 (bits 3~0).
 *	Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDEC
 *	standard.
 */
enum MEM_EFF_DIMM_TYPE
{
    MEM_EFF_DIMM_TYPE_EMPTY                                     = 0x00000000,
    MEM_EFF_DIMM_TYPE_RDIMM                                     = 0x00000001,
    MEM_EFF_DIMM_TYPE_UDIMM                                     = 0x00000002,
    MEM_EFF_DIMM_TYPE_LRDIMM                                    = 0x00000003,
    MEM_EFF_DIMM_TYPE_DDIMM                                     = 0x00000004,
    MEM_EFF_DIMM_TYPE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Hybrid Media. Decodes SPD Byte 3 (bits 6~4)
 */
enum MEM_EFF_HYBRID_MEMORY_TYPE
{
    MEM_EFF_HYBRID_MEMORY_TYPE_NONE                             = 0x00000000,
    MEM_EFF_HYBRID_MEMORY_TYPE_NVDIMM                           = 0x00000001,
    MEM_EFF_HYBRID_MEMORY_TYPE_MDS                              = 0x00000003,
    MEM_EFF_HYBRID_MEMORY_TYPE_NVDIMM_N                         = 0x00000004,
    MEM_EFF_HYBRID_MEMORY_TYPE_NVDIMM_P                         = 0x00000002,
    MEM_EFF_HYBRID_MEMORY_TYPE_INVALID                          = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Hybrid. Decodes SPD Byte 3 (bit 7)
 */
enum MEM_EFF_HYBRID
{
    MEM_EFF_HYBRID_NOT_HYBRID                                   = 0x00000000,
    MEM_EFF_HYBRID_IS_HYBRID                                    = 0x00000001,
    MEM_EFF_HYBRID_INVALID                                      = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM]
 */
enum MEM_EFF_HOST_TO_DDR_SPEED_RATIO
{
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_UNITIALIZED                 = 0x00000000,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_1_TO_1                      = 0x00000001,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_2_TO_1                      = 0x00000002,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_4_TO_1                      = 0x00000004,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_8_TO_1                      = 0x00000008,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_16_TO_1                     = 0x00000010,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_32_TO_1                     = 0x00000020,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_64_TO_1                     = 0x00000040,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_128_TO_1                    = 0x00000080,
    MEM_EFF_HOST_TO_DDR_SPEED_RATIO_INVALID                     = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total
 *	SDRAM capacity per die. For multi-die stacks (DDP, QDP, or 3DS),
 *	this represents the capacity of each DRAM die in the stack.
 */
enum MEM_EFF_DRAM_DENSITY
{
    MEM_EFF_DRAM_DENSITY_4G                                     = 0x00000004,
    MEM_EFF_DRAM_DENSITY_8G                                     = 0x00000008,
    MEM_EFF_DRAM_DENSITY_12G                                    = 0x0000000C,
    MEM_EFF_DRAM_DENSITY_16G                                    = 0x00000010,
    MEM_EFF_DRAM_DENSITY_24G                                    = 0x00000018,
    MEM_EFF_DRAM_DENSITY_32G                                    = 0x00000020,
    MEM_EFF_DRAM_DENSITY_48G                                    = 0x00000030,
    MEM_EFF_DRAM_DENSITY_64G                                    = 0x00000040,
    MEM_EFF_DRAM_DENSITY_RESERVED                               = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Column Address Bits. Decoded SPD Byte 5 (bits 2~0).
 *	Actual number of DRAM columns is 2^N, where N is the number of
 *	column address bits
 */
enum MEM_EFF_DRAM_COLUMN_BITS
{
    MEM_EFF_DRAM_COLUMN_BITS_NUM10                              = 0x0000000A,
    MEM_EFF_DRAM_COLUMN_BITS_NUM11                              = 0x0000000B,
    MEM_EFF_DRAM_COLUMN_BITS_INVALID                            = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Row Address Bits. Decodes Byte 5 (bits 5~3). Number
 *	of DRAM column address bits. Actual number of DRAM rows is 2^N,
 *	where N is the number of row address bits
 */
enum MEM_EFF_DRAM_ROW_BITS
{
    MEM_EFF_DRAM_ROW_BITS_NUM14                                 = 0x0000000E,
    MEM_EFF_DRAM_ROW_BITS_NUM15                                 = 0x0000000F,
    MEM_EFF_DRAM_ROW_BITS_NUM16                                 = 0x00000010,
    MEM_EFF_DRAM_ROW_BITS_NUM17                                 = 0x00000011,
    MEM_EFF_DRAM_ROW_BITS_NUM18                                 = 0x00000012,
    MEM_EFF_DRAM_ROW_BITS_INVALID                               = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Primary SDRAM Die Count. Decodes Byte 6 (bits 6~4).
 */
enum MEM_EFF_PRIM_DIE_COUNT
{
    MEM_EFF_PRIM_DIE_COUNT_D1                                   = 0x00000001,
    MEM_EFF_PRIM_DIE_COUNT_D2                                   = 0x00000002,
    MEM_EFF_PRIM_DIE_COUNT_D3                                   = 0x00000003,
    MEM_EFF_PRIM_DIE_COUNT_D4                                   = 0x00000004,
    MEM_EFF_PRIM_DIE_COUNT_D5                                   = 0x00000005,
    MEM_EFF_PRIM_DIE_COUNT_D6                                   = 0x00000006,
    MEM_EFF_PRIM_DIE_COUNT_D7                                   = 0x00000007,
    MEM_EFF_PRIM_DIE_COUNT_D8                                   = 0x00000008,
    MEM_EFF_PRIM_DIE_COUNT_D16                                  = 0x00000010,
    MEM_EFF_PRIM_DIE_COUNT_RESERVED                             = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Primary SDRAM Package Type (bits 1~0). Decodes Byte
 *	6. This byte defines the primary set of SDRAMs. Monolithic = SPD,
 *	Multi-load stack = DDP/QDP, Single-load stack = 3DS
 */
enum MEM_EFF_PRIM_STACK_TYPE
{
    MEM_EFF_PRIM_STACK_TYPE_SDP                                 = 0x00000000,
    MEM_EFF_PRIM_STACK_TYPE_DDP_QDP                             = 0x00000001,
    MEM_EFF_PRIM_STACK_TYPE_3DS                                 = 0x00000002,
    MEM_EFF_PRIM_STACK_TYPE_INVALID                             = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Primary bus with (bits 1~0). Decodes Byte 13.
 */
enum MEM_EFF_PRIM_BUS_WIDTH
{
    MEM_EFF_PRIM_BUS_WIDTH_8_BITS                               = 0x00000008,
    MEM_EFF_PRIM_BUS_WIDTH_16_BITS                              = 0x00000010,
    MEM_EFF_PRIM_BUS_WIDTH_32_BITS                              = 0x00000020,
    MEM_EFF_PRIM_BUS_WIDTH_64_BITS                              = 0x00000040,
    MEM_EFF_PRIM_BUS_WIDTH_INVALID                              = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Number of channels per DIMM (bits 6~5). Decodes Byte
 *	235.
 */
enum MEM_EFF_CHANNELS_PER_DIMM
{
    MEM_EFF_CHANNELS_PER_DIMM_1_CHANNEL                         = 0x00000001,
    MEM_EFF_CHANNELS_PER_DIMM_2_CHANNELS                        = 0x00000002,
    MEM_EFF_CHANNELS_PER_DIMM_INVALID                           = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Post Package Repair. Used in various locations and
 *	is evaluated in mss_eff_cnfg.
 */
enum MEM_EFF_DRAM_PPR
{
    MEM_EFF_DRAM_PPR_NOT_SUPPORTED                              = 0x00000000,
    MEM_EFF_DRAM_PPR_SUPPORTED                                  = 0x00000001,
    MEM_EFF_DRAM_PPR_INVALID                                    = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Soft Post Package Repair. Used in various locations
 *	and is evaluated in mss_eff_cnfg.
 */
enum MEM_EFF_DRAM_SOFT_PPR
{
    MEM_EFF_DRAM_SOFT_PPR_NOT_SUPPORTED                         = 0x00000000,
    MEM_EFF_DRAM_SOFT_PPR_SUPPORTED                             = 0x00000001,
    MEM_EFF_DRAM_SOFT_PPR_INVALID                               = 0x000000FF,
};

/**
 *  @brief Minimum CAS to CAS Delay Time, same bank group in nck (number of
 *	clock cycles). Decodes SPD byte 40 (bits 7~0) and byte 117 (bits
 *	7~0). This is for DDR5 RDs. Each memory channel will have a value.
 */
enum MEM_EFF_DRAM_TCCD_L
{
    MEM_EFF_DRAM_TCCD_L_4NCK                                    = 0x00000004,
    MEM_EFF_DRAM_TCCD_L_5NCK                                    = 0x00000005,
    MEM_EFF_DRAM_TCCD_L_6NCK                                    = 0x00000006,
    MEM_EFF_DRAM_TCCD_L_7NCK                                    = 0x00000007,
    MEM_EFF_DRAM_TCCD_L_8NCK                                    = 0x00000008,
    MEM_EFF_DRAM_TCCD_L_12NCK                                   = 0x0000000C,
    MEM_EFF_DRAM_TCCD_L_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Minimum CAS to CAS Delay Time, same bank group in nck (number of
 *	clock cycles). Decodes SPD byte 40 (bits 7~0) and byte 117 (bits
 *	7~0). This is for DDR5 WRs. Each memory channel will have a value.
 */
enum MEM_EFF_DRAM_TCCD_L_WR
{
    MEM_EFF_DRAM_TCCD_L_WR_32NCK                                = 0x00000020,
    MEM_EFF_DRAM_TCCD_L_WR_36NCK                                = 0x00000024,
    MEM_EFF_DRAM_TCCD_L_WR_40NCK                                = 0x00000028,
    MEM_EFF_DRAM_TCCD_L_WR_44NCK                                = 0x0000002C,
    MEM_EFF_DRAM_TCCD_L_WR_48NCK                                = 0x00000030,
    MEM_EFF_DRAM_TCCD_L_WR_INVALID                              = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] SDRAM Device Width Decodes SPD Byte 12 (bits 2~0).
 *	Options: X4 (4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits).
 */
enum MEM_EFF_DRAM_WIDTH
{
    MEM_EFF_DRAM_WIDTH_X4                                       = 0x00000004,
    MEM_EFF_DRAM_WIDTH_X8                                       = 0x00000008,
    MEM_EFF_DRAM_WIDTH_X16                                      = 0x00000010,
    MEM_EFF_DRAM_WIDTH_X32                                      = 0x00000020,
    MEM_EFF_DRAM_WIDTH_INVALID                                  = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Total number of ranks in each DIMM. For monolithic
 *	and multi-load stack modules (SDP/DDP) this is the same as the
 *	number of package ranks per DIMM (SPD Byte 12 bits 5~3). For single
 *	load stack (3DS) modules this value represents the number of
 *	logical ranks per DIMM. Logical rank refers the individually
 *	addressable die in a 3DS stack and has no meaning for monolithic or
 *	multi-load stacked SDRAMs.
 */
enum MEM_EFF_LOGICAL_RANKS_PER_DIMM
{
    MEM_EFF_LOGICAL_RANKS_PER_DIMM_1R                           = 0x00000001,
    MEM_EFF_LOGICAL_RANKS_PER_DIMM_2R                           = 0x00000002,
    MEM_EFF_LOGICAL_RANKS_PER_DIMM_4R                           = 0x00000004,
    MEM_EFF_LOGICAL_RANKS_PER_DIMM_8R                           = 0x00000008,
    MEM_EFF_LOGICAL_RANKS_PER_DIMM_16R                          = 0x00000010,
    MEM_EFF_LOGICAL_RANKS_PER_DIMM_INVALID                      = 0x000000FF,
};

/**
 *  @brief Setting for 3DS stack. Calculated from logical_ranks /
 *	master_ranks
 */
enum MEM_3DS_HEIGHT
{
    MEM_3DS_HEIGHT_PLANAR                                       = 0x00000000,
    MEM_3DS_HEIGHT_H2                                           = 0x00000002,
    MEM_3DS_HEIGHT_H4                                           = 0x00000004,
    MEM_3DS_HEIGHT_H8                                           = 0x00000008,
    MEM_3DS_HEIGHT_H16                                          = 0x00000010,
    MEM_3DS_HEIGHT_RESERVED                                     = 0x000000FF,
    MEM_3DS_HEIGHT_INVALID                                      = 0x0000FFFF,
};

/**
 *  @brief ARRAY[DIMM] Register Type Decodes SPD Byte 131
 */
enum MEM_EFF_REGISTER_TYPE
{
    MEM_EFF_REGISTER_TYPE_RCD01                                 = 0x00000000,
    MEM_EFF_REGISTER_TYPE_RCD02                                 = 0x00000001,
    MEM_EFF_REGISTER_TYPE_INVALID                               = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Module MFG ID Decodes SPD Byte 320 and 321 for
 *	ISDIMMs (Fujitsu, US Modular) Decodes SPD Byte 512 and 513 for
 *	DDIMMs (Micron, Samsung, Smart)
 */
enum MEM_EFF_MODULE_MFG_ID
{
    MEM_EFF_MODULE_MFG_ID_MICRON                                = 0x0000802C,
    MEM_EFF_MODULE_MFG_ID_SAMSUNG                               = 0x000080CE,
    MEM_EFF_MODULE_MFG_ID_SMART                                 = 0x00000194,
    MEM_EFF_MODULE_MFG_ID_IBM                                   = 0x000080A4,
    MEM_EFF_MODULE_MFG_ID_FUJITSU                               = 0x00008004,
    MEM_EFF_MODULE_MFG_ID_US_MODULAR                            = 0x000004AB,
    MEM_EFF_MODULE_MFG_ID_INVALID                               = 0x0000FFFF,
};

/**
 *  @brief ARRAY[DIMM] DRAM Manufacturer ID Code Decodes SPD Byte 350 and
 *	351 for ISDIMMs Decodes SPD Byte 552 and 553 for DDIMMs
 */
enum MEM_EFF_DRAM_MFG_ID
{
    MEM_EFF_DRAM_MFG_ID_MICRON                                  = 0x0000802C,
    MEM_EFF_DRAM_MFG_ID_SAMSUNG                                 = 0x000080CE,
    MEM_EFF_DRAM_MFG_ID_HYNIX                                   = 0x000080AD,
    MEM_EFF_DRAM_MFG_ID_INVALID                                 = 0x0000FFFF,
};

/**
 *  @brief ARRAY[DIMM] DRAM Modlue Height Decodes SPD Byte 193
 */
enum MEM_EFF_DRAM_MODULE_HEIGHT
{
    MEM_EFF_DRAM_MODULE_HEIGHT_1U                               = 0x00000000,
    MEM_EFF_DRAM_MODULE_HEIGHT_2U                               = 0x00000001,
    MEM_EFF_DRAM_MODULE_HEIGHT_4U                               = 0x00000004,
    MEM_EFF_DRAM_MODULE_HEIGHT_RESERVED                         = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Register Manufacturer ID Code Decodes SPD Byte 133
 *	and 134 DDIMM Module Bytes 265 and 266
 */
enum MEM_EFF_RCD_MFG_ID
{
    MEM_EFF_RCD_MFG_ID_INPHI                                    = 0x0000B304,
    MEM_EFF_RCD_MFG_ID_MONTAGE                                  = 0x00003286,
    MEM_EFF_RCD_MFG_ID_IDT                                      = 0x0000B380,
    MEM_EFF_RCD_MFG_ID_INVALID                                  = 0x0000FFFF,
};

/**
 *  @brief ARRAY[DIMM] DIMM Size, in GB Used in various locations
 */
enum MEM_EFF_DIMM_SIZE
{
    MEM_EFF_DIMM_SIZE_4GB                                       = 0x00000004,
    MEM_EFF_DIMM_SIZE_8GB                                       = 0x00000008,
    MEM_EFF_DIMM_SIZE_16GB                                      = 0x00000010,
    MEM_EFF_DIMM_SIZE_32GB                                      = 0x00000020,
    MEM_EFF_DIMM_SIZE_64GB                                      = 0x00000040,
    MEM_EFF_DIMM_SIZE_128GB                                     = 0x00000080,
    MEM_EFF_DIMM_SIZE_256GB                                     = 0x00000100,
    MEM_EFF_DIMM_SIZE_512GB                                     = 0x00000200,
    MEM_EFF_DIMM_SIZE_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief Spare DRAM availability. Used in various locations and is
 *	computed in mss_eff_cnfg. Array indexes are [DIMM][RANK]
 */
enum MEM_EFF_DIMM_SPARE
{
    MEM_EFF_DIMM_SPARE_NO_SPARE                                 = 0x00000000,
    MEM_EFF_DIMM_SPARE_LOW_NIBBLE                               = 0x00000001,
    MEM_EFF_DIMM_SPARE_HIGH_NIBBLE                              = 0x00000002,
    MEM_EFF_DIMM_SPARE_FULL_BYTE                                = 0x00000003,
    MEM_EFF_DIMM_SPARE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Specifies the number of master ranks per DIMM.
 *	Represents the number of physical ranks on a DIMM. From SPD spec
 *	JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12 (Bits 5~3) Number
 *	of package ranks per DIMM. Package ranks per DIMM refers to the
 *	collections of devices on the module sharing common chip select
 *	signals.
 */
enum MEM_EFF_NUM_MASTER_RANKS_PER_DIMM
{
    MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_1R                        = 0x00000001,
    MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_2R                        = 0x00000002,
    MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_4R                        = 0x00000004,
    MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_8R                        = 0x00000008,
    MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_INVALID                   = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] Byte 264: Registered Clock Drivers (RCD). DDIMM SPD
 *	spec. Module's supported RCD options
 */
enum MEM_EFF_SUPPORTED_RCD
{
    MEM_EFF_SUPPORTED_RCD_NO_RCD                                = 0x00000000,
    MEM_EFF_SUPPORTED_RCD_RCD_PER_CHANNEL_1                     = 0x00000001,
    MEM_EFF_SUPPORTED_RCD_INVALID                               = 0x000000FF,
};

/**
 *  @brief Determines DDIMM memory controller P series versus Z series
 *	specific settings.
 */
enum MEM_EFF_Z_MODE
{
    MEM_EFF_Z_MODE_FALSE                                        = 0x00000000,
    MEM_EFF_Z_MODE_TRUE                                         = 0x00000001,
    MEM_EFF_Z_MODE_INVALID                                      = 0x000000FF,
};

/**
 *  @brief The availability of thermal sensor 0
 */
enum MEM_EFF_THERM_SENSOR_0_AVAIL
{
    MEM_EFF_THERM_SENSOR_0_AVAIL_NOT_AVAILABLE                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_0_AVAIL_AVAILABLE                      = 0x00000001,
    MEM_EFF_THERM_SENSOR_0_AVAIL_INVALID                        = 0x000000FF,
};

/**
 *  @brief The availability of thermal sensor 0's secondary sensor
 */
enum MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL
{
    MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_NOT_AVAILABLE           = 0x00000000,
    MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_AVAILABLE               = 0x00000001,
    MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_INVALID                 = 0x000000FF,
};

/**
 *  @brief The sensor type of thermal sensor 0 JC42 =
 *	JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 = MCHP_EMC1412_OR_COMPATIBLE
 */
enum MEM_EFF_THERM_SENSOR_0_TYPE
{
    MEM_EFF_THERM_SENSOR_0_TYPE_NO_SENSOR                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_0_TYPE_JC42                            = 0x00000001,
    MEM_EFF_THERM_SENSOR_0_TYPE_EMC1412                         = 0x00000002,
    MEM_EFF_THERM_SENSOR_0_TYPE_INVALID                         = 0x000000FF,
};

/**
 *  @brief The chosen usage monitor of thermal sensor 0. Note that the SPD
 *	encoding of DRAM_AND_PMIC usage (0x03) is not supported and will be
 *	changed to PMIC in this attribute.
 */
enum MEM_EFF_THERM_SENSOR_0_USAGE
{
    MEM_EFF_THERM_SENSOR_0_USAGE_DISABLED                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_0_USAGE_DRAM                           = 0x00000001,
    MEM_EFF_THERM_SENSOR_0_USAGE_PMIC                           = 0x00000002,
    MEM_EFF_THERM_SENSOR_0_USAGE_MEM_BUF_EXT                    = 0x00000004,
    MEM_EFF_THERM_SENSOR_0_USAGE_DRAM_AND_MEM_BUF_EXT           = 0x00000005,
    MEM_EFF_THERM_SENSOR_0_USAGE_INVALID                        = 0x000000FF,
};

/**
 *  @brief The availability of thermal sensor 1
 */
enum MEM_EFF_THERM_SENSOR_1_AVAIL
{
    MEM_EFF_THERM_SENSOR_1_AVAIL_NOT_AVAILABLE                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_1_AVAIL_AVAILABLE                      = 0x00000001,
    MEM_EFF_THERM_SENSOR_1_AVAIL_INVALID                        = 0x000000FF,
};

/**
 *  @brief The availability of thermal sensor 1's secondary sensor
 */
enum MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL
{
    MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_NOT_AVAILABLE           = 0x00000000,
    MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_AVAILABLE               = 0x00000001,
    MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_INVALID                 = 0x000000FF,
};

/**
 *  @brief The sensor type of thermal sensor 1 JC42 =
 *	JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 = MCHP_EMC1412_OR_COMPATIBLE
 */
enum MEM_EFF_THERM_SENSOR_1_TYPE
{
    MEM_EFF_THERM_SENSOR_1_TYPE_NO_SENSOR                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_1_TYPE_JC42                            = 0x00000001,
    MEM_EFF_THERM_SENSOR_1_TYPE_EMC1412                         = 0x00000002,
    MEM_EFF_THERM_SENSOR_1_TYPE_INVALID                         = 0x000000FF,
};

/**
 *  @brief The chosen usage monitor of thermal sensor 1. Note that the SPD
 *	encoding of DRAM_AND_PMIC usage (0x03) is not supported and will be
 *	changed to PMIC in this attribute.
 */
enum MEM_EFF_THERM_SENSOR_1_USAGE
{
    MEM_EFF_THERM_SENSOR_1_USAGE_DISABLED                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_1_USAGE_DRAM                           = 0x00000001,
    MEM_EFF_THERM_SENSOR_1_USAGE_PMIC                           = 0x00000002,
    MEM_EFF_THERM_SENSOR_1_USAGE_MEM_BUF_EXT                    = 0x00000004,
    MEM_EFF_THERM_SENSOR_1_USAGE_DRAM_AND_MEM_BUF_EXT           = 0x00000005,
    MEM_EFF_THERM_SENSOR_1_USAGE_INVALID                        = 0x000000FF,
};

/**
 *  @brief The availability of thermal sensor 2
 */
enum MEM_EFF_THERM_SENSOR_2_AVAIL
{
    MEM_EFF_THERM_SENSOR_2_AVAIL_NOT_AVAILABLE                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_2_AVAIL_AVAILABLE                      = 0x00000001,
    MEM_EFF_THERM_SENSOR_2_AVAIL_INVALID                        = 0x000000FF,
};

/**
 *  @brief The sensor type of thermal sensor 2 JC42 =
 *	JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 = MCHP_EMC1412_OR_COMPATIBLE
 */
enum MEM_EFF_THERM_SENSOR_2_TYPE
{
    MEM_EFF_THERM_SENSOR_2_TYPE_NO_SENSOR                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_2_TYPE_JC42                            = 0x00000001,
    MEM_EFF_THERM_SENSOR_2_TYPE_EMC1412                         = 0x00000002,
    MEM_EFF_THERM_SENSOR_2_TYPE_INVALID                         = 0x000000FF,
};

/**
 *  @brief The chosen usage monitor of thermal sensor 2. Note that the SPD
 *	encoding of DRAM_AND_PMIC usage (0x03) is not supported and will be
 *	changed to PMIC in this attribute.
 */
enum MEM_EFF_THERM_SENSOR_2_USAGE
{
    MEM_EFF_THERM_SENSOR_2_USAGE_DISABLED                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_2_USAGE_DRAM                           = 0x00000001,
    MEM_EFF_THERM_SENSOR_2_USAGE_PMIC                           = 0x00000002,
    MEM_EFF_THERM_SENSOR_2_USAGE_MEM_BUF_EXT                    = 0x00000004,
    MEM_EFF_THERM_SENSOR_2_USAGE_DRAM_AND_MEM_BUF_EXT           = 0x00000005,
    MEM_EFF_THERM_SENSOR_2_USAGE_INVALID                        = 0x000000FF,
};

/**
 *  @brief The availability of thermal sensor 3
 */
enum MEM_EFF_THERM_SENSOR_3_AVAIL
{
    MEM_EFF_THERM_SENSOR_3_AVAIL_NOT_AVAILABLE                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_3_AVAIL_AVAILABLE                      = 0x00000001,
    MEM_EFF_THERM_SENSOR_3_AVAIL_INVALID                        = 0x000000FF,
};

/**
 *  @brief The sensor type of thermal sensor 3 JC42 =
 *	JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 = MCHP_EMC1412_OR_COMPATIBLE
 */
enum MEM_EFF_THERM_SENSOR_3_TYPE
{
    MEM_EFF_THERM_SENSOR_3_TYPE_NO_SENSOR                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_3_TYPE_JC42                            = 0x00000001,
    MEM_EFF_THERM_SENSOR_3_TYPE_EMC1412                         = 0x00000002,
    MEM_EFF_THERM_SENSOR_3_TYPE_INVALID                         = 0x000000FF,
};

/**
 *  @brief The chosen usage monitor of thermal sensor 3. Note that the SPD
 *	encoding of DRAM_AND_PMIC usage (0x03) is not supported and will be
 *	changed to PMIC in this attribute.
 */
enum MEM_EFF_THERM_SENSOR_3_USAGE
{
    MEM_EFF_THERM_SENSOR_3_USAGE_DISABLED                       = 0x00000000,
    MEM_EFF_THERM_SENSOR_3_USAGE_DRAM                           = 0x00000001,
    MEM_EFF_THERM_SENSOR_3_USAGE_PMIC                           = 0x00000002,
    MEM_EFF_THERM_SENSOR_3_USAGE_MEM_BUF_EXT                    = 0x00000004,
    MEM_EFF_THERM_SENSOR_3_USAGE_DRAM_AND_MEM_BUF_EXT           = 0x00000005,
    MEM_EFF_THERM_SENSOR_3_USAGE_INVALID                        = 0x000000FF,
};

/**
 *  @brief The availability of the differential onchip thermal sensor
 */
enum MEM_EFF_THERM_SENSOR_DIFF_AVAIL
{
    MEM_EFF_THERM_SENSOR_DIFF_AVAIL_NOT_AVAILABLE               = 0x00000000,
    MEM_EFF_THERM_SENSOR_DIFF_AVAIL_AVAILABLE                   = 0x00000001,
    MEM_EFF_THERM_SENSOR_DIFF_AVAIL_INVALID                     = 0x000000FF,
};

/**
 *  @brief The sensor type of the differential onchip thermal sensor JC42 =
 *	JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 = MCHP_EMC1412_OR_COMPATIBLE
 */
enum MEM_EFF_THERM_SENSOR_DIFF_TYPE
{
    MEM_EFF_THERM_SENSOR_DIFF_TYPE_NO_SENSOR                    = 0x00000000,
    MEM_EFF_THERM_SENSOR_DIFF_TYPE_JC42                         = 0x00000001,
    MEM_EFF_THERM_SENSOR_DIFF_TYPE_EMC1412                      = 0x00000002,
    MEM_EFF_THERM_SENSOR_DIFF_TYPE_INVALID                      = 0x000000FF,
};

/**
 *  @brief The chosen usage monitor of the differential onchip thermal
 *	sensor MB_INT_DTM = MEMORY_BUFFER_INTERNAL_DTM MB_INT_DTM_REM =
 *	MEMORY_BUFFER_INTERNAL_DTM_REMOTE_SENSE
 */
enum MEM_EFF_THERM_SENSOR_DIFF_USAGE
{
    MEM_EFF_THERM_SENSOR_DIFF_USAGE_DISABLED                    = 0x00000000,
    MEM_EFF_THERM_SENSOR_DIFF_USAGE_MB_INT_DTM                  = 0x00000001,
    MEM_EFF_THERM_SENSOR_DIFF_USAGE_MB_INT_DTM_REM              = 0x00000002,
    MEM_EFF_THERM_SENSOR_DIFF_USAGE_INVALID                     = 0x000000FF,
};

/**
 *  @brief Secondary Thermal Sensor 1 Location
 */
enum MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION
{
    MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_LOWER_LEFT           = 0x00000000,
    MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_UPPER_LEFT           = 0x00000001,
    MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_LOWER_RIGHT          = 0x00000002,
    MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_UPPER_RIGHT          = 0x00000003,
    MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_INVALID              = 0x000000FF,
};

/**
 *  @brief Secondary Thermal Sensor 0 Location
 */
enum MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION
{
    MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_LOWER_LEFT           = 0x00000000,
    MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_UPPER_LEFT           = 0x00000001,
    MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_LOWER_RIGHT          = 0x00000002,
    MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_UPPER_RIGHT          = 0x00000003,
    MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_INVALID              = 0x000000FF,
};

/**
 *  @brief Thermal Sensor 3 Location
 */
enum MEM_EFF_THERM_SENSOR_3_LOCATION
{
    MEM_EFF_THERM_SENSOR_3_LOCATION_LOWER_LEFT                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_3_LOCATION_UPPER_LEFT                  = 0x00000001,
    MEM_EFF_THERM_SENSOR_3_LOCATION_LOWER_RIGHT                 = 0x00000002,
    MEM_EFF_THERM_SENSOR_3_LOCATION_UPPER_RIGHT                 = 0x00000003,
    MEM_EFF_THERM_SENSOR_3_LOCATION_INVALID                     = 0x000000FF,
};

/**
 *  @brief Thermal Sensor 2 Location
 */
enum MEM_EFF_THERM_SENSOR_2_LOCATION
{
    MEM_EFF_THERM_SENSOR_2_LOCATION_LOWER_LEFT                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_2_LOCATION_UPPER_LEFT                  = 0x00000001,
    MEM_EFF_THERM_SENSOR_2_LOCATION_LOWER_RIGHT                 = 0x00000002,
    MEM_EFF_THERM_SENSOR_2_LOCATION_UPPER_RIGHT                 = 0x00000003,
    MEM_EFF_THERM_SENSOR_2_LOCATION_INVALID                     = 0x000000FF,
};

/**
 *  @brief Thermal Sensor 1 Location
 */
enum MEM_EFF_THERM_SENSOR_1_LOCATION
{
    MEM_EFF_THERM_SENSOR_1_LOCATION_LOWER_LEFT                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_1_LOCATION_UPPER_LEFT                  = 0x00000001,
    MEM_EFF_THERM_SENSOR_1_LOCATION_LOWER_RIGHT                 = 0x00000002,
    MEM_EFF_THERM_SENSOR_1_LOCATION_UPPER_RIGHT                 = 0x00000003,
    MEM_EFF_THERM_SENSOR_1_LOCATION_INVALID                     = 0x000000FF,
};

/**
 *  @brief Thermal Sensor 0 Location
 */
enum MEM_EFF_THERM_SENSOR_0_LOCATION
{
    MEM_EFF_THERM_SENSOR_0_LOCATION_LOWER_LEFT                  = 0x00000000,
    MEM_EFF_THERM_SENSOR_0_LOCATION_UPPER_LEFT                  = 0x00000001,
    MEM_EFF_THERM_SENSOR_0_LOCATION_LOWER_RIGHT                 = 0x00000002,
    MEM_EFF_THERM_SENSOR_0_LOCATION_UPPER_RIGHT                 = 0x00000003,
    MEM_EFF_THERM_SENSOR_0_LOCATION_INVALID                     = 0x000000FF,
};

/**
 *  @brief Thermal Sensor Init read override, by default thermal init
 *	should only read DRAM sensor downstream of airflow direction. This
 *	override should only be used to force all on-board temperature
 *	sensors to be configured for reading for DIMM testers and Memory
 *	Qual.
 */
enum MEM_EFF_THERM_SENSOR_READ_OVERRIDE
{
    MEM_EFF_THERM_SENSOR_READ_OVERRIDE_FALSE                    = 0x00000000,
    MEM_EFF_THERM_SENSOR_READ_OVERRIDE_TRUE                     = 0x00000001,
    MEM_EFF_THERM_SENSOR_READ_OVERRIDE_INVALID                  = 0x000000FF,
};

/**
 *  @brief Indicates if the DIMM connected to this controller are in a
 *	planar configuration
 */
enum MEM_MRW_IS_PLANAR
{
    MEM_MRW_IS_PLANAR_FALSE                                     = 0x00000000,
    MEM_MRW_IS_PLANAR_TRUE                                      = 0x00000001,
    MEM_MRW_IS_PLANAR_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Machine Readable Workbook Refresh Rate Desired refresh interval
 *	used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us
 *	(SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us
 *	(DOUBLE_10_PERCENT_FASTER)
 */
enum MSS_MRW_REFRESH_RATE_REQUEST
{
    MSS_MRW_REFRESH_RATE_REQUEST_DOUBLE                         = 0x00000000,
    MSS_MRW_REFRESH_RATE_REQUEST_SINGLE                         = 0x00000001,
    MSS_MRW_REFRESH_RATE_REQUEST_SINGLE_10_PERCENT_FASTER       = 0x00000002,
    MSS_MRW_REFRESH_RATE_REQUEST_DOUBLE_10_PERCENT_FASTER       = 0x00000003,
    MSS_MRW_REFRESH_RATE_REQUEST_INVALID                        = 0x000000FF,
};

/**
 *  @brief Machine Readable Workbook enablement of the HWP code to adjust
 *	the VMEM regulator power limit based on number of installed DIMMs.
 */
enum MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE
{
    MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_FALSE = 0x00000000,
    MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_TRUE = 0x00000001,
    MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_INVALID = 0x000000FF,
};

/**
 *  @brief Used for to determine whether to apply an offset to AVDD.
 *	Supplied by MRW.
 */
enum MSS_MRW_AVDD_OFFSET_ENABLE
{
    MSS_MRW_AVDD_OFFSET_ENABLE_ENABLE                           = 0x00000001,
    MSS_MRW_AVDD_OFFSET_ENABLE_DISABLE                          = 0x00000000,
    MSS_MRW_AVDD_OFFSET_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Used for to determine whether to apply an offset to VDD.
 *	Supplied by MRW.
 */
enum MSS_MRW_VDD_OFFSET_ENABLE
{
    MSS_MRW_VDD_OFFSET_ENABLE_ENABLE                            = 0x00000001,
    MSS_MRW_VDD_OFFSET_ENABLE_DISABLE                           = 0x00000000,
    MSS_MRW_VDD_OFFSET_ENABLE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Used for to determine whether to apply an offset to VCS.
 *	Supplied by MRW.
 */
enum MSS_MRW_VCS_OFFSET_ENABLE
{
    MSS_MRW_VCS_OFFSET_ENABLE_ENABLE                            = 0x00000001,
    MSS_MRW_VCS_OFFSET_ENABLE_DISABLE                           = 0x00000000,
    MSS_MRW_VCS_OFFSET_ENABLE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Used for to determine whether to apply an offset to VCS.
 *	Supplied by MRW.
 */
enum MSS_MRW_VPP_OFFSET_ENABLE
{
    MSS_MRW_VPP_OFFSET_ENABLE_ENABLE                            = 0x00000001,
    MSS_MRW_VPP_OFFSET_ENABLE_DISABLE                           = 0x00000000,
    MSS_MRW_VPP_OFFSET_ENABLE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Used for to determine whether to apply an offset to VDDR.
 *	Supplied by MRW.
 */
enum MSS_MRW_VDDR_OFFSET_ENABLE
{
    MSS_MRW_VDDR_OFFSET_ENABLE_ENABLE                           = 0x00000001,
    MSS_MRW_VDDR_OFFSET_ENABLE_DISABLE                          = 0x00000000,
    MSS_MRW_VDDR_OFFSET_ENABLE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From
 *	JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1 Note:
 *	DDR5 will use either the NORMAL or DDR5_FINE enum values For DDR5,
 *	MR4's settings are set based upon the values of this attribute
 */
enum MSS_MRW_FINE_REFRESH_MODE
{
    MSS_MRW_FINE_REFRESH_MODE_NORMAL                            = 0x00000000,
    MSS_MRW_FINE_REFRESH_MODE_FIXED_2X                          = 0x00000001,
    MSS_MRW_FINE_REFRESH_MODE_FIXED_4X                          = 0x00000002,
    MSS_MRW_FINE_REFRESH_MODE_FLY_2X                            = 0x00000005,
    MSS_MRW_FINE_REFRESH_MODE_FLY_4X                            = 0x00000006,
    MSS_MRW_FINE_REFRESH_MODE_DDR5_FINE                         = 0x00000007,
    MSS_MRW_FINE_REFRESH_MODE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Temperature refresh range. Sets DDR4 MRS4. Should be defaulted
 *	to extended range. NORMAL for running at 85 degrees C or less,
 *	EXTENDED for 95 or less degrees C Used for calculating periodic
 *	refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46
 *	4.8.1
 */
enum MSS_MRW_TEMP_REFRESH_RANGE
{
    MSS_MRW_TEMP_REFRESH_RANGE_NORMAL                           = 0x00000000,
    MSS_MRW_TEMP_REFRESH_RANGE_EXTEND                           = 0x00000001,
    MSS_MRW_TEMP_REFRESH_RANGE_INVALID                          = 0x000000FF,
};

/**
 *  @brief For resetting the phy delay values at the beginning of calling
 *	mss_draminit_training. YES means the vaules will be reset.
 */
enum MSS_MRW_RESET_DELAY_BEFORE_CAL
{
    MSS_MRW_RESET_DELAY_BEFORE_CAL_YES                          = 0x00000000,
    MSS_MRW_RESET_DELAY_BEFORE_CAL_NO                           = 0x00000001,
    MSS_MRW_RESET_DELAY_BEFORE_CAL_INVALID                      = 0x000000FF,
};

/**
 *  @brief Allows user to manually turn on and off 2N Mode. AUTO indicates
 *	to use Signal Integrity generated setting (from VPD).
 */
enum MSS_MRW_DRAM_2N_MODE
{
    MSS_MRW_DRAM_2N_MODE_AUTO                                   = 0x00000000,
    MSS_MRW_DRAM_2N_MODE_FORCE_TO_1N_MODE                       = 0x00000001,
    MSS_MRW_DRAM_2N_MODE_FORCE_TO_2N_MODE                       = 0x00000002,
    MSS_MRW_DRAM_2N_MODE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enables DRAM Write CRC
 */
enum MSS_MRW_DRAM_WRITE_CRC
{
    MSS_MRW_DRAM_WRITE_CRC_DISABLE                              = 0x00000000,
    MSS_MRW_DRAM_WRITE_CRC_ENABLE                               = 0x00000001,
    MSS_MRW_DRAM_WRITE_CRC_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enables DRAM Read CRC
 */
enum MSS_MRW_DDR5_DRAM_READ_CRC
{
    MSS_MRW_DDR5_DRAM_READ_CRC_DISABLE                          = 0x00000000,
    MSS_MRW_DDR5_DRAM_READ_CRC_ENABLE                           = 0x00000001,
    MSS_MRW_DDR5_DRAM_READ_CRC_INVALID                          = 0x000000FF,
};

/**
 *  @brief An override switch to shut off broadcast mode Enum values: YES:
 *	broadcast mode is forced off NO: broadcast mode uses the default
 *	value
 */
enum MSS_MRW_FORCE_BCMODE_OFF
{
    MSS_MRW_FORCE_BCMODE_OFF_NO                                 = 0x00000000,
    MSS_MRW_FORCE_BCMODE_OFF_YES                                = 0x00000001,
    MSS_MRW_FORCE_BCMODE_OFF_INVALID                            = 0x000000FF,
};

/**
 *  @brief A bitmap containing the plug rules for NVDIMM. 1 if a DIMM
 *	supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0
 *	is the left most bit The index to the bitmap is the position of the
 *	DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM
 *	plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit
 *	number to account for 16 DIMM per processor if there is ever a 4
 *	processor system
 */
enum MSS_MRW_NVDIMM_PLUG_RULES
{
    MSS_MRW_NVDIMM_PLUG_RULES_NO_NVDIMM                         = 0x00000000,
    MSS_MRW_NVDIMM_PLUG_RULES_NVDIMM_CAPABLE                    = 0x00000001,
    MSS_MRW_NVDIMM_PLUG_RULES_INVALID                           = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief Switch that allows unsupported raw card references by providing
 *	a default raw card setting.
 */
enum MSS_MRW_ALLOW_UNSUPPORTED_RCW
{
    MSS_MRW_ALLOW_UNSUPPORTED_RCW_DISABLE                       = 0x00000000,
    MSS_MRW_ALLOW_UNSUPPORTED_RCW_ENABLE                        = 0x00000001,
    MSS_MRW_ALLOW_UNSUPPORTED_RCW_INVALID                       = 0x000000FF,
};

/**
 *  @brief Bitmap of DRAM widths supported by a system. A 1 indicates that
 *	the system supports a density. Enums below represent the the bit
 *	location in the attribute for a given DRAM width. Default value is
 *	0xC -> both x4/x8 supported
 */
enum MSS_MRW_SUPPORTED_DRAM_WIDTH
{
    MSS_MRW_SUPPORTED_DRAM_WIDTH_X4                             = 0x00000000,
    MSS_MRW_SUPPORTED_DRAM_WIDTH_X8                             = 0x00000001,
    MSS_MRW_SUPPORTED_DRAM_WIDTH_INVALID                        = 0x000000FF,
};

/**
 *  @brief Machine Readable Workbook value to describe the airflow past
 *	DIMM slots. Facing the front of the DIMM, the airflow is described
 *	as either RIGHT_TO_LEFT or LEFT_TO_RIGHT using the attribute enums.
 *	Note that the enum values here map to the left/right sensor
 *	locations in the DDIMM SPD.
 */
enum MSS_MRW_DIMM_SLOT_AIRFLOW
{
    MSS_MRW_DIMM_SLOT_AIRFLOW_RIGHT_TO_LEFT                     = 0x00000000,
    MSS_MRW_DIMM_SLOT_AIRFLOW_LEFT_TO_RIGHT                     = 0x00000001,
    MSS_MRW_DIMM_SLOT_AIRFLOW_INVALID                           = 0x000000FF,
};

/**
 *  @brief System specific DIMM height mixing plug rule
 */
enum MSS_MRW_DIMM_HEIGHT_MIXING_POLICY
{
    MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_NOT_ALLOWED               = 0x00000000,
    MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_ALLOWED                   = 0x00000001,
    MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_INVALID                   = 0x000000FF,
};

/**
 *  @brief List of memory frequencies supported by the current system.
 */
enum MSS_MRW_SUPPORTED_FREQ
{
    MSS_MRW_SUPPORTED_FREQ_MT1866                               = 0x0000074A,
    MSS_MRW_SUPPORTED_FREQ_MT2133                               = 0x00000855,
    MSS_MRW_SUPPORTED_FREQ_MT2400                               = 0x00000960,
    MSS_MRW_SUPPORTED_FREQ_MT2666                               = 0x00000A6A,
    MSS_MRW_SUPPORTED_FREQ_MT2933                               = 0x00000B75,
    MSS_MRW_SUPPORTED_FREQ_MT3200                               = 0x00000C80,
    MSS_MRW_SUPPORTED_FREQ_INVALID                              = 0xFFFFFFFF,
};

/**
 *  @brief Set to ENABLED to activate a workaround for 4U DDIMMs to set
 *	thermal sensor usage from DRAM to DRAM_AND_MEM_BUF_EXT, and from
 *	PMIC to MEM_BUF_EXT. Affects power management subsystem fan speed
 *	controls.
 */
enum MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE
{
    MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_DISABLED                = 0x00000000,
    MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_ENABLED                 = 0x00000001,
    MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_INVALID                 = 0x000000FF,
};

/**
 *  @brief Used for to determine if DDR5 is supported by this system.
 */
enum MSS_MRW_ALLOW_DDR5
{
    MSS_MRW_ALLOW_DDR5_ALLOW                                    = 0x00000001,
    MSS_MRW_ALLOW_DDR5_REJECT                                   = 0x00000000,
    MSS_MRW_ALLOW_DDR5_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Used for setting maximum system frequency based on each OCMB.
 */
enum MRW_MAX_DDR_FREQ_PER_SLOT
{
    MRW_MAX_DDR_FREQ_PER_SLOT_FREQ_3200                         = 0x00000C80,
    MRW_MAX_DDR_FREQ_PER_SLOT_FREQ_4000                         = 0x00000FA0,
    MRW_MAX_DDR_FREQ_PER_SLOT_FREQ_4800                         = 0x000012C0,
    MRW_MAX_DDR_FREQ_PER_SLOT_INVALID                           = 0x0000FFFF,
};

/**
 *  @brief [Channel] ATX Slew Rate and Drive Strength Pull-Up / Pull-Down
 *	for AC Determines CsrAtXSrc, ADrvStrenP, and ADrvStrenN settings in
 *	Address/Command ANIBs (CH0)1,2,3,4 and (CH1)9,10,11,12
 */
enum MEM_EFF_DDR5_TX_SLEW_RISE_AC
{
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_10_SLOW_MODERATE           = 0x00000001,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_10_FAST                    = 0x00000002,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_15_SLOW                    = 0x00000003,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_15_MODERATE                = 0x00000005,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_15_FAST                    = 0x00000006,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_20_SLOW                    = 0x00000007,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_20_MODERATE_FAST           = 0x00000008,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_24                         = 0x00000009,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_OHM_30                         = 0x0000000A,
    MEM_EFF_DDR5_TX_SLEW_RISE_AC_INVALID                        = 0x000000FF,
};

/**
 *  @brief [Channel] ATX Slew Rate and Drive Strength Pull-Up / Pull-Down
 *	for CS Determines CsrAtXSrc, ADrvStrenP, and ADrvStrenN settings in
 *	CS ANIBs (CH0)0 and (CH1)13
 */
enum MEM_EFF_DDR5_TX_SLEW_FALL_AC
{
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_10_SLOW_MODERATE           = 0x00000001,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_10_FAST                    = 0x00000002,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_15_SLOW                    = 0x00000003,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_15_MODERATE                = 0x00000005,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_15_FAST                    = 0x00000006,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_20_SLOW                    = 0x00000007,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_20_MODERATE_FAST           = 0x00000008,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_24                         = 0x00000009,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_OHM_30                         = 0x0000000A,
    MEM_EFF_DDR5_TX_SLEW_FALL_AC_INVALID                        = 0x000000FF,
};

/**
 *  @brief [Channel] ATX Slew Rate and Drive Strength Pull-Up / Pull-Down
 *	for CK Determines CsrAtXSrc, ADrvStrenP, and ADrvStrenN settings in
 *	CK ANIBs (CH0)5,7 and (CH1)6,8
 */
enum MEM_EFF_DDR5_TX_SLEW_RISE_CK
{
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_10_SLOW_MODERATE           = 0x00000001,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_10_FAST                    = 0x00000002,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_15_SLOW_MODERATE           = 0x00000004,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_15_FAST                    = 0x00000006,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_20_SLOW                    = 0x00000007,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_20_MODERATE_FAST           = 0x00000008,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_24                         = 0x00000009,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_OHM_30                         = 0x0000000A,
    MEM_EFF_DDR5_TX_SLEW_RISE_CK_INVALID                        = 0x000000FF,
};

/**
 *  @brief Control the length of DDR5 write DQ preamble for U0
 *	EnTxDqPreamblePatternU0 in phyinit struct
 */
enum DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0
{
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_TCK0                      = 0x00000000,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_TCK1                      = 0x00000001,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_TCK2                      = 0x00000003,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_TCK3                      = 0x00000007,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_TCK4                      = 0x0000000F,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_INVALID                   = 0x000000FF,
};

/**
 *  @brief Control the length of DDR5 write DQ preamble for U1
 *	EnTxDqPreamblePatternU1 in phyinit struct
 */
enum DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1
{
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_TCK0                      = 0x00000000,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_TCK1                      = 0x00000001,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_TCK2                      = 0x00000003,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_TCK3                      = 0x00000007,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_TCK4                      = 0x0000000F,
    DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_INVALID                   = 0x000000FF,
};

/**
 *  @brief Control the length of DDR5 write DM preamble
 *	EnTxDmPreamblePattern in phyinit struct
 */
enum DDR5_EN_TX_DM_PREAMBLE_PATTERN
{
    DDR5_EN_TX_DM_PREAMBLE_PATTERN_TCK0                         = 0x00000000,
    DDR5_EN_TX_DM_PREAMBLE_PATTERN_TCK1                         = 0x00000001,
    DDR5_EN_TX_DM_PREAMBLE_PATTERN_TCK2                         = 0x00000003,
    DDR5_EN_TX_DM_PREAMBLE_PATTERN_TCK3                         = 0x00000007,
    DDR5_EN_TX_DM_PREAMBLE_PATTERN_TCK4                         = 0x0000000F,
    DDR5_EN_TX_DM_PREAMBLE_PATTERN_INVALID                      = 0x000000FF,
};

/**
 *  @brief Rank0 DRAM will be half driven by CS0 and CS2. Rank1 DRAM will
 *	be half driven by CS1 and CS3.
 */
enum MEM_EFF_REDUNDANT_CS_EN
{
    MEM_EFF_REDUNDANT_CS_EN_DISABLE                             = 0x00000000,
    MEM_EFF_REDUNDANT_CS_EN_ENABLE                              = 0x00000001,
    MEM_EFF_REDUNDANT_CS_EN_INVALID                             = 0x000000FF,
};

/**
 *  @brief Byte 235 - Enabled Phys and channels is based on mem ports per
 *	ocmb target
 */
enum MEM_EFF_DDR5_MEM_PORT_ENABLE
{
    MEM_EFF_DDR5_MEM_PORT_ENABLE_NOT_EN                         = 0x00000000,
    MEM_EFF_DDR5_MEM_PORT_ENABLE_PORT0_EN                       = 0x00000001,
    MEM_EFF_DDR5_MEM_PORT_ENABLE_PORT1_EN                       = 0x00000002,
    MEM_EFF_DDR5_MEM_PORT_ENABLE_BOTH_EN                        = 0x00000003,
    MEM_EFF_DDR5_MEM_PORT_ENABLE_INVALID                        = 0x000000FF,
};

/**
 *  @brief Byte 235 - Bus Width for Channels A and B ARRAY[CHANNEL]
 */
enum MEM_EFF_DDR5_CHANNEL_BUS_WIDTH
{
    MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_NOT_USED                     = 0x00000000,
    MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_32_BITS                      = 0x00000020,
    MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_36_BITS                      = 0x00000024,
    MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_40_BITS                      = 0x00000028,
    MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_INVALID                      = 0x000000FF,
};

/**
 *  @brief Enable Explorer upstream transmit template 1. Should be disabled
 *	by default.
 */
enum EXPLR_ENABLE_US_TMPL_1
{
    EXPLR_ENABLE_US_TMPL_1_DISABLED                             = 0x00000000,
    EXPLR_ENABLE_US_TMPL_1_ENABLED                              = 0x00000001,
    EXPLR_ENABLE_US_TMPL_1_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enable Explorer upstream transmit template 5. Should be enabled
 *	by default.
 */
enum EXPLR_ENABLE_US_TMPL_5
{
    EXPLR_ENABLE_US_TMPL_5_DISABLED                             = 0x00000000,
    EXPLR_ENABLE_US_TMPL_5_ENABLED                              = 0x00000001,
    EXPLR_ENABLE_US_TMPL_5_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enable Explorer upstream transmit template 9. Should be enabled
 *	by default.
 */
enum EXPLR_ENABLE_US_TMPL_9
{
    EXPLR_ENABLE_US_TMPL_9_DISABLED                             = 0x00000000,
    EXPLR_ENABLE_US_TMPL_9_ENABLED                              = 0x00000001,
    EXPLR_ENABLE_US_TMPL_9_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enable Explorer upstream transmit template A. Not supported by
 *	Axone
 */
enum EXPLR_ENABLE_US_TMPL_A
{
    EXPLR_ENABLE_US_TMPL_A_DISABLED                             = 0x00000000,
    EXPLR_ENABLE_US_TMPL_A_ENABLED                              = 0x00000001,
    EXPLR_ENABLE_US_TMPL_A_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enable Explorer upstream transmit template B. Not supported by
 *	Axone
 */
enum EXPLR_ENABLE_US_TMPL_B
{
    EXPLR_ENABLE_US_TMPL_B_DISABLED                             = 0x00000000,
    EXPLR_ENABLE_US_TMPL_B_ENABLED                              = 0x00000001,
    EXPLR_ENABLE_US_TMPL_B_INVALID                              = 0x000000FF,
};

/**
 *  @brief Indicates whether the OCMB can support enterprise mode or if it
 *	has been fused to only support non-enterprise mode. Note: needs to
 *	be setup by the get ECID functionality
 */
enum MSS_OCMB_ENTERPRISE_MODE
{
    MSS_OCMB_ENTERPRISE_MODE_NON_ENTERPRISE                     = 0x00000000,
    MSS_OCMB_ENTERPRISE_MODE_ENTERPRISE                         = 0x00000001,
    MSS_OCMB_ENTERPRISE_MODE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Indicates whether the OCMB is allowed to run in enterprise mode,
 *	commodity mode, or either. ALLOW_ENTERPRISE = Most permissive, uses
 *	whatever is installed in the way it is intended to be used.
 *	REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that
 *	are installed. FORCE_NONENTERPRISE = Throws an error for any
 *	enterprise dimms that are installed.
 */
enum MSS_OCMB_ENTERPRISE_POLICY
{
    MSS_OCMB_ENTERPRISE_POLICY_ALLOW_ENTERPRISE                 = 0x00000000,
    MSS_OCMB_ENTERPRISE_POLICY_REQUIRE_ENTERPRISE               = 0x00000001,
    MSS_OCMB_ENTERPRISE_POLICY_FORCE_NONENTERPRISE              = 0x00000002,
    MSS_OCMB_ENTERPRISE_POLICY_INVALID                          = 0x000000FF,
};

/**
 *  @brief An override to allow an enterprise capable DIMM to be run in
 *	non-enterprise mode. Defaults to NO_OVERRIDE
 */
enum MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE
{
    MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_NO_OVERRIDE            = 0x00000000,
    MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_OVERRIDE_NON_ENTERPRISE = 0x00000001,
    MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_INVALID                = 0x000000FF,
};

/**
 *  @brief Contains the settings for write/read reorder queue
 */
enum MSS_EXP_REORDER_QUEUE_SETTING
{
    MSS_EXP_REORDER_QUEUE_SETTING_REORDER                       = 0x00000000,
    MSS_EXP_REORDER_QUEUE_SETTING_FIFO                          = 0x00000001,
    MSS_EXP_REORDER_QUEUE_SETTING_INVALID                       = 0x000000FF,
};

/**
 *  @brief Enable Special mode for Emulation Support
 */
enum MEM_EXP_FIRMWARE_EMULATION_MODE
{
    MEM_EXP_FIRMWARE_EMULATION_MODE_NORMAL                      = 0x00000000,
    MEM_EXP_FIRMWARE_EMULATION_MODE_EMULATION                   = 0x00000001,
    MEM_EXP_FIRMWARE_EMULATION_MODE_INVALID                     = 0x000000FF,
};

/**
 *  @brief Controls whether or not transaction bytes are swapped before and
 *	after mmio accesses to the buffer.
 */
enum MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL
{
    MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_SWAP                   = 0x00000000,
    MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_NO_SWAP                = 0x00000001,
    MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_INVALID                = 0x000000FF,
};

/**
 *  @brief Controls whether the structure fields written and read to and
 *	from the buffer are big or little endian.
 */
enum MSS_OCMB_EXP_STRUCT_ENDIAN
{
    MSS_OCMB_EXP_STRUCT_ENDIAN_BIG_ENDIAN                       = 0x00000000,
    MSS_OCMB_EXP_STRUCT_ENDIAN_LITTLE_ENDIAN                    = 0x00000001,
    MSS_OCMB_EXP_STRUCT_ENDIAN_INVALID                          = 0x000000FF,
};

/**
 *  @brief Controls whether or not the first and second half of MMIO
 *	transactions are swapped before and after mmio accesses to the
 *	buffer.
 */
enum MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP
{
    MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_SWAP                     = 0x00000000,
    MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_NO_SWAP                  = 0x00000001,
    MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_INVALID                  = 0x000000FF,
};

/**
 *  @brief Mode for PHY initialization.
 */
enum MSS_OCMB_PHY_INIT_MODE
{
    MSS_OCMB_PHY_INIT_MODE_NORMAL                               = 0x00000000,
    MSS_OCMB_PHY_INIT_MODE_WITH_EYE_CAPTURE                     = 0x00000001,
    MSS_OCMB_PHY_INIT_MODE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Flag to disable exp_mss_thermal_init interval read command
 */
enum MSS_OCMB_DISABLE_THERM_INIT_READ
{
    MSS_OCMB_DISABLE_THERM_INIT_READ_ENABLED                    = 0x00000000,
    MSS_OCMB_DISABLE_THERM_INIT_READ_DISABLED                   = 0x00000001,
    MSS_OCMB_DISABLE_THERM_INIT_READ_INVALID                    = 0x000000FF,
};

/**
 *  @brief ID of Explorer partition that firmware was booted from
 */
enum MSS_EXP_FW_PARTITION_ID
{
    MSS_EXP_FW_PARTITION_ID_A                                   = 0x00000041,
    MSS_EXP_FW_PARTITION_ID_B                                   = 0x00000042,
    MSS_EXP_FW_PARTITION_ID_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Can be used by general procedure code to determine
 *	sideband/inband mode, etc.
 */
enum MSS_EXP_COMM_STATE
{
    MSS_EXP_COMM_STATE_NO_I2C                                   = 0x00000000,
    MSS_EXP_COMM_STATE_I2C_NO_SCOM                              = 0x00000001,
    MSS_EXP_COMM_STATE_I2C_WITH_SCOM                            = 0x00000002,
    MSS_EXP_COMM_STATE_INBAND                                   = 0x00000003,
    MSS_EXP_COMM_STATE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Read Burst Type from DDR4 DRAM Spec This is for DDR4 MRS0. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_RBT
{
    MSS_EXP_RESP_DRAM_RBT_SEQUENTIAL                            = 0x00000000,
    MSS_EXP_RESP_DRAM_RBT_INTERLEAVE                            = 0x00000001,
    MSS_EXP_RESP_DRAM_RBT_INVALID                               = 0x000000FF,
};

/**
 *  @brief Test Mode from DDR4 DRAM Spec This is for DDR4 MRS0. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_TM
{
    MSS_EXP_RESP_DRAM_TM_NORMAL                                 = 0x00000000,
    MSS_EXP_RESP_DRAM_TM_TEST                                   = 0x00000001,
    MSS_EXP_RESP_DRAM_TM_INVALID                                = 0x000000FF,
};

/**
 *  @brief DLL Reset from DDR4 DRAM Spec This is for DDR4 MRS0. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_DLL_RESET
{
    MSS_EXP_RESP_DRAM_DLL_RESET_NO                              = 0x00000000,
    MSS_EXP_RESP_DRAM_DLL_RESET_YES                             = 0x00000001,
    MSS_EXP_RESP_DRAM_DLL_RESET_INVALID                         = 0x000000FF,
};

/**
 *  @brief DLL Reset from DDR4 DRAM Spec This is for DDR4 MRS0. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_BURST_LENGTH
{
    MSS_EXP_RESP_DRAM_BURST_LENGTH_FIXED8                       = 0x00000000,
    MSS_EXP_RESP_DRAM_BURST_LENGTH_ON_THE_FLY                   = 0x00000001,
    MSS_EXP_RESP_DRAM_BURST_LENGTH_BC4                          = 0x00000002,
    MSS_EXP_RESP_DRAM_BURST_LENGTH_RESERVED                     = 0x00000003,
    MSS_EXP_RESP_DRAM_BURST_LENGTH_INVALID                      = 0x000000FF,
};

/**
 *  @brief DLL Enable from DDR4 DRAM Spec This is for DDR4 MRS1. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_DLL_ENABLE
{
    MSS_EXP_RESP_DRAM_DLL_ENABLE_ENABLE                         = 0x00000001,
    MSS_EXP_RESP_DRAM_DLL_ENABLE_DISABLE                        = 0x00000000,
    MSS_EXP_RESP_DRAM_DLL_ENABLE_INVALID                        = 0x000000FF,
};

/**
 *  @brief DRAM output driver impedance control from DDR4 DRAM Spec This is
 *	for DDR4 MRS1. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_ODIC
{
    MSS_EXP_RESP_DRAM_ODIC_RZQ5                                 = 0x00000001,
    MSS_EXP_RESP_DRAM_ODIC_RZQ7                                 = 0x00000000,
    MSS_EXP_RESP_DRAM_ODIC_INVALID                              = 0x000000FF,
};

/**
 *  @brief Additive Latency from DDR4 DRAM Spec This is for DDR4 MRS1. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_AL
{
    MSS_EXP_RESP_DRAM_AL_DISABLE                                = 0x00000000,
    MSS_EXP_RESP_DRAM_AL_CL_MINUS_1                             = 0x00000001,
    MSS_EXP_RESP_DRAM_AL_CL_MINUS_2                             = 0x00000002,
    MSS_EXP_RESP_DRAM_AL_INVALID                                = 0x000000FF,
};

/**
 *  @brief Write Level Enable from DDR4 DRAM Spec This is for DDR4 MRS1.
 *	From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_WR_LVL_ENABLE
{
    MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_DISABLE                     = 0x00000000,
    MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_ENABLE                      = 0x00000001,
    MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_INVALID                     = 0x000000FF,
};

/**
 *  @brief TDQS from DDR4 DRAM Spec This is for DDR4 MRS1. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_TDQS
{
    MSS_EXP_RESP_DRAM_TDQS_DISABLE                              = 0x00000000,
    MSS_EXP_RESP_DRAM_TDQS_ENABLE                               = 0x00000001,
    MSS_EXP_RESP_DRAM_TDQS_INVALID                              = 0x000000FF,
};

/**
 *  @brief DRAM Qoff from DDR4 DRAM Spec Enables or disables DRAM output.
 *	This is for DDR4 MRS1. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_OUTPUT_BUFFER
{
    MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_DISABLE                     = 0x00000001,
    MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_ENABLE                      = 0x00000000,
    MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_INVALID                     = 0x000000FF,
};

/**
 *  @brief Low Power Auto Self-Refresh from DDR4 DRAM Spec This is for DDR4
 *	MRS2. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_LPASR
{
    MSS_EXP_RESP_DRAM_LPASR_MANUAL_NORMAL                       = 0x00000000,
    MSS_EXP_RESP_DRAM_LPASR_MANUAL_REDUCED                      = 0x00000001,
    MSS_EXP_RESP_DRAM_LPASR_MANUAL_EXTENDED                     = 0x00000002,
    MSS_EXP_RESP_DRAM_LPASR_ASR                                 = 0x00000003,
    MSS_EXP_RESP_DRAM_LPASR_INVALID                             = 0x000000FF,
};

/**
 *  @brief RTT_WR value from DDR4 DRAM Spec This is for DDR4 MRS2. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DRAM_RTT_WR
{
    MSS_EXP_RESP_DRAM_RTT_WR_DYNAMIC_ODT_OFF                    = 0x00000000,
    MSS_EXP_RESP_DRAM_RTT_WR_RZQ2                               = 0x00000001,
    MSS_EXP_RESP_DRAM_RTT_WR_RZQ1                               = 0x00000002,
    MSS_EXP_RESP_DRAM_RTT_WR_HIZ                                = 0x00000003,
    MSS_EXP_RESP_DRAM_RTT_WR_RZQ3                               = 0x00000004,
    MSS_EXP_RESP_DRAM_RTT_WR_INVALID                            = 0x000000FF,
};

/**
 *  @brief MPR Page Selection from DDR4 DRAM Spec. This is for DDR4 MRS3.
 *	From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_MPR_PAGE
{
    MSS_EXP_RESP_MPR_PAGE_PG0                                   = 0x00000000,
    MSS_EXP_RESP_MPR_PAGE_PG1                                   = 0x00000001,
    MSS_EXP_RESP_MPR_PAGE_PG2                                   = 0x00000002,
    MSS_EXP_RESP_MPR_PAGE_PG3                                   = 0x00000003,
    MSS_EXP_RESP_MPR_PAGE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Multi Purpose Register Mode from DDR4 DRAM Spec This is for DDR4
 *	MRS3. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_MPR_MODE
{
    MSS_EXP_RESP_MPR_MODE_DISABLE                               = 0x00000000,
    MSS_EXP_RESP_MPR_MODE_ENABLE                                = 0x00000001,
    MSS_EXP_RESP_MPR_MODE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Gear Down Mode from DDR4 DRAM Spec. This is for DDR4 MRS3. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_GEARDOWN_MODE
{
    MSS_EXP_RESP_GEARDOWN_MODE_HALF                             = 0x00000000,
    MSS_EXP_RESP_GEARDOWN_MODE_QUARTER                          = 0x00000001,
    MSS_EXP_RESP_GEARDOWN_MODE_INVALID                          = 0x000000FF,
};

/**
 *  @brief Per DRAM accessibility from DDR4 DRAM Spec This is for DDR4
 *	MRS3. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_PER_DRAM_ACCESS
{
    MSS_EXP_RESP_PER_DRAM_ACCESS_DISABLE                        = 0x00000000,
    MSS_EXP_RESP_PER_DRAM_ACCESS_ENABLE                         = 0x00000001,
    MSS_EXP_RESP_PER_DRAM_ACCESS_INVALID                        = 0x000000FF,
};

/**
 *  @brief Temperature sensor readout from DDR4 DRAM Spec. This is for DDR4
 *	MRS3. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_TEMP_READOUT
{
    MSS_EXP_RESP_TEMP_READOUT_DISABLE                           = 0x00000000,
    MSS_EXP_RESP_TEMP_READOUT_ENABLE                            = 0x00000001,
    MSS_EXP_RESP_TEMP_READOUT_INVALID                           = 0x000000FF,
};

/**
 *  @brief Write latency for CRC and DM from DDR4 DRAM Spec. This is for
 *	DDR4 MRS3. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_CRC_WR_LATENCY
{
    MSS_EXP_RESP_CRC_WR_LATENCY_4NCK                            = 0x00000004,
    MSS_EXP_RESP_CRC_WR_LATENCY_5NCK                            = 0x00000005,
    MSS_EXP_RESP_CRC_WR_LATENCY_6NCK                            = 0x00000006,
    MSS_EXP_RESP_CRC_WR_LATENCY_INVALID                         = 0x000000FF,
};

/**
 *  @brief MPR READ FORMAT from DDR4 DRAM Spec. This is for DDR4 MRS3. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_MPR_RD_FORMAT
{
    MSS_EXP_RESP_MPR_RD_FORMAT_SERIAL                           = 0x00000000,
    MSS_EXP_RESP_MPR_RD_FORMAT_PARALLEL                         = 0x00000001,
    MSS_EXP_RESP_MPR_RD_FORMAT_STAGGERED                        = 0x00000002,
    MSS_EXP_RESP_MPR_RD_FORMAT_INVALID                          = 0x000000FF,
};

/**
 *  @brief Max Power down mode from DDR4 DRAM Spec. This is for DDR4 MRS4.
 *	From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_MAX_POWERDOWN_MODE
{
    MSS_EXP_RESP_MAX_POWERDOWN_MODE_DISABLE                     = 0x00000000,
    MSS_EXP_RESP_MAX_POWERDOWN_MODE_ENABLE                      = 0x00000001,
    MSS_EXP_RESP_MAX_POWERDOWN_MODE_INVALID                     = 0x000000FF,
};

/**
 *  @brief Internal Vref Monitor from DDR4 DRAM Spec. This is for DDR4
 *	MRS4. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_INTERNAL_VREF_MONITOR
{
    MSS_EXP_RESP_INTERNAL_VREF_MONITOR_DISABLE                  = 0x00000000,
    MSS_EXP_RESP_INTERNAL_VREF_MONITOR_ENABLE                   = 0x00000001,
    MSS_EXP_RESP_INTERNAL_VREF_MONITOR_INVALID                  = 0x000000FF,
};

/**
 *  @brief Self Refresh Abort from DDR4 DRAM Spec. This is for DDR4 MRS4.
 *	From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_SELF_REF_ABORT
{
    MSS_EXP_RESP_SELF_REF_ABORT_DISABLE                         = 0x00000000,
    MSS_EXP_RESP_SELF_REF_ABORT_ENABLE                          = 0x00000001,
    MSS_EXP_RESP_SELF_REF_ABORT_INVALID                         = 0x000000FF,
};

/**
 *  @brief Read Pre amble Training Mode from DDR4 DRAM Spec. This is for
 *	DDR4 MRS4. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_RD_PREAMBLE_TRAIN
{
    MSS_EXP_RESP_RD_PREAMBLE_TRAIN_DISABLE                      = 0x00000000,
    MSS_EXP_RESP_RD_PREAMBLE_TRAIN_ENABLE                       = 0x00000001,
    MSS_EXP_RESP_RD_PREAMBLE_TRAIN_INVALID                      = 0x000000FF,
};

/**
 *  @brief Read Pre amble Mode from DDR4 DRAM Spec. This is for DDR4 MRS4.
 *	From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_RD_PREAMBLE
{
    MSS_EXP_RESP_RD_PREAMBLE_1NCLK                              = 0x00000000,
    MSS_EXP_RESP_RD_PREAMBLE_2NCLK                              = 0x00000001,
    MSS_EXP_RESP_RD_PREAMBLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Write Pre amble Mode from DDR4 DRAM Spec. This is for DDR4 MRS4.
 *	From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_WR_PREAMBLE
{
    MSS_EXP_RESP_WR_PREAMBLE_1NCLK                              = 0x00000000,
    MSS_EXP_RESP_WR_PREAMBLE_2NCLK                              = 0x00000001,
    MSS_EXP_RESP_WR_PREAMBLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief CRC Error Clear from DDR4 DRAM Spec. This is for DDR4 MRS5. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_CRC_ERROR_CLEAR
{
    MSS_EXP_RESP_CRC_ERROR_CLEAR_CLEAR                          = 0x00000000,
    MSS_EXP_RESP_CRC_ERROR_CLEAR_ERROR                          = 0x00000001,
    MSS_EXP_RESP_CRC_ERROR_CLEAR_INVALID                        = 0x000000FF,
};

/**
 *  @brief C/A Parity Error Status from DDR4 DRAM Spec. This is for DDR4
 *	MRS5. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_CA_PARITY_ERROR_STATUS
{
    MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_CLEAR                   = 0x00000000,
    MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_ERROR                   = 0x00000001,
    MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_INVALID                 = 0x000000FF,
};

/**
 *  @brief ODT Input Buffer during power down from DDR4 DRAM Spec. This is
 *	for DDR4 MRS5. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_ODT_INPUT_BUFF
{
    MSS_EXP_RESP_ODT_INPUT_BUFF_ACTIVATED                       = 0x00000000,
    MSS_EXP_RESP_ODT_INPUT_BUFF_DEACTIVATED                     = 0x00000001,
    MSS_EXP_RESP_ODT_INPUT_BUFF_INVALID                         = 0x000000FF,
};

/**
 *  @brief CA Parity Persistance Error from DDR4 DRAM Spec. This is for
 *	DDR4 MRS5. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_CA_PARITY
{
    MSS_EXP_RESP_CA_PARITY_DISABLE                              = 0x00000000,
    MSS_EXP_RESP_CA_PARITY_ENABLE                               = 0x00000001,
    MSS_EXP_RESP_CA_PARITY_INVALID                              = 0x000000FF,
};

/**
 *  @brief Data Mask from DDR4 DRAM Spec. This is for DDR4 MRS5. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_DATA_MASK
{
    MSS_EXP_RESP_DATA_MASK_DISABLE                              = 0x00000000,
    MSS_EXP_RESP_DATA_MASK_ENABLE                               = 0x00000001,
    MSS_EXP_RESP_DATA_MASK_INVALID                              = 0x000000FF,
};

/**
 *  @brief Write DBI from DDR4 DRAM Spec. This is for DDR4 MRS5. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_WRITE_DBI
{
    MSS_EXP_RESP_WRITE_DBI_DISABLE                              = 0x00000000,
    MSS_EXP_RESP_WRITE_DBI_ENABLE                               = 0x00000001,
    MSS_EXP_RESP_WRITE_DBI_INVALID                              = 0x000000FF,
};

/**
 *  @brief Read DBI from DDR4 DRAM Spec. This is for DDR4 MRS5. From
 *	user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_READ_DBI
{
    MSS_EXP_RESP_READ_DBI_DISABLE                               = 0x00000000,
    MSS_EXP_RESP_READ_DBI_ENABLE                                = 0x00000001,
    MSS_EXP_RESP_READ_DBI_INVALID                               = 0x000000FF,
};

/**
 *  @brief VrefDQ Training Range from DDR4 DRAM Spec. This is for DDR4
 *	MRS6. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE
{
    MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_RANGE1                     = 0x00000000,
    MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_RANGE2                     = 0x00000001,
    MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_INVALID                    = 0x000000FF,
};

/**
 *  @brief VrefDQ Training Value from DDR4 DRAM Spec. This is for DDR4
 *	MRS6. From user_response_mrs_msdg_t in draminit.
 */
enum MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE
{
    MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_DISABLE                   = 0x00000000,
    MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_ENABLE                    = 0x00000001,
    MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_INVALID                   = 0x000000FF,
};

/**
 *  @brief This enables the override to the Explroer CDR bandwidth, to the
 *	value specified by ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE. (Deprecated.
 *	Use ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE instead.)
 */
enum MSS_EXP_CDR_BW_OVERRIDE_ENABLE
{
    MSS_EXP_CDR_BW_OVERRIDE_ENABLE_DISABLE                      = 0x00000000,
    MSS_EXP_CDR_BW_OVERRIDE_ENABLE_ENABLE                       = 0x00000001,
    MSS_EXP_CDR_BW_OVERRIDE_ENABLE_INVALID                      = 0x000000FF,
};

/**
 *  @brief Value for the Explorer CDR Bandwidth to be applied before
 *	BOOT_CONFIG0 command.
 */
enum MSS_EXP_OMI_CDR_BW_OVERRIDE
{
    MSS_EXP_OMI_CDR_BW_OVERRIDE_DEFAULT                         = 0x00000000,
    MSS_EXP_OMI_CDR_BW_OVERRIDE_INVALID                         = 0x000000FF,
};

/**
 *  @brief This is a lab override attribute to disable masking Explorer FIR
 *	interrupts during OMI training. Disabling this can work around scom
 *	fails caused by older FW versions not including the register
 *	0x08040017
 */
enum MSS_EXP_INTR_MASK_DISABLE
{
    MSS_EXP_INTR_MASK_DISABLE_ENABLE                            = 0x00000000,
    MSS_EXP_INTR_MASK_DISABLE_DISABLE                           = 0x00000001,
    MSS_EXP_INTR_MASK_DISABLE_INVALID                           = 0x000000FF,
};

/**
 *  @brief This is a lab override attribute to disable dumping Explorer
 *	firmware logs via i2c in FFDC handling. Dumping out logs using this
 *	method is destructive, i.e. the logs get cleared, so they will not
 *	be accessible via lab tool after the initial FFDC dump. FFDC may
 *	not be able to store the entire log so setting this could be
 *	necessary in a lab setting.
 */
enum MSS_EXP_I2C_FW_LOG_DUMP_DISABLE
{
    MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_ENABLE                      = 0x00000000,
    MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_DISABLE                     = 0x00000001,
    MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_INVALID                     = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] A-Side CA bus drives rank 0/1 and B-Side CA bus
 *	drives rank 2/3, DQ/DQS are shared across the ranks
 */
enum MEM_EFF_FOUR_RANK_MODE
{
    MEM_EFF_FOUR_RANK_MODE_DISABLE                              = 0x00000000,
    MEM_EFF_FOUR_RANK_MODE_ENABLE                               = 0x00000001,
    MEM_EFF_FOUR_RANK_MODE_INVALID                              = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] MRAM Support Support timing parameters of Everspin
 *	DDR4 MRAM
 */
enum MEM_EFF_MRAM_SUPPORT
{
    MEM_EFF_MRAM_SUPPORT_DISABLE                                = 0x00000000,
    MEM_EFF_MRAM_SUPPORT_ENABLE                                 = 0x00000001,
    MEM_EFF_MRAM_SUPPORT_INVALID                                = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] DDP Compatibility Support 1 rank 3DS Device in DDP
 *	board routing. CKE[1], CSN[1], ODT[1] of PHY are connected to C[0],
 *	C[1], C[2] of DRAM
 */
enum MEM_EFF_DDP_COMPATIBILITY
{
    MEM_EFF_DDP_COMPATIBILITY_DISABLE                           = 0x00000000,
    MEM_EFF_DDP_COMPATIBILITY_ENABLE                            = 0x00000001,
    MEM_EFF_DDP_COMPATIBILITY_INVALID                           = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] TSV 8H Support Support 8H 3DS routing in board
 *	routing when parity check is disabled
 */
enum MEM_EFF_TSV_8H_SUPPORT
{
    MEM_EFF_TSV_8H_SUPPORT_DISABLE                              = 0x00000000,
    MEM_EFF_TSV_8H_SUPPORT_ENABLE                               = 0x00000001,
    MEM_EFF_TSV_8H_SUPPORT_INVALID                              = 0x000000FF,
};

/**
 *  @brief ARRAY[DIMM] MDS DDIMM type derived attribute Will be true if
 *	HYBRID_MEMORY_TYPE is MDS and HYBRID is true
 */
enum MEM_EFF_MDS_DDIMM
{
    MEM_EFF_MDS_DDIMM_FALSE                                     = 0x00000000,
    MEM_EFF_MDS_DDIMM_TRUE                                      = 0x00000001,
    MEM_EFF_MDS_DDIMM_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Indicates the FW MODE of the OCMB
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE
{
    MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_NORMAL_MODE                = 0x00000000,
    MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_MANUFACTURING_MODE         = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_PRODUCT_QUALIFICATION_MODE = 0x00000002,
    MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_INVALID                    = 0x000000FF,
};

/**
 *  @brief Indicates wheather to enable the loopback test
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST
{
    MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_NO_LOOPBACK_TESTING = 0x00000000,
    MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_PERFORM_LOOPBACK_TESTING = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_INVALID     = 0x000000FF,
};

/**
 *  @brief The transport layer of OCMB
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER
{
    MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_OPEN_CAPI          = 0x00000000,
    MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_I2C                = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_JTAG               = 0x00000002,
    MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_INVALID            = 0x000000FF,
};

/**
 *  @brief Indicates whether the OpenCAPI DL boots immediately or waits for
 *	host command. BOOT_CONFIG0 should use either setting '0' (legacy
 *	Explorer FW) or '2' (newer Explorer FW). BOOT_CONFIG1 should use
 *	setting '1'
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE
{
    MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_NON_DL_TRAINING = 0x00000000,
    MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_ONLY_DL_TRAINING = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_NON_DL_TRAINING_VERSION2 = 0x00000002,
    MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_INVALID         = 0x000000FF,
};

/**
 *  @brief Set to enable or disable DFE
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE
{
    MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_DISABLE                = 0x00000000,
    MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_ENABLE                 = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_INVALID                = 0x000000FF,
};

/**
 *  @brief The lane width of the OpenCapi channel
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE
{
    MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_LANE_8                   = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_LANE_4                   = 0x00000002,
    MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_INVALID                  = 0x000000FF,
};

/**
 *  @brief The frequency of the OpenCAPI
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY
{
    MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_SERDES_21_33GBPS  = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_SERDES_23_46GBPS  = 0x00000002,
    MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_SERDES_25_60GBPS  = 0x00000003,
    MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_INVALID           = 0x000000FF,
};

/**
 *  @brief Indicates whether to enable adaptation
 */
enum MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE
{
    MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_DISABLE            = 0x00000000,
    MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_ENABLE             = 0x00000001,
    MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_INVALID            = 0x000000FF,
};

/**
 *  @brief Enable execution of FW_TWI_FFE_SETTINGS command on Explorer.
 *	Defaults to DISABLE.
 */
enum OMI_FFE_SETTINGS_COMMAND
{
    OMI_FFE_SETTINGS_COMMAND_DISABLE                            = 0x00000000,
    OMI_FFE_SETTINGS_COMMAND_ENABLE                             = 0x00000001,
    OMI_FFE_SETTINGS_COMMAND_INVALID                            = 0x000000FF,
};

/**
 *  @brief Enable Odyssey upstream transmit template 1. Should be disabled
 *	by default.
 */
enum ODY_ENABLE_US_TMPL_1
{
    ODY_ENABLE_US_TMPL_1_DISABLED                               = 0x00000000,
    ODY_ENABLE_US_TMPL_1_ENABLED                                = 0x00000001,
    ODY_ENABLE_US_TMPL_1_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enable Odyssey upstream transmit template 5. Should not be
 *	enabled by default.
 */
enum ODY_ENABLE_US_TMPL_5
{
    ODY_ENABLE_US_TMPL_5_DISABLED                               = 0x00000000,
    ODY_ENABLE_US_TMPL_5_ENABLED                                = 0x00000001,
    ODY_ENABLE_US_TMPL_5_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enable Odyssey upstream transmit template 9. Should be enabled
 *	by default.
 */
enum ODY_ENABLE_US_TMPL_9
{
    ODY_ENABLE_US_TMPL_9_DISABLED                               = 0x00000000,
    ODY_ENABLE_US_TMPL_9_ENABLED                                = 0x00000001,
    ODY_ENABLE_US_TMPL_9_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enable Odyssey upstream transmit template A. Not supported by
 *	Axone
 */
enum ODY_ENABLE_US_TMPL_A
{
    ODY_ENABLE_US_TMPL_A_DISABLED                               = 0x00000000,
    ODY_ENABLE_US_TMPL_A_ENABLED                                = 0x00000001,
    ODY_ENABLE_US_TMPL_A_INVALID                                = 0x000000FF,
};

/**
 *  @brief Enable Odyssey upstream transmit template 11. Should be disabled
 *	by default.
 */
enum ODY_ENABLE_US_TMPL_B
{
    ODY_ENABLE_US_TMPL_B_DISABLED                               = 0x00000000,
    ODY_ENABLE_US_TMPL_B_ENABLED                                = 0x00000001,
    ODY_ENABLE_US_TMPL_B_INVALID                                = 0x000000FF,
};

/**
 *  @brief Contains state information for each Target. Used to sync the
 *	fapi2::TargetState from the Host to the SPPE.
 */
enum SPPE_TARGET_STATE
{
    SPPE_TARGET_STATE_TARGET_STATE_NOT_PRESENT_NOT_FUNCTIONAL   = 0x00000000,
    SPPE_TARGET_STATE_TARGET_STATE_PRESENT                      = 0x00000001,
    SPPE_TARGET_STATE_TARGET_STATE_FUNCTIONAL                   = 0x00000002,
    SPPE_TARGET_STATE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief The i2c engine of the temperature sensor behind the Odyssey.
 *	There is only a single engine on odyssey which is engine B.
 */
enum SPPE_I2C_ENGINE
{
    SPPE_I2C_ENGINE_I2C_ENGINE_B                                = 0x00000000,
    SPPE_I2C_ENGINE_I2C_ENGINE_C                                = 0x00000001,
    SPPE_I2C_ENGINE_I2C_ENGINE_D                                = 0x00000002,
    SPPE_I2C_ENGINE_I2C_ENGINE_E                                = 0x00000003,
    SPPE_I2C_ENGINE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Controls whether OMI CFG reg accesses are considered big or
 *	little endian.
 */
enum MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL
{
    MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_LITTLE_ENDIAN              = 0x00000000,
    MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_BIG_ENDIAN                 = 0x00000001,
    MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_INVALID                    = 0x000000FF,
};

/**
 *  @brief 1 if this port passed swizzle detect, otherwise 0
 */
enum MSS_ODY_PASSED_SWIZZLE_DETECT
{
    MSS_ODY_PASSED_SWIZZLE_DETECT_NOT_RUN                       = 0x00000000,
    MSS_ODY_PASSED_SWIZZLE_DETECT_PASSED                        = 0x00000001,
    MSS_ODY_PASSED_SWIZZLE_DETECT_INVALID                       = 0x000000FF,
};

/**
 *  @brief Controls which PHY firmware image (ATE or production DRAM
 *	training) the Odyssey SBE will load into the PHY during load_imem
 *	and load_dmem.
 */
enum MSS_ODY_PHY_IMAGE_SELECT
{
    MSS_ODY_PHY_IMAGE_SELECT_TRAINING_IMAGE                     = 0x00000000,
    MSS_ODY_PHY_IMAGE_SELECT_ATE_IMAGE                          = 0x00000001,
    MSS_ODY_PHY_IMAGE_SELECT_INVALID                            = 0x000000FF,
};

/**
 *  @brief Switch from using attribute control in PHY message block to
 *	using sim environment hard codes.
 */
enum ODY_MSG_BLOCK_DATA_SOURCE
{
    ODY_MSG_BLOCK_DATA_SOURCE_USE_ATTRIBUTES                    = 0x00000000,
    ODY_MSG_BLOCK_DATA_SOURCE_USE_HARDCODES                     = 0x00000001,
    ODY_MSG_BLOCK_DATA_SOURCE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Attribute to enable or disable draminit erroring if a fatal
 *	Synopsys error was found or new bad bits were found in a training
 *	run. This attribute takes precedence over
 *	ATTR_ODY_DRAMINIT_RECOVERY_ENABLE
 */
enum ODY_DRAMINIT_ERROR_ON_FAILURE
{
    ODY_DRAMINIT_ERROR_ON_FAILURE_DISABLE                       = 0x00000000,
    ODY_DRAMINIT_ERROR_ON_FAILURE_ENABLE                        = 0x00000001,
    ODY_DRAMINIT_ERROR_ON_FAILURE_INVALID                       = 0x000000FF,
};

/**
 *  @brief Attribute to enable or disable draminit recovery.
 *	ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE takes precedence over this
 *	attribute
 */
enum ODY_DRAMINIT_RECOVERY_ENABLE
{
    ODY_DRAMINIT_RECOVERY_ENABLE_DISABLE                        = 0x00000000,
    ODY_DRAMINIT_RECOVERY_ENABLE_ENABLE                         = 0x00000001,
    ODY_DRAMINIT_RECOVERY_ENABLE_INVALID                        = 0x000000FF,
};

/**
 *  @brief Attribute to track values from the swizzle detect failure
 *	streaming message The attribute has the following format: 0xWXYZ W:
 *	if 0, this no failure. If 1, this attribute contains a failure X:
 *	TG aka the rank Y: DBYTE the byte in question from the PHY
 *	perspective Z: DQ, which bit failed (used to ID the failing nibble)
 */
enum ODY_SWIZZLE_DETECT_FAIL_VALUE
{
    ODY_SWIZZLE_DETECT_FAIL_VALUE_NO_VALUE                      = 0x00000000,
    ODY_SWIZZLE_DETECT_FAIL_VALUE_INVALID                       = 0x0000FFFF,
};

/**
 *  @brief Attribute to enable or disable draminit's specialized FIR error
 *	code
 */
enum ODY_DRAMINIT_FIR_CHECK_ENABLE
{
    ODY_DRAMINIT_FIR_CHECK_ENABLE_DISABLE                       = 0x00000000,
    ODY_DRAMINIT_FIR_CHECK_ENABLE_ENABLE                        = 0x00000001,
    ODY_DRAMINIT_FIR_CHECK_ENABLE_INVALID                       = 0x000000FF,
};

/**
 *  @brief Bitmap to control which procedure steps get run during istep
 *	mss_draminit. Bits numbered from left to right, set to '1' to
 *	enable each step: 0 = load_imem 1 = load_dmem 2 = load training
 *	message block 3 = run training 4 = load and execute PIE (PHY
 *	initialization engine)
 */
enum ODY_DRAMINIT_STEP_ENABLE
{
    ODY_DRAMINIT_STEP_ENABLE_LOAD_IMEM                          = 0x00000000,
    ODY_DRAMINIT_STEP_ENABLE_LOAD_DMEM                          = 0x00000001,
    ODY_DRAMINIT_STEP_ENABLE_LOAD_MSG_BLOCK                     = 0x00000002,
    ODY_DRAMINIT_STEP_ENABLE_RUN_TRAINING                       = 0x00000003,
    ODY_DRAMINIT_STEP_ENABLE_LOAD_PIE                           = 0x00000004,
    ODY_DRAMINIT_STEP_ENABLE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Threshold value (in number of attempts) for a DQS drift
 *	recalibration to be run. Even if a significant temperature change
 *	has not occurred since the previous recalibration, another one will
 *	be triggered after this many attempts have passed. Set to zero to
 *	force recalibration to run every time the drift tracking procedure
 *	is run. Set to DISABLE to disable upper threshold (recalibration
 *	will not be forced unless temperature changes more than temperature
 *	threshold)
 */
enum ODY_DQS_TRACKING_COUNT_THRESHOLD
{
    ODY_DQS_TRACKING_COUNT_THRESHOLD_DISABLE                    = 0x0000FFFF,
};

/**
 *  @brief Status attribute to tell PMIC telemetry if the DDR5 DQS tracking
 *	algorithm is intended to be running or suspended. Value is updated
 *	automatically by memory software functions, so this attribute
 *	should not need to be written manually.
 */
enum ODY_DQS_TRACKING_SUSPENDED
{
    ODY_DQS_TRACKING_SUSPENDED_TRUE                             = 0x00000001,
    ODY_DQS_TRACKING_SUSPENDED_FALSE                            = 0x00000000,
    ODY_DQS_TRACKING_SUSPENDED_INVALID                          = 0x000000FF,
};

/**
 *  @brief Status attribute to tell if the DDR5 DQS tracking algorithm has
 *	encountered a fail. Value is updated automatically by HWP code so
 *	this attribute should not be written manually.
 */
enum ODY_DQS_TRACKING_FAILED
{
    ODY_DQS_TRACKING_FAILED_YES                                 = 0x00000001,
    ODY_DQS_TRACKING_FAILED_NO                                  = 0x00000000,
    ODY_DQS_TRACKING_FAILED_INVALID                             = 0x000000FF,
};

/**
 *  @brief To track the error produced for the first i2c sensor read fail
 */
enum ODY_SENSOR_READ_FIRST_FAIL
{
    ODY_SENSOR_READ_FIRST_FAIL_FALSE                            = 0x00000000,
    ODY_SENSOR_READ_FIRST_FAIL_TRUE                             = 0x00000001,
    ODY_SENSOR_READ_FIRST_FAIL_INVALID                          = 0x000000FF,
};

/**
 *  @brief Controls the number of debug messages sent by the Odyssey PHY
 *	firmware based on verbosity field (HdtCtrl) in the training Message
 *	Block
 */
enum ODY_DRAMINIT_VERBOSITY
{
    ODY_DRAMINIT_VERBOSITY_MAX_DEBUG                            = 0x00000004,
    ODY_DRAMINIT_VERBOSITY_DETAILED_DEBUG                       = 0x00000005,
    ODY_DRAMINIT_VERBOSITY_COARSE_DEBUG                         = 0x0000000A,
    ODY_DRAMINIT_VERBOSITY_STAGE_COMPLETE                       = 0x000000C8,
    ODY_DRAMINIT_VERBOSITY_ASSERTION                            = 0x000000C9,
    ODY_DRAMINIT_VERBOSITY_FW_COMPLETE                          = 0x000000FF,
};

/**
 *  @brief Set this to 1 if the ARdPtrInitVal should be overriden via
 *	userInput.
 */
enum MEM_EFF_ARDPTRINITVALOVR
{
    MEM_EFF_ARDPTRINITVALOVR_NO_OVERRIDE                        = 0x00000000,
    MEM_EFF_ARDPTRINITVALOVR_OVERRIDE                           = 0x00000001,
    MEM_EFF_ARDPTRINITVALOVR_INVALID                            = 0x000000FF,
};

/**
 *  @brief Whether to disable PtrInit from clearing the TxTrkState csr
 *	during skip retrain.
 */
enum ODY_DIS_PTRINITCLR_TXTRACKING
{
    ODY_DIS_PTRINITCLR_TXTRACKING_DO_NOT_CLEAR                  = 0x00000000,
    ODY_DIS_PTRINITCLR_TXTRACKING_CLEAR_TXTRKSTATE              = 0x00000001,
    ODY_DIS_PTRINITCLR_TXTRACKING_INVALID                       = 0x000000FF,
};

/**
 *  @brief Indicates value of impedance calibration pull-down resistor
 *	connected to BP_ZN pin of the Odyssey PHY.
 */
enum MEM_EFF_EXTCALRESVAL
{
    MEM_EFF_EXTCALRESVAL_40_OHM                                 = 0x00000028,
    MEM_EFF_EXTCALRESVAL_120_OHM                                = 0x00000078,
    MEM_EFF_EXTCALRESVAL_240_OHM                                = 0x000000F0,
    MEM_EFF_EXTCALRESVAL_RESERVED                               = 0x000000FF,
};

/**
 *  @brief Indicate how the ERR/ALERT signal (which communicates feedback
 *	such as an address/command parity error) should be accommodated.
 */
enum MEM_EFF_MEMALERTEN
{
    MEM_EFF_MEMALERTEN_DISABLE                                  = 0x00000000,
    MEM_EFF_MEMALERTEN_ENABLE                                   = 0x00000001,
    MEM_EFF_MEMALERTEN_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Time between the end of one training step and the start of the
 *	next. It is the max expected time from dfi_init_complete asserted
 *	to tdfi_phymstr_ack asserted.
 */
enum ODY_PHY_MSTRTRAIN_INTERVAL
{
    ODY_PHY_MSTRTRAIN_INTERVAL_DISABLE                          = 0x00000000,
    ODY_PHY_MSTRTRAIN_INTERVAL_524288_MEMCLK                    = 0x00000001,
    ODY_PHY_MSTRTRAIN_INTERVAL_1048576_MEMCLK                   = 0x00000002,
    ODY_PHY_MSTRTRAIN_INTERVAL_2097152_MEMCLK                   = 0x00000003,
    ODY_PHY_MSTRTRAIN_INTERVAL_4194304_MEMCLK                   = 0x00000004,
    ODY_PHY_MSTRTRAIN_INTERVAL_8388608_MEMCLK                   = 0x00000005,
    ODY_PHY_MSTRTRAIN_INTERVAL_16777216_MEMCLK                  = 0x00000006,
    ODY_PHY_MSTRTRAIN_INTERVAL_33554432_MEMCLK                  = 0x00000007,
    ODY_PHY_MSTRTRAIN_INTERVAL_67108864_MEMCLK                  = 0x00000008,
    ODY_PHY_MSTRTRAIN_INTERVAL_134217728_MEMCLK                 = 0x00000009,
    ODY_PHY_MSTRTRAIN_INTERVAL_268435456_MEMCLK                 = 0x0000000A,
    ODY_PHY_MSTRTRAIN_INTERVAL_8192_MEMCLK                      = 0x0000000E,
    ODY_PHY_MSTRTRAIN_INTERVAL_INVALID                          = 0x000000FF,
};

/**
 *  @brief Max time from tdfi_phymstr_req asserted to tdfi_phymstr_ack
 *	asserted.
 */
enum ODY_PHY_MSTRMAXREQTOACK
{
    ODY_PHY_MSTRMAXREQTOACK_DISABLE                             = 0x00000000,
    ODY_PHY_MSTRMAXREQTOACK_512_MEMCLK                          = 0x00000001,
    ODY_PHY_MSTRMAXREQTOACK_1024_MEMCLK                         = 0x00000002,
    ODY_PHY_MSTRMAXREQTOACK_2048_MEMCLK                         = 0x00000003,
    ODY_PHY_MSTRMAXREQTOACK_4096_MEMCLK                         = 0x00000004,
    ODY_PHY_MSTRMAXREQTOACK_8192_MEMCLK                         = 0x00000005,
    ODY_PHY_MSTRMAXREQTOACK_INVALID                             = 0x000000FF,
};

/**
 *  @brief Phy Master Control Mode
 */
enum ODY_PHY_MSTRCTRLMODE
{
    ODY_PHY_MSTRCTRLMODE_INITIATE_BY_TIMER                      = 0x00000000,
    ODY_PHY_MSTRCTRLMODE_INITIATE_BY_DFI_CTRLMSG                = 0x00000001,
    ODY_PHY_MSTRCTRLMODE_INVALID                                = 0x000000FF,
};

/**
 *  @brief The interval between successive PHY impedance calibrations.
 */
enum ODY_PHY_CALINTERVAL
{
    ODY_PHY_CALINTERVAL_CONTINUOUS                              = 0x00000000,
    ODY_PHY_CALINTERVAL_13_US                                   = 0x00000001,
    ODY_PHY_CALINTERVAL_100_US                                  = 0x00000002,
    ODY_PHY_CALINTERVAL_1_MS                                    = 0x00000003,
    ODY_PHY_CALINTERVAL_2_MS                                    = 0x00000004,
    ODY_PHY_CALINTERVAL_3_MS                                    = 0x00000005,
    ODY_PHY_CALINTERVAL_4_MS                                    = 0x00000006,
    ODY_PHY_CALINTERVAL_8_MS                                    = 0x00000007,
    ODY_PHY_CALINTERVAL_10_MS                                   = 0x00000008,
    ODY_PHY_CALINTERVAL_20_MS                                   = 0x00000009,
    ODY_PHY_CALINTERVAL_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Selects the behaviour of CSR CalRun. CALINTERVAL causes
 *	calibration to be initiated at the CALINTERVAL interval. CALRUN
 *	causes it to be run once each time CALRUN transitions from 0 to 1.
 */
enum ODY_PHY_CALONCE
{
    ODY_PHY_CALONCE_CALINTERVAL                                 = 0x00000000,
    ODY_PHY_CALONCE_CALRUN                                      = 0x00000001,
    ODY_PHY_CALONCE_INVALID                                     = 0x000000FF,
};

/**
 *  @brief When VDD=0.9V nominal, set this to 1'b1, otherwise set to 1'b0.
 *	This input is used to program TxSlewRate[8] and ATxSlewRate[9].
 */
enum ODY_IS_HIGHVDD
{
    ODY_IS_HIGHVDD_NOT_0P9_VDD                                  = 0x00000000,
    ODY_IS_HIGHVDD_0P9_VDD                                      = 0x00000001,
    ODY_IS_HIGHVDD_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Enable tracking of tDQS2DQ. Array[RANK]
 */
enum ODY_EN_TDQS2DQ_TRACKING
{
    ODY_EN_TDQS2DQ_TRACKING_DISABLE                             = 0x00000000,
    ODY_EN_TDQS2DQ_TRACKING_ENABLE                              = 0x00000001,
    ODY_EN_TDQS2DQ_TRACKING_INVALID                             = 0x000000FF,
};

/**
 *  @brief DQS oscillator interval timer (in MEMCLK). Must match the value
 *	programmed to the MR for DQS oscillator interval timer.
 */
enum ODY_DQS_OSC_RUNTIME_SEL
{
    ODY_DQS_OSC_RUNTIME_SEL_256_MEMCLK                          = 0x00000100,
    ODY_DQS_OSC_RUNTIME_SEL_512_MEMCLK                          = 0x00000200,
    ODY_DQS_OSC_RUNTIME_SEL_1024_MEMCLK                         = 0x00000400,
    ODY_DQS_OSC_RUNTIME_SEL_2048_MEMCLK                         = 0x00000800,
    ODY_DQS_OSC_RUNTIME_SEL_4096_MEMCLK                         = 0x00001000,
    ODY_DQS_OSC_RUNTIME_SEL_8192_MEMCLK                         = 0x00002000,
    ODY_DQS_OSC_RUNTIME_SEL_INVALID                             = 0x0000FFFF,
};

/**
 *  @brief Enable tracking of the incoming read DQS to modify the read gate
 *	timing.
 */
enum ODY_EN_RXDQS_TRACKING
{
    ODY_EN_RXDQS_TRACKING_DISABLE                               = 0x00000000,
    ODY_EN_RXDQS_TRACKING_ENABLE                                = 0x00000001,
    ODY_EN_RXDQS_TRACKING_INVALID                               = 0x000000FF,
};

/**
 *  @brief Disables ARC Microcontroller ECC.
 */
enum ODY_DISABLE_PMU_ECC
{
    ODY_DISABLE_PMU_ECC_ENABLE                                  = 0x00000000,
    ODY_DISABLE_PMU_ECC_DISABLE                                 = 0x00000001,
    ODY_DISABLE_PMU_ECC_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Enables Async Path from MALERT_N to dfi_alert_n.
 */
enum ODY_ENABLE_MALERT_ASYNC
{
    ODY_ENABLE_MALERT_ASYNC_DISABLE                             = 0x00000000,
    ODY_ENABLE_MALERT_ASYNC_ENABLE                              = 0x00000001,
    ODY_ENABLE_MALERT_ASYNC_INVALID                             = 0x000000FF,
};

/**
 *  @brief Enables logic that disables/resets RxTracking during an Alert.
 */
enum ODY_ALERT_RECOV_ENABLE
{
    ODY_ALERT_RECOV_ENABLE_DISABLE                              = 0x00000000,
    ODY_ALERT_RECOV_ENABLE_ENABLE                               = 0x00000001,
    ODY_ALERT_RECOV_ENABLE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Controls Async Path from MALERT_N to dfi_alert_n. Controls
 *	whether an alert will SUSPEND RxTracking until the next ctrlupd or
 *	an alert will RESET RxTracking state
 */
enum ODY_RST_RXTRK_STATE
{
    ODY_RST_RXTRK_STATE_SUSPEND                                 = 0x00000000,
    ODY_RST_RXTRK_STATE_RESET                                   = 0x00000001,
    ODY_RST_RXTRK_STATE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Enable the overriding of the UserInput NoX4onUpperNibbleTg.
 */
enum ODY_UPPERNIBBLE_OVERRIDE
{
    ODY_UPPERNIBBLE_OVERRIDE_DISABLE                            = 0x00000000,
    ODY_UPPERNIBBLE_OVERRIDE_ENABLE                             = 0x00000001,
    ODY_UPPERNIBBLE_OVERRIDE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Disables automatically calculating userInputSim->tCASL_add (for
 *	sim).
 */
enum ODY_SIM_TCASL_OVERRIDE
{
    ODY_SIM_TCASL_OVERRIDE_OVERRIDE                             = 0x00000000,
    ODY_SIM_TCASL_OVERRIDE_NO_OVERRIDE                          = 0x00000001,
    ODY_SIM_TCASL_OVERRIDE_INVALID                              = 0x000000FF,
};

/**
 *  @brief Enable additional Power savings during LP2 LP2_PwrSavings_En in
 *	ddrphyinit struct
 */
enum ODY_LP2_PWRSAVINGS
{
    ODY_LP2_PWRSAVINGS_ENABLE                                   = 0x00000001,
    ODY_LP2_PWRSAVINGS_DISABLE                                  = 0x00000000,
    ODY_LP2_PWRSAVINGS_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Select if the PHY uses PLL bypass. PllBypassEn in the message
 *	block structure.
 */
enum ODY_PLL_BYPASS_EN
{
    ODY_PLL_BYPASS_EN_USE_PHY_PLL                               = 0x00000000,
    ODY_PLL_BYPASS_EN_PLL_BYPASSED                              = 0x00000001,
    ODY_PLL_BYPASS_EN_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Set whether or not per rank MR values are used. UseBroadcastMR
 *	in the message block structure.
 */
enum ODY_PHY_USE_BROADCAST_MR
{
    ODY_PHY_USE_BROADCAST_MR_USE_PER_RANK_VALUES                = 0x00000000,
    ODY_PHY_USE_BROADCAST_MR_USE_BROADCAST_VALUES               = 0x00000001,
    ODY_PHY_USE_BROADCAST_MR_INVALID                            = 0x000000FF,
};

/**
 *  @brief Tx impedance of DQ driver cells when equalization is disabled,
 *	per pstate
 */
enum ODY_TX_IMPEDANCE_CTRL1
{
    ODY_TX_IMPEDANCE_CTRL1_HIGH_IMP                             = 0x00000000,
    ODY_TX_IMPEDANCE_CTRL1_OHM_25                               = 0x00000019,
    ODY_TX_IMPEDANCE_CTRL1_OHM_27                               = 0x0000001B,
    ODY_TX_IMPEDANCE_CTRL1_OHM_28                               = 0x0000001C,
    ODY_TX_IMPEDANCE_CTRL1_OHM_30                               = 0x0000001E,
    ODY_TX_IMPEDANCE_CTRL1_OHM_32                               = 0x00000020,
    ODY_TX_IMPEDANCE_CTRL1_OHM_34                               = 0x00000022,
    ODY_TX_IMPEDANCE_CTRL1_OHM_36                               = 0x00000024,
    ODY_TX_IMPEDANCE_CTRL1_OHM_40                               = 0x00000028,
    ODY_TX_IMPEDANCE_CTRL1_OHM_43                               = 0x0000002B,
    ODY_TX_IMPEDANCE_CTRL1_OHM_48                               = 0x00000030,
    ODY_TX_IMPEDANCE_CTRL1_OHM_53                               = 0x00000035,
    ODY_TX_IMPEDANCE_CTRL1_OHM_60                               = 0x0000003C,
    ODY_TX_IMPEDANCE_CTRL1_OHM_68                               = 0x00000044,
    ODY_TX_IMPEDANCE_CTRL1_OHM_80                               = 0x00000050,
    ODY_TX_IMPEDANCE_CTRL1_OHM_96                               = 0x00000060,
    ODY_TX_IMPEDANCE_CTRL1_OHM_120                              = 0x00000078,
    ODY_TX_IMPEDANCE_CTRL1_OHM_160                              = 0x000000A0,
    ODY_TX_IMPEDANCE_CTRL1_OHM_240                              = 0x000000F0,
    ODY_TX_IMPEDANCE_CTRL1_OHM_480                              = 0x000001E0,
    ODY_TX_IMPEDANCE_CTRL1_INVALID                              = 0x0000FFFF,
};

/**
 *  @brief Tx impedance of DQ driver cells when equalization is disabled,
 *	per pstate
 */
enum ODY_TX_IMPEDANCE_CTRL2
{
    ODY_TX_IMPEDANCE_CTRL2_HIGH_IMP                             = 0x00000000,
    ODY_TX_IMPEDANCE_CTRL2_OHM_25                               = 0x00000019,
    ODY_TX_IMPEDANCE_CTRL2_OHM_27                               = 0x0000001B,
    ODY_TX_IMPEDANCE_CTRL2_OHM_28                               = 0x0000001C,
    ODY_TX_IMPEDANCE_CTRL2_OHM_30                               = 0x0000001E,
    ODY_TX_IMPEDANCE_CTRL2_OHM_32                               = 0x00000020,
    ODY_TX_IMPEDANCE_CTRL2_OHM_34                               = 0x00000022,
    ODY_TX_IMPEDANCE_CTRL2_OHM_36                               = 0x00000024,
    ODY_TX_IMPEDANCE_CTRL2_OHM_40                               = 0x00000028,
    ODY_TX_IMPEDANCE_CTRL2_OHM_43                               = 0x0000002B,
    ODY_TX_IMPEDANCE_CTRL2_OHM_48                               = 0x00000030,
    ODY_TX_IMPEDANCE_CTRL2_OHM_53                               = 0x00000035,
    ODY_TX_IMPEDANCE_CTRL2_OHM_60                               = 0x0000003C,
    ODY_TX_IMPEDANCE_CTRL2_OHM_68                               = 0x00000044,
    ODY_TX_IMPEDANCE_CTRL2_OHM_80                               = 0x00000050,
    ODY_TX_IMPEDANCE_CTRL2_OHM_96                               = 0x00000060,
    ODY_TX_IMPEDANCE_CTRL2_OHM_120                              = 0x00000078,
    ODY_TX_IMPEDANCE_CTRL2_OHM_160                              = 0x000000A0,
    ODY_TX_IMPEDANCE_CTRL2_OHM_240                              = 0x000000F0,
    ODY_TX_IMPEDANCE_CTRL2_OHM_480                              = 0x000001E0,
    ODY_TX_IMPEDANCE_CTRL2_INVALID                              = 0x0000FFFF,
};

/**
 *  @brief Keeps track if the Odyssey's DMEM has been loaded before As the
 *	DMEM can be reset to all zeroes, this attribute can be used to
 *	speed up the DMEM loads by skipping the any DMEM addresses that are
 *	zeroes
 */
enum ODY_DMEM_FIRST_LOAD
{
    ODY_DMEM_FIRST_LOAD_NO                                      = 0x00000000,
    ODY_DMEM_FIRST_LOAD_YES                                     = 0x00000001,
    ODY_DMEM_FIRST_LOAD_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Setup emergeny throttles. This attribute gets set automatically
 *	in the code, and it's enabled only in the case of P Hostboot
 */
enum ODY_SETUP_SAFEMODE_THROTTLES
{
    ODY_SETUP_SAFEMODE_THROTTLES_ENABLE                         = 0x00000001,
    ODY_SETUP_SAFEMODE_THROTTLES_DISABLE                        = 0x00000000,
    ODY_SETUP_SAFEMODE_THROTTLES_INVALID                        = 0x000000FF,
};

/**
 *  @brief By default, draminit will disable a whole DRAM when its DQ0
 *	fails training. This attribute can be used for testing purposes to
 *	skip this behavior.
 */
enum ODY_DISABLE_DRAM_WITH_BAD_DQ0
{
    ODY_DISABLE_DRAM_WITH_BAD_DQ0_SKIP_DISABLE                  = 0x00000001,
    ODY_DISABLE_DRAM_WITH_BAD_DQ0_DISABLE_DRAM                  = 0x00000000,
    ODY_DISABLE_DRAM_WITH_BAD_DQ0_INVALID                       = 0x000000FF,
};

/**
 *  @brief Specifies the number of Rx lanes.
 */
enum OMI_RX_LANES
{
    OMI_RX_LANES_X8                                             = 0xFF000000,
    OMI_RX_LANES_X4                                             = 0xA5000000,
    OMI_RX_LANES_X2                                             = 0x81000000,
    OMI_RX_LANES_INVALID                                        = 0xFFFFFFFF,
};

/**
 *  @brief Specifies the number of Tx lanes.
 */
enum OMI_TX_LANES
{
    OMI_TX_LANES_X8                                             = 0xFF000000,
    OMI_TX_LANES_X4                                             = 0xA5000000,
    OMI_TX_LANES_X2                                             = 0x81000000,
    OMI_TX_LANES_INVALID                                        = 0xFFFFFFFF,
};

/**
 *  @brief Specifies if the BIST ESD test is going to run
 */
enum OMI_BIST_ESD_TEST
{
    OMI_BIST_ESD_TEST_DISABLED                                  = 0x00000000,
    OMI_BIST_ESD_TEST_ENABLED                                   = 0x00000001,
    OMI_BIST_ESD_TEST_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Specifies if the BIST DAC test is going to run
 */
enum OMI_BIST_DAC_TEST
{
    OMI_BIST_DAC_TEST_DISABLED                                  = 0x00000000,
    OMI_BIST_DAC_TEST_ENABLED                                   = 0x00000001,
    OMI_BIST_DAC_TEST_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Specifies if OMI Error Detection Per Lane is Enabled
 */
enum OMI_EDPL
{
    OMI_EDPL_DISABLED                                           = 0x00000000,
    OMI_EDPL_ENABLED                                            = 0x00000001,
    OMI_EDPL_INVALID                                            = 0x000000FF,
};

/**
 *  @brief Select whether or not to run procedures in hotplug mode
 */
enum HOTPLUG
{
    HOTPLUG_FALSE                                               = 0x00000000,
    HOTPLUG_TRUE                                                = 0x00000001,
    HOTPLUG_INVALID                                             = 0x000000FF,
};

/**
 *  @brief PLL bucket selection
 */
enum OCMB_PLL_BUCKET
{
    OCMB_PLL_BUCKET_TANK1600                                    = 0x00000000,
    OCMB_PLL_BUCKET_TANK2000                                    = 0x00000001,
    OCMB_PLL_BUCKET_TANK2400                                    = 0x00000002,
    OCMB_PLL_BUCKET_RING2400                                    = 0x00000003,
    OCMB_PLL_BUCKET_SIM0267                                     = 0x0000000E,
    OCMB_PLL_BUCKET_SIM2133                                     = 0x0000000F,
    OCMB_PLL_BUCKET_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Sim specific PLL bucket selection
 */
enum OCMB_PLL_BUCKET_SIM
{
    OCMB_PLL_BUCKET_SIM_TANK1600                                = 0x00000000,
    OCMB_PLL_BUCKET_SIM_TANK2000                                = 0x00000001,
    OCMB_PLL_BUCKET_SIM_TANK2400                                = 0x00000002,
    OCMB_PLL_BUCKET_SIM_RING2400                                = 0x00000003,
    OCMB_PLL_BUCKET_SIM_SIM0267                                 = 0x0000000E,
    OCMB_PLL_BUCKET_SIM_SIM2133                                 = 0x0000000F,
    OCMB_PLL_BUCKET_SIM_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Controls the SBE boot side, written to SB_CS prior to sbe boot
 */
enum SPPE_BOOT_SIDE
{
    SPPE_BOOT_SIDE_SIDE0                                        = 0x00000000,
    SPPE_BOOT_SIDE_SIDE1                                        = 0x00000001,
    SPPE_BOOT_SIDE_GOLDEN                                       = 0x00000002,
    SPPE_BOOT_SIDE_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Enable or Disable LBIST. This is to skip LBIST procedures if
 *	user elects
 */
enum ENABLE_LBIST
{
    ENABLE_LBIST_DISABLE                                        = 0x00000000,
    ENABLE_LBIST_ENABLE                                         = 0x00000001,
    ENABLE_LBIST_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Enable or Disable ABIST. This is to skip ABIST procedures if
 *	user elects
 */
enum ENABLE_ABIST
{
    ENABLE_ABIST_DISABLE                                        = 0x00000000,
    ENABLE_ABIST_ENABLE                                         = 0x00000001,
    ENABLE_ABIST_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Reflects the boot security level of the given chip. This is
 *	purely informative and to be used by procedures to adjust their
 *	behavior, e.g. by disabling some debugging functions. This
 *	attribute is set by SBE during SBE boot flow. Once set by SBE the
 *	ATTR cannot be updated. Settings for a higher security level done
 *	in OTPROM will always take precedence over corresponding bits
 *	defined in scratch 11 for lab/test-only purposes. Level 0 -
 *	DISABLED - Security disabled, SAB=0 Level 1 - PERMISSIVE - Security
 *	enabled but not strictly enforced, SAB=1 but firmware signed with
 *	imprint keys If this is set, then users can still override (set to
 *	1) the default setting for allow-deny list enable with bit 11 in
 *	scratch 11 to disable scom filtering but would still get a chip-op
 *	error for such scoms. Level 2 - ENFORCING - Security enabled and
 *	strictly enforced, SAB=1 and firmware signed with production keys
 */
enum SECURITY_LEVEL
{
    SECURITY_LEVEL_DISABLED                                     = 0x00000000,
    SECURITY_LEVEL_PERMISSIVE                                   = 0x00000001,
    SECURITY_LEVEL_ENFORCING                                    = 0x00000002,
    SECURITY_LEVEL_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Permits customization of the order in which RTG (repair, time,
 *	gptr) scan ring images will be applied. CUST_BEFORE_EKB CUST pak
 *	settings apply prior to EKB specified inits EKB_BEFORE_CUST EKB
 *	specified inits apply prior to CUST pak settings
 */
enum RTG_SCAN_ORDER
{
    RTG_SCAN_ORDER_CUST_BEFORE_EKB                              = 0x00000000,
    RTG_SCAN_ORDER_EKB_BEFORE_CUST                              = 0x00000001,
    RTG_SCAN_ORDER_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Force one of 4 N-Mode configurations instead of N_PLUS_1 mode.
 *	The bits are as follows: [PMIC0, PMIC1, PMIC2, PMIC3, 0, 0, 0, 0]
 *	Set the bits high for the desired PMICs to run with. For DDR4 a
 *	valid configuration to boot with is at least a pair with one each
 *	of [0,2] and [1,3]. FOr DDR5 a valid configuration to boot with is
 *	at least 3 PMICs This only applies to 4U DDIMMs.
 */
enum MEM_PMIC_FORCE_N_MODE
{
    MEM_PMIC_FORCE_N_MODE_N_PLUS_1                              = 0x000000F0,
    MEM_PMIC_FORCE_N_MODE_PMIC01                                = 0x000000C0,
    MEM_PMIC_FORCE_N_MODE_PMIC03                                = 0x00000090,
    MEM_PMIC_FORCE_N_MODE_PMIC12                                = 0x00000060,
    MEM_PMIC_FORCE_N_MODE_PMIC23                                = 0x00000030,
    MEM_PMIC_FORCE_N_MODE_PMIC012                               = 0x000000E0,
    MEM_PMIC_FORCE_N_MODE_PMIC013                               = 0x000000D0,
    MEM_PMIC_FORCE_N_MODE_PMIC023                               = 0x000000B0,
    MEM_PMIC_FORCE_N_MODE_PMIC123                               = 0x00000070,
    MEM_PMIC_FORCE_N_MODE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Redundant PMIC exists for PMIC0
 */
enum MEM_EFF_PMIC0_REDUNDANCY
{
    MEM_EFF_PMIC0_REDUNDANCY_DISABLED                           = 0x00000000,
    MEM_EFF_PMIC0_REDUNDANCY_ENABLED                            = 0x00000001,
    MEM_EFF_PMIC0_REDUNDANCY_INVALID                            = 0x000000FF,
};

/**
 *  @brief Redundant PMIC exists for PMIC1
 */
enum MEM_EFF_PMIC1_REDUNDANCY
{
    MEM_EFF_PMIC1_REDUNDANCY_DISABLED                           = 0x00000000,
    MEM_EFF_PMIC1_REDUNDANCY_ENABLED                            = 0x00000001,
    MEM_EFF_PMIC1_REDUNDANCY_INVALID                            = 0x000000FF,
};

/**
 *  @brief The frequency of a processor's nest mesh clock, in MHz. This is
 *	the same for all chips in the system. Provided by the MRW.
 */
enum FREQ_PB_MHZ
{
    FREQ_PB_MHZ_1600                                            = 0x00000640,
    FREQ_PB_MHZ_1866                                            = 0x0000074A,
    FREQ_PB_MHZ_2000                                            = 0x000007D0,
    FREQ_PB_MHZ_2133                                            = 0x00000855,
    FREQ_PB_MHZ_2400                                            = 0x00000960,
    FREQ_PB_MHZ_INVALID                                         = 0xFFFFFFFF,
};

/**
 *  @brief MC mesh to use Nest mesh or not
 */
enum MC_SYNC_MODE
{
    MC_SYNC_MODE_IN_SYNC                                        = 0x00000001,
    MC_SYNC_MODE_NOT_IN_SYNC                                    = 0x00000000,
    MC_SYNC_MODE_INVALID                                        = 0x000000FF,
};

/**
 *  @brief HWP/Init "risk level" enabled. Used by HB to pass to HB driven
 *	HWPs
 */
enum RISK_LEVEL
{
    RISK_LEVEL_RL0                                              = 0x00000000,
    RISK_LEVEL_RL1                                              = 0x00000001,
    RISK_LEVEL_RL2                                              = 0x00000002,
    RISK_LEVEL_RL3                                              = 0x00000003,
    RISK_LEVEL_RL4                                              = 0x00000004,
    RISK_LEVEL_RL5                                              = 0x00000005,
    RISK_LEVEL_INVALID                                          = 0x000000FF,
};

/**
 *  @brief Switch to enable or disable Power Management Complex FFDC
 *	collection to HOMER. When set, the PM Complex Reset flow will
 *	collect PM Complex data to the chip HOMER region to assist with
 *	failure analysis and recovery. Producer: HB must set or reset this
 *	based on the platform use-case and state. Consumer: p9_pm_reset.C,
 *	p9_pm_callout.C
 */
enum PM_RESET_FFDC_ENABLE
{
    PM_RESET_FFDC_ENABLE_FALSE                                  = 0x00000000,
    PM_RESET_FFDC_ENABLE_TRUE                                   = 0x00000001,
    PM_RESET_FFDC_ENABLE_INVALID                                = 0x000000FF,
};

/**
 *  @brief Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 =
 *	NV 2.0 3 = OPENCAPI Provided by the MRW.
 */
enum OPTICS_CONFIG_MODE
{
    OPTICS_CONFIG_MODE_SMP                                      = 0x00000000,
    OPTICS_CONFIG_MODE_CAPI                                     = 0x00000001,
    OPTICS_CONFIG_MODE_NV                                       = 0x00000002,
    OPTICS_CONFIG_MODE_OCAPI                                    = 0x00000003,
    OPTICS_CONFIG_MODE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief In sub DD1.02 Nimbus the HW VREF calibrations should not be run
 */
enum SKIP_HW_VREF_CAL
{
    SKIP_HW_VREF_CAL_RUN                                        = 0x00000000,
    SKIP_HW_VREF_CAL_SKIP                                       = 0x00000001,
    SKIP_HW_VREF_CAL_INVALID                                    = 0x000000FF,
};

/**
 *  @brief In sub DD1.03 Nimbus the HW VREF calibrations should not be run
 */
enum SKIP_RD_VREF_VREFSENSE_OVERRIDE
{
    SKIP_RD_VREF_VREFSENSE_OVERRIDE_RUN                         = 0x00000000,
    SKIP_RD_VREF_VREFSENSE_OVERRIDE_SKIP                        = 0x00000001,
    SKIP_RD_VREF_VREFSENSE_OVERRIDE_INVALID                     = 0x000000FF,
};

/**
 *  @brief Set equal to 1 to disable setting of RTT_NOM to use RTT_WR
 *	values during WR_LEVEL calibration.
 */
enum MSS_RTT_NOM_OVERRIDE_DISABLE
{
    MSS_RTT_NOM_OVERRIDE_DISABLE_NO                             = 0x00000000,
    MSS_RTT_NOM_OVERRIDE_DISABLE_YES                            = 0x00000001,
    MSS_RTT_NOM_OVERRIDE_DISABLE_INVALID                        = 0x000000FF,
};

/**
 *  @brief Enables the SGPE Hcode to enable the CME instruction traces into
 *	the L3 Trace array for debug. Note: all configured CMEs will be put
 *	into this mode if this attribute is ON. Consumer:
 *	p9_hcode_image_build.c -> SGPE Header field Platform default: OFF
 */
enum CME_INSTRUCTION_TRACE_ENABLE
{
    CME_INSTRUCTION_TRACE_ENABLE_OFF                            = 0x00000000,
    CME_INSTRUCTION_TRACE_ENABLE_ON                             = 0x00000001,
    CME_INSTRUCTION_TRACE_ENABLE_INVALID                        = 0x000000FF,
};

/**
 *  @brief Enables pstate parameter block code to use the static system
 *	vfrt data Consumer: p9_pstate_parameter_block.C -> Platform
 *	default: OFF
 */
enum SYS_VFRT_STATIC_DATA_ENABLE
{
    SYS_VFRT_STATIC_DATA_ENABLE_OFF                             = 0x00000000,
    SYS_VFRT_STATIC_DATA_ENABLE_ON                              = 0x00000001,
    SYS_VFRT_STATIC_DATA_ENABLE_VDN_STEP_OFF                    = 0x00000002,
    SYS_VFRT_STATIC_DATA_ENABLE_INVALID                         = 0x000000FF,
};

/**
 *  @brief Flags to indicate if rx / tx dccal has been run.
 */
enum IO_OBUS_DCCAL_FLAGS
{
    IO_OBUS_DCCAL_FLAGS_NONE                                    = 0x00000000,
    IO_OBUS_DCCAL_FLAGS_TX                                      = 0x00000001,
    IO_OBUS_DCCAL_FLAGS_RX                                      = 0x00000002,
    IO_OBUS_DCCAL_FLAGS_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Indicate if debug data should be taken pre / post linktraining.
 */
enum IO_O_DEBUG
{
    IO_O_DEBUG_FALSE                                            = 0x00000000,
    IO_O_DEBUG_TRUE                                             = 0x00000001,
    IO_O_DEBUG_INVALID                                          = 0x000000FF,
};

/**
 *  @brief Indicate if manufacturing tests should be taken pre / post
 *	linktraining.
 */
enum IO_X_MFG_CHK
{
    IO_X_MFG_CHK_FALSE                                          = 0x00000000,
    IO_X_MFG_CHK_TRUE                                           = 0x00000001,
    IO_X_MFG_CHK_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Enables the SGPE Hcode to enable the CME instruction traces into
 *	the CHTM for debug. Note: all configured CMEs will be put into this
 *	mode if this attribute is ON. Consumer: p9_hcode_image_build.c ->
 *	SGPE Header field Platform default: OFF
 */
enum CME_CHTM_TRACE_ENABLE
{
    CME_CHTM_TRACE_ENABLE_OFF                                   = 0x00000000,
    CME_CHTM_TRACE_ENABLE_ON                                    = 0x00000001,
    CME_CHTM_TRACE_ENABLE_INVALID                               = 0x000000FF,
};

/**
 *  @brief Disables the enablement of Voltage Droop Monitors (VDM) in the
 *	system. Producer: MRW Consumers: p9_pstate_parameter_block to clear
 *	flag for CME QuadManager Hcode reaction
 */
enum SYSTEM_VDM_DISABLE
{
    SYSTEM_VDM_DISABLE_OFF                                      = 0x00000000,
    SYSTEM_VDM_DISABLE_ON                                       = 0x00000001,
    SYSTEM_VDM_DISABLE_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Voltage Droop Monitors (VDM) to be enabled is present and valid
 *	Producer: p9_build_pstate_datablock Consumers: p9_hcode_image_build
 *	-> SGPE Header CME Header
 */
enum VDM_ENABLED
{
    VDM_ENABLED_FALSE                                           = 0x00000000,
    VDM_ENABLED_TRUE                                            = 0x00000001,
    VDM_ENABLED_INVALID                                         = 0x000000FF,
};

/**
 *  @brief Disables IVRM enablement in the system Producer: Override
 *	Consumers: p9_build_pstate_datablock -> Pstate Parameter Block
 *	(PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad
 *	Manager
 */
enum SYSTEM_IVRM_DISABLE
{
    SYSTEM_IVRM_DISABLE_OFF                                     = 0x00000000,
    SYSTEM_IVRM_DISABLE_ON                                      = 0x00000001,
    SYSTEM_IVRM_DISABLE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Internal Voltage Regulator Macros (IVRMs) to be enabled is present
 *	and valid Producer: p9_build_pstate_datablock Consumers:
 *	p9_hcode_image_build -> PGPE Header CME Header
 */
enum IVRM_ENABLED
{
    IVRM_ENABLED_FALSE                                          = 0x00000000,
    IVRM_ENABLED_TRUE                                           = 0x00000001,
    IVRM_ENABLED_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Controls ENABLE/DISABLE of workaround that sets the PHY
 *	sequencer to trigger refresh after draminit.
 */
enum MSS_PHY_SEQ_REFRESH
{
    MSS_PHY_SEQ_REFRESH_DISABLE                                 = 0x00000000,
    MSS_PHY_SEQ_REFRESH_ENABLE                                  = 0x00000001,
    MSS_PHY_SEQ_REFRESH_INVALID                                 = 0x000000FF,
};

/**
 *  @brief If wof_enabled, defines the Frequency Ratio calculation
 *	performed. (THIS IS NOT SUPPORTED IN P9 GA1!).
 */
enum WOF_ENABLE_FRATIO
{
    WOF_ENABLE_FRATIO_FIXED                                     = 0x00000000,
    WOF_ENABLE_FRATIO_STEPPED                                   = 0x00000001,
    WOF_ENABLE_FRATIO_INVALID                                   = 0x000000FF,
};

/**
 *  @brief If wof_enabled, defines the Voltage Ratio calculation performed.
 *	THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).
 */
enum WOF_ENABLE_VRATIO
{
    WOF_ENABLE_VRATIO_FIXED                                     = 0x00000000,
    WOF_ENABLE_VRATIO_CALCULATED                                = 0x00000001,
    WOF_ENABLE_VRATIO_INVALID                                   = 0x000000FF,
};

/**
 *  @brief If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this
 *	attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio
 *	is the number of active cores to the number of good cores FULL:
 *	Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal
 *	interpolated regulator voltage (including load line uplife @ RDP
 *	current) derated with presently measured Idd current (from the
 *	AVSBus) and the loadline.
 */
enum WOF_VRATIO_SELECT
{
    WOF_VRATIO_SELECT_ACTIVE_CORES                              = 0x00000000,
    WOF_VRATIO_SELECT_FULL                                      = 0x00000001,
    WOF_VRATIO_SELECT_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Selects whether or not DCD should be run
 */
enum MSS_RUN_DCD_CALIBRATION
{
    MSS_RUN_DCD_CALIBRATION_NO                                  = 0x00000000,
    MSS_RUN_DCD_CALIBRATION_YES                                 = 0x00000001,
    MSS_RUN_DCD_CALIBRATION_INVALID                             = 0x000000FF,
};

/**
 *  @brief Controls ENABLE/DISABLE of Write CRC
 */
enum MSS_EFF_WR_CRC
{
    MSS_EFF_WR_CRC_DISABLE                                      = 0x00000000,
    MSS_EFF_WR_CRC_ENABLE                                       = 0x00000001,
    MSS_EFF_WR_CRC_INVALID                                      = 0x000000FF,
};

/**
 *  @brief Indicate if manufcaturing tests should be taken pre / post
 *	linktraining.
 */
enum IO_O_MFG_CHK
{
    IO_O_MFG_CHK_FALSE                                          = 0x00000000,
    IO_O_MFG_CHK_TRUE                                           = 0x00000001,
    IO_O_MFG_CHK_INVALID                                        = 0x000000FF,
};

/**
 *  @brief To allow for selective enablement for lab testing To allow skew
 *	function to be enabled/disabled.
 */
enum SYSTEM_CORECACHE_SKEWADJ_DISABLE
{
    SYSTEM_CORECACHE_SKEWADJ_DISABLE_FALSE                      = 0x00000000,
    SYSTEM_CORECACHE_SKEWADJ_DISABLE_TRUE                       = 0x00000001,
    SYSTEM_CORECACHE_SKEWADJ_DISABLE_INVALID                    = 0x000000FF,
};

/**
 *  @brief To allow for selective enablement for lab testing To allow dcadj
 *	function to be enabled/disabled.
 */
enum SYSTEM_CORECACHE_DCADJ_DISABLE
{
    SYSTEM_CORECACHE_DCADJ_DISABLE_FALSE                        = 0x00000000,
    SYSTEM_CORECACHE_DCADJ_DISABLE_TRUE                         = 0x00000001,
    SYSTEM_CORECACHE_DCADJ_DISABLE_INVALID                      = 0x000000FF,
};

/**
 *  @brief Indicates that a special wakeup is in progress for an EQ
 *	Producer: p9_cpu_special_wakeup_eq.C Consumers:
 *	p9_cpu_special_wakeup_eq.C
 */
enum EQ_INSIDE_SPECIAL_WAKEUP
{
    EQ_INSIDE_SPECIAL_WAKEUP_FALSE                              = 0x00000000,
    EQ_INSIDE_SPECIAL_WAKEUP_TRUE                               = 0x00000001,
    EQ_INSIDE_SPECIAL_WAKEUP_INVALID                            = 0x000000FF,
};

/**
 *  @brief Indicates that a special wakeup is in progress for an EX.
 *	Producer: p9_cpu_special_wakeup_ex.C Consumers:
 *	p9_cpu_special_wakeup_ex.C
 */
enum EX_INSIDE_SPECIAL_WAKEUP
{
    EX_INSIDE_SPECIAL_WAKEUP_FALSE                              = 0x00000000,
    EX_INSIDE_SPECIAL_WAKEUP_TRUE                               = 0x00000001,
    EX_INSIDE_SPECIAL_WAKEUP_INVALID                            = 0x000000FF,
};

/**
 *  @brief Alternate settings for short Xbus channels bit 0 -- Disable RX
 *	LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init
 *	Settings bit 3 -- Lower VGA Gain Target -10%
 */
enum IO_XBUS_CHAN_EQ
{
    IO_XBUS_CHAN_EQ_DIS_RX_LTE                                  = 0x00000001,
    IO_XBUS_CHAN_EQ_DIS_TX_AC_BOOST                             = 0x00000002,
    IO_XBUS_CHAN_EQ_LOWER_GAIN_PEAK_INITS                       = 0x00000004,
    IO_XBUS_CHAN_EQ_LOWER_VGA_GAIN_TARGET                       = 0x00000008,
    IO_XBUS_CHAN_EQ_INVALID                                     = 0x000000FF,
};

/**
 *  @brief Indicates if the Obus channel is a board or a cable
 */
enum IO_O_CHANNEL_TYPE
{
    IO_O_CHANNEL_TYPE_BOARD                                     = 0x00000000,
    IO_O_CHANNEL_TYPE_CABLE                                     = 0x00000001,
    IO_O_CHANNEL_TYPE_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Enumeration specifying a target's CEC degraded mode domain
 */
enum CDM_DOMAIN
{
    CDM_DOMAIN_NONE                                             = 0x00000000,
    CDM_DOMAIN_CPU                                              = 0x00000001,
    CDM_DOMAIN_DIMM                                             = 0x00000002,
    CDM_DOMAIN_FABRIC                                           = 0x00000003,
    CDM_DOMAIN_MEM                                              = 0x00000004,
    CDM_DOMAIN_IO                                               = 0x00000005,
    CDM_DOMAIN_NODE                                             = 0x00000006,
    CDM_DOMAIN_CLOCK                                            = 0x00000007,
    CDM_DOMAIN_PSI                                              = 0x00000008,
    CDM_DOMAIN_FSP                                              = 0x00000009,
    CDM_DOMAIN_SECURITY                                         = 0x0000000A,
    CDM_DOMAIN_ALL                                              = 0x0000000B,
    CDM_DOMAIN_INVALID                                          = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration of CDM_POLICIES flags
 */
enum CDM_POLICIES
{
    CDM_POLICIES_MANUFACTURING_DISABLED                         = 0x00000001,
    CDM_POLICIES_PREDICTIVE_DISABLED                            = 0x00000002,
    CDM_POLICIES_INVALID                                        = 0x000000FF,
};

/**
 *  @brief Enumeration specifying the CHECK_ATTN_AFTER_ISTEP_FAIL values 0
 *	DEFAULT : Initial value and indicates FIR bits set if Ody HWP
 *	failed 1 NO : If Ody HWP Failed, indicates FIR bits NOT set
 */
enum CHECK_ATTN_AFTER_ISTEP_FAIL
{
    CHECK_ATTN_AFTER_ISTEP_FAIL_DEFAULT                         = 0x00000000,
    CHECK_ATTN_AFTER_ISTEP_FAIL_NO                              = 0x00000001,
    CHECK_ATTN_AFTER_ISTEP_FAIL_INVALID                         = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the target's class
 */
enum CLASS
{
    CLASS_NA                                                    = 0x00000000,
    CLASS_CARD                                                  = 0x00000001,
    CLASS_ENC                                                   = 0x00000002,
    CLASS_CHIP                                                  = 0x00000003,
    CLASS_UNIT                                                  = 0x00000004,
    CLASS_DEV                                                   = 0x00000005,
    CLASS_SYS                                                   = 0x00000006,
    CLASS_LOGICAL_CARD                                          = 0x00000007,
    CLASS_BATTERY                                               = 0x00000008,
    CLASS_LED                                                   = 0x00000009,
    CLASS_SP                                                    = 0x0000000A,
    CLASS_ASIC                                                  = 0x0000000B,
    CLASS_MAX                                                   = 0x0000000C,
    CLASS_INVALID                                               = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration for DEBUG_ODY_HRESET_CONTROL
 */
enum DEBUG_ODY_HRESET_CONTROL
{
    DEBUG_ODY_HRESET_CONTROL_DEFAULT                            = 0x00000000,
    DEBUG_ODY_HRESET_CONTROL_ONE_HRESET                         = 0x00000001,
    DEBUG_ODY_HRESET_CONTROL_NO_HRESET                          = 0x00000002,
    DEBUG_ODY_HRESET_CONTROL_NO_HRESET_CALL_DUMP                = 0x00000003,
    DEBUG_ODY_HRESET_CONTROL_CALL_DUMP_ON_FAIL                  = 0x00000004,
    DEBUG_ODY_HRESET_CONTROL_INVALID                            = 0x000000FF,
};

/**
 *  @brief Enumeration specifying status of VPD data
 */
enum EECACHE_VPD_STATE
{
    EECACHE_VPD_STATE_VPD_GOOD                                  = 0x00000000,
    EECACHE_VPD_STATE_VPD_NEEDS_REFRESH                         = 0x00000001,
    EECACHE_VPD_STATE_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating a target's eeprom content type. RAW -
 *	eeprom has no specified layout ISDIMM - uses standard JEDEC layout
 *	for DDR memory IBM_FRUVPD - uses ipz converged vpd layout with
 *	records/keywords for generic FRUs IBM_MVPD - use ipz converged vpd
 *	layout with records/keywords for processor modules DDIMM - uses
 *	Differential DIMM layout SBE_BOOT_CODE - SBE code
 *	SBE_MEASUREMENT_CODE - Measurement code WOF_DATA - WOF data
 *	KEYSTORE - Keystore data PLANAR_OCMB_SPD - eeproms found on the
 *	backplane for ocmb SPD
 */
enum EEPROM_CONTENT_TYPE
{
    EEPROM_CONTENT_TYPE_RAW                                     = 0x00000000,
    EEPROM_CONTENT_TYPE_ISDIMM                                  = 0x00000001,
    EEPROM_CONTENT_TYPE_IBM_FRUVPD                              = 0x00000002,
    EEPROM_CONTENT_TYPE_IBM_MVPD                                = 0x00000003,
    EEPROM_CONTENT_TYPE_DDIMM                                   = 0x00000004,
    EEPROM_CONTENT_TYPE_SBE_BOOT_CODE                           = 0x00000005,
    EEPROM_CONTENT_TYPE_SBE_MEASUREMENT_CODE                    = 0x00000006,
    EEPROM_CONTENT_TYPE_WOF_DATA                                = 0x00000007,
    EEPROM_CONTENT_TYPE_KEYSTORE                                = 0x00000008,
    EEPROM_CONTENT_TYPE_PLANAR_OCMB_SPD                         = 0x00000009,
    EEPROM_CONTENT_TYPE_INVALID                                 = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating which VPDs are disabled on a target.
 *	These values can be OR-ed together to make a bitmask.
 */
enum EEPROM_VPD_ACCESSIBILITY
{
    EEPROM_VPD_ACCESSIBILITY_NONE_DISABLED                      = 0x00000000,
    EEPROM_VPD_ACCESSIBILITY_CACHE_DISABLED                     = 0x00000001,
    EEPROM_VPD_ACCESSIBILITY_PRIMARY_DISABLED                   = 0x00000002,
    EEPROM_VPD_ACCESSIBILITY_SECONDARY_DISABLED                 = 0x00000004,
    EEPROM_VPD_ACCESSIBILITY_LAST_DISABLED                      = 0x00000008,
    EEPROM_VPD_ACCESSIBILITY_INVALID                            = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating EEPROM VPD redundancy on a target.
 */
enum EEPROM_VPD_REDUNDANCY
{
    EEPROM_VPD_REDUNDANCY_POSSIBLE                              = 0x00000000,
    EEPROM_VPD_REDUNDANCY_PRESENT                               = 0x00000001,
    EEPROM_VPD_REDUNDANCY_NOT_PRESENT                           = 0x00000002,
    EEPROM_VPD_REDUNDANCY_INVALID                               = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the target's engine type
 */
enum ENGINE_TYPE
{
    ENGINE_TYPE_NA                                              = 0x00000000,
    ENGINE_TYPE_ENGINE_IIC                                      = 0x00000001,
    ENGINE_TYPE_ENGINE_SCOM                                     = 0x00000002,
    ENGINE_TYPE_INVALID                                         = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration defining special FAPI_POS values. FAPI_POS is based
 *	on logical connections to processor chips and is not guaranteed to
 *	be unique.
 */
enum FAPI_POS
{
    FAPI_POS_NA                                                 = 0xFFFFFFFF,
};

/**
 *  @brief Defines presence detection states
 */
enum FOUND_PRESENT_BY_SP
{
    FOUND_PRESENT_BY_SP_NO_ATTEMPT                              = 0x00000000,
    FOUND_PRESENT_BY_SP_FOUND                                   = 0x00000001,
    FOUND_PRESENT_BY_SP_MISSING                                 = 0x00000002,
    FOUND_PRESENT_BY_SP_SKIP                                    = 0x00000003,
    FOUND_PRESENT_BY_SP_INVALID                                 = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the master's FSI type
 */
enum FSI_MASTER_TYPE
{
    FSI_MASTER_TYPE_MFSI                                        = 0x00000000,
    FSI_MASTER_TYPE_CMFSI                                       = 0x00000001,
    FSI_MASTER_TYPE_NO_MASTER                                   = 0x00000002,
    FSI_MASTER_TYPE_INVALID                                     = 0xFFFFFFFF,
};

/**
 *  @brief Enum for FUSED_CORE_MODE_HB
 */
enum FUSED_CORE_MODE_HB
{
    FUSED_CORE_MODE_HB_SMT4_DEFAULT                             = 0x00000000,
    FUSED_CORE_MODE_HB_SMT4_ONLY                                = 0x00000004,
    FUSED_CORE_MODE_HB_SMT8_ONLY                                = 0x00000008,
    FUSED_CORE_MODE_HB_INVALID                                  = 0x000000FF,
};

/**
 *  @brief Enum for FUSED_CORE_OPTION
 */
enum FUSED_CORE_OPTION
{
    FUSED_CORE_OPTION_USING_DEFAULT_CORES                       = 0x00000000,
    FUSED_CORE_OPTION_USING_NORMAL_CORES                        = 0x00000001,
    FUSED_CORE_OPTION_USING_FUSED_CORES                         = 0x00000002,
    FUSED_CORE_OPTION_INVALID                                   = 0x000000FF,
};

/**
 *  @brief Pulled from the MRW, this describes the device purpose to the
 *	HDAT. This is for I2C devices only.
 */
enum HDAT_I2C_DEVICE_PURPOSE
{
    HDAT_I2C_DEVICE_PURPOSE_CABLE_CARD_PRES                     = 0x00000001,
    HDAT_I2C_DEVICE_PURPOSE_PCI_HOTPLUG_PGOOD                   = 0x00000002,
    HDAT_I2C_DEVICE_PURPOSE_PCI_HOTPLUG_CONTROL                 = 0x00000003,
    HDAT_I2C_DEVICE_PURPOSE_TPM                                 = 0x00000004,
    HDAT_I2C_DEVICE_PURPOSE_MODULE_VPD                          = 0x00000005,
    HDAT_I2C_DEVICE_PURPOSE_DIMM_SPD                            = 0x00000006,
    HDAT_I2C_DEVICE_PURPOSE_PROC_MODULE_VPD                     = 0x00000007,
    HDAT_I2C_DEVICE_PURPOSE_SBE_SEEPROM                         = 0x00000008,
    HDAT_I2C_DEVICE_PURPOSE_PLANAR_VPD                          = 0x00000009,
    HDAT_I2C_DEVICE_PURPOSE_NVLINK_CABLE_TOPOLOGY_VERIFICATION  = 0x0000000A,
    HDAT_I2C_DEVICE_PURPOSE_NVLINK                              = 0x0000000B,
    HDAT_I2C_DEVICE_PURPOSE_NVLINK_CABLE_MICRO_RESET            = 0x0000000B,
    HDAT_I2C_DEVICE_PURPOSE_I2C_ASSOC_WITH_NVLINK_CABLE         = 0x0000000C,
    HDAT_I2C_DEVICE_PURPOSE_WINDOW_OPEN                         = 0x0000000D,
    HDAT_I2C_DEVICE_PURPOSE_PHYSICAL_PRESENCE                   = 0x0000000E,
    HDAT_I2C_DEVICE_PURPOSE_MEX_FPGA                            = 0x0000000F,
    HDAT_I2C_DEVICE_PURPOSE_UNKNOWN                             = 0x000000FF,
    HDAT_I2C_DEVICE_PURPOSE_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Pulled from the MRW, this describes the device type to the HDAT.
 *	This is for I2C devices only.
 */
enum HDAT_I2C_DEVICE_TYPE
{
    HDAT_I2C_DEVICE_TYPE_9551                                   = 0x00000001,
    HDAT_I2C_DEVICE_TYPE_955X                                   = 0x00000001,
    HDAT_I2C_DEVICE_TYPE_SEEPROM                                = 0x00000002,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel28c128                    = 0x00000002,
    HDAT_I2C_DEVICE_TYPE_NUVOTON_TPM                            = 0x00000003,
    HDAT_I2C_DEVICE_TYPE_MEX_FPGA                               = 0x00000004,
    HDAT_I2C_DEVICE_TYPE_UCX90XX                                = 0x00000005,
    HDAT_I2C_DEVICE_TYPE_NVLINK                                 = 0x00000006,
    HDAT_I2C_DEVICE_TYPE_9552                                   = 0x00000006,
    HDAT_I2C_DEVICE_TYPE_9553                                   = 0x00000007,
    HDAT_I2C_DEVICE_TYPE_9554                                   = 0x00000008,
    HDAT_I2C_DEVICE_TYPE_9555                                   = 0x00000009,
    HDAT_I2C_DEVICE_TYPE_SMP_or_OpenCAPI_Cable                  = 0x0000000A,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel28c256                    = 0x0000000B,
    HDAT_I2C_DEVICE_TYPE_THERMAL_SENSOR                         = 0x0000000C,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel24c04                     = 0x0000000D,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel24c412                    = 0x0000000E,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel24c32                     = 0x0000000F,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel24c64                     = 0x00000010,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel24c16                     = 0x00000011,
    HDAT_I2C_DEVICE_TYPE_NVDIA_GPU                              = 0x00000012,
    HDAT_I2C_DEVICE_TYPE_NXP_LPC_Microcontroller_LPC11U35       = 0x00000013,
    HDAT_I2C_DEVICE_TYPE_9550                                   = 0x00000014,
    HDAT_I2C_DEVICE_TYPE_TCG_I2C_TPM                            = 0x00000015,
    HDAT_I2C_DEVICE_TYPE_UNKNOWN                                = 0x000000FF,
    HDAT_I2C_DEVICE_TYPE_INVALID                                = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the services that are concerned with
 *	target changes (ie, via HCDB change). The values can be combined
 *	using a bitwise 'OR'.
 */
enum HWAS_CHANGED_BIT
{
    HWAS_CHANGED_BIT_GARD                                       = 0x00000001,
    HWAS_CHANGED_BIT_MEMDIAG                                    = 0x00000002,
    HWAS_CHANGED_BIT_PSIDIAG                                    = 0x00000004,
    HWAS_CHANGED_BIT_DIAG_MASK                                  = 0x00000006,
    HWAS_CHANGED_BIT_HOSTSVC_HBEL                               = 0x00000008,
    HWAS_CHANGED_BIT_RESRC_RECOV                                = 0x00000010,
    HWAS_CHANGED_BIT_GARD_APPLIED                               = 0x00000020,
    HWAS_CHANGED_BIT_DEVTREE_SYNC                               = 0x00000040,
    HWAS_CHANGED_BIT_INVALID                                    = 0xFFFFFFFF,
};

/**
 *  @brief Enum indicating the different possible Key Clear Request values
 *	NOTE: See "Host FW key clear requests" in HDAT spec
 */
enum KEY_CLEAR_REQUEST
{
    KEY_CLEAR_REQUEST_NONE                                      = 0x00000000,
    KEY_CLEAR_REQUEST_ALL                                       = 0x00008000,
    KEY_CLEAR_REQUEST_OS_KEYS                                   = 0x00004000,
    KEY_CLEAR_REQUEST_POWERVM_SYSKEY                            = 0x00001000,
    KEY_CLEAR_REQUEST_RESERVED_1                                = 0x00002C00,
    KEY_CLEAR_REQUEST_MFG_ALL                                   = 0x00000200,
    KEY_CLEAR_REQUEST_MFG                                       = 0x00000100,
    KEY_CLEAR_REQUEST_RESERVED_2                                = 0x000000FF,
    KEY_CLEAR_REQUEST_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief Enum indicating the current Secure Boot key transition state for
 *	the node.
 */
enum KEY_TRANSITION_STATE
{
    KEY_TRANSITION_STATE_KEY_TRANSITION_NOT_REQUESTED           = 0x00000000,
    KEY_TRANSITION_STATE_KEY_TRANSITION_STARTED                 = 0x00000001,
    KEY_TRANSITION_STATE_KEY_TRANSITION_FAILED                  = 0x00000002,
    KEY_TRANSITION_STATE_KEY_TRANSITION_SUCCEEDED               = 0x00000003,
    KEY_TRANSITION_STATE_INVALID                                = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the target's model
 */
enum MODEL
{
    MODEL_NA                                                    = 0x00000000,
    MODEL_RESERVED                                              = 0x00000010,
    MODEL_VENICE                                                = 0x00000011,
    MODEL_MURANO                                                = 0x00000012,
    MODEL_NAPLES                                                = 0x00000013,
    MODEL_NIMBUS                                                = 0x00000014,
    MODEL_CUMULUS                                               = 0x00000015,
    MODEL_AXONE                                                 = 0x00000016,
    MODEL_CENTAUR                                               = 0x00000030,
    MODEL_OCMB                                                  = 0x00000031,
    MODEL_JEDEC                                                 = 0x00000050,
    MODEL_CDIMM                                                 = 0x00000051,
    MODEL_POWER8                                                = 0x00000070,
    MODEL_POWER9                                                = 0x00000090,
    MODEL_POWER10                                               = 0x00000091,
    MODEL_CECTPM                                                = 0x00000092,
    MODEL_BMC                                                   = 0x00000093,
    MODEL_AST2500                                               = 0x00000094,
    MODEL_AST2600                                               = 0x00000095,
    MODEL_PCA9847                                               = 0x00000096,
    MODEL_UCD9090                                               = 0x00000097,
    MODEL_UCD90120A                                             = 0x00000098,
    MODEL_UCD90320                                              = 0x00000099,
    MODEL_INVALID                                               = 0xFFFFFFFF,
};

/**
 *  @brief Memory power control settings for IDLE powersave mode Used by
 *	OCC when entering idle power-save mode
 */
enum MSS_MRW_IDLE_POWER_CONTROL_REQUESTED
{
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_OFF                    = 0x00000000,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_POWER_DOWN             = 0x00000001,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_PD_AND_STR             = 0x00000002,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_PD_AND_STR_CLK_STOP    = 0x00000003,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_INVALID                = 0x000000FF,
};

/**
 *  @brief Memory power control settings programmed during IPL Used by OCC
 *	when exiting idle power-save mode
 */
enum MSS_MRW_POWER_CONTROL_REQUESTED
{
    MSS_MRW_POWER_CONTROL_REQUESTED_OFF                         = 0x00000000,
    MSS_MRW_POWER_CONTROL_REQUESTED_POWER_DOWN                  = 0x00000001,
    MSS_MRW_POWER_CONTROL_REQUESTED_PD_AND_STR                  = 0x00000002,
    MSS_MRW_POWER_CONTROL_REQUESTED_PD_AND_STR_CLK_STOP         = 0x00000003,
    MSS_MRW_POWER_CONTROL_REQUESTED_INVALID                     = 0x000000FF,
};

/**
 *  @brief Used in MR4 A3 Temperature refresh mode Should be defaulted to
 *	disable
 */
enum MSS_MRW_TEMP_REFRESH_MODE
{
    MSS_MRW_TEMP_REFRESH_MODE_DISABLE                           = 0x00000000,
    MSS_MRW_TEMP_REFRESH_MODE_ENABLE                            = 0x00000001,
    MSS_MRW_TEMP_REFRESH_MODE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Enumeration indicating the multi scome buffer size. The values
 *	can be combined using a bitwise 'OR'. The values will need to be
 *	kept in sync with the FAPI enumerator values. Also the enumeration
 *	type is used by the ATTR_MULTI_SCOM_BUFFER_MAX_SIZE. Should note
 *	that the MULTI_SCOM_BUFFER_MAX_SIZE values are of type uint32_t
 */
enum MULTI_SCOM_BUFFER_MAX_SIZE_BIT
{
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_1KB   = 0x00000400,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_2KB   = 0x00000800,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_4KB   = 0x00001000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_8KB   = 0x00002000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_16KB  = 0x00004000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_32KB  = 0x00008000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_64KB  = 0x00010000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_128KB = 0x00020000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_256KB = 0x00040000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_512KB = 0x00080000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_1MB   = 0x00100000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_INVALID                      = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the BAR size used with
 *	ATTR_PROC_NPU_MMIO_BAR_SIZE
 */
enum NPU_MMIO_BAR_SIZE
{
    NPU_MMIO_BAR_SIZE_2_MB                                      = 0x00200000,
    NPU_MMIO_BAR_SIZE_1_MB                                      = 0x00100000,
    NPU_MMIO_BAR_SIZE_512_KB                                    = 0x00080000,
    NPU_MMIO_BAR_SIZE_256_KB                                    = 0x00040000,
    NPU_MMIO_BAR_SIZE_128_KB                                    = 0x00020000,
    NPU_MMIO_BAR_SIZE_64_KB                                     = 0x00010000,
    NPU_MMIO_BAR_SIZE_INVALID                                   = 0xFFFFFFFFFFFFFFFFULL,
};

/**
 *  @brief Describes whether the OCMB firmware running on this device is up
 *	to date or not. This enumeration is used for the various OCMB
 *	Firmware update behaviors.
 */
enum OCMB_FW_STATE
{
    OCMB_FW_STATE_UNKNOWN                                       = 0x00000000,
    OCMB_FW_STATE_UP_TO_DATE                                    = 0x00000001,
    OCMB_FW_STATE_OUT_OF_DATE                                   = 0x00000002,
    OCMB_FW_STATE_INVALID                                       = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration for the various OCMB Firmware update behaviors
 */
enum OCMB_FW_UPDATE_BEHAVIOR
{
    OCMB_FW_UPDATE_BEHAVIOR_CHECK_VERSIONS                      = 0x00000000,
    OCMB_FW_UPDATE_BEHAVIOR_FORCE_UPDATE                        = 0x00000001,
    OCMB_FW_UPDATE_BEHAVIOR_PREVENT_UPDATE                      = 0x00000002,
    OCMB_FW_UPDATE_BEHAVIOR_CHECK_BUT_NO_UPDATE                 = 0x00000003,
    OCMB_FW_UPDATE_BEHAVIOR_MDS_FORCE_UPDATE                    = 0x00000004,
    OCMB_FW_UPDATE_BEHAVIOR_FORCE_UPDATE_ONCE                   = 0x00000005,
    OCMB_FW_UPDATE_BEHAVIOR_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating what kind of payload is to be started
 */
enum PAYLOAD_KIND
{
    PAYLOAD_KIND_UNKNOWN                                        = 0x00000000,
    PAYLOAD_KIND_PHYP                                           = 0x00000001,
    PAYLOAD_KIND_SAPPHIRE                                       = 0x00000002,
    PAYLOAD_KIND_NONE                                           = 0x00000003,
    PAYLOAD_KIND_INVALID                                        = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the OFF setting for the core and cache
 *	chiplet VCS PFET controllers
 */
enum PFET_VCS_VOFF_SEL
{
    PFET_VCS_VOFF_SEL_NOOFF                                     = 0x00000000,
    PFET_VCS_VOFF_SEL_ALLBUT1TO7OFF                             = 0x00000001,
    PFET_VCS_VOFF_SEL_ALLBUT2TO7OFF                             = 0x00000002,
    PFET_VCS_VOFF_SEL_ALLBUT3TO7OFF                             = 0x00000003,
    PFET_VCS_VOFF_SEL_ALLBUT4TO7OFF                             = 0x00000004,
    PFET_VCS_VOFF_SEL_ALLBUT5TO7OFF                             = 0x00000005,
    PFET_VCS_VOFF_SEL_ALLBUT6TO7OFF                             = 0x00000006,
    PFET_VCS_VOFF_SEL_ALLBUT7TO7OFF                             = 0x00000007,
    PFET_VCS_VOFF_SEL_ALLOFF                                    = 0x00000008,
    PFET_VCS_VOFF_SEL_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the OFF setting for the core and cache
 *	chiplet DD PFET controllers
 */
enum PFET_VDD_VOFF_SEL
{
    PFET_VDD_VOFF_SEL_NOOFF                                     = 0x00000000,
    PFET_VDD_VOFF_SEL_ALLBUT1TO7OFF                             = 0x00000001,
    PFET_VDD_VOFF_SEL_ALLBUT2TO7OFF                             = 0x00000002,
    PFET_VDD_VOFF_SEL_ALLBUT3TO7OFF                             = 0x00000003,
    PFET_VDD_VOFF_SEL_ALLBUT4TO7OFF                             = 0x00000004,
    PFET_VDD_VOFF_SEL_ALLBUT5TO7OFF                             = 0x00000005,
    PFET_VDD_VOFF_SEL_ALLBUT6TO7OFF                             = 0x00000006,
    PFET_VDD_VOFF_SEL_ALLBUT7TO7OFF                             = 0x00000007,
    PFET_VDD_VOFF_SEL_ALLOFF                                    = 0x00000008,
    PFET_VDD_VOFF_SEL_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration specifying the compatibility setting for Processor
 *	ECs ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed
 *	FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level
 *	FORCED_NATIVE = set RISK_LEVEL to ECs native setting
 */
enum PROC_COMPATIBILITY_REQ
{
    PROC_COMPATIBILITY_REQ_ALLOW_COMPATIBILITY                  = 0x00000000,
    PROC_COMPATIBILITY_REQ_FORCED_COMPATIBILITY                 = 0x00000001,
    PROC_COMPATIBILITY_REQ_FORCED_NATIVE                        = 0x00000002,
    PROC_COMPATIBILITY_REQ_INVALID                              = 0xFFFFFFFF,
};

/**
 *  @brief Processor epsilon table type. Used to calculate the processor
 *	nest epsilon register values. Provided by the MRW.
 */
enum PROC_EPS_TABLE_TYPE
{
    PROC_EPS_TABLE_TYPE_EPS_TYPE_LE                             = 0x00000001,
    PROC_EPS_TABLE_TYPE_EPS_TYPE_MR                             = 0x00000002,
    PROC_EPS_TABLE_TYPE_EPS_TYPE_HE                             = 0x00000003,
    PROC_EPS_TABLE_TYPE_INVALID                                 = 0x000000FF,
};

/**
 *  @brief Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH
 */
enum PROC_FABRIC_A_BUS_WIDTH
{
    PROC_FABRIC_A_BUS_WIDTH_2_BYTE                              = 0x00000001,
    PROC_FABRIC_A_BUS_WIDTH_4_BYTE                              = 0x00000002,
    PROC_FABRIC_A_BUS_WIDTH_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the PROC_FABRIC_CAPI_MODE
 */
enum PROC_FABRIC_CAPI_MODE
{
    PROC_FABRIC_CAPI_MODE_OFF                                   = 0x00000000,
    PROC_FABRIC_CAPI_MODE_ON                                    = 0x00000001,
    PROC_FABRIC_CAPI_MODE_INVALID                               = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE
 */
enum PROC_FABRIC_SMP_OPTICS_MODE
{
    PROC_FABRIC_SMP_OPTICS_MODE_OPTICS_IS_X_BUS                 = 0x00000000,
    PROC_FABRIC_SMP_OPTICS_MODE_OPTICS_IS_A_BUS                 = 0x00000001,
    PROC_FABRIC_SMP_OPTICS_MODE_INVALID                         = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH
 */
enum PROC_FABRIC_X_BUS_WIDTH
{
    PROC_FABRIC_X_BUS_WIDTH_2_BYTE                              = 0x00000001,
    PROC_FABRIC_X_BUS_WIDTH_4_BYTE                              = 0x00000002,
    PROC_FABRIC_X_BUS_WIDTH_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the role of proc as
 *	master/alt_master/not_master
 */
enum PROC_MASTER_TYPE
{
    PROC_MASTER_TYPE_ACTING_MASTER                              = 0x00000000,
    PROC_MASTER_TYPE_MASTER_CANDIDATE                           = 0x00000001,
    PROC_MASTER_TYPE_NOT_MASTER                                 = 0x00000002,
    PROC_MASTER_TYPE_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Enumeration for processor module type that come from HDAT spec
 *	0x0050 – P10 with Godel bus mapping 0x0051 – P10 with Blaise bus
 *	mapping 0x0052 – P11 with Godel bus mapping 0x0053 – P11 with
 *	Blaise bus mapping
 */
enum PROC_MODULE_TYPE
{
    PROC_MODULE_TYPE_GODEL                                      = 0x00000050,
    PROC_MODULE_TYPE_BLAISE                                     = 0x00000051,
    PROC_MODULE_TYPE_P11_GODEL                                  = 0x00000052,
    PROC_MODULE_TYPE_P11_BLAISE                                 = 0x00000053,
    PROC_MODULE_TYPE_INVALID                                    = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating which _PBIEX_ASYNC_SEL should be use
 */
enum PROC_PBIEX_ASYNC_SEL
{
    PROC_PBIEX_ASYNC_SEL_SEL0                                   = 0x00000000,
    PROC_PBIEX_ASYNC_SEL_SEL1                                   = 0x00000001,
    PROC_PBIEX_ASYNC_SEL_SEL2                                   = 0x00000002,
    PROC_PBIEX_ASYNC_SEL_INVALID                                = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating which chip should be used as the
 *	PROC_SELECT_BOOT_MASTER
 */
enum PROC_SELECT_BOOT_MASTER
{
    PROC_SELECT_BOOT_MASTER_PRIMARY                             = 0x00000001,
    PROC_SELECT_BOOT_MASTER_SECONDARY                           = 0x00000002,
    PROC_SELECT_BOOT_MASTER_INVALID                             = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating which SEEPROM image should be used to
 *	boot a processor
 */
enum PROC_SELECT_BOOT_SEEPROM_IMAGE
{
    PROC_SELECT_BOOT_SEEPROM_IMAGE_FIRST                        = 0x00000001,
    PROC_SELECT_BOOT_SEEPROM_IMAGE_SECOND                       = 0x00000002,
    PROC_SELECT_BOOT_SEEPROM_IMAGE_INVALID                      = 0x000000FF,
};

/**
 *  @brief Enumeration indicating which SEEPROM image should be used for
 *	the boot master
 */
enum PROC_SELECT_SEEPROM_IMAGE
{
    PROC_SELECT_SEEPROM_IMAGE_FIRST                             = 0x00000001,
    PROC_SELECT_SEEPROM_IMAGE_SECOND                            = 0x00000002,
    PROC_SELECT_SEEPROM_IMAGE_INVALID                           = 0x000000FF,
};

/**
 *  @brief Enumeration specifying what was used to setup the RISK_LEVEL
 */
enum RISK_LEVEL_ORIGIN
{
    RISK_LEVEL_ORIGIN_USER                                      = 0x00000000,
    RISK_LEVEL_ORIGIN_MRW                                       = 0x00000001,
    RISK_LEVEL_ORIGIN_INVALID                                   = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indication which Hot Plug Controllers are supported
 *	by the current system.
 */
enum SUPPORTED_HOT_PLUG
{
    SUPPORTED_HOT_PLUG_NA                                       = 0x00000000,
    SUPPORTED_HOT_PLUG_MAX5961                                  = 0x00000001,
    SUPPORTED_HOT_PLUG_PCA9551                                  = 0x00000002,
    SUPPORTED_HOT_PLUG_INVALID                                  = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating what role this chip has in tod topology
 */
enum TOD_ROLE
{
    TOD_ROLE_NON_MASTER                                         = 0x00000000,
    TOD_ROLE_PRIMARY                                            = 0x00000001,
    TOD_ROLE_SECONDARY                                          = 0x00000002,
    TOD_ROLE_INVALID                                            = 0x000000FF,
};

/**
 *  @brief Enumeration indicating the target's type
 */
enum TYPE
{
    TYPE_NA                                                     = 0x00000000,
    TYPE_SYS                                                    = 0x00000001,
    TYPE_NODE                                                   = 0x00000002,
    TYPE_DIMM                                                   = 0x00000003,
    TYPE_MEMBUF                                                 = 0x00000004,
    TYPE_PROC                                                   = 0x00000005,
    TYPE_EX                                                     = 0x00000006,
    TYPE_CORE                                                   = 0x00000007,
    TYPE_L2                                                     = 0x00000008,
    TYPE_L3                                                     = 0x00000009,
    TYPE_L4                                                     = 0x0000000A,
    TYPE_MCS                                                    = 0x0000000B,
    TYPE_MBA                                                    = 0x0000000D,
    TYPE_XBUS                                                   = 0x0000000E,
    TYPE_ABUS                                                   = 0x0000000F,
    TYPE_PCI                                                    = 0x00000010,
    TYPE_DPSS                                                   = 0x00000011,
    TYPE_APSS                                                   = 0x00000012,
    TYPE_OCC                                                    = 0x00000013,
    TYPE_PSI                                                    = 0x00000014,
    TYPE_FSP                                                    = 0x00000015,
    TYPE_PNOR                                                   = 0x00000016,
    TYPE_OSC                                                    = 0x00000017,
    TYPE_TODCLK                                                 = 0x00000018,
    TYPE_CONTROL_NODE                                           = 0x00000019,
    TYPE_OSCREFCLK                                              = 0x0000001A,
    TYPE_OSCPCICLK                                              = 0x0000001B,
    TYPE_REFCLKENDPT                                            = 0x0000001C,
    TYPE_PCICLKENDPT                                            = 0x0000001D,
    TYPE_NX                                                     = 0x0000001E,
    TYPE_PORE                                                   = 0x0000001F,
    TYPE_PCIESWITCH                                             = 0x00000020,
    TYPE_CAPP                                                   = 0x00000021,
    TYPE_FSI                                                    = 0x00000022,
    TYPE_EQ                                                     = 0x00000023,
    TYPE_MCA                                                    = 0x00000024,
    TYPE_MCBIST                                                 = 0x00000025,
    TYPE_MI                                                     = 0x00000026,
    TYPE_DMI                                                    = 0x00000027,
    TYPE_OBUS                                                   = 0x00000028,
    TYPE_SBE                                                    = 0x0000002A,
    TYPE_PPE                                                    = 0x0000002B,
    TYPE_PERV                                                   = 0x0000002C,
    TYPE_PEC                                                    = 0x0000002D,
    TYPE_PHB                                                    = 0x0000002E,
    TYPE_SYSREFCLKENDPT                                         = 0x0000002F,
    TYPE_MFREFCLKENDPT                                          = 0x00000030,
    TYPE_TPM                                                    = 0x00000031,
    TYPE_SP                                                     = 0x00000032,
    TYPE_UART                                                   = 0x00000033,
    TYPE_PS                                                     = 0x00000034,
    TYPE_FAN                                                    = 0x00000035,
    TYPE_VRM                                                    = 0x00000036,
    TYPE_USB                                                    = 0x00000037,
    TYPE_ETH                                                    = 0x00000038,
    TYPE_PANEL                                                  = 0x00000039,
    TYPE_BMC                                                    = 0x0000003A,
    TYPE_FLASH                                                  = 0x0000003B,
    TYPE_SEEPROM                                                = 0x0000003C,
    TYPE_TMP                                                    = 0x0000003D,
    TYPE_GPIO_EXPANDER                                          = 0x0000003E,
    TYPE_POWER_SEQUENCER                                        = 0x0000003F,
    TYPE_RTC                                                    = 0x00000040,
    TYPE_FANCTLR                                                = 0x00000041,
    TYPE_OBUS_BRICK                                             = 0x00000042,
    TYPE_NPU                                                    = 0x00000043,
    TYPE_MC                                                     = 0x00000044,
    TYPE_TEST_FAIL                                              = 0x00000045,
    TYPE_MFREFCLK                                               = 0x00000046,
    TYPE_SMPGROUP                                               = 0x00000047,
    TYPE_OMI                                                    = 0x00000048,
    TYPE_MCC                                                    = 0x00000049,
    TYPE_OMIC                                                   = 0x0000004A,
    TYPE_OCMB_CHIP                                              = 0x0000004B,
    TYPE_MEM_PORT                                               = 0x0000004C,
    TYPE_I2C_MUX                                                = 0x0000004D,
    TYPE_PMIC                                                   = 0x0000004E,
    TYPE_NMMU                                                   = 0x0000004F,
    TYPE_PAU                                                    = 0x00000050,
    TYPE_IOHS                                                   = 0x00000051,
    TYPE_PAUC                                                   = 0x00000052,
    TYPE_FC                                                     = 0x00000053,
    TYPE_LPCREFCLKENDPT                                         = 0x00000054,
    TYPE_GENERIC_I2C_DEVICE                                     = 0x00000055,
    TYPE_MDS_CTLR                                               = 0x00000056,
    TYPE_DCM                                                    = 0x00000057,
    TYPE_POWER_IC                                               = 0x00000066,
    TYPE_TEMP_SENSOR                                            = 0x00000067,
    TYPE_LAST_IN_RANGE                                          = 0x00000068,
    TYPE_INVALID                                                = 0x0000007F,
};

/**
 *  @brief Enumeration for Voltage Drop Monitor enable
 */
enum VDM_ENABLE
{
    VDM_ENABLE_OFF                                              = 0x00000000,
    VDM_ENABLE_ON                                               = 0x00000001,
    VDM_ENABLE_INVALID                                          = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration to select WOF Power Limit
 */
enum WOF_POWER_LIMIT
{
    WOF_POWER_LIMIT_NOMINAL                                     = 0x00000000,
    WOF_POWER_LIMIT_TURBO                                       = 0x00000001,
    WOF_POWER_LIMIT_INVALID                                     = 0x000000FF,
};

/**
 *  @brief This attribute will keep the SBE state , and can be referred to
 *	determine if operations are possible on SBE or not
 */
enum SBE_STATE
{
    SBE_STATE_NOT_USABLE                                        = 0x00000000,
    SBE_STATE_BOOTED                                            = 0x00000001,
    SBE_STATE_CHECK_CFAM                                        = 0x00000002,
    SBE_STATE_DEBUG_MODE                                        = 0x00000003,
    SBE_STATE_FAILED                                            = 0x00000004,
    SBE_STATE_UNKNOWN                                           = 0x00000005,
    SBE_STATE_INVALID                                           = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the payload state
 */
enum PAYLOAD_STATE
{
    PAYLOAD_STATE_NOT_LOADED                                    = 0x00000000,
    PAYLOAD_STATE_RUNNING                                       = 0x00000001,
    PAYLOAD_STATE_STOPPED                                       = 0x00000002,
    PAYLOAD_STATE_INVALID                                       = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the PSI target link state
 */
enum PSI_LINK_STATE
{
    PSI_LINK_STATE_NOT_ACTIVE                                   = 0x00000000,
    PSI_LINK_STATE_ACTIVE                                       = 0x00000001,
    PSI_LINK_STATE_CANDIDATE                                    = 0x00000002,
    PSI_LINK_STATE_INVALID                                      = 0xFFFFFFFF,
};

/**
 *  @brief Enumeration indicating the FSI Mailbox DMA state.
 */
enum FMBX_DMA_STATE
{
    FMBX_DMA_STATE_REJECT_DMA                                   = 0x00000000,
    FMBX_DMA_STATE_DMA_VIA_FSI                                  = 0x00000001,
    FMBX_DMA_STATE_DMA_VIA_PSI                                  = 0x00000002,
    FMBX_DMA_STATE_INVALID                                      = 0xFFFFFFFF,
};

/**
 *  @brief Indicates the PNOR side that was successfully opened earlier
 */
enum PNOR_PARTITION_SIDE
{
    PNOR_PARTITION_SIDE_SIDEA                                   = 0x00000001,
    PNOR_PARTITION_SIDE_SIDEB                                   = 0x00000002,
    PNOR_PARTITION_SIDE_INVALID                                 = 0x00000000,
};

/**
 *  @brief Enumeration for SPL_WAKEUP_STATE attribute
 */
enum SPL_WAKEUP_STATE
{
    SPL_WAKEUP_STATE_DISABLE                                    = 0x00000001,
    SPL_WAKEUP_STATE_ENABLE                                     = 0x00000000,
    SPL_WAKEUP_STATE_INVALID                                    = 0xFFFFFFFF,
};

/**
 *  @brief Version of DDR DIMM
 */
enum SPD_DRAM_DIMM_DEVICE_TYPE
{
    SPD_DRAM_DIMM_DEVICE_TYPE_NONE                              = 0x00000000,
    SPD_DRAM_DIMM_DEVICE_TYPE_DDR3                              = 0x0000000B,
    SPD_DRAM_DIMM_DEVICE_TYPE_DDR4                              = 0x0000000C,
    SPD_DRAM_DIMM_DEVICE_TYPE_DDR5                              = 0x00000012,
    SPD_DRAM_DIMM_DEVICE_TYPE_INVALID                           = 0xFFFFFFFF,
};

/**
 *  @brief This attribute is to indicate the primary source
 *	oscillator(MFREFCLK) for multi-reference clock used for clocking
 *	PCI and TOD.
 */
enum PRIMARY_MF_CLOCK
{
    PRIMARY_MF_CLOCK_BOTH_SRC0                                  = 0x00000000,
    PRIMARY_MF_CLOCK_BOTH_SRC1                                  = 0x00000001,
    PRIMARY_MF_CLOCK_SRC0                                       = 0x00000002,
    PRIMARY_MF_CLOCK_SRC1                                       = 0x00000003,
    PRIMARY_MF_CLOCK_SRC_NONE                                   = 0x00000004,
    PRIMARY_MF_CLOCK_INVALID                                    = 0xFFFFFFFF,
};

/**
 *  @brief This attribute is to notify if the current system has redundant
 *	multi-freq clock oscillator or not.
 */
enum REDUNDANT_MF_CLOCKS
{
    REDUNDANT_MF_CLOCKS_TRUE                                    = 0x00000001,
    REDUNDANT_MF_CLOCKS_FALSE                                   = 0x00000000,
    REDUNDANT_MF_CLOCKS_INVALID                                 = 0xFFFFFFFF,
};

/**
 *  @brief Indicates which sublinks should be initialized/trained
 */
enum LINK_TRAIN
{
    LINK_TRAIN_BOTH                                             = 0x00000000,
    LINK_TRAIN_EVEN_ONLY                                        = 0x00000001,
    LINK_TRAIN_ODD_ONLY                                         = 0x00000002,
    LINK_TRAIN_NONE                                             = 0x00000003,
    LINK_TRAIN_INVALID                                          = 0x000000FF,
};

/**
 *  @brief DRAM Device Type. Located in DDR3/DDR4 SPD byte 2.
 */
enum CEN_SPD_DRAM_DEVICE_TYPE
{
    CEN_SPD_DRAM_DEVICE_TYPE_DDR3                               = 0x0000000B,
    CEN_SPD_DRAM_DEVICE_TYPE_DDR4                               = 0x0000000C,
    CEN_SPD_DRAM_DEVICE_TYPE_DDR5                               = 0x00000012,
    CEN_SPD_DRAM_DEVICE_TYPE_INVALID                            = 0x000000FF,
};

/**
 *  @brief Attribute to control the cache inject mode. DISABLE_CI = 0x0 -
 *	Disable cache inject completely. (Reset value default) P7_STYLE_CI
 *	= 0x1 - Use cache inject design from Power7. PCITLP_STYLE_CI = 0x2
 *	- Use PCI TLP Hint bits in packet to perform the cache inject.
 *	P9_STYLE_CI = 0x3 - Initial attempt as cache inject. Power9 style.
 *	(Attribute default) Different cache inject modes will affect DMA
 *	write performance. The attribute default was selected based on
 *	various workloads and was the most optimal setting for Power9.
 */
enum PROC_PCIE_CACHE_INJ_MODE
{
    PROC_PCIE_CACHE_INJ_MODE_DISABLE_CI                         = 0x00000000,
    PROC_PCIE_CACHE_INJ_MODE_P7_STYLE_CI                        = 0x00000001,
    PROC_PCIE_CACHE_INJ_MODE_PCITLP_STYLE_CI                    = 0x00000002,
    PROC_PCIE_CACHE_INJ_MODE_P9_STYLE_CI                        = 0x00000003,
    PROC_PCIE_CACHE_INJ_MODE_INVALID                            = 0x000000FF,
};

} // End namespace TARGETING

#endif // TARG_ATTRIBUTEENUMS_H

