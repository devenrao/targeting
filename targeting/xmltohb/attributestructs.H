
#ifndef TARG_ATTRIBUTESTRUCTS_H
#define TARG_ATTRIBUTESTRUCTS_H

/**
 *  @file attributestructs.H
 *
 *  @brief Complex structures for host boot attributes.  This file is
 *      autogenerated and should not be altered.
 */

//******************************************************************************
// Includes
//******************************************************************************

// STD
#include <stdint.h>
#include <stdlib.h>

// Targeting component
#include <builtins.h>
#include <targeting/common/attributes.H>
#include <targeting/common/entitypath.H>

//******************************************************************************
// Complex Types
//******************************************************************************

namespace TARGETING
{

/**
 *  @brief Structure which defines a they IPL types Applicable for System
 *	target only.
 */
struct CecIplType
{
    // Perform mainstore dump collection. Only valid for MPIPL 0b0: Do not
    // collect mainstore dump 0b1: Perform mainstore dump collection
    uint8_t PostDump : 1; 

    // Minor IPL Type
    uint8_t MinorIPLType : 7; 

} PACKED;

/**
 *  @brief Structure which defines what Explorer logs to grab Prefixes:
 *	early = early in the IPL late = later in the IPL
 */
struct DebugOcmbLogs
{
    // Grab Saved Log from Image A side (SPI flash data) 0b0: Do not
    // collect log 0b1: Collect the log
    uint8_t earlySavedLogA : 1; 

    // Grab Saved Log from Image B side (SPI flash data) 0b0: Do not
    // collect log 0b1: Collect the log
    uint8_t earlySavedLogB : 1; 

    // Grab Active log (RAM data) 0b0: Do not collect log 0b1: Collect the
    // log
    uint8_t earlyActiveLog : 1; 

    // Reserved for future expansion
    uint8_t earlyReserved : 1; 

    // Grab Saved Log from Image A side (SPI flash data) 0b0: Do not
    // collect log 0b1: Collect the log
    uint8_t lateSavedLogA : 1; 

    // Grab Saved Log from Image B side (SPI flash data) 0b0: Do not
    // collect log 0b1: Collect the log
    uint8_t lateSavedLogB : 1; 

    // Grab Active log (RAM data) 0b0: Do not collect log 0b1: Collect the
    // log
    uint8_t lateActiveLog : 1; 

    // Reserved for future expansion
    uint8_t lateReserved : 1; 

} PACKED;

/**
 *  @brief Structure to define the addressing for NV controller.
 */
struct EepromNvInfo
{
    // Entity path to the chip that contains the I2C master.
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value, but then
    // shifted 2 bits left.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value, but then shifted 6 bits
    // left.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset. For NV controller it's only one byte addressing with
    // no page select (3) 0 = Zero Byte Addressing 1 = One Byte Addressing
    // with page select 2 = Two Byte Addressing 3 = OneByte Addressing with
    // no page select
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The number of chips making up an eeprom device.
    uint8_t chipCount; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct EepromSbeBackupInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The number of chips making up an eeprom device.
    uint8_t chipCount; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct EepromSbePrimaryInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The number of chips making up an eeprom device.
    uint8_t chipCount; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached I2C eeprom
 *	device that contains secondary VPD info.
 */
struct EepromVpdBackupInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The number of chips making up an eeprom device.
    uint8_t chipCount; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

    // Indicates the target's eeprom content type
    uint32_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached I2C eeprom
 *	device that contains primary VPD info.
 */
struct EepromVpdPrimaryInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset. DDR4 DIMMs require a special EEPROM page switching
    // mechanic denoted here by a value of 1 0 = Zero Byte Addressing 1 =
    // One Byte Addressing with page select 2 = Two Byte Addressing 3 =
    // OneByte Addressing with no page select
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The number of chips making up an eeprom device.
    uint8_t chipCount; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

    // Indicates the target's eeprom content type
    uint32_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define addressing this I2C slave device.
 */
struct FapiI2cControlInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

} PACKED;

/**
 *  @brief FSI flags
 */
struct FsiOptionFlags
{
    // Set on FSI master chips (procs) if that chip uses slaveB to attach
    // to the acting master chip.
    uint16_t flipPort : 1; 

    // Reserved for future expansion
    uint16_t reserved : 15; 

} PACKED;

/**
 *  @brief Structure which defines a system's HB settings. Applicable for
 *	System target only.
 */
struct HbSettings
{
    // Enable / Disable continuous trace. 0b0: Continuous trace is
    // disabled. 0b1: Continuous trace is enabled.
    uint8_t traceContinuous : 1; 

    // Override trace debug selection for SCAN component. 0b0: TRACS
    // entries for SCAN have default behavior. 0b1: TRACS entries for SCAN
    // are enabled.
    uint8_t traceScanDebug : 1; 

    // Override trace debug selection for DBG component. 0b0: TRACS entries
    // for DBG have default behavior. 0b1: TRACS entries for DBG are
    // enabled.
    uint8_t traceFapiDebug : 1; 

    // Reserved for future use
    uint8_t reserved : 5; 

} PACKED;

/**
 *  @brief Structure consisting of an EID (or reason), 6 booleans, and 2
 *	reserved bits
 */
struct HwasState
{
    // If this target was deconfigured, this will be a special
    // DECONFIGURED_BY_ enum, OR it will be the errlog EID that caused it,
    // either directly or by association,
    uint32_t deconfiguredByEid; 

    // 0b0: Target is not powered on (is off); 0b1: Target is powered on;
    uint8_t poweredOn : 1; 

    // 0b0: Target is not present in the system; 0b1: Target is present in
    // the system
    uint8_t present : 1; 

    // 0b0: Target is not functional; 0b1: Target is functional
    uint8_t functional : 1; 

    // FSP Only, used by DUMP applet; 0b0: target is dump capabile; 0b1:
    // target is not dump capabile;
    uint8_t dumpfunctional : 1; 

    // Set for speculative deconfig; 0b0: target is not speculatively
    // deconfigured; 0b1: target is speculatively deconfigured;
    uint8_t specdeconfig : 1; 

    // If a core was deconfigured due to Field Core Override (FCO) set this
    // bit. This is used by HB and BMC during reconfig loops to treat cores
    // deconfigured by FCO as functional. 0b0: leave target functional bit
    // unchanged during reconfig loops 0b1: set target functional bit to 1
    // during reconfig loops
    uint8_t functionalOverride : 1; 

    // Reserved for future use
    uint8_t reserved : 2; 

} PACKED;

/**
 *  @brief Structure consisting of an EID (or reason), 6 booleans, and 2
 *	reserved bits
 */
struct HwasStateTestsave
{
    // 0b0: Target is not powered on (is off); 0b1: Target is powered on;
    uint8_t poweredOn : 1; 

    // 0b0: Target is not present in the system; 0b1: Target is present in
    // the system
    uint8_t present : 1; 

    // 0b0: Target is not functional; 0b1: Target is functional
    uint8_t functional : 1; 

    // FSP Only, used by DUMP applet; 0b0: target is dump capabile; 0b1:
    // target is not dump capabile;
    uint8_t dumpfunctional : 1; 

    // Set for speculative deconfig; 0b0: target is not speculatively
    // deconfigured; 0b1: target is speculatively deconfigured;
    uint8_t specdeconfig : 1; 

    // If a core was deconfigured due to Field Core Override (FCO) set this
    // bit. This is used by HB and BMC during reconfig loops to treat cores
    // deconfigured by FCO as functional. 0b0: leave target functional bit
    // unchanged during reconfig loops 0b1: set target functional bit to 1
    // during reconfig loops
    uint8_t functionalOverride : 1; 

    // Reserved for future use
    uint8_t reserved : 2; 

} PACKED;

/**
 *  @brief Structure to define addressing this I2C slave device.
 */
struct I2cControlInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // Determines which of the N selectable buses the I2C mux for this
    // device must enable to connect this device to its I2C master, if
    // applicable. 0xFF indicates no I2C mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path of the I2C mux for this device, if any.
    EntityPath i2cMuxPath; 

} PACKED;

/**
 *  @brief Structure which defines which I2C access method to use at a
 *	point in time. Only applicable if target supports one or more I2C
 *	types. Only one bit (of the first two) can ever be set at any one
 *	time.
 */
struct I2cSwitches
{
    // 0b0: Do not use FSI I2C at this time. 0b1: Use FSI I2C at this time
    uint8_t useFsiI2C : 1; 

    // 0b0: Do not use Host I2C at this time. 0b1: Use Host I2C at this
    // time
    uint8_t useHostI2C : 1; 

    // Reserved for future expansion
    uint8_t reserved : 6; 

} PACKED;

/**
 *  @brief Numeric POD type test structure
 */
struct NumericPodTypeTest
{
    // Entity path for testing purposes
    EntityPath fsiPath; 

    // Class for testing purposes
    CLASS className; 

    // Test uint8
    uint8_t uint8; 

    // Test uint16
    uint16_t uint16; 

    // Test uint32
    uint32_t uint32; 

    // Test uint64
    uint64_t uint64; 

    // Test int8
    int8_t int8; 

    // Test int16
    int16_t int16; 

    // Test int32
    int32_t int32; 

    // Test int64
    int64_t int64; 

} PACKED;

/**
 *  @brief Armed State
 */
struct NvdimmArmed
{
    // Is NVDIMM armed
    uint8_t armed : 1; 

    // NVDIMM controller error detected
    uint8_t error_detected : 1; 

    // Reserved for future use
    uint8_t reserved : 6; 

} PACKED;

/**
 *  @brief Structure which defines update status
 */
struct OcmbFwUpdateStatus
{
    // 0b0: No update necessary 0b1: At least one explorer needs update
    uint8_t updateRequired : 1; 

    // Update via I2C 0b0: Next update via MMIO (default) 0b1: Next update
    // via I2C
    uint8_t updateI2c : 1; 

    // 0b0: I2C update not done 0b1: I2C update has been attempted
    uint8_t i2cUpdateAttempted : 1; 

    // 0b0: I2C update still available to try 0b1: Hard failure (failure
    // after I2C update)
    uint8_t hardFailure : 1; 

    // Reserved for future use
    uint8_t reserved : 4; 

} PACKED;

/**
 *  @brief Structure which defines a target's deconfigure rules. Structure
 *	is read-only.
 */
struct ParentDeconfigRules
{
    // Are the rule bits set correctly?
    uint8_t valid : 1; 

    // 0b0: Target should NOT be deconfigured by child rollup 0b1: Target
    // allowed to be deconfigured by child rollup
    uint8_t childRollupAllowed : 1; 

    // 0b0: Target should NOT rollup its deconfigure to its parent 0b1:
    // Target should deconfigure its parent if no more functioning children
    // of same type exist for its parent
    uint8_t deconfigureParent : 1; 

    // Reserved for future use
    uint8_t reserved : 5; 

} PACKED;

/**
 *  @brief Structure which defines a target's primary capabilities. A
 *	target can only support at most FSI SCOM and one of the other two
 *	SCOM types. Applicable for all targets. Structure is read-only.
 */
struct PrimaryCapabilities
{
    // 0b0: Target does not support FSI SCOM; 0b1: Target supports FSI SCOM
    uint8_t supportsFsiScom : 1; 

    // 0b0: Target does not support XSCOM; 0b1: Target supports FSI XSCOM
    uint8_t supportsXscom : 1; 

    // 0b0: Target does not support inband SCOM
    uint8_t supportsInbandScom : 1; 

    // Reserved for future use
    uint8_t reserved : 5; 

} PACKED;

/**
 *  @brief Structure which defines which SCOM to use at a point in time.
 *	Only applicable if target supports one or more SCOM types. Only one
 *	bit (of the first three) can ever be set at any one time.
 */
struct ScomSwitches
{
    // 0b0: Do not use FSI SCOM at this time. 0b1: Use FSI SCOM at this
    // time
    uint8_t useFsiScom : 1; 

    // 0b0: Do not use XSCOM at this time. 0b1: Use XSCOM at this time
    uint8_t useXscom : 1; 

    // 0b0: Do not use inband SCOM at this time. 0b1: Use inband SCOM at
    // this time
    uint8_t useInbandScom : 1; 

    // 0b0: Do not use SBE SCOM at this time. 0b1: Use SBE SCOM at this
    // time
    uint8_t useSbeScom : 1; 

    // 0b0: Do not use I2C SCOM at this time. 0b1: Use I2C SCOM at this
    // time
    uint8_t useI2cScom : 1; 

    // 0b0: Do not use SPI FSI SCOM at this time. 0b1: Use SPI FSI SCOM at
    // this time
    uint8_t useSpiFsiScom : 1; 

    // Reserved for future expansion
    uint8_t reserved : 2; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains SPARE info.
 */
struct SpiEepromSpareInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of SPARE data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of SPARE data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains backup VPD info, SBE measurement code, and
 *	Keystore.
 */
struct SpiEepromVpdBackupInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Offset of the section (always 0 for hardware device)
    uint16_t dataOffsetKB; 

    // The size of the EEPROM in kilobytes
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains backup VPD info, SBE measurement code, and WOF
 *	data.
 */
struct SpiEepromVpdPrimaryInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Offset of the section (always 0 for hardware device)
    uint16_t dataOffsetKB; 

    // The size of the EEPROM in kilobytes
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains keystore info for HOSTBOOT.
 */
struct SpiKeystoreInfoHostboot
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of keystore data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of keystore data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains the first partition of keystore info for OPAL.
 */
struct SpiKeystoreInfoOpal0
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of keystore data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of keystore data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains the second partition of keystore info for
 *	OPAL.
 */
struct SpiKeystoreInfoOpal1
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of keystore data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of keystore data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains the third partition of keystore info for OPAL.
 */
struct SpiKeystoreInfoOpal2
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of keystore data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of keystore data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains keystore info for PHYP.
 */
struct SpiKeystoreInfoPhyp
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of keystore data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of keystore data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains backup VPD info.
 */
struct SpiMvpdBackupInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of VPD data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of BACKUP VPD data in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains primary VPD info.
 */
struct SpiMvpdPrimaryInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of VPD data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of PRIMARY VPD in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains backup SBE boot code.
 */
struct SpiSbeBootCodeBackupInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of backup SBE boot code in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of backup SBE boot code in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains primary SBE boot code.
 */
struct SpiSbeBootCodePrimaryInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of primary SBE boot code in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of primary SBE boot code in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains the backup SBE measurement code.
 */
struct SpiSbeMeasurementCodeBackupInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of SBE measurement code in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of SBE measurement code in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains the primary SBE measurement code.
 */
struct SpiSbeMeasurementCodePrimaryInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of SBE measurement code in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of SBE measurement code in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure which defines which SPI access method to use at a
 *	point in time. Only one bit (of the first two) can ever be set at
 *	any one time.
 */
struct SpiSwitches
{
    // 0b0: Do not use FSI SPI at this time. 0b1: Use FSI SPI at this time
    uint8_t useFsiSPI : 1; 

    // 0b0: Do not use PIB SPI at this time. 0b1: Use PIB SPI at this time
    uint8_t usePibSPI : 1; 

    // Reserved for future expansion
    uint8_t reserved : 6; 

} PACKED;

/**
 *  @brief Structure to define the addressing of an attached TPM chip via
 *	SPI.
 */
struct SpiTpmInfo
{
    // Entity path to the chip that contains the SPI engine that drives the
    // TPM. When the SPI_TPM_INFO object is being used, only this field
    // should be edited. All the other fields do not change regardless of
    // P10 system.
    EntityPath spiMasterPath; 

    // SPI engine for TPM
    uint8_t engine; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an attached SPI eeprom
 *	device that contains WOF data.
 */
struct SpiWofDataInfo
{
    // Entity path to the chip that contains the SPI master
    EntityPath spiMasterPath; 

    // SPI master engine
    uint8_t engine; 

    // Starting offset (in KB) of WOF data in EEPROM
    uint16_t dataOffsetKB; 

    // The number of kilobytes of WOF data + ECC in EEPROM
    uint16_t dataSizeKB; 

    // Indicates the target's eeprom content type
    uint8_t eepromContentType; 

} PACKED;

/**
 *  @brief Structure which defines a system's SP functions. Applicable for
 *	System target only. Structure is read-only. Default values match
 *	OpenBMC implementation.
 */
struct SpFunctions
{
    // If this flag is set then mailboxEnabled MUST also be set 0b0: SP
    // does not support for VPD, payload, ATTR sync, VDDR, TOD; 0b1: SP
    // supports VPD, payload, ATTR sync, VDDR, TOD
    uint32_t baseServices : 1; 

    // 0b0: SP does not initialize FSI slave logic, Hostboot must; 0b1: SP
    // does initialize FSI slave logic so Hostboot should not
    uint32_t fsiSlaveInit : 1; 

    // 0b0: There is no SP mailbox support; 0b1: There is SP mailbox
    // support
    uint32_t mailboxEnabled : 1; 

    // 0b0: SP does not initialize FSI master logic, Hostboot must; 0b1: SP
    // does initialize FSI master logic so Hostboot should not
    uint32_t fsiMasterInit : 1; 

    // 0b0: SP does not perform hardware change detection, Hostboot must;
    // 0b1: SP does perform hardware change detection (HCDB) so Hostboot
    // should not
    uint32_t hardwareChangeDetection : 1; 

    // 0b0: SP does not perform Power Line Disturbance (PLD) detection,
    // Hostboot must; 0b1: SP does perform Power Line Disturbance (PLD)
    // detection so Hostboot should not
    uint32_t powerLineDisturbance : 1; 

    // Reserved for future use
    uint32_t reserved : 26; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct TempSensorI2cConfig
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // Determines which of the N selectable buses the mux will connect to.
    // OxFF indicates no mux present or N/A.
    uint8_t i2cMuxBusSelector; 

    // Entity path to the I2C mux for this device.
    EntityPath i2cMuxPath; 

} PACKED;

/**
 *  @brief Structure which defines info necessary for I2C. Only applicable
 *	for chip targets which support I2C. Structure is read-only.
 */
struct I2cChipInfo
{
    // Slave device bus speed
    uint32_t busSpeed; 

    // Slave device address
    uint32_t deviceAddr; 

    // Slave device port location
    uint32_t devicePort; 

    // Master I2C engine slave is hung off of
    uint32_t deviceMasterEng; 

} PACKED;

} // End namespace TARGETING

#endif // TARG_ATTRIBUTESTRUCTS_H

