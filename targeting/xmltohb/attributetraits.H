
#ifndef TARG_ATTRIBUTETRAITS_H
#define TARG_ATTRIBUTETRAITS_H

/**
 *  @file attributetraits.H
 *
 *  @brief Templates which map attributes to their type/properties
 *
 *  This header file contains templates which map attributes to their
 *  type/properties.  This file is autogenerated and should not be altered.
 */

//******************************************************************************
// Includes
//******************************************************************************

// STD
#include <stdint.h>
#include <stdlib.h>

// std::array support is dependent on the compiler supporting c++11
#if __cplusplus >= 201103L
#include <array>
#endif
#ifdef FSP
#include <utilmutex.H>
#endif
#include <targeting/common/entitypath.H>

namespace TARGETING
{

//******************************************************************************
// Attribute Property Mappings
//******************************************************************************

/**
 *  @brief Template associating a specific attribute with a type and other
 *      properties, such as whether it is readable/writable
 *
 *      This is automatically generated
 *
 *      enum {
 *          disabled = Special value for the basic, unused wildcard attribute
 *          readable = Attribute is readable
 *          writable = Attribute is writable
 *          hasStringConversion = Attribute has debug string conversion
 *      }
 *
 *      typedef <type> TYPE // <type> is the Attribute's valid type
 */
template<const ATTRIBUTE_ID A>
class AttributeTraits
{
    private:
        enum { disabled };
        typedef void* Type;
};

template<>
class AttributeTraits<ATTR_AUX_FUNC_INVOCATION_TIME_MS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t AUX_FUNC_INVOCATION_TIME_MS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_BIAS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t FREQ_BIAS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_VOLTAGE_EXT_BIAS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type[2][8];
#if __cplusplus >= 201103L 
        static constexpr int8_t VOLTAGE_EXT_BIAS_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 8>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_VOLTAGE_EXT_VDN_BIAS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t VOLTAGE_EXT_VDN_BIAS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_VDN_UPLIFT_MV>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_VDN_UPLIFT_MV_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_DCCR_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t WOF_DCCR_VALUE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_FLMR_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t WOF_FLMR_VALUE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_FMMR_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t WOF_FMMR_VALUE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_DELAY_ADJUST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr int16_t DDS_DELAY_ADJUST_INVALID = 0xFFFF;
        typedef std::array<int16_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_LARGE_DROOP_DETECT_ADJUST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDS_LARGE_DROOP_DETECT_ADJUST_INVALID = 0xFF;
        typedef std::array<int8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_TRIP_OFFSET_ADJUST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDS_TRIP_OFFSET_ADJUST_INVALID = 0xFF;
        typedef std::array<int8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_DROOP_EXTREME_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[9];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_DROOP_EXTREME_OVERRIDE_INVALID = 0xFF;
        typedef std::array<uint8_t, 9> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t SAFE_MODE_NODDS_UPLIFT_0P5PCT_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_DPLL_SLEW_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_DPLL_SLEW_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_TRIP_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_TRIP_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_TRIP_INTERPOLATION_CONTROL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_TRIP_INTERPOLATION_CONTROL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DUMP_STOP_INFO_ENABLE_ERRORLOG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PGPE_HCODE_FUNCTION_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PGPE_HCODE_FUNCTION_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_GLOBAL_FIR_TRACE_EN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_GLOBAL_FIR_TRACE_EN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_POUND_W_STATIC_DATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t POUND_W_STATIC_DATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_POUND_V_STATIC_DATA_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t POUND_V_STATIC_DATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_AW_STATIC_DATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t AW_STATIC_DATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IQ_STATIC_DATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IQ_STATIC_DATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_POUNDV_BUCKET_NUM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t POUNDV_BUCKET_NUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_POUNDV_BUCKET_NUM_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t POUNDV_BUCKET_NUM_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SKIP_WAKEUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SKIP_WAKEUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_VRT_STATIC_DATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_VRT_STATIC_DATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_RING_DBG_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_RING_DBG_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_MALF_ALERT_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_MALF_ALERT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_HALT_FFDC_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_HALT_FFDC_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_DDS_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_DDS_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_DDS_FREQ_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_DDS_FREQ_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_AUXILLARY_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_AUXILLARY_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PSTATES_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PSTATES_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_SUSPEND_OCC_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_SUSPEND_OCC_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_RESCLK_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_RESCLK_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_RESCLK_ISTEP4_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_RVRM_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_RVRM_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOF_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOF_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOV_OVERV_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOV_OVERV_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOV_UNDERV_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOV_UNDERV_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_INDEX_SELECT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_INDEX_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOF_DISABLE_DIMENSION>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOF_DISABLE_DIMENSION_INVALID = 0xFF;
        typedef std::array<uint8_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_THROTTLE_CONTROL_LOOP_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_PITCH_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_PITCH_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_THROTTLE_CONTROL_LOOP_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_THROTTLE_CONTROL_KP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_THROTTLE_CONTROL_KP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_THROTTLE_CONTROL_KI>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_THROTTLE_CONTROL_KI_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_OCS_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_OCS_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PGPE_CURRENT_READ_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_DCM_TRACKING_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_DCM_TRACKING_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOF_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOF_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOF_LAB_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PDV_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PDV_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PDV_LAB_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PDW_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PDW_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_IQ_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_IQ_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PBAX_BRDCST_ID_VECTOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PBAX_BRDCST_ID_VECTOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PBAX_CHIPID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PBAX_CHIPID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PBAX_GROUPID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PBAX_GROUPID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPIPSS_FREQUENCY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SPIPSS_FREQUENCY_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPIPSS_SELECT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPIPSS_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_R_DISTLOSS_UOHM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_R_DISTLOSS_UOHM_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_R_LOADLINE_UOHM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_R_LOADLINE_UOHM_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_VRM_VOFFSET_UV>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_VRM_VOFFSET_UV_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_THROTTLE_ASSERT_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CORE_THROTTLE_ASSERT_COUNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_THROTTLE_DEASSERT_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CORE_THROTTLE_DEASSERT_COUNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_AVSBUS_BUSNUM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t AVSBUS_BUSNUM_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_AVSBUS_FREQUENCY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t AVSBUS_FREQUENCY_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_AVSBUS_RAIL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t AVSBUS_RAIL_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXTERNAL_VRM_STEPSIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXTERNAL_VRM_STEPSIZE_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXTERNAL_VRM_TRANSITION_START_NS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXTERNAL_VRM_TRANSITION_START_NS_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SADDLEBACK_VRM_ROLLOVER_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_VRATIO_VDD_10THPCT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_VRATIO_VDD_10THPCT_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_VRATIO_VCS_10THPCT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_VRATIO_VCS_10THPCT_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_IO_POWER_BASE_W>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_TABLE_IO_POWER_BASE_W_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_IO_BASE_POWER_0P01W>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_IO_BASE_POWER_0P01W_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_MAX_DROOP_10THPCT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t WOV_MAX_DROOP_10THPCT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_MAX_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_OVERV_MAX_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_STEP_DECR_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_OVERV_STEP_DECR_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_STEP_INCR_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_OVERV_STEP_INCR_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_VMAX_SETPOINT_MV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOV_OVERV_VMAX_SETPOINT_MV_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_UNDERV_MAX_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_UNDERV_MAX_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_WOV_DDS_CALIBRATION_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOV_UNDERV_EXTENDED_MAX_10THPCT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOV_OVERV_EXTENDED_MAX_10THPCT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_LIGHT_PERF_LOSS_THRESH_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_HEAVY_PERF_LOSS_THRESH_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_UNDERV_STEP_DECR_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_UNDERV_STEP_DECR_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_UNDERV_STEP_INCR_10THPCT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_UNDERV_STEP_INCR_10THPCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_UNDERV_VMIN_MV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOV_UNDERV_VMIN_MV_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_DIRTY_UNCURRENT_CONTROL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_DIRTY_UNCURRENT_CONTROL_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_OCS_WITH_DDS_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCS_WITH_DDS_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_WITH_DDS_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_OVERV_WITH_DDS_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_DPLL_FMAX_FAST_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_DPLL_FMAX_FAST_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_DPLL_FMIN_FAST_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_DPLL_FMIN_FAST_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_FMAX_OVERRIDE_KHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[9];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDS_FMAX_OVERRIDE_KHZ_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 9> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_FMIN_OVERRIDE_KHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDS_FMIN_OVERRIDE_KHZ_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PB_MHZ_POUNDV_FALLBACK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SAFE_MODE_FREQUENCY_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SAFE_MODE_FREQUENCY_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SAFE_MODE_VOLTAGE_MV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t SAFE_MODE_VOLTAGE_MV_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_VDN_UPLIFT_MV>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t VDN_UPLIFT_MV_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PMCR_MOST_RECENT_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PMCR_MOST_RECENT_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_UNSECURE_HOMER_ADDRESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t UNSECURE_HOMER_ADDRESS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_UNSECURE_HOMER_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t UNSECURE_HOMER_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FUSED_CORE_PAIRED_MODE_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FUSED_CORE_PAIRED_MODE_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_MMA_POWEROFF_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_MMA_POWEROFF_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_MMA_POWERON_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_MMA_POWERON_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RVRM_VID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RVRM_VID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RVRM_DEADZONE_MV>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RVRM_DEADZONE_MV_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_STOP_LEVELS_SUPPORTED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t STOP_LEVELS_SUPPORTED_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_STOP_LEVELS_DISABLED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t STOP_LEVELS_DISABLED_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_BOOT_VOLTAGE_BIAS_0P5PCT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BOOT_VOLTAGE_BIAS_0P5PCT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_OMI_FORCE_FREQ_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t WOF_OMI_FORCE_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SRAM_WRITE_ASSIST_MV>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SRAM_WRITE_ASSIST_MV_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_THRESHOLD_PSTATE_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_THRESHOLD_PSTATE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_COARSE_THROTTLE_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_COARSE_THROTTLE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_FREQ_JUMP_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_FREQ_JUMP_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_BIAS_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_BIAS_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_THROTTLE_TABLE_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint32_t THROTTLE_TABLE_OVERRIDE_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_THROTTLE_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t THROTTLE_MODE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DLR_LINKS_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DLR_LINKS_ENABLED_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DLR_SAMPLE_TIME_MS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t DLR_SAMPLE_TIME_MS_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DLR_PLSF_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DLR_PLSF_OVERRIDE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SAFE_MODE_XSTOP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SAFE_MODE_XSTOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_ALTITUDE_TEMP_ADJUSTMENT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TDP_ALTITUDE_REFERENCE_M>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TDP_ALTITUDE_REFERENCE_M_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_FMAX_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_FMAX_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CURRENT_SCALING_FACTOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CURRENT_SCALING_FACTOR_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IO_GROUNDED_CONTROLLERS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t IO_GROUNDED_CONTROLLERS_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_GROUNDED_LINKS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t IO_GROUNDED_LINKS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_IO_POWER_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_IO_POWER_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXTENDED_FREQ_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXTENDED_FREQ_MODE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DVFS_ADJUSTMENT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DVFS_ADJUSTMENT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCC_START_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCC_START_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WTH_OVERRIDE_CORE_COUNT_INDEX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_EFFICIENCY_ALG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WTH_OVERRIDE_EFFICIENCY_ALG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[8][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 2>, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[8][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 2>, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[8][4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 4>, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_WTH_OVERRIDE_TEST_CORE_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WTH_OVERRIDE_TEST_CORE_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_SRESET_THREADS_BVEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_SRESET_THREADS_BVEC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_CYCLE_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RUNN_CYCLE_COUNT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_CHIP_CYCLE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RUNN_CHIP_CYCLE_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_QUAD_CYCLE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RUNN_QUAD_CYCLE_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_CORE_CYCLE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_CORE_CYCLE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_DO_CONFIG_CHECKS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_DO_CONFIG_CHECKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_USE_QME_TIMEBASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_USE_QME_TIMEBASE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_STOP_ON_XSTOP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_STOP_ON_XSTOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_MASTER_SEED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RUNN_MASTER_SEED_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_CORE_SEED_SELECT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUNN_CORE_SEED_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_THREAD_SEEDS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint64_t RUNN_THREAD_SEEDS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_RUNN_STAGGER_DELAY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RUNN_STAGGER_DELAY_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_INBAND_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_INBAND_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t OMI_INBAND_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_GEN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_GEN_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DIMM_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DIMM_TYPE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_HYBRID_MEMORY_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_HYBRID_MEMORY_TYPE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_HYBRID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_HYBRID_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_DENSITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_DENSITY_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_BANK_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_BANK_BITS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_BANK_GROUP_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_BANK_GROUP_BITS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_COLUMN_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_COLUMN_BITS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_ROW_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_ROW_BITS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_PRIM_STACK_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_PRIM_STACK_TYPE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_PPR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_PPR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_SOFT_PPR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_SOFT_PPR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRCD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TRCD_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TRP_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRAS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TRAS_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TRC_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRFC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EFF_DRAM_TRFC_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TFAW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TFAW_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRRD_S>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TRRD_S_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TRRD_L>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TRRD_L_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TCCD_L>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TCCD_L_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TWR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TWR_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TWTR_S>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TWTR_S_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TWTR_L>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_TWTR_L_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_TMAW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EFF_DRAM_TMAW_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_WIDTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_WIDTH_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_RANK_MIX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DRAM_RANK_MIX_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_NUM_RANKS_PER_DIMM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_NUM_RANKS_PER_DIMM_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_REGISTER_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_REGISTER_TYPE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DRAM_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EFF_DRAM_MFG_ID_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_RCD_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EFF_RCD_MFG_ID_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_REGISTER_REV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_REGISTER_REV_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_PACKAGE_RANK_MAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2][18];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_PACKAGE_RANK_MAP_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 18>, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_NIBBLE_MAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2][18];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_NIBBLE_MAP_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 18>, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ROW_REPAIR_SUPPORTED_MRW>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ROW_REPAIR_SUPPORTED_MRW_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEMORY_BAR_REGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[4][10][2];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MEMORY_BAR_REGS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<std::array<std::array<uint64_t, 2>, 10>, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MEM_BASES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MEM_BASES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MEM_SIZES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MEM_SIZES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MIRROR_BASES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MIRROR_BASES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MIRROR_SIZES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MIRROR_SIZES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MEM_BASES_ACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MEM_BASES_ACK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MEM_SIZES_ACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MEM_SIZES_ACK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MIRROR_BASES_ACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MIRROR_BASES_ACK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MCC_GROUP_32>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[16][21];
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_MCC_GROUP_32_INVALID = 0xFFFFFFFF;
        typedef std::array<std::array<uint32_t, 21>, 16> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_HTM_QUEUES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTM_QUEUES_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MIRROR_SIZES_ACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_MIRROR_SIZES_ACK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MEM_MC_IN_GROUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MEM_MC_IN_GROUP_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_MIRROR_PLACEMENT_POLICY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_MIRROR_PLACEMENT_POLICY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_INTERLEAVE_GROUP_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MAX_INTERLEAVE_GROUP_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_INTERLEAVE_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_INTERLEAVE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_INTERLEAVE_GRANULARITY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_INTERLEAVE_GRANULARITY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MEM_IPL_COMPLETE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MEM_IPL_COMPLETE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_HW_MIRRORING_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MRW_HW_MIRRORING_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DYNAMIC_INIT_FEATURE_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type[1];
#if __cplusplus >= 201103L 
        static constexpr uint64_t DYNAMIC_INIT_FEATURE_VEC_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 1> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DYNAMIC_INIT_FEATURE_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t DYNAMIC_INIT_FEATURE_COUNT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_DYNAMIC_INIT_MODE_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type[1];
#if __cplusplus >= 201103L 
        static constexpr uint64_t DYNAMIC_INIT_MODE_VEC_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 1> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DYNAMIC_INIT_MODE_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t DYNAMIC_INIT_MODE_COUNT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_TRACE_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NHTM_TRACE_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_TRACE_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_TRACE_TYPE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_HTMSC_MODE_CONTENT_SEL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NHTM_HTMSC_MODE_CONTENT_SEL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_HTMSC_MODE_CAPTURE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t NHTM_HTMSC_MODE_CAPTURE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NHTM_HTMSC_MODE_SYNC_STAMP_FORCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_HTMSC_MODE_WRITETOIO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NHTM_HTMSC_MODE_WRITETOIO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_STOP_ON_MATCH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_STOP_ON_MATCH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_STOP_CYCLES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_STOP_CYCLES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_TTYPEFILT_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_TTYPEFILT_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_TSIZEFILT_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_TSIZEFILT_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_TTYPEFILT_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_TTYPEFILT_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_TSIZEFILT_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_TSIZEFILT_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_TTYPEFILT_INVERT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_TTYPEFILT_INVERT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CRESPFILT_INVERT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CRESPFILT_INVERT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_ADDR_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HTMSC_FILT_ADDR_PAT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_ADDR_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HTMSC_FILT_ADDR_MASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_TTAG_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HTMSC_FILT_TTAG_PAT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_OCC_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HTMSC_FILT_OCC_PAT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_SCOPE_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_SCOPE_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_SOURCE_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_SOURCE_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_PORT_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_PORT_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_PORT1_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_PORT1_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_TTAGFILT_INVERT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_TTAGFILT_INVERT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_CRESP_PAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_CRESP_PAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_TTAG_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HTMSC_FILT_TTAG_MASK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_OCC_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HTMSC_FILT_OCC_MASK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_SCOPE_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_SCOPE_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_SOURCE_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_SOURCE_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_PORT_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_PORT_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_PORT1_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_PORT1_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_FILT_CRESP_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_FILT_CRESP_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MEM_SCOPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MEM_SCOPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MEM_PRIORITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MEM_PRIORITY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_CTRL_TRIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NHTM_CTRL_TRIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NHTM_CTRL_MARK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NHTM_CTRL_MARK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_CTRL_TRIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_CTRL_TRIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_CTRL_MARK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_CTRL_MARK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_DBG0_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_DBG0_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_DBG1_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_DBG1_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_RUN_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_RUN_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_OTHER_DBG0_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_OTHER_DBG0_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_XSTOP_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_XSTOP_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_CHIP0_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_CHIP0_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_CTRL_CHIP1_STOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_CTRL_CHIP1_STOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_IMA_PDBAR_SCOPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_IMA_PDBAR_SCOPE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_IMA_PDBAR_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint64_t HTMSC_IMA_PDBAR_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MODE_WRAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MODE_WRAP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MODE_DIS_TSTAMP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MODE_DIS_TSTAMP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MODE_SINGLE_TSTAMP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MODE_SINGLE_TSTAMP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MODE_MARKERS_ONLY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MODE_MARKERS_ONLY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HTMSC_MODE_VGTARGET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HTMSC_MODE_VGTARGET_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_LLAT_CAPTURE_STORE_DIS_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_LLAT_IMBEDDED_TS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_LLAT_IMBEDDED_TS_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_LLAT_PAUSE_ON_PURGE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_CORE_WRAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_CORE_WRAP_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_DIS_TSTAMP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_DIS_TSTAMP_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_SINGLE_TIME_STAMP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_SINGLE_TIME_STAMP_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_DIS_STALL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_DIS_STALL_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_MARKERS_ONLY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_MARKERS_ONLY_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_DIS_GROUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_DIS_GROUP_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_MODE_VGTARGET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_MODE_VGTARGET_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_MODE_CORE_INSTR_STALL_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_REFCLOCK_SWIZZLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_REFCLOCK_SWIZZLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_TOPOLOGY_ID_TABLE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_SL_DOMAIN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_SL_DOMAIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_TSNOOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_FABRIC_TSNOOP_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_BROADCAST_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_BROADCAST_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_PRESENT_GROUPS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_PRESENT_GROUPS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_TOPOLOGY_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_TOPOLOGY_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_TOPOLOGY_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_TOPOLOGY_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_EFF_TOPOLOGY_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_SYSTEM_MASTER_CHIP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_GROUP_MASTER_CHIP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_GROUP_MASTER_CHIP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_CONFIG_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_CONFIG_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_IOHS_BUS_WIDTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_IOHS_BUS_WIDTH_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_DRAWER_INTERCONNECT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_DRAWER_INTERCONNECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_SMP9_INTERCONNECT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_SMP9_INTERCONNECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_FABRIC_TOD_CROSS_CONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_FABRIC_LANE_REVERSAL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_FABRIC_LANE_REVERSAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_LINK_ACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_LINK_ACTIVE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_LINK_TRAIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_LINK_TRAIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_LINK_SPLIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_LINK_SPLIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_LINK_SPEED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t LINK_SPEED_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_ATTACHED_CHIP_CNFG_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_LINKS_CNFG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_LINKS_CNFG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_ATTACHED_CHIP_CNFG_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_LINKS_CNFG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_LINKS_CNFG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_ATTACHED_CHIP_ID_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_ATTACHED_LINK_ID_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_ATTACHED_CHIP_ID_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_ATTACHED_LINK_ID_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_AGGREGATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_AGGREGATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_ADDR_DIS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_X_ADDR_DIS_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_X_LINK_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_FABRIC_X_LINK_DELAY_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_AGGREGATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_AGGREGATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_ADDR_DIS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_ADDR_DIS_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_INDIRECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_A_INDIRECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_R_INDIRECT_EN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_R_INDIRECT_EN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_A_LINK_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_FABRIC_A_LINK_DELAY_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE_INVALID = 0xFF;
        typedef std::array<uint8_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_ASYNC_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_ASYNC_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_DLR_PSAVE_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_DLR_PSAVE_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FABRIC_CORE_FREQ_RATIO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FABRIC_CORE_FREQ_RATIO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_GB_PERCENTAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t PROC_EPS_GB_PERCENTAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_TABLE_TYPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_EPS_TABLE_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_READ_CYCLES_T0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_EPS_READ_CYCLES_T0_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_READ_CYCLES_T1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_EPS_READ_CYCLES_T1_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_READ_CYCLES_T2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_EPS_READ_CYCLES_T2_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_WRITE_CYCLES_T1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_EPS_WRITE_CYCLES_T1_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EPS_WRITE_CYCLES_T2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_EPS_WRITE_CYCLES_T2_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_L2_INCREASE_JITTER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MRW_L2_INCREASE_JITTER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_P1PF_MIN_CONFIDENCE_3>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MRW_P1PF_MIN_CONFIDENCE_3_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_CONVERT_DCBZ_TO_RWITM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MRW_CONVERT_DCBZ_TO_RWITM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FAVOR_AGGRESSIVE_PREFETCH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_MODE_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_LCO_MODE_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_MODE_SETUP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_LCO_MODE_SETUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_LCO_MODE_SETUP_ADAPTIVE_N_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_LCO_MODE_SETUP_ADAPTIVE_D_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_TARGETS_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_LCO_TARGETS_COUNT_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_TARGETS_VECTOR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_LCO_TARGETS_VECTOR_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LCO_TARGETS_MIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_LCO_TARGETS_MIN_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_PHY_TO_PAU_MAPPING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_PHY_TO_PAU_MAPPING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_L2_HASH_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_L2_HASH_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_L3_HASH_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_L3_HASH_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SBE_MCS_SETUP_REG_STATES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[9];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_SBE_MCS_SETUP_REG_STATES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 9> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MEMORY_ENCRYPTION_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_MEMORY_ENCRYPTION_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_SBE_MCS_SETUP_SELECTED_MC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HW543384_WAR_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HW543384_WAR_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_FUSED_CORE_PAIRED_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_QME_STATE_LOSS_CORES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t QME_STATE_LOSS_CORES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_DPLL_DIVIDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_DPLL_DIVIDER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t XGPE_BOOT_COPIER_IVPR_OFFSET_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PGPE_BOOT_COPIER_IVPR_OFFSET_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_SPWUP_IGNORE_XSTOP_FLAG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCC_LFIRMASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t OCC_LFIRMASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PBAO_LFIRMASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PBAO_LFIRMASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_QME_LFIRMASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t QME_LFIRMASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PBAF_LFIRMASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PBAF_LFIRMASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PM_FIRINIT_DONE_ONCE_FLAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_FIRINIT_DONE_ONCE_FLAG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_L3_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t L3_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_L3_HASPOWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t L3_HASPOWER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_HASPOWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_HASPOWER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PSTATES_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PSTATES_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RESCLK_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RESCLK_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDS_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDS_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RVRM_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RVRM_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCS_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCS_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_UNDERV_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_UNDERV_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOV_OVERV_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOV_OVERV_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_THROTTLE_CONTROL_DISABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_THROTTLE_CONTROL_DISABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_XGPE_PHANTOM_HALT_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t XGPE_PHANTOM_HALT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PGPE_PHANTOM_HALT_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PGPE_PHANTOM_HALT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_QME_STOP_PHANTOM_HALT_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t QME_STOP_PHANTOM_HALT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_INSIDE_SPECIAL_WAKEUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_INSIDE_SPECIAL_WAKEUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_INITIATED_PM_HALT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t INITIATED_PM_HALT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_RESTART_PHASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_RESTART_PHASE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_MALF_CYCLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_MALF_CYCLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BOOT_VOLTAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t BOOT_VOLTAGE_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_QME_BROADSIDE_SCAN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t QME_BROADSIDE_SCAN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SYSTEM_MAX_OPERATING_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_PSTATE0_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SYSTEM_PSTATE0_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HOMER_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HOMER_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_QME_BOOT_CONTROL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t QME_BOOT_CONTROL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPIPSS_FRAME_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_SPIPSS_FRAME_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPIPSS_IN_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_SPIPSS_IN_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPIPSS_CLOCK_POLARITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_SPIPSS_CLOCK_POLARITY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPIPSS_CLOCK_PHASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_SPIPSS_CLOCK_PHASE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPIPSS_CLOCK_DIVIDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PM_SPIPSS_CLOCK_DIVIDER_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PM_SPIPSS_INTER_FRAME_DELAY_SETTING_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_INSIDE_SPECIAL_WAKEUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t INSIDE_SPECIAL_WAKEUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SOCKET_POWER_NOMINAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t SOCKET_POWER_NOMINAL_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_COMPAT_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t SYSTEM_COMPAT_FREQ_MHZ_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_OVERRIDE_UT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TABLE_OVERRIDE_UT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_OVERRIDE_WB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TABLE_OVERRIDE_WB_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_OVERRIDE_PS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TABLE_OVERRIDE_PS_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_OVERRIDE_FF>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TABLE_OVERRIDE_FF_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_OVERRIDE_SP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TABLE_OVERRIDE_SP_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_OVERRIDE_RC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_TABLE_OVERRIDE_RC_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_IO_START>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_IO_START_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_IO_STEP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_IO_STEP_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_IO_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t WOF_IO_COUNT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VDN_VOLTAGE_MV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t VDN_VOLTAGE_MV_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TDP_IO_INDEX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_TDP_IO_INDEX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DEAD_CORE_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DEAD_CORE_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SAFE_MODE_THROTTLE_IDX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SAFE_MODE_THROTTLE_IDX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PDW_TRACE_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PDW_TRACE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MIN_PROC_POWER_PER_CHIP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MIN_PROC_POWER_PER_CHIP_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_AVSBUS_VRM_FAIL_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t AVSBUS_VRM_FAIL_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_SPREAD_SPECTRUM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_SPREAD_SPECTRUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_SPREAD_SPECTRUM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_SPREAD_SPECTRUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_MNFG_BAD_LANE_MAX>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_MNFG_BAD_LANE_MAX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_MNFG_BAD_LANE_DURATION>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_MNFG_BAD_LANE_DURATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_VIO_SET_POINT_MV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t VIO_SET_POINT_MV_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_MFG_BAD_LANE_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t IOHS_MFG_BAD_LANE_VEC_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_MFG_BAD_LANE_VEC_VALID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_MFG_BAD_LANE_VEC_VALID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_IOHS_XTALK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_IOHS_XTALK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_IOHS_CHANNEL_LOSS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_IOHS_CHANNEL_LOSS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OMI_CHANNEL_LOSS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OMI_CHANNEL_LOSS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OMI_PRE1>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OMI_PRE1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OMI_PRE2>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OMI_PRE2_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_IOHS_PRE1>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_IOHS_PRE1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_IOHS_PRE1_ISC1_WORKAROUND_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_IOHS_PRE2>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_IOHS_PRE2_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_DL_GROUP_POS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_DL_GROUP_POS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_DL_NUM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_DL_NUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_COUNTER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OCMB_COUNTER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VIO_RAILS_NOT_POWERED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t VIO_RAILS_NOT_POWERED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SAVED_PB_PTL_FIR_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SAVED_PB_PTL_FIR_MASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SAVED_DLP_FIR_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SAVED_DLP_FIR_MASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_INTERPOSER_REV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t INTERPOSER_REV_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_INTERPOSER_FEATURE_HW632898>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t INTERPOSER_FEATURE_HW632898_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PHB_ACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_PHB_ACTIVE_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_LANE_REVERSAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_LANE_REVERSAL_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_BAR_ENABLE_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[6];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 6> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[6];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 6> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[6];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 6> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_BAR_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_PCIE_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_FW_VERSION_0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_FW_VERSION_0_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_FW_VERSION_1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_FW_VERSION_1_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS0_REFCLOCK_RCVR_TERM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS0_REFCLOCK_RCVR_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS1_REFCLOCK_RCVR_TERM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS1_REFCLOCK_RCVR_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCI0_REFCLOCK_RCVR_TERM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCI0_REFCLOCK_RCVR_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCI1_REFCLOCK_RCVR_TERM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCI1_REFCLOCK_RCVR_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_CLK_NE_TERMINATION_SITE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_CLK_NE_TERMINATION_SITE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_CLK_NE_TERMINATION_STRENGTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_CLK_NE_TERMINATION_STRENGTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CP_REFCLOCK_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CP_REFCLOCK_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX0A_RCS_PLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX0A_RCS_PLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX0B_RCS_PLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX0B_RCS_PLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX0C_RCS_PLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX0C_RCS_PLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX0D_RCS_PLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX0D_RCS_PLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX1_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX1_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX2A_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX2A_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX2B_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX2B_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX3_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX3_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX10_PAU_DPLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX10_PAU_DPLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX11_NEST_DPLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX11_NEST_DPLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX12_OMI_LCPLL_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX13_OPT_133_SOURCE_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX14_OPT_156_SOURCE_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX_IOHS_LCPLL_INPUT_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX23_PCI_INPUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX23_PCI_INPUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_MUX_PCI_LCPLL_INPUT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_MUX_PCI_LCPLL_INPUT_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_PLL_MUX_TOD>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCK_PLL_MUX_TOD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HW543822_WAR_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HW543822_WAR_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_TOD_SYNC_SPREAD>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_TOD_SYNC_SPREAD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FORCE_MC_PLL_BANDSEL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FORCE_MC_PLL_BANDSEL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_MC_PLL_BANDSEL_OVERRIDE_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_IPL_PHASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_IPL_PHASE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_CHIP_IPL_PHASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_CHIP_IPL_PHASE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IPL_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IPL_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CONTAINED_IPL_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CONTAINED_IPL_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CONTAINED_LOAD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CONTAINED_LOAD_PATH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_RUNTIME_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_RUNTIME_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_SP_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_SP_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_HBBL_VECTORS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_HBBL_VECTORS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BACKUP_SEEPROM_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BACKUP_SEEPROM_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BACKUP_MEASUREMENT_SEEPROM_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BOOT_FLAGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t BOOT_FLAGS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ALLOW_ATTR_OVERRIDES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ALLOW_ATTR_OVERRIDES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NO_XSCOM_ENFORCEMENT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NO_XSCOM_ENFORCEMENT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECURITY_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECURITY_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_SELECT_EX_POLICY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_SELECT_EX_POLICY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MASTER_CORE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MASTER_CORE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ACTIVE_CORES_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ACTIVE_CORES_VEC_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CHIP_CONTAINED_ACTIVE_CORES_VEC_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_BACKING_CACHES_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t BACKING_CACHES_VEC_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CHIP_CONTAINED_BACKING_CACHES_VEC_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ACTIVE_CORES_NUM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ACTIVE_CORES_NUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BACKING_CACHES_NUM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BACKING_CACHES_NUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_LPAR_MODE_POLICY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_LPAR_MODE_POLICY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_LPAR_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_LPAR_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ZERO_CORE_CHIP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ZERO_CORE_CHIP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HB_FALLBACK_CORES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HB_FALLBACK_CORES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PVR_82_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PVR_82_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_IOSCM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_IOSCM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PG_MVPD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PG_MVPD_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ECO_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ECO_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SBE_MASTER_CHIP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_SBE_MASTER_CHIP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECTOR_BUFFER_STRENGTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECTOR_BUFFER_STRENGTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NDL_MESHCTRL_SETUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NDL_MESHCTRL_SETUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MC_PLL_BUCKET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MC_PLL_BUCKET_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IOHS_PLL_BUCKET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t IOHS_PLL_BUCKET_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FILTER_PLL_BUCKET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FILTER_PLL_BUCKET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCI_PLL_BUCKET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCI_PLL_BUCKET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CP_PLLTODFLT_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CP_PLLTODFLT_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CP_PLLNESTFLT_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CP_PLLNESTFLT_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CP_PLLIOFLT_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CP_PLLIOFLT_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CP_PLLIOSSFLT_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CP_PLLIOSSFLT_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PAU_DPLL_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PAU_DPLL_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_DPLL_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NEST_DPLL_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_TANK_PLL_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_TANK_PLL_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SKEWADJ_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SKEWADJ_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SKEWADJ_CORE_PDLY_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t SKEWADJ_CORE_PDLY_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t SKEWADJ_CACHE_PDLY_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DCADJ_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DCADJ_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DCADJ_DCC_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t DCADJ_DCC_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DCADJ_TARGET_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t DCADJ_TARGET_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ECID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint64_t ECID_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_INTERPOSER_ECID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t INTERPOSER_ECID_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_LPC_CONSOLE_CNFG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t LPC_CONSOLE_CNFG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_SYS_CONFIG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_SYS_CONFIG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_EC_GARD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EC_GARD_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCKSTOP_ON_XSTOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CLOCKSTOP_ON_XSTOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_XSTOP_ON_SPATTN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t XSTOP_ON_SPATTN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BOOT_PAU_DPLL_BYPASS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BOOT_PAU_DPLL_BYPASS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ORIG_FIR_SETTINGS_ACTION0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ORIG_FIR_SETTINGS_ACTION0_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ORIG_FIR_SETTINGS_ACTION1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ORIG_FIR_SETTINGS_ACTION1_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_QME_HCODE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t QME_HCODE_OFFSET_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_QME_HCODE_BLOCK_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t QME_HCODE_BLOCK_COUNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_CP_REFCLOCK_KHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_CP_REFCLOCK_KHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_DPLL_REFCLOCK_KHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_DPLL_REFCLOCK_KHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_IO_REFCLOCK_KHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_IO_REFCLOCK_KHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_CORE_FLOOR_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_CORE_FLOOR_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_SYSTEM_CORE_FLOOR_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_SYSTEM_CORE_CEILING_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_CORE_BOOT_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_CORE_BOOT_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_MC_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_MC_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PLL_BUCKET_BUILD_INDEX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PLL_BUCKET_BUILD_INDEX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_OMI_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_OMI_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_IOHS_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_IOHS_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_IOHS_LINK_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_IOHS_LINK_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PROC_IOHS_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PROC_IOHS_MHZ_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PAU_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PAU_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_INCREASED_PAU_FREQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t INCREASED_PAU_FREQ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PCIE_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PCIE_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPI_BUS_DIV_REF>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t SPI_BUS_DIV_REF_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TPM_SPI_BUS_DIV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t TPM_SPI_BUS_DIV_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_ALLOWED_DIMM_FREQ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAX_ALLOWED_DIMM_FREQ_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_REQUIRED_SYNCH_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t REQUIRED_SYNCH_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NOMINAL_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t NOMINAL_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOFBASE_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t WOFBASE_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PAU_VPD_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PAU_VPD_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_BOOTLOADER_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_BOOTLOADER_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_LOAD_BOOTLOADER_CHUNK_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_LOAD_BOOTLOADER_HBBL_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_MASTER_HRMOR_ADDRESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_MASTER_HRMOR_ADDRESS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HOSTBOOT_HRMOR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HOSTBOOT_HRMOR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_BOOT_SIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_BOOT_SIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_LPC_CONSOLE_INITIALIZED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t LPC_CONSOLE_INITIALIZED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECURE_SETTINGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECURE_SETTINGS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_HBBL_EXCEPTION_INSTRUCT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_HBBL_EXCEPTION_INSTRUCT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_ADDR_KEY_STASH_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_ADDR_KEY_STASH_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_NUM_KEY_ADDR_PAIR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NUM_KEY_ADDR_PAIR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_MEASUREMENT_SEEPROM_VERSION>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_MEASUREMENT_SEEPROM_VERSION_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_HW_KEY_HASH_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SBE_HW_KEY_HASH_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_MINIMUM_SECURE_VERSION>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_MINIMUM_SECURE_VERSION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_SECURE_BOOT_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_SECURE_BOOT_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_IMAGE_MINIMUM_VALID_ECS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_IMAGE_MINIMUM_VALID_ECS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_SBE_SEEPROM_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAX_SBE_SEEPROM_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_CUST_FORCE_MVPD_ONLY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_CUST_FORCE_MVPD_ONLY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_DSTLCFG_MMIO_ADDRBIT_POS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_ENABLE_DL_TMPL_1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_ENABLE_DL_TMPL_1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_ENABLE_DL_TMPL_4>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_ENABLE_DL_TMPL_4_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_ENABLE_DL_TMPL_7>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_ENABLE_DL_TMPL_7_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_ENABLE_DL_TMPL_A>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_ENABLE_DL_TMPL_A_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_TMPL_0_PACING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_TMPL_0_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_TMPL_1_PACING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_TMPL_1_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_TMPL_4_PACING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_TMPL_4_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_TMPL_7_PACING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_TMPL_7_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_TMPL_A_PACING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_TMPL_A_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_DISABLE_MCU_TIMEOUTS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_DISABLE_MCU_TIMEOUTS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_DISABLE_HWFM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_DISABLE_HWFM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_ENABLE_MC_HW520600_X4CTR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_ENABLE_MC_HW520600_X4CTR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_OMI_OC_MAJOR_VER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_OMI_OC_MAJOR_VER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_OMI_OC_MINOR_VER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_OMI_OC_MINOR_VER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_CHANNEL_FAIL_ACTION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_CHANNEL_FAIL_ACTION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MFG_SCREEN_OMI_CRC_ALLOWED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MFG_SCREEN_OMI_CRC_ALLOWED_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MFG_SCREEN_OMI_EDPL_ALLOWED_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MNFG_EDPL_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MNFG_EDPL_TIME_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MNFG_EDPL_THRESHOLD>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MNFG_EDPL_THRESHOLD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_XSCOM_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_LPC_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FSP_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FSP_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_FSP_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FSP_BAR_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_FSP_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_FSP_MMIO_MASK_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_FSP_MMIO_MASK_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PAU_MMIO_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PAU_MMIO_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PSI_BRIDGE_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PSI_BRIDGE_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_NX_RNG_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_NX_RNG_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_NX_RNG_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_NX_RNG_FAILED_INT_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_NX_RNG_FAILED_INT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_NX_RNG_FAILED_INT_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_NX_RNG_FAILED_INT_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_NHTM_BAR_BASE_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_NHTM_BAR_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_NHTM_BAR_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_NHTM_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_CHTM_BAR_BASE_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_CHTM_BAR_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_CHTM_BAR_SIZES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[32];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_CHTM_BAR_SIZES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 32> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SMF_BAR_BASE_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_SMF_BAR_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SMF_BAR_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_SMF_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SMF_CONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SMF_CONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_OCC_SANDBOX_BASE_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_OCC_SANDBOX_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_OCC_SANDBOX_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_OCC_SANDBOX_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_IC_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_IC_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_INT_IC_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_IC_BAR_PAGE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_IC_BAR_PAGE_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_TM_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_TM_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_INT_TM_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_TM_BAR_PAGE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_TM_BAR_PAGE_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVPG_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVPG_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVPG_BAR_PAGE_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVPG_BAR_RANGE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVPG_BAR_RANGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVC_BAR_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVC_BAR_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVC_BAR_PAGE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVC_BAR_PAGE_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PROC_INT_NVC_BAR_BASE_ADDR_OFFSET_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_INT_NVC_BAR_RANGE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_INT_NVC_BAR_RANGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_DEV_TYPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_DEV_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_SUB_POS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_SUB_POS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FAPI_POS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FAPI_POS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_BUS_POS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BUS_POS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_SIMULATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_SIMULATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXECUTION_PLATFORM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXECUTION_PLATFORM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MFG_FLAGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t MFG_FLAGS_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_RECONFIGURE_LOOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RECONFIGURE_LOOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MINI_EC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MINI_EC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SCAN_CHIPLET_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SCAN_CHIPLET_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SLOW_MEM_POOL_TEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SLOW_MEM_POOL_TEST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_HALF_DIMM_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_HALF_DIMM_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DRAM_CWL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DRAM_CWL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_RDIMM_BUFFER_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_RDIMM_BUFFER_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_REORDER_QUEUE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_REORDER_QUEUE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_THERMAL_INIT_COMPLETE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_THERMAL_INIT_COMPLETE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_2N_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_2N_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_VPD_DQ_MAP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[80];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_VPD_DQ_MAP_INVALID = 0xFF;
        typedef std::array<uint8_t, 80> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC0F>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC0F_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_CS_CMD_LATENCY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_CS_CMD_LATENCY_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_CA_PARITY_LATENCY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_CA_PARITY_LATENCY_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC02>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC02_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC03>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC03_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC04>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC04_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC05>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC05_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC0B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC0B_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC1X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC1X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F0RC7X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F0RC7X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC00>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC00_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC02>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC02_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC03>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC03_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC04>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC04_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC05>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC05_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_POS_METADATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_DIMM_POS_METADATA_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DRAM_GEN_METADATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DRAM_GEN_METADATA_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_TYPE_METADATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_TYPE_METADATA_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OMI_EDPL_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OMI_EDPL_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_OVERRIDE_FREQ_LIMITATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_OVERRIDE_FREQ_LIMITATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_IGNORE_PLUG_RULES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_IGNORE_PLUG_RULES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_X4_DEGRADE_ACTION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_X4_DEGRADE_ACTION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_CRC_DEBUG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_CRC_DEBUG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ENABLE_FIR_UNMASKING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ENABLE_FIR_UNMASKING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_IS_APOLLO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_IS_APOLLO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_POST_MEMDIAGS_READ_SUBTEST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_SAFEMODE_DRAM_DATABUS_UTIL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_OCMB_CHECKSTOP_OBJ_HANDLE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_RECOV_OBJ_HANDLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_OCMB_RECOV_OBJ_HANDLE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_OCMB_SPECATTN_OBJ_HANDLE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_OCMB_APPINTR_OBJ_HANDLE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DRAM_ADDRESS_MIRRORING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DRAM_ADDRESS_MIRRORING_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ECS_ERROR_COUNT_THRESHOLD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ECS_ERROR_COUNT_THRESHOLD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CONFIG_FREQ_LIMIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CONFIG_FREQ_LIMIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OMI_VDD_UPLIFT_APPLIED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OMI_VDD_UPLIFT_APPLIED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_SIGNATURE_HASH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_SI_SIGNATURE_HASH_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DIMM_RCD_IBT_CA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DIMM_RCD_IBT_CA_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DIMM_RCD_IBT_CKE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DIMM_RCD_IBT_CKE_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DIMM_RCD_IBT_CS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DIMM_RCD_IBT_CS_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DIMM_RCD_IBT_ODT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DIMM_RCD_IBT_ODT_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DRAM_DRV_IMP_DQ_DQS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DRAM_PREAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DRAM_PREAMBLE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DRAM_RTT_NOM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DRAM_RTT_NOM_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DRAM_RTT_PARK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DRAM_RTT_PARK_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_DRAM_RTT_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_DRAM_RTT_WR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_GEARDOWN_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_GEARDOWN_MODE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_DQ_DQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_DQ_DQS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_RCV_EQ_DQ_DQS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_EQ_DQ_DQS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_PHY_EQUALIZATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_PHY_EQUALIZATION_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_IMP_CLK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_IMP_CLK_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_IMP_CMD_ADDR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_IMP_CNTL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_IMP_CNTL_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_IMP_CSCID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_IMP_CSCID_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_SLEW_RATE_CLK_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_SLEW_RATE_CNTL_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_SLEW_RATE_CSCID_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_RCV_IMP_ALERT_N>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_MC_RCV_IMP_ALERT_N_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_SI_MC_RCV_IMP_DQ_DQS_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_ODT_RD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_ODT_RD_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_ODT_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_ODT_WR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_VREF_DRAM_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_SI_VREF_DRAM_WR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_VREF_MC_RD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_SI_VREF_MC_RD_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_WINDAGE_RD_CTR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type;
#if __cplusplus >= 201103L 
        static constexpr int16_t MEM_SI_WINDAGE_RD_CTR_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC1X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC1X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC2X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC2X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC3X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC3X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC4X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC4X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC5X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC5X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC6X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC6X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DIMM_DDR4_F1RC7X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DIMM_DDR4_F1RC7X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_BURST_LENGTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_BURST_LENGTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_MPSM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_MPSM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_CS_ASSERT_IN_MPC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_CS_ASSERT_IN_MPC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DEVICE15_MPSM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DEVICE15_MPSM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_INTERNAL_WR_TIMING_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_INTERNAL_WR_TIMING_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_WL_INTERNAL_CYCLE_ALIGNMENT_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_REF_INTERVAL_RATE_INDIC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_REF_INTERVAL_RATE_INDIC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_MIN_REF_RATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_MIN_REF_RATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_REF_WIDE_RANGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_REF_WIDE_RANGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_REF_TUF>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_REF_TUF_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DRAM_PU_DRV_IMP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DRAM_PU_DRV_IMP_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_TEST_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_TEST_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DRAM_PD_DRV_IMP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DRAM_PD_DRV_IMP_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_RD_PREAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_RD_PREAMBLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_WR_PREAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_WR_PREAMBLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_RD_POSTAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_RD_POSTAMBLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_WR_POSTAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_WR_POSTAMBLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_WR_VREFDQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_WR_VREFDQ_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_VREFCA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_VREFCA_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_VREFCS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_VREFCS_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_RESET_COUNTER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_RESET_COUNTER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_COUNT_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_COUNT_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_SRANK_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_SRANK_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_THRESHOLD_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_IN_SELF_REFRESH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_WRITEBACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_WRITEBACK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ECS_X4_WRITES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_ECS_X4_WRITES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_CK_ODT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_DRAM_CK_ODT_INVALID = 0xFFFF;
        typedef std::array<std::array<std::array<uint16_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_CS_ODT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_DRAM_CS_ODT_INVALID = 0xFFFF;
        typedef std::array<std::array<std::array<uint16_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_CK_ODT_PER_DRAM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_DRAM_CK_ODT_PER_DRAM_INVALID = 0xFFFF;
        typedef std::array<std::array<std::array<uint16_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_CS_ODT_PER_DRAM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_DRAM_CS_ODT_PER_DRAM_INVALID = 0xFFFF;
        typedef std::array<std::array<std::array<uint16_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_CA_ODT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_DRAM_CA_ODT_INVALID = 0xFFFF;
        typedef std::array<std::array<std::array<uint16_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_DQS_RTT_PARK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_DQS_RTT_PARK_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_CA_ODT_PER_DRAM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint16_t DDR5_DRAM_CA_ODT_PER_DRAM_INVALID = 0xFFFF;
        typedef std::array<std::array<std::array<uint16_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_RTT_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_RTT_WR_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_RTT_PARK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_RTT_PARK_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_RTT_NOM_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_RTT_NOM_WR_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_RTT_NOM_RD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_DRAM_RTT_NOM_RD_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ODTLON_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDR5_DRAM_ODTLON_WR_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ODTLOFF_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDR5_DRAM_ODTLOFF_WR_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ODTLON_WR_NT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDR5_DRAM_ODTLON_WR_NT_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ODTLOFF_WR_NT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDR5_DRAM_ODTLOFF_WR_NT_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ODTLON_RD_NT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDR5_DRAM_ODTLON_RD_NT_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_DRAM_ODTLOFF_RD_NT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr int8_t DDR5_DRAM_ODTLOFF_RD_NT_INVALID = 0xFF;
        typedef std::array<std::array<int8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_WR_CRC_ERR_STATUS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_WR_CRC_ERR_STATUS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_GLOBAL_DFE_GAIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_GLOBAL_DFE_GAIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_GLOBAL_DFE_TAP1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_GLOBAL_DFE_TAP1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_GLOBAL_DFE_TAP2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_GLOBAL_DFE_TAP2_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_GLOBAL_DFE_TAP3>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_GLOBAL_DFE_TAP3_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_GLOBAL_DFE_TAP4>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_GLOBAL_DFE_TAP4_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_DFE_GAIN_BIAS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_DFE_GAIN_BIAS_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_DFE_SIGN_BIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_DDR5_DFE_SIGN_BIT_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_GEN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_GEN_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DIMM_TYPE_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_HYBRID_MEMORY_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_HYBRID_MEMORY_TYPE_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_HYBRID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_HYBRID_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_HOST_TO_DDR_SPEED_RATIO_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_DENSITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_DENSITY_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_BANK_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_BANK_BITS_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_BANK_GROUP_BITS_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_COLUMN_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_COLUMN_BITS_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_ROW_BITS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_ROW_BITS_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PRIM_DIE_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PRIM_DIE_COUNT_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PRIM_STACK_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PRIM_STACK_TYPE_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PRIM_BUS_WIDTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PRIM_BUS_WIDTH_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_CHANNELS_PER_DIMM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_CHANNELS_PER_DIMM_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_PPR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_PPR_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_SOFT_PPR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_SOFT_PPR_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRCD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRCD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRAS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRAS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRFC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DRAM_TRFC_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TFAW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TFAW_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRRD_S>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRRD_S_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRRD_L>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRRD_L_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRRD_DLR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRRD_DLR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TCCD_L>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TCCD_L_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TCCD_L_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TCCD_L_WR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TWR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TWR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TWTR_S>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TWTR_S_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TWTR_L>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TWTR_L_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TMAW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DRAM_TMAW_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_WIDTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_WIDTH_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_LOGICAL_RANKS_PER_DIMM_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_3DS_HEIGHT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_3DS_HEIGHT_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_REGISTER_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_REGISTER_TYPE_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_MODULE_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_MODULE_MFG_ID_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DRAM_MFG_ID_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_MODULE_HEIGHT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_MODULE_HEIGHT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_RCD_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_RCD_MFG_ID_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_REGISTER_REV>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_REGISTER_REV_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PACKAGE_RANK_MAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PACKAGE_RANK_MAP_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 20>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_NIBBLE_MAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_NIBBLE_MAP_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 20>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_EFF_DIMM_SIZE_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_SPARE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DIMM_SPARE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_CL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_CL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_MDS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_MDS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_RANKS_CONFIGED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DIMM_RANKS_CONFIGED_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TREFI>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DRAM_TREFI_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRTP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DRAM_TRTP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DRAM_TRFC_DLR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DRAM_TRFC_DLR_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_FREQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MEM_EFF_FREQ_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_VOLT_VDDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_EFF_VOLT_VDDR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_VOLT_VDDQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_EFF_VOLT_VDDQ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_VOLT_VPP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_EFF_VOLT_VPP_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_SPD_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_SPD_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_SPD_CONTENT_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_SPD_CONTENT_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_SUPPORTED_RCD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_SUPPORTED_RCD_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_BYTE_ENABLES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_BYTE_ENABLES_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_NIBBLE_ENABLES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_EFF_NIBBLE_ENABLES_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_Z_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_Z_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_SERIAL_NUMBER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[26];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DIMM_SERIAL_NUMBER_INVALID = 0xFF;
        typedef std::array<uint8_t, 26> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_MODULE_THERMAL_SENSORS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_MODULE_THERMAL_SENSORS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_USAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_USAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_USAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_USAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_2_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_2_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_2_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_2_USAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_2_USAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_2_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_3_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_3_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_3_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_3_USAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_3_USAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_3_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_DIFF_AVAIL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_DIFF_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_DIFF_USAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_3_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_2_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_1_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_0_LOCATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_THERM_SENSOR_READ_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXP_RUNTIME_MEM_M_DRAM_CLOCKS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t EXP_MEM_PORT_POS_OF_FAIL_THROTTLE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_MEM_WATT_TARGET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXP_MEM_WATT_TARGET_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_TOTAL_PWR_SLOPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_TOTAL_PWR_SLOPE_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_TOTAL_PWR_INTERCEPT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EXP_TOTAL_PWR_INTERCEPT_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_PORT_MAXPOWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXP_PORT_MAXPOWER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_DIMM_THERMAL_LIMIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXP_DIMM_THERMAL_LIMIT_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_MRW_IS_PLANAR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_MRW_IS_PLANAR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_CONFIG_FREQ_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_CONFIG_FREQ_LIMIT_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_PWR_INTERCEPT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[100];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_PWR_INTERCEPT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 100> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_PWR_SLOPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[100];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_PWR_SLOPE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 100> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_REFRESH_RATE_REQUEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_REFRESH_RATE_REQUEST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_MRW_MEM_M_DRAM_CLOCKS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_MRW_MAX_DRAM_DATABUS_UTIL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_POWER_CONTROL_REQUESTED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_POWER_CONTROL_REQUESTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_AVDD_OFFSET_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_AVDD_OFFSET_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_VDD_OFFSET_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_VDD_OFFSET_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_VCS_OFFSET_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_VCS_OFFSET_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_VPP_OFFSET_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_VPP_OFFSET_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_VDDR_OFFSET_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_VDDR_OFFSET_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_FINE_REFRESH_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_FINE_REFRESH_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_TEMP_REFRESH_RANGE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_TEMP_REFRESH_RANGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_RESET_DELAY_BEFORE_CAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DRAM_2N_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DRAM_2N_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DRAM_WRITE_CRC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DRAM_WRITE_CRC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DDR5_DRAM_READ_CRC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DDR5_DRAM_READ_CRC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_TEMP_REFRESH_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_TEMP_REFRESH_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_FORCE_BCMODE_OFF>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_FORCE_BCMODE_OFF_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_NVDIMM_PLUG_RULES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_NVDIMM_PLUG_RULES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_ALLOW_UNSUPPORTED_RCW_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_SUPPORTED_DRAM_WIDTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[25];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OCMB_PWR_SLOPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[50];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_OCMB_PWR_SLOPE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OCMB_PWR_INTERCEPT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[50];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_OCMB_PWR_INTERCEPT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[25];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DIMM_SLOT_AIRFLOW_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MEM_PORT_POS_OF_FAIL_THROTTLE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OCMB_RESET_GROUP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_OCMB_RESET_GROUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_SUPPORTED_FREQ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_MRW_SUPPORTED_FREQ_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[10];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_THERMAL_MEMORY_POWER_LIMIT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 10> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[50];
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_ALLOW_DDR5>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MRW_ALLOW_DDR5_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_MAX_DDR_FREQ_PER_SLOT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MRW_MAX_DDR_FREQ_PER_SLOT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_ENTER_STR_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_ENTER_STR_TIME_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MRW_MAX_DDR_FREQ_ON_IOSCM_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_TX_SLEW_RISE_DQ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_TX_SLEW_FALL_DQ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_TX_SLEW_RISE_AC_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_TX_SLEW_FALL_AC_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_TX_SLEW_RISE_CK_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_TX_SLEW_FALL_CK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_EN_TX_DM_PREAMBLE_PATTERN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_TX_DQ_PREAMBLE_PATTERN_U0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_TX_DQ_PREAMBLE_PATTERN_U1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DDR5_TX_DM_PREAMBLE_PATTERN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DDR5_TX_DM_PREAMBLE_PATTERN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_REDUNDANT_CS_EN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_REDUNDANT_CS_EN_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_RXEN_ADJ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_RXEN_ADJ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_WL_ADJ_START>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DDR5_WL_ADJ_START_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_WL_ADJ_END>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_DDR5_WL_ADJ_END_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_PHY_VREF_RD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_PHY_VREF_RD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_RTT_PARK_RD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_RTT_PARK_RD_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_RTT_PARK_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_RTT_PARK_WR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_DDR5_SPD_CL_SUPPORTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MEM_DDR5_SPD_CL_SUPPORTED_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_CHB_ACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_CHB_ACTIVE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_MEM_PORT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_VREFCS_SWEEP_MIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_VREFCS_SWEEP_MAX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_VREFCA_SWEEP_MIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDR5_VREFCA_SWEEP_MAX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW00_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW00_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW01_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW01_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW05_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW05_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW08_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW08_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW09_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW09_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0A_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0A_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0C_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0C_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0D_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0D_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0E_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0E_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0F_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0F_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW40_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW40_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW41_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW41_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW42_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW42_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW43_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW43_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW44_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW44_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW45_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW45_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW46_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW46_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW47_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW47_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW48_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW48_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW49_CHA_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW49_CHA_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW00_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW00_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW01_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW01_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW05_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW05_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW08_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW08_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW09_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW09_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0A_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0A_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0C_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0C_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0D_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0D_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0E_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0E_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0F_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0F_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW40_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW40_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW41_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW41_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW42_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW42_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW43_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW43_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW44_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW44_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW45_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW45_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW46_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW46_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW47_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW47_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW48_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW48_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW49_CHA_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW49_CHA_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW00_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW00_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW01_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW01_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW05_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW05_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW08_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW08_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW09_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW09_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0A_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0A_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0C_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0C_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0D_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0D_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0E_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0E_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0F_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0F_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW40_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW40_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW41_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW41_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW42_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW42_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW43_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW43_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW44_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW44_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW45_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW45_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW46_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW46_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW47_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW47_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW48_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW48_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW49_CHB_D0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW49_CHB_D0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW00_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW00_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW01_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW01_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW05_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW05_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW08_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW08_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW09_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW09_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0A_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0A_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0C_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0C_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0D_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0D_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0E_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0E_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW0F_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW0F_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW40_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW40_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW41_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW41_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW42_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW42_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW43_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW43_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW44_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW44_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW45_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW45_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW46_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW46_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW47_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW47_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW48_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW48_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCW49_CHB_D1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCW49_CHB_D1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_ENABLE_US_TMPL_1>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_ENABLE_US_TMPL_1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_ENABLE_US_TMPL_5>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_ENABLE_US_TMPL_5_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_ENABLE_US_TMPL_9>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_ENABLE_US_TMPL_9_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_ENABLE_US_TMPL_A>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_ENABLE_US_TMPL_A_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_ENABLE_US_TMPL_B>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_ENABLE_US_TMPL_B_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_TMPL_0_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_TMPL_0_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_TMPL_1_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_TMPL_1_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_TMPL_5_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_TMPL_5_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_TMPL_9_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_TMPL_9_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_TMPL_B_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_TMPL_B_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_SHRT_BACKOFF_TIMER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_SHRT_BACKOFF_TIMER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_METADATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_METADATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_PASID_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXPLR_PASID_BASE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_ACTAG_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXPLR_ACTAG_BASE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_AFU_ACTAG_LEN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXPLR_AFU_ACTAG_LEN_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXPLR_PASID_LEN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EXPLR_PASID_LEN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_IBM_SIMULATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_IBM_SIMULATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_ENTERPRISE_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_ENTERPRISE_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_ENTERPRISE_POLICY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_ENTERPRISE_POLICY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_INIT_VREF_DQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EXP_INIT_VREF_DQ_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_INIT_PHY_VREF>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EXP_INIT_PHY_VREF_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_RCD_DIC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EXP_RCD_DIC_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_RCD_VOLTAGE_CTRL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EXP_RCD_VOLTAGE_CTRL_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EXP_DRAM_ADDRESS_MIRRORING_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_RCD_SLEW_RATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EXP_RCD_SLEW_RATE_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_SPD_CL_SUPPORTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_EXP_SPD_CL_SUPPORTED_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_SPD_TAA_MIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EXP_SPD_TAA_MIN_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_REORDER_QUEUE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_REORDER_QUEUE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EXP_FIRMWARE_EMULATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_STRUCT_ENDIAN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_ECID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[14];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_OCMB_ECID_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 14> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EXP_DFIMRL_CLK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EXP_DFIMRL_CLK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_ATXDLY_A>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_ATXDLY_A_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_ATXDLY_B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_ATXDLY_B_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_PHY_INIT_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_PHY_INIT_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CHECK_FOR_READY_TIMEOUT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_CHECK_FOR_READY_TIMEOUT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_DISABLE_THERM_INIT_READ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_FW_API_VERSION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_FW_API_VERSION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_FW_VERSION_A>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_EXP_FW_VERSION_A_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_FW_VERSION_B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_EXP_FW_VERSION_B_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_FW_PARTITION_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_EXP_FW_PARTITION_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_FW_FAILED_AUTHENTICATION_A_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_FW_FAILED_AUTHENTICATION_B_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_COMM_STATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_COMM_STATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC00>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC00_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC01>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC01_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC03>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC03_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC04>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC04_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC05>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC05_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC0B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC0B_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC0E>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC0E_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC0F>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC0F_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC1X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC1X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F0RC7X>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F0RC7X_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F1RC00>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F1RC00_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F1RC02>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F1RC02_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F1RC03>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F1RC03_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F1RC04>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F1RC04_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DDR4_F1RC05>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DDR4_F1RC05_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_RBT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_RBT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_TM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_TM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_DLL_RESET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_DLL_RESET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_BURST_LENGTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_DLL_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_ODIC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_ODIC_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_AL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_AL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_RTT_NOM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_RTT_NOM_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_RTT_PARK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_RTT_PARK_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_TDQS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_TDQS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_LPASR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_LPASR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DRAM_RTT_WR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DRAM_RTT_WR_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_MPR_PAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_MPR_PAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_MPR_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_MPR_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_GEARDOWN_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_GEARDOWN_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_PER_DRAM_ACCESS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_TEMP_READOUT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_TEMP_READOUT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_CRC_WR_LATENCY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_CRC_WR_LATENCY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_MPR_RD_FORMAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_MPR_RD_FORMAT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_MAX_POWERDOWN_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_INTERNAL_VREF_MONITOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_SELF_REF_ABORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_SELF_REF_ABORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_RD_PREAMBLE_TRAIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_RD_PREAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_RD_PREAMBLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_WR_PREAMBLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_WR_PREAMBLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_CRC_ERROR_CLEAR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_ODT_INPUT_BUFF_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_CA_PARITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_CA_PARITY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_DATA_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_DATA_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_WRITE_DBI>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_WRITE_DBI_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_READ_DBI>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_READ_DBI_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][4][20];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_CDR_BW_OVERRIDE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_CDR_BW_OVERRIDE_VALUE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_OMI_CDR_BW_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_EXP_OMI_SETUP_POLL_COUNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_OMI_CDR_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_OMI_CDR_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_OMI_CDR_OFFSET_LANE_MASK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_INTR_MASK_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_INTR_MASK_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EXP_SERIAL_NUMBER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[26];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EXP_SERIAL_NUMBER_INVALID = 0xFF;
        typedef std::array<uint8_t, 26> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PSTATES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PSTATES_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_FOUR_RANK_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_FOUR_RANK_MODE_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_MRAM_SUPPORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_MRAM_SUPPORT_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_DDP_COMPATIBILITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_DDP_COMPATIBILITY_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_TSV_8H_SUPPORT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_TSV_8H_SUPPORT_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_MDS_DDIMM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_MDS_DDIMM_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_DL_PREIPL_PRBS_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OMI_DL_PREIPL_PRBS_TIME_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EXP_DATABUS_UTIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EXP_DATABUS_UTIL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_FFE_SETTINGS_COMMAND>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_FFE_SETTINGS_COMMAND_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_FFE_PRE_CURSOR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OMI_FFE_PRE_CURSOR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_FFE_POST_CURSOR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OMI_FFE_POST_CURSOR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ENABLE_US_TMPL_1>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ENABLE_US_TMPL_1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ENABLE_US_TMPL_5>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ENABLE_US_TMPL_5_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ENABLE_US_TMPL_9>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ENABLE_US_TMPL_9_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ENABLE_US_TMPL_A>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ENABLE_US_TMPL_A_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ENABLE_US_TMPL_B>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ENABLE_US_TMPL_B_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TMPL_0_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_TMPL_0_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TMPL_1_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_TMPL_1_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TMPL_5_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_TMPL_5_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TMPL_9_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_TMPL_9_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TMPL_B_PACING>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_TMPL_B_PACING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SHRT_BACKOFF_TIMER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_SHRT_BACKOFF_TIMER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_METADATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_METADATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PASID_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ODY_PASID_BASE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ACTAG_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ODY_ACTAG_BASE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_AFU_ACTAG_LEN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ODY_AFU_ACTAG_LEN_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PASID_LEN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PASID_LEN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_TARGET_STATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_TARGET_STATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_I2C_DEV_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_I2C_DEV_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_I2C_ENGINE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_I2C_ENGINE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_I2C_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_I2C_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_I2C_MAX_RETRY_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_I2C_MAX_RETRY_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_ODY_PASSED_SWIZZLE_DETECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_ODY_PHY_IMAGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_ODY_PHY_IMAGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_MSG_BLOCK_DATA_SOURCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_MSG_BLOCK_DATA_SOURCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DRAMINIT_ERROR_ON_FAILURE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_RECOVERY_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DRAMINIT_RECOVERY_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SWIZZLE_DETECT_FAIL_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DRAMINIT_FIR_CHECK_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_STEP_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DRAMINIT_STEP_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SENSOR_POLLING_PERIOD_MS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ODY_SENSOR_POLLING_PERIOD_MS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ODY_SENSOR_POLLING_PERIOD_MS_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_HALF_DIMM_TARGET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_PERIOD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_PERIOD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_PERIOD_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_PERIOD_INIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_TEMP_THRESHOLD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DQS_TRACKING_COUNT_THRESHOLD_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_RECAL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DQS_TRACKING_RECAL_COUNT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_LOG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[24];
#if __cplusplus >= 201103L 
        static constexpr uint64_t ODY_DQS_TRACKING_LOG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 24> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type;
#if __cplusplus >= 201103L 
        static constexpr int16_t ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_SUSPENDED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_SUSPENDED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_TRACKING_FAILED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DQS_TRACKING_FAILED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type;
#if __cplusplus >= 201103L 
        static constexpr int16_t ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type;
#if __cplusplus >= 201103L 
        static constexpr int16_t ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type;
#if __cplusplus >= 201103L 
        static constexpr int16_t ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int16_t Type;
#if __cplusplus >= 201103L 
        static constexpr int16_t ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SENSOR_READ_FIRST_FAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_SENSOR_READ_FIRST_FAIL_INVALID = 0xFF;
        typedef std::array<uint8_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_VERBOSITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DRAMINIT_VERBOSITY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PHY_GET_MAIL_TIMEOUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PHY_GET_MAIL_TIMEOUT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_DRAMINIT_TRAINING_TIMEOUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t DRAMINIT_TRAINING_TIMEOUT_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MAIL_MESSAGE_BITMAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAIL_MESSAGE_BITMAP_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_ARDPTRINITVAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_ARDPTRINITVAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_ARDPTRINITVALOVR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_ARDPTRINITVALOVR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DIS_PTRINITCLR_TXTRACKING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DIS_PTRINITCLR_TXTRACKING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EXTCALRESVAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_EXTCALRESVAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_MEMALERTEN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_MEMALERTEN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_MSTRTRAIN_INTERVAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_MSTRTRAIN_INTERVAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_MSTRMAXREQTOACK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_MSTRMAXREQTOACK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_MSTRCTRLMODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_MSTRCTRLMODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_CALINTERVAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_CALINTERVAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_CALONCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_CALONCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_IS_HIGHVDD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_IS_HIGHVDD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_EN_TDQS2DQ_TRACKING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_EN_TDQS2DQ_TRACKING_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DQS_OSC_RUNTIME_SEL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DQS_OSC_RUNTIME_SEL_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_EN_RXDQS_TRACKING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_EN_RXDQS_TRACKING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DISABLE_PMU_ECC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DISABLE_PMU_ECC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ENABLE_MALERT_ASYNC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ENABLE_MALERT_ASYNC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ALERT_RECOV_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ALERT_RECOV_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_RST_RXTRK_STATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_RST_RXTRK_STATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_UPPERNIBBLE_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_UPPERNIBBLE_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_UPPERNIBBLE_TG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_UPPERNIBBLE_TG_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DFIPHYUPDCNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DFIPHYUPDCNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DFIPHYUPDRESP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DFIPHYUPDRESP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SIM_TDQS2DQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SIM_TDQS2DQ_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SIM_TDQSCK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SIM_TDQSCK_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SIM_TSTAOFF>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SIM_TSTAOFF_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SIM_TPDM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SIM_TPDM_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SIM_TCASL_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_SIM_TCASL_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SIM_TCASL_ADD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SIM_TCASL_ADD_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_POWERDOWN_ANIBS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_POWERDOWN_ANIBS_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_LP2_PWRSAVINGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_LP2_PWRSAVINGS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SPECIAL_OFFSET_VALUE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SPECIAL_OFFSET_VALUE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_ADV_TRAIN_OPT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_ADV_TRAIN_OPT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_MSG_MISC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_MSG_MISC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PLL_BYPASS_EN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PLL_BYPASS_EN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_RX2D_DFE_MISC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_RX2D_DFE_MISC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_D5MISC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_D5MISC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_WL_ADJ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_WL_ADJ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SEQUENCE_CTRL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_SEQUENCE_CTRL_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_CFG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_CFG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_DFIMRL_MARGIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_DFIMRL_MARGIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_USE_BROADCAST_MR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_USE_BROADCAST_MR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_DISABLED_DBYTE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_DISABLED_DBYTE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_CA_TRAIN_OPTIONS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_CA_TRAIN_OPTIONS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_CA_DFE_TRAIN_OPTIONS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_TX2D_DFE_MISC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_TX2D_DFE_MISC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_RX2D_TRAIN_OPT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_RX2D_TRAIN_OPT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_TX2D_TRAIN_OPT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_TX2D_TRAIN_OPT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_DEBUG_TRAIN_OPTIONS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_CONFIG_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_PHY_CONFIG_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_ENABLED_DQ_CHA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_ENABLED_DQ_CHA_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PHY_ENABLED_DQ_CHB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PHY_ENABLED_DQ_CHB_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TX_IMPEDANCE_CTRL1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_TX_IMPEDANCE_CTRL1_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_TX_IMPEDANCE_CTRL2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_TX_IMPEDANCE_CTRL2_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_MRR_ODT_TERM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_MRR_ODT_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_FW_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DRAMINIT_FW_REVISION_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DRAMINIT_INTERNAL_FW_REVISION0_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DRAMINIT_INTERNAL_FW_REVISION1_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t ODY_DRAMINIT_FW_DATA_ADDR_OFFSET_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DMEM_FIRST_LOAD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DMEM_FIRST_LOAD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PSRO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ODY_PSRO_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_SETUP_SAFEMODE_THROTTLES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_SETUP_SAFEMODE_THROTTLES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_DISABLE_DRAM_WITH_BAD_DQ0_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_RX_LANES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OMI_RX_LANES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_TX_LANES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OMI_TX_LANES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_BIST_ESD_TEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_BIST_ESD_TEST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_BIST_DAC_TEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_BIST_DAC_TEST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_BIST_TIMER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_BIST_TIMER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_CHANNEL_LENGTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OMI_CHANNEL_LENGTH_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_RX_LTEG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int32_t Type;
#if __cplusplus >= 201103L 
        static constexpr int32_t OMI_RX_LTEG_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_RX_LTEZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int32_t Type;
#if __cplusplus >= 201103L 
        static constexpr int32_t OMI_RX_LTEZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_TX_PRE1>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_TX_PRE1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_TX_PRE2>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_TX_PRE2_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_TX_POST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_TX_POST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_RX_VERT_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_RX_VERT_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_RX_HORIZ_DATA_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_RX_HORIZ_DATA_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_RX_HORIZ_EDGE_OFFSET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_RX_HORIZ_EDGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OMI_EDPL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OMI_EDPL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HOTPLUG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HOTPLUG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HOTPLUG_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HOTPLUG_MASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_REL_POS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_REL_POS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_PLL_BUCKET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_PLL_BUCKET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_PLL_BUCKET_SIM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_PLL_BUCKET_SIM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SIM_CHIPLET_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SIM_CHIPLET_MASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SCAN0_SCAN_RATIO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SCAN0_SCAN_RATIO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_BOOT_SIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_BOOT_SIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_BOOT_FLAGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OCMB_BOOT_FLAGS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ENABLE_LBIST>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ENABLE_LBIST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ENABLE_ABIST>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ENABLE_ABIST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECURITY_LEVEL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECURITY_LEVEL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RTG_SCAN_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RTG_SCAN_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_PMIC_4U_N_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_PMIC_4U_N_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_PMIC_FORCE_N_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_PMIC_FORCE_N_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_FAIL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_FAIL_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_PMIC0_MFG_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG0_R40_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG1_R41_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG2_R42_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG3_R43_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_PMIC1_MFG_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG0_R40_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG1_R41_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG2_R42_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG3_R43_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_PMIC2_MFG_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG0_R40_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG1_R41_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG2_R42_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG3_R43_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_MFG_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t MEM_EFF_PMIC3_MFG_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG0_R40_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG1_R41_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG2_R42_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG3_R43_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_REDUNDANCY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_REDUNDANCY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_PHASE_COMB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_PHASE_COMB_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SEQUENCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SEQUENCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWA_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWB_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWC_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC0_SWD_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_REDUNDANCY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_REDUNDANCY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_PHASE_COMB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_PHASE_COMB_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SEQUENCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SEQUENCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWA_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWB_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWC_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC1_SWD_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_PHASE_COMB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_PHASE_COMB_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SEQUENCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SEQUENCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWA_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWB_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWC_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC2_SWD_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_REVISION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_REVISION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_PHASE_COMB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_PHASE_COMB_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SEQUENCE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SEQUENCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWA_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWB_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWC_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_EFF_PMIC3_SWD_CURRENT_WARNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PB_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PB_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_X_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_X_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MC_SYNC_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MC_SYNC_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_CORE_NOMINAL_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_CORE_NOMINAL_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_BOOT_FREQ_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t BOOT_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_RISK_LEVEL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RISK_LEVEL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PM_RESET_FFDC_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PM_RESET_FFDC_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EFF_FABRIC_GROUP_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_EFF_FABRIC_GROUP_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HB_HRMOR_BYTES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HB_HRMOR_BYTES_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_EFF_FABRIC_CHIP_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_EFF_FABRIC_CHIP_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_O_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_O_MHZ_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_OPTICS_CONFIG_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OPTICS_CONFIG_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_RDVREF_CAL_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSS_RDVREF_CAL_ENABLE_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SKIP_HW_VREF_CAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SKIP_HW_VREF_CAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SKIP_RD_VREF_VREFSENSE_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_RTT_NOM_OVERRIDE_DISABLE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PERF_24x7_INVOCATION_TIME_MS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PERF_24x7_INVOCATION_TIME_MS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CME_INSTRUCTION_TRACE_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CME_INSTRUCTION_TRACE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_VFRT_STATIC_DATA_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYS_VFRT_STATIC_DATA_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OBUS_DCCAL_FLAGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OBUS_DCCAL_FLAGS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_O_DEBUG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_O_DEBUG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OBUS_TX_MARGIN_RATIO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OBUS_TX_MARGIN_RATIO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OBUS_TX_FFE_PRECURSOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OBUS_TX_FFE_PRECURSOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_OBUS_TX_FFE_POSTCURSOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_OBUS_TX_FFE_POSTCURSOR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_RANK_GROUP_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint16_t EFF_RANK_GROUP_OVERRIDE_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IO_X_MFG_CHK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_X_MFG_CHK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_X_MFG_MIN_EYE_WIDTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_X_MFG_MIN_EYE_WIDTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_O_MFG_STRESS_PR_OFFSET_EVEN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_O_MFG_STRESS_PR_OFFSET_ODD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CME_CHTM_TRACE_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CME_CHTM_TRACE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CME_CHTM_TRACE_MEMORY_CONFIG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t CME_CHTM_TRACE_MEMORY_CONFIG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_VDM_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_VDM_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_VDM_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t VDM_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t IO_XBUS_GRP0_PRE_BAD_LANE_DATA_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t IO_XBUS_GRP1_PRE_BAD_LANE_DATA_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_IVRM_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_IVRM_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IVRM_ENABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IVRM_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_ENABLE_FRATIO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_ENABLE_FRATIO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_ENABLE_VRATIO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_ENABLE_VRATIO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_VRATIO_SELECT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_VRATIO_SELECT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_LEAKAGE_PERCENT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NEST_LEAKAGE_PERCENT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_RUN_DCD_CALIBRATION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_RUN_DCD_CALIBRATION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_EFF_WR_CRC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_EFF_WR_CRC_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IO_O_MFG_CHK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_O_MFG_CHK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_O_MFG_MIN_EYE_WIDTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_O_MFG_MIN_EYE_WIDTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_CORECACHE_SKEWADJ_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYSTEM_CORECACHE_DCADJ_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EQ_INSIDE_SPECIAL_WAKEUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EQ_INSIDE_SPECIAL_WAKEUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VPD_MT_MC_BIAS_TRIM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_VPD_MT_MC_BIAS_TRIM_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EX_INSIDE_SPECIAL_WAKEUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EX_INSIDE_SPECIAL_WAKEUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_XBUS_CHAN_EQ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_XBUS_CHAN_EQ_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IO_O_CHANNEL_TYPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IO_O_CHANNEL_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_PLL_BUCKET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NEST_PLL_BUCKET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_AFFINITY_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EntityPath Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_ALLOW_EEPROM_WRITES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ALLOW_EEPROM_WRITES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ALL_MCS_IN_INTERLEAVING_GROUP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ALL_MCS_IN_INTERLEAVING_GROUP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ALTFSI_MASTER_CHIP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EntityPath Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_ALTFSI_MASTER_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ALTFSI_MASTER_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ASYNC_NEST_FREQ_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ASYNC_NEST_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ATTN_AREA_1_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ATTN_AREA_1_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ATTN_AREA_2_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ATTN_AREA_2_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_AVDD_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t AVDD_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_BLOCK_SPEC_DECONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t BLOCK_SPEC_DECONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BMC_FRU_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t BMC_FRU_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CDM_DOMAIN>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef CDM_DOMAIN Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CDM_DOMAIN_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CDM_POLICIES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CDM_POLICIES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEC_IPL_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef CecIplType Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_CENTAUR_ECID_FRU_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CENTAUR_ECID_FRU_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_AVDD_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VCS_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VDDR_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VDD_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VPP_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHASSIS_LOCATION_CODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef CHECK_ATTN_AFTER_ISTEP_FAIL Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CHECK_ATTN_AFTER_ISTEP_FAIL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHIPLET_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHIPLET_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHIP_FAN_CFM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t CHIP_FAN_CFM_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHIP_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CHIP_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CHIP_UNIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CHIP_UNIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLASS>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef CLASS Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CLASS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_COLLECT_SBE_SCRATCH_DATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t COLLECT_SBE_SCRATCH_DATA_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_IS_SPARE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_IS_SPARE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CPU_ATTR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CPU_ATTR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DATA_CACHE_LINE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DATA_CACHE_LINE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DATA_CACHE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DATA_CACHE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DCACHE_ASSOC_SETS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DCACHE_ASSOC_SETS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DCACHE_LINE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DCACHE_LINE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DEBUG_OCMB_LOGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef DebugOcmbLogs Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_DEBUG_ODY_HRESET_CONTROL>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DEBUG_ODY_HRESET_CONTROL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DECONFIG_GARDABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DECONFIG_GARDABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DIMM_POWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[12];
#if __cplusplus >= 201103L 
        static constexpr uint32_t DIMM_POWER_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 12> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DIMM_POWER_UTIL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[12];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DIMM_POWER_UTIL_INVALID = 0xFF;
        typedef std::array<uint8_t, 12> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[10];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DIMM_POWER_UTIL_INTERMEDIATE_POINTS_INVALID = 0xFF;
        typedef std::array<uint8_t, 10> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DIMM_PREHEAT_POWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[12];
#if __cplusplus >= 201103L 
        static constexpr uint32_t DIMM_PREHEAT_POWER_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 12> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_PLD_WAIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_PLD_WAIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_PREDICTIVE_MEM_GUARD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_PREDICTIVE_MEM_GUARD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DUMMY_HEAP_ZERO_DEFAULT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DUMMY_HEAP_ZERO_DEFAULT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DUMMY_RO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DUMMY_RO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DUMMY_RW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[1][3][5];
#if __cplusplus >= 201103L 
        static constexpr uint8_t DUMMY_RW_INVALID = 0xFF;
        typedef std::array<std::array<std::array<uint8_t, 5>, 3>, 1> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_DUMMY_WO>
{
    public:
        enum { writeable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DUMMY_WO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EECACHE_DISABLE_AUTO_RESET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EECACHE_DISABLE_AUTO_RESET_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EECACHE_VPD_STATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EECACHE_VPD_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EECACHE_VPD_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_CONTENT_TYPE>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef EEPROM_CONTENT_TYPE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EEPROM_CONTENT_TYPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_NV_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EepromNvInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_SBE_BACKUP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EepromSbeBackupInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_SBE_PRIMARY_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EepromSbePrimaryInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_VPD_ACCESSIBILITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EEPROM_VPD_ACCESSIBILITY Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EEPROM_VPD_ACCESSIBILITY_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_VPD_ACTIVE_COPY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EEPROM_VPD_ACTIVE_COPY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_VPD_BACKUP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EepromVpdBackupInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_VPD_PRIMARY_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EepromVpdPrimaryInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_EEPROM_VPD_REDUNDANCY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef EEPROM_VPD_REDUNDANCY Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EEPROM_VPD_REDUNDANCY_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EFFECTIVE_EC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFFECTIVE_EC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ENABLED_THREADS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ENABLED_THREADS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ENGINE_TYPE>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef ENGINE_TYPE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ENGINE_TYPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FABRIC_CHIP_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FABRIC_CHIP_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FABRIC_GROUP_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FABRIC_GROUP_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FABRIC_PRESENT_GROUPS>
{
    public:
        enum { writeable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FABRIC_PRESENT_GROUPS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FABRIC_TO_PHYSICAL_NODE_MAP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t FABRIC_TO_PHYSICAL_NODE_MAP_INVALID = 0xFF;
        typedef std::array<uint8_t, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FAPI_I2C_CONTROL_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef FapiI2cControlInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_FAPI_NAME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FIELD_CORE_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FIELD_CORE_OVERRIDE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FIELD_TH_L2_LINE_DELETES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FIELD_TH_L2_LINE_DELETES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FIELD_TH_L3_LINE_DELETES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FIELD_TH_L3_LINE_DELETES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FORCE_SBE_SCRATCH_DATA_COLLECTION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FORCE_SERIAL_ISTEPS>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FORCE_SERIAL_ISTEPS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FORCE_SRAM_MMIO_OVER_I2C>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FORCE_SRAM_MMIO_OVER_I2C_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FOUND_PRESENT_BY_SP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef FOUND_PRESENT_BY_SP Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FOUND_PRESENT_BY_SP_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_CORE_CEILING_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_CORE_CEILING_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PROC_REFCLOCK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PROC_REFCLOCK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FRU_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FRU_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSI_MASTER_CHIP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EntityPath Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_FSI_MASTER_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSI_MASTER_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSI_MASTER_TYPE>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef FSI_MASTER_TYPE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FSI_MASTER_TYPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSI_OPTION_FLAGS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef FsiOptionFlags Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_FSI_SLAVE_CASCADE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSI_SLAVE_CASCADE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_BAR_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t FSP_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_BASE_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t FSP_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_FUSED_CORE_MODE_HB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FUSED_CORE_MODE_HB_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FUSED_CORE_OPTION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FUSED_CORE_OPTION_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HBRT_HYP_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HBRT_HYP_ID_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HB_HRMOR_NODAL_BASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HB_HRMOR_NODAL_BASE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HB_MIN_BACKING_CACHE_FC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HB_MIN_BACKING_CACHE_FC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HB_RSV_MEM_SIZE_MB>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HB_RSV_MEM_SIZE_MB_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HB_SETTINGS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef HbSettings Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_HB_SETTINGS_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HB_SETTINGS_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HDAT_EC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HDAT_EC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HDAT_HBRT_NUM_SECTIONS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HDAT_HBRT_NUM_SECTIONS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HDAT_HBRT_SECTION_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[9];
#if __cplusplus >= 201103L 
        static constexpr uint64_t HDAT_HBRT_SECTION_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 9> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_HDAT_RSV_MEM_NUM_SECTIONS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HDAT_RSV_MEM_NUM_SECTIONS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HDDW_ORDER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HDDW_ORDER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HOMER_PHYS_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HOMER_PHYS_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HOSTSVC_PLID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HOSTSVC_PLID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HOT_PLUG_POWER_CONTROLLER_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[8][8];
#if __cplusplus >= 201103L 
        static constexpr uint8_t HOT_PLUG_POWER_CONTROLLER_INFO_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 8>, 8> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_HUID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HUID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HWAS_STATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef HwasState Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_HWAS_STATE_CHANGED_FLAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HWAS_STATE_CHANGED_FLAG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t HWAS_STATE_CHANGED_SUBSCRIPTION_MASK_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_HWAS_STATE_TESTSAVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef HwasStateTestsave Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_I2C_BUS_SPEED_ARRAY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4][16];
#if __cplusplus >= 201103L 
        static constexpr uint16_t I2C_BUS_SPEED_ARRAY_INVALID = 0xFFFF;
        typedef std::array<std::array<uint16_t, 16>, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_CONTROL_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef I2cControlInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_SWITCHES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef I2cSwitches Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_IBSCOM_MCS_BASE_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t IBSCOM_MCS_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_IBSCOM_PROC_BASE_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t IBSCOM_PROC_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ICACHE_ASSOC_SETS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ICACHE_ASSOC_SETS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ICACHE_BLOCK_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ICACHE_BLOCK_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ICACHE_LINE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ICACHE_LINE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ICACHE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ICACHE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_INIT_TO_AVAILABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t INIT_TO_AVAILABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_INT_CQ_TM_BAR_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t INT_CQ_TM_BAR_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ISTEP_CALLOUT_INJECT_ACTION>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ISTEP_CALLOUT_INJECT_ACTION_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ISTEP_CALLOUT_INJECT_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ISTEP_CALLOUT_INJECT_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ISTEP_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ISTEP_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ISTEP_PAUSE_CONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t ISTEP_PAUSE_CONFIG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ISTEP_PAUSE_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ISTEP_PAUSE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_INTER_ENCLOSURE_BUS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_INTER_ENCLOSURE_BUS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_STANDALONE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_STANDALONE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_KEY_CLEAR_REQUEST>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef KEY_CLEAR_REQUEST Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t KEY_CLEAR_REQUEST_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_KEY_TRANSITION_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef KEY_TRANSITION_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t KEY_TRANSITION_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_L2_CACHE_ASSOC_SETS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t L2_CACHE_ASSOC_SETS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_L2_CACHE_LINE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t L2_CACHE_LINE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_L2_CACHE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t L2_CACHE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_L3_CACHE_LINE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t L3_CACHE_LINE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_L3_CACHE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t L3_CACHE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_LAST_IPLTIME_EID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t LAST_IPLTIME_EID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_LMB_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t LMB_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_LOCATION_CODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_LPC_BUS_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t LPC_BUS_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_CHIPLETS_PER_PROC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_CHIPLETS_PER_PROC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_COMPUTE_NODES_PER_SYSTEM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_COMPUTE_NODES_PER_SYSTEM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_DIMMS_PER_MBA_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_DIMMS_PER_MBA_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_DIMM_POWER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAX_DIMM_POWER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_DMI_PER_PROC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_DMI_PER_PROC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_EXS_PER_PROC_CHIP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_EXS_PER_PROC_CHIP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_MBAS_PER_MEMBUF_CHIP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_MBAS_PER_MEMBUF_CHIP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_MBA_PORTS_PER_MBA>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_MBA_PORTS_PER_MBA_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_MCS_PER_SYSTEM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_MCS_PER_SYSTEM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_POWER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_POWER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_PROC_CHIPS_PER_NODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_PROC_CHIPS_PER_NODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MBA_DIMM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MBA_DIMM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MBA_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MBA_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_AVDD_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_AVDD_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_BASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MEM_BASE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MEM_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_VCS_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_VCS_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_VDDR_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_VDDR_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_VDD_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_VDD_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MEM_VPP_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MEM_VPP_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MFG_TRACE_ENABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MFG_TRACE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MGC_LOAD_SOURCE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MGC_LOAD_SOURCE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MIN_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MIN_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MIRROR_BASE_ADDRESS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MIRROR_BASE_ADDRESS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MMIO_PHYS_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MMIO_PHYS_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_ABUS_MIN_EYE_HEIGHT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_ABUS_MIN_EYE_HEIGHT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_ABUS_MIN_EYE_WIDTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_ABUS_MIN_EYE_WIDTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_DMI_MIN_EYE_HEIGHT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_DMI_MIN_EYE_HEIGHT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_DMI_MIN_EYE_WIDTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_DMI_MIN_EYE_WIDTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_L2_CACHE_CES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_L2_CACHE_CES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_L2_DIR_CES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_L2_DIR_CES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_L2_LINE_DELETES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_L2_LINE_DELETES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_L3_CACHE_CES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_L3_CACHE_CES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_L3_DIR_CES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_L3_DIR_CES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_L3_LINE_DELETES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_L3_LINE_DELETES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_MEMORY_IMPES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_MEMORY_IMPES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_MEMORY_IUES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_MEMORY_IUES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_MEMORY_RCD_PARITY_ERRORS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_MEMORY_RT_RCE_PER_RANK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MNFG_XBUS_MIN_EYE_WIDTH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MNFG_XBUS_MIN_EYE_WIDTH_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MODEL>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef MODEL Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MODEL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRU_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRU_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_DDR3_VDDR_MAX_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_DDR3_VDDR_MAX_LIMIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_DDR4_VDDR_MAX_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_DDR4_VDDR_MAX_LIMIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_DEFAULT_RISK_LEVEL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_DEFAULT_RISK_LEVEL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MRW_MEM_THROTTLE_DENOMINATOR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MRW_MEM_THROTTLE_DENOMINATOR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSL_FIELD_SUPPORTED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[12];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSL_FIELD_SUPPORTED_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 12> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSL_MFG_ALLOW>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[12];
#if __cplusplus >= 201103L 
        static constexpr uint16_t MSL_MFG_ALLOW_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 12> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_AVDD_PROGRAM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_AVDD_PROGRAM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_AVDD_INTERCEPT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_AVDD_INTERCEPT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_AVDD_SLOPE_ACTIVE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_AVDD_SLOPE_INACTIVE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_VCS_INTERCEPT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_VCS_INTERCEPT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_VCS_SLOPE_ACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_VCS_SLOPE_ACTIVE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_VCS_SLOPE_INACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_VCS_SLOPE_INACTIVE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_VDD_INTERCEPT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_VDD_INTERCEPT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_VDD_SLOPE_ACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_VDD_SLOPE_ACTIVE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_CENT_VDD_SLOPE_INACTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_CENT_VDD_SLOPE_INACTIVE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_DATABUS_UTIL_PER_MBA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_DATABUS_UTIL_PER_MBA_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MBA_ADDR_INTERLEAVE_BIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_MBA_CACHELINE_INTERLEAVE_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_PHY_SEQ_REFRESH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_PHY_SEQ_REFRESH_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VCS_PROGRAM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_VCS_PROGRAM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VDDR_PROGRAM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_VDDR_PROGRAM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VDD_PROGRAM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_VDD_PROGRAM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_AVDD_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_AVDD_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR3_VDDR_INTERCEPT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR3_VDDR_SLOPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR3_VDDR_SLOPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR4_VDDR_INTERCEPT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR4_VDDR_SLOPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR4_VDDR_SLOPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VCS_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VCS_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VCS_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VDDR_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VDDR_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VDD_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VDD_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VDD_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VPP_INTERCEPT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VPP_INTERCEPT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VPP_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VPP_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VPP_OFFSET_MILLIVOLTS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VPP_SLOPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VPP_SLOPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_VPP_PROGRAM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSS_VPP_PROGRAM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_PLL_FREQ_BUCKETS>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NEST_PLL_FREQ_BUCKETS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_PLL_FREQ_I2CDIV_LIST>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint32_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint32_t NEST_PLL_FREQ_I2CDIV_LIST_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_PLL_FREQ_LIST>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint32_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint32_t NEST_PLL_FREQ_LIST_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_VCS_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t NEST_VCS_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_VDDR_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t NEST_VDDR_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_VDD_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t NEST_VDD_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_VDN_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t NEST_VDN_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NEST_VIO_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t NEST_VIO_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NO_RECONFIG_ON_DECONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NO_RECONFIG_ON_DECONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NPU_MMIO_BAR_BASE_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[4][2];
#if __cplusplus >= 201103L 
        static constexpr uint64_t NPU_MMIO_BAR_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<std::array<uint64_t, 2>, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NPU_MMIO_BAR_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[4][2];
#if __cplusplus >= 201103L 
        static constexpr uint64_t NPU_MMIO_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<std::array<uint64_t, 2>, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NUMERIC_POD_TYPE_TEST>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef NumericPodTypeTest Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_NVDIMM_ARMED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef NvdimmArmed Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_NV_OPS_TIMEOUT_MSEC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type[6];
#if __cplusplus >= 201103L 
        static constexpr uint32_t NV_OPS_TIMEOUT_MSEC_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 6> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NV_STATUS_FLAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NV_STATUS_FLAG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OBUS_BRICK_LANE_MASK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OBUS_BRICK_LANE_MASK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OBUS_SLOT_INDEX>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OBUS_SLOT_INDEX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCC_MASTER_CAPABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCC_MASTER_CAPABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_BOOT_SIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_BOOT_SIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_CODE_LEVEL_SUMMARY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[256];
#if __cplusplus >= 201103L 
        typedef std::array<char, 256> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_CODE_UPDATED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_CODE_UPDATED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_FORCE_IMAGE_SYNC>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_FORCE_IMAGE_SYNC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_FW_STATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef OCMB_FW_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OCMB_FW_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_FW_UPDATE_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_FW_UPDATE_OVERRIDE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_FW_UPDATE_STATUS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef OcmbFwUpdateStatus Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_GOLDEN_BOOT_ATTEMPTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_IGNORE_SCOM_CHECK_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_ISTEP_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_ISTEP_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCMB_RESET_DELAY_SEC>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t OCMB_RESET_DELAY_SEC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint64_t ODYSSEY_PRIORITY_CODE_UPDATE_RULE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ODY_PNOR_COMBINED_IMAGES_HASH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint8_t ODY_PNOR_COMBINED_IMAGES_HASH_INVALID = 0xFF;
        typedef std::array<uint8_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_ORDINAL_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ORDINAL_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PARENT_DECONFIG_RULES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef ParentDeconfigRules Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_PAYLOAD_BASE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PAYLOAD_BASE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PAYLOAD_ENTRY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PAYLOAD_ENTRY_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PAYLOAD_IN_MIRROR_MEM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PAYLOAD_IN_MIRROR_MEM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PAYLOAD_KIND>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef PAYLOAD_KIND Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PAYLOAD_KIND_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_32BIT_DMA_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCIE_32BIT_DMA_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_32BIT_MMIO_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCIE_32BIT_MMIO_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_64BIT_DMA_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCIE_64BIT_DMA_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_64BIT_MMIO_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCIE_64BIT_MMIO_SIZE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_CAPABILITES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCIE_CAPABILITES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_NVME_CCIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PCIE_NVME_CCIN_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PCIE_NVME_PHB_CONFIG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PCIE_NVME_PHB_CONFIG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<std::array<uint64_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PCI_REFCLOCK_RCVR_TERM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PCI_REFCLOCK_RCVR_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_IS_BIFURCATABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_IS_BIFURCATABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_HX_KEYWORD_DATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[9];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_PCIE_HX_KEYWORD_DATA_INVALID = 0xFF;
        typedef std::array<uint8_t, 9> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_IOP_REVERSAL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_PCIE_IOP_REVERSAL_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_PCIE_IOP_REVERSAL_BIFURCATED_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_PCIE_IOP_SWAP_BIFURCATED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PEC_PCIE_IOP_SWAP_NON_BIFURCATED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_LANE_MASK_BIFURCATED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PEC_PCIE_LANE_MASK_BIFURCATED_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PEC_PCIE_LANE_MASK_NON_BIFURCATED_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PEER_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EntityPath Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_PEER_TARGET>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef TARGETING::Target* Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_PG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PG_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PG_SAVED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PG_SAVED_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PHB_BASE_ADDRS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint64_t PHB_BASE_ADDRS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PHYS_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EntityPath Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_PIB_I2C_NEST_PLL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PIB_I2C_NEST_PLL_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PIB_I2C_REFCLOCK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PIB_I2C_REFCLOCK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PLCK_IPL_ATTR_OVERRIDES_EXIST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PMIC_CALLBACK_STAGGER_TIME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PMIC_CALLBACK_STAGGER_TIME_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PMIC_HEALTH_CHECK_DDR5_TIMER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PMIC_HEALTH_CHECK_TIMER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PMIC_HEALTH_CHECK_TIMER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PNOR_FLASH_WORKAROUNDS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PNOR_FLASH_WORKAROUNDS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_POSITION>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t POSITION_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_POS_ON_MEM_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t POS_ON_MEM_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_POWERVS_P10_FW_VER>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3][3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t POWERVS_P10_FW_VER_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 3>, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_POWER_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef EntityPath Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PRD_DD1_OMI_DEGRADE_PREDICTIVE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PRD_HWP_PLID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PRD_HWP_PLID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PREHEAT_PERCENT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PREHEAT_PERCENT_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PRIMARY_CAPABILITIES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef PrimaryCapabilities Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_PROC_COMPATIBILITY_REQ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef PROC_COMPATIBILITY_REQ Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_COMPATIBILITY_REQ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_DCM_INSTALLED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_DCM_INSTALLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MASTER_TYPE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_MASTER_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_MODULE_TYPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef PROC_MODULE_TYPE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_MODULE_TYPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_IOP_CONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_IOP_CONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_IOVALID_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_IOVALID_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_IS_SLOT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_IS_SLOT_INVALID = 0xFF;
        typedef std::array<uint8_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[16];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_LANE_EQUALIZATION_GEN3_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 16> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[16];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_LANE_EQUALIZATION_GEN4_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 16> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[16];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_LANE_EQUALIZATION_GEN5_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 16> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_LANE_MASK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_LANE_MASK_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_LANE_REVERSAL_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_LANE_REVERSAL_BASE_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_NUM_PEC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_NUM_PEC_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_PCS_RX_LOFF_CONTROL_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_PCS_RX_SIGDET_CNTL_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type[4];
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3_INVALID = 0xFFFF;
        typedef std::array<uint16_t, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_PHB_ACTIVE_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_PHB_ACTIVE_BASE_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_REFCLOCK_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_REFCLOCK_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_REFCLOCK_RCVR_TERM>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_REFCLOCK_RCVR_TERM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_SELECT_BOOT_SEEPROM_IMAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SELECT_SEEPROM_IMAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_SELECT_SEEPROM_IMAGE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PSI_BRIDGE_BASE_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PSI_BRIDGE_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PSI_HB_ESB_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t PSI_HB_ESB_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RAW_MTM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCD_PARITY_RECONFIG_LOOPS_ALLOWED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RCD_PARITY_RECONFIG_LOOP_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RECONFIG_LOOP_TESTS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type[5];
#if __cplusplus >= 201103L 
        static constexpr uint64_t RECONFIG_LOOP_TESTS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
        typedef std::array<uint64_t, 5> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_RECONFIG_LOOP_TESTS_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RECONFIG_LOOP_TESTS_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_REDUNDANT_CLOCKS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t REDUNDANT_CLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_REL_POS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t REL_POS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_REPLACED_BY_SPARE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t REPLACED_BY_SPARE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RESOURCE_IS_CRITICAL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RESOURCE_IS_CRITICAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RISK_LEVEL_ORIGIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef RISK_LEVEL_ORIGIN Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t RISK_LEVEL_ORIGIN_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_RNG_BAR_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RNG_BAR_SIZE_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RNG_BASE_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t RNG_BASE_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_RUN_MAX_MEM_PATTERNS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUN_MAX_MEM_PATTERNS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RUN_ODY_HWP_FROM_HOST>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RUN_ODY_HWP_FROM_HOST_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SAVED_STATE_UINT8>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SAVED_STATE_UINT8_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_BOOTLOADER_CODELEVEL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_BOOTLOADER_CODELEVEL_INVALID = 0xFF;
        typedef std::array<uint8_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_BUILD_TAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[21];
#if __cplusplus >= 201103L 
        typedef std::array<char, 21> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_COMMIT_ID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_COMMIT_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_EKB_BUILD_TAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[21];
#if __cplusplus >= 201103L 
        typedef std::array<char, 21> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_FIFO_CAPABILITIES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type[40];
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_FIFO_CAPABILITIES_INVALID = 0xFFFFFFFF;
        typedef std::array<uint32_t, 40> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_HANDLES_SMP_TPM_EXTEND>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_HANDLES_SMP_TPM_EXTEND_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_IS_STARTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_IS_STARTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_NUM_CAPABILITIES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_NUM_CAPABILITIES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_NUM_IMAGES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_NUM_IMAGES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_RELEASE_TAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[21];
#if __cplusplus >= 201103L 
        typedef std::array<char, 21> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_RUNTIME_CODELEVEL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_RUNTIME_CODELEVEL_INVALID = 0xFF;
        typedef std::array<uint8_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_UPDATE_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_UPDATE_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SBE_VERSION_INFO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_VERSION_INFO_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SCOM_SWITCHES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef ScomSwitches Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SCRATCH_UINT32_1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SCRATCH_UINT32_1_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SCRATCH_UINT32_2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SCRATCH_UINT32_2_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SCRATCH_UINT64_1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SCRATCH_UINT64_1_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SCRATCH_UINT64_2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SCRATCH_UINT64_2_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SCRATCH_UINT8_1>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SCRATCH_UINT8_1_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SCRATCH_UINT8_2>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SCRATCH_UINT8_2_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECUREBOOT_PROTECT_DECONFIGURED_TPM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECURE_VERSION_LOCKIN_POLICY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECURE_VERSION_LOCKIN_POLICY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECURE_VERSION_NUM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECURE_VERSION_NUM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECURE_VERSION_SEEPROM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECURE_VERSION_SEEPROM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SKIP_HBRT_ATTR_UPDATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SKIP_HBRT_ATTR_UPDATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SLOT_INDEX>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SLOT_INDEX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SLOT_NAME>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SLOT_NAME_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SMF_MEM_AMT_REQUESTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SMF_MEM_AMT_REQUESTED_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SOCKET_POWER_TURBO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SOCKET_POWER_TURBO_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPARE_CORES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPARE_CORES_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPARE_CORES_DEPLOYED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPARE_CORES_DEPLOYED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPARE_CORE_ACTIONS_DISABLED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPARE_CORE_ACTIONS_DISABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPI_EEPROM_SPARE_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiEepromSpareInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_EEPROM_VPD_BACKUP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiEepromVpdBackupInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_EEPROM_VPD_PRIMARY_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiEepromVpdPrimaryInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_KEYSTORE_INFO_HOSTBOOT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiKeystoreInfoHostboot Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_KEYSTORE_INFO_OPAL_0>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiKeystoreInfoOpal0 Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_KEYSTORE_INFO_OPAL_1>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiKeystoreInfoOpal1 Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_KEYSTORE_INFO_OPAL_2>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiKeystoreInfoOpal2 Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_KEYSTORE_INFO_PHYP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiKeystoreInfoPhyp Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_MVPD_BACKUP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiMvpdBackupInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_MVPD_PRIMARY_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiMvpdPrimaryInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiSbeBootCodeBackupInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiSbeBootCodePrimaryInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiSbeMeasurementCodeBackupInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiSbeMeasurementCodePrimaryInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_SWITCHES>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef SpiSwitches Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_TPM_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiTpmInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPI_WOF_DATA_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpiWofDataInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_BOOTLOADER_MEASUREMENT_HASH_INVALID = 0xFF;
        typedef std::array<uint8_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SPPE_RUNTIME_MEASUREMENT_HASH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPPE_RUNTIME_MEASUREMENT_HASH_INVALID = 0xFF;
        typedef std::array<uint8_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SP_FUNCTIONS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SpFunctions Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_STOP5_DISABLE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t STOP5_DISABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SUPPORTED_STOP_STATES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SUPPORTED_STOP_STATES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SUPPORTS_DYNAMIC_MEM_VOLT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SUPPORTS_DYNAMIC_MEM_VOLT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG>
{
    public:
        enum { readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t SW511706_CHECKSTOP_ON_GTE_LV1_HANG_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_SYNC_BETWEEN_STEPS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SYNC_BETWEEN_STEPS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_FAMILY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_THERMAL_RESISTANCE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SYSTEM_THERMAL_RESISTANCE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_TYPE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SYS_LOCATION_CODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[64];
#if __cplusplus >= 201103L 
        typedef std::array<char, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_TCE_START_TOKEN_FOR_HDAT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TCE_START_TOKEN_FOR_HDAT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TCE_START_TOKEN_FOR_PAYLOAD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TCE_START_TOKEN_FOR_PAYLOAD_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TEMP_SENSOR_I2C_CONFIG>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef TempSensorI2cConfig Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_TEST_MAX_STRING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[4];
#if __cplusplus >= 201103L 
        typedef std::array<char, 4> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_TEST_MIN_STRING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[10];
#if __cplusplus >= 201103L 
        typedef std::array<char, 10> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_TEST_NEGATIVE_FCN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t TEST_NEGATIVE_FCN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TEST_NO_DEFAULT_STRING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[10];
#if __cplusplus >= 201103L 
        typedef std::array<char, 10> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_TEST_NULL_STRING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[10];
#if __cplusplus >= 201103L 
        typedef std::array<char, 10> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_THREAD_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t THREAD_COUNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TIME_BASE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TIME_BASE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TLB_DATA_ASSOC_SETS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TLB_DATA_ASSOC_SETS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TLB_DATA_ENTRIES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TLB_DATA_ENTRIES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TLB_INSTR_ASSOC_SETS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TLB_INSTR_ASSOC_SETS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TLB_INSTR_ENTRIES>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TLB_INSTR_ENTRIES_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TLB_RESERVE_SIZE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TLB_RESERVE_SIZE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TOD_CPU_DATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type[44];
#if __cplusplus >= 201103L 
        static constexpr uint8_t TOD_CPU_DATA_INVALID = 0xFF;
        typedef std::array<uint8_t, 44> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_TOD_ROLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TOD_ROLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TPM_ENABLED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TPM_ENABLED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TPM_POISONED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TPM_POISONED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TPM_REQUIRED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TPM_REQUIRED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TPM_UNUSABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TPM_UNUSABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TYPE>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef TYPE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TYPE_INVALID = 0x7F;
#endif
};

template<>
class AttributeTraits<ATTR_UCD_MFR_REVISION_OVERRIDE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t UCD_MFR_REVISION_OVERRIDE_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ULTRA_TURBO_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ULTRA_TURBO_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_USE_11S_SPD>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t USE_11S_SPD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_USE_PIPE_FIFO>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t USE_PIPE_FIFO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_USE_TCES_FOR_DMAS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t USE_TCES_FOR_DMAS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_VCS_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t VCS_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VDDR_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t VDDR_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VDD_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t VDD_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VENDOR_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t VENDOR_ID_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_VPD_REC_NUM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t VPD_REC_NUM_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VPP_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t VPP_ID_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_POWER_LIMIT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t WOF_POWER_LIMIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_WOF_TABLE_LID_NUMBER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t WOF_TABLE_LID_NUMBER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_XIVE_CONTROLLER_BAR_ADDR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t XIVE_CONTROLLER_BAR_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_XSCOM_BASE_ADDRESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t XSCOM_BASE_ADDRESS_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_CHIP_INFO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef I2cChipInfo Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SBE_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef SBE_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SBE_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HCSI_CHIP_SBE_INTERFACE_PTR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HCSI_CHIP_SBE_INTERFACE_PTR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HCSI_CHIP_INTERFACE_PTR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HCSI_CHIP_INTERFACE_PTR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SCANRING_FACTORY_PTR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SCANRING_FACTORY_PTR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ALG_TYPE_TO_ALG_TOKEN_CONTAINER_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_ECMD_TARGET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[64];
#if __cplusplus >= 201103L 
        static constexpr uint8_t ECMD_TARGET_INVALID = 0xFF;
        typedef std::array<uint8_t, 64> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_RID>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t RID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_SCOM_DEVICE_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_SCOM_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_SCOM_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_SCAN_DEVICE_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_SCAN_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_SCAN_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_MBOX_DEVICE_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_MBOX_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_MBOX_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_SBEFIFO_DEVICE_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_SBEFIFO_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_SBEFIFO_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_MS_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MAX_MS_ADDR_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PAYLOAD_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef PAYLOAD_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PAYLOAD_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PAYLOAD_STARTED>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PAYLOAD_STARTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HB_RUNNING>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HB_RUNNING_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_RESUME_PAYLOAD>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RESUME_PAYLOAD_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PSI_LINK_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef PSI_LINK_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PSI_LINK_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PSI_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[38];
#if __cplusplus >= 201103L 
        typedef std::array<char, 38> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_HOST_MAILBOX_DEV_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[17];
#if __cplusplus >= 201103L 
        typedef std::array<char, 17> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_MTD_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_MTDBLOCK_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[30];
#if __cplusplus >= 201103L 
        typedef std::array<char, 30> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_HOSTBOOT_IMG_OFFSET>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t EFF_HOSTBOOT_IMG_OFFSET_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_HW_TOPOLOGY>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint16_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint16_t PROC_HW_TOPOLOGY_INVALID = 0xFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VMEM_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VMEM_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VMEM_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VDDR_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VDDR_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VDDR_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VDD_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VDD_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VDD_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_AVDD_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_AVDD_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_AVDD_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VCS_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VCS_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VCS_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VPP_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VPP_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VPP_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VIO_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VIO_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VIO_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VDN_DEVICE_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[25];
#if __cplusplus >= 201103L 
        typedef std::array<char, 25> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_VDN_I2C_ADDR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_VDN_I2C_ADDR_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_MPIPL>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_MPIPL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MSL_CHECK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MSL_CHECK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PRIMARY_SBE_SEEPROM_ADDRESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[50];
#if __cplusplus >= 201103L 
        typedef std::array<char, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[50];
#if __cplusplus >= 201103L 
        typedef std::array<char, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[50];
#if __cplusplus >= 201103L 
        typedef std::array<char, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SECONDARY_SBE_SEEPROM_ADDRESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[50];
#if __cplusplus >= 201103L 
        typedef std::array<char, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[50];
#if __cplusplus >= 201103L 
        typedef std::array<char, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[50];
#if __cplusplus >= 201103L 
        typedef std::array<char, 50> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SELECT_CLOCK_MUX_MODE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_SELECT_CLOCK_MUX_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_POWERSAVE_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t POWERSAVE_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TURBO_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TURBO_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FFO_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FFO_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_OCC_MIN_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OCC_MIN_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_NUM_PSI_LINKS_PER_FSP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_NUM_PSI_LINKS_PER_FSP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MIN_NUM_PSI_LINKS_PER_FSP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MIN_NUM_PSI_LINKS_PER_FSP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PRIORITY_PSI_LINK_SELECTION>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PRIORITY_PSI_LINK_SELECTION_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MODEL_EC>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MODEL_EC_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t VPD_POWERSAVE_MIN_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_MASTER_NODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_MASTER_NODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_PNOR_ECC_RECOVERY_IN_PROGRESS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_UPDATE_SLW_SCOM_TO_PHYP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t UPDATE_SLW_SCOM_TO_PHYP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_PM_SPWUP_OHA_FLAG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_PM_SPWUP_OHA_FLAG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SLW_IN_CHECKSTOP>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SLW_IN_CHECKSTOP_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPECIAL_WAKEUP_NEEDED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SPECIAL_WAKEUP_NEEDED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_SPECIAL_WAKEUP_ON_SYSTEM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MELTBOX_NEST_FREQ_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MELTBOX_NEST_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MELTBOX_FREQ_PB>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MELTBOX_FREQ_PB_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MELTBOX_FREQ_X>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MELTBOX_FREQ_X_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DEFAULT_NEST_FREQ_MHZ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DEFAULT_NEST_FREQ_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DEFAULT_FREQ_PB>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DEFAULT_FREQ_PB_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DEFAULT_FREQ_X>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t DEFAULT_FREQ_X_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_SLEEP_WINKLE_LID_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PROC_SLEEP_WINKLE_LID_ID_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_PROC_REFCLOCK_ACTUAL_KHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_HW_DECONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HW_DECONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HB_HW_DECONFIG>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t HB_HW_DECONFIG_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HW_RECONFIG_CURRENT_ITR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HW_RECONFIG_CURRENT_ITR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_HW_RECONFIG_MAX_COUNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FSP_HW_RECONFIG_MAX_COUNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FMBX_DMA_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef FMBX_DMA_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FMBX_DMA_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_LOCK_SERVICE_LOCK>
{
    public:
        enum { writeable, readable, notHbMutex, fspMutex, fspAccessible };
        typedef util::Mutex* Type;
#if __cplusplus >= 201103L 
#endif
};

template<>
class AttributeTraits<ATTR_SBE_UPDATE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SBE_UPDATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t LAST_KNOWN_CONFIGURED_MEM_SIZE_MB_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_PNOR_PARTITION_SIDE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef PNOR_PARTITION_SIDE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PNOR_PARTITION_SIDE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DEALLOCATED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DEALLOCATED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_BASE_PVR>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t BASE_PVR_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_MASTER_EX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_MASTER_EX_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_OVERRIDE_FREQ_PROC_REFCLOCK>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t OVERRIDE_FREQ_PROC_REFCLOCK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_PART_ID>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[30];
#if __cplusplus >= 201103L 
        typedef std::array<char, 30> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_SPEED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t I2C_SPEED_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_ADDRESS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t I2C_ADDRESS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_I2C_DEV_PATH>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[30];
#if __cplusplus >= 201103L 
        typedef std::array<char, 30> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_IS_IPL_DECONFIG_ALLOWED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_IPL_DECONFIG_ALLOWED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_ISTEP_TIMEOUT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t ISTEP_TIMEOUT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_EID_ON_HBEL_FSP_A>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAX_EID_ON_HBEL_FSP_A_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_EID_ON_HBEL_FSP_B>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAX_EID_ON_HBEL_FSP_B_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPL_WAKEUP_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef SPL_WAKEUP_STATE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SPL_WAKEUP_STATE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FCO_SUPPORTED>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FCO_SUPPORTED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SMP_CONNECTION_STATE>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SMP_CONNECTION_STATE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TARGET_SCOMABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TARGET_SCOMABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_CARD_WORKAROUND>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_CARD_WORKAROUND_INVALID = 0xFF;
        typedef std::array<uint8_t, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_APPLY_PCIE_WORKAROUND>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t APPLY_PCIE_WORKAROUND_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PERST_CONTROL_PIN_NUMBERS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[3];
#if __cplusplus >= 201103L 
        static constexpr uint8_t PERST_CONTROL_PIN_NUMBERS_INVALID = 0xFF;
        typedef std::array<uint8_t, 3> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PERST_CONTROL_DEVICE_PATHS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[120];
#if __cplusplus >= 201103L 
        typedef std::array<char, 120> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_SYSTEM_CONFIG_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SYSTEM_CONFIG_TYPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_RT_DECONFIG_FAILED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t RT_DECONFIG_FAILED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_DECONFIG_BUT_NOT_GARDED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DECONFIG_BUT_NOT_GARDED_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SPD_DRAM_DIMM_DEVICE_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef SPD_DRAM_DIMM_DEVICE_TYPE Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t SPD_DRAM_DIMM_DEVICE_TYPE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_CRITICAL_CORE_TEMP>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t CRITICAL_CORE_TEMP_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_ENABLE_CORE_TEMP_CHECK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t ENABLE_CORE_TEMP_CHECK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CORE_TEMP_CHECK_INTERVAL_SECONDS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_MASTER_CORE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_MASTER_CORE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_SECURITY_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t FSP_SECURITY_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_DIMM_SPD_P0_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_DIMM_SPD_P1_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_DIMM_SPD_P0_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_A_DIMM_SPD_P1_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_DIMM_SPD_P0_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_FSP_B_DIMM_SPD_P1_PATH>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef char Type[35];
#if __cplusplus >= 201103L 
        typedef std::array<char, 35> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_PRIMARY_SEEPROM_FAIL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PRIMARY_SEEPROM_FAIL_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECONDARY_SEEPROM_FAIL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECONDARY_SEEPROM_FAIL_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_HOSTBOOT_TIME_OUT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t HOSTBOOT_TIME_OUT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_IS_TCES_MODE_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t IS_TCES_MODE_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PRIMARY_MF_CLOCK>
{
    public:
        enum { writeable, readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef PRIMARY_MF_CLOCK Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t PRIMARY_MF_CLOCK_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_REDUNDANT_MF_CLOCKS>
{
    public:
        enum { readable, hasStringConversion, notHbMutex, notFspMutex, fspAccessible };
        typedef REDUNDANT_MF_CLOCKS Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t REDUNDANT_MF_CLOCKS_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_TEMP_LOL_ERR_CNT>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t TEMP_LOL_ERR_CNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_SECURITY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_SECURITY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_MAX_LOL_ERR_CNT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t MAX_LOL_ERR_CNT_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DISABLE_SBE_RUNTIME_RECOVERY>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DISABLE_SBE_RUNTIME_RECOVERY_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CLOCK_PLL_MUX>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CLOCK_PLL_MUX_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_NVDIMM_AUTO_ARM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NVDIMM_AUTO_ARM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NVDIMM_ENCRYPTION_ENABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t NVDIMM_ENCRYPTION_ENABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[96];
#if __cplusplus >= 201103L 
        static constexpr uint8_t NVDIMM_ENCRYPTION_KEYS_ANCHOR_INVALID = 0xFF;
        typedef std::array<uint8_t, 96> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_NVDIMM_ENCRYPTION_KEYS_FW>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[96];
#if __cplusplus >= 201103L 
        static constexpr uint8_t NVDIMM_ENCRYPTION_KEYS_FW_INVALID = 0xFF;
        typedef std::array<uint8_t, 96> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_LINK_TRAIN>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t LINK_TRAIN_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DIMM_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint32_t EFF_DIMM_SIZE_INVALID = 0xFFFFFFFF;
        typedef std::array<std::array<uint32_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_EFF_DIMM_SIZE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CEN_EFF_DIMM_SIZE_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_L2_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t L2_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_C0_EXEC_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t C0_EXEC_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_C1_EXEC_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t C1_EXEC_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_C0_PC_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t C0_PC_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_C1_PC_HASCLOCKS>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t C1_PC_HASCLOCKS_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_L2_HASPOWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t L2_HASPOWER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_C0_HASPOWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t C0_HASPOWER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_C1_HASPOWER>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t C1_HASPOWER_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_SPD_DRAM_DEVICE_TYPE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CEN_SPD_DRAM_DEVICE_TYPE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_TARGET_IS_SCOMMABLE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t TARGET_IS_SCOMMABLE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_PROC_PCIE_CACHE_INJ_MODE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t PROC_PCIE_CACHE_INJ_MODE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_A_MHZ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t FREQ_A_MHZ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_DIMM_RANKS_CONFIGED>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_DIMM_RANKS_CONFIGED_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[2][2];
#if __cplusplus >= 201103L 
        static constexpr uint8_t EFF_NUM_MASTER_RANKS_PER_DIMM_INVALID = 0xFF;
        typedef std::array<std::array<uint8_t, 2>, 2> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_DQ_TO_DIMM_CONN_DQ>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type[80];
#if __cplusplus >= 201103L 
        static constexpr uint8_t CEN_DQ_TO_DIMM_CONN_DQ_INVALID = 0xFF;
        typedef std::array<uint8_t, 80> TypeStdArr;
#endif
};

template<>
class AttributeTraits<ATTR_MSS_FREQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint64_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint64_t MSS_FREQ_INVALID = 0xFFFFFFFFFFFFFFFFULL;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_FREQ_OVERRIDE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_FREQ_OVERRIDE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_DD1_SLOW_PCI_REF_CLOCK>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t DD1_SLOW_PCI_REF_CLOCK_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MBA_PORT>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CEN_MBA_PORT_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MBA_DIMM>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t CEN_MBA_DIMM_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_CEN_MSS_FREQ>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t CEN_MSS_FREQ_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VDN_BOOT_VOLTAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t VDN_BOOT_VOLTAGE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VDD_BOOT_VOLTAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t VDD_BOOT_VOLTAGE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_VCS_BOOT_VOLTAGE>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint32_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint32_t VCS_BOOT_VOLTAGE_INVALID = 0xFFFFFFFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_BIAS_ULTRATURBO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t FREQ_BIAS_ULTRATURBO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_BIAS_TURBO>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t FREQ_BIAS_TURBO_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_BIAS_NOMINAL>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t FREQ_BIAS_NOMINAL_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_FREQ_BIAS_POWERSAVE>
{
    public:
        enum { readable, notHbMutex, notFspMutex, fspAccessible };
        typedef int8_t Type;
#if __cplusplus >= 201103L 
        static constexpr int8_t FREQ_BIAS_POWERSAVE_INVALID = 0xFF;
#endif
};

template<>
class AttributeTraits<ATTR_COLLECT_ONLY_CLOCK_ON_DATA>
{
    public:
        enum { writeable, readable, notHbMutex, notFspMutex, fspAccessible };
        typedef uint8_t Type;
#if __cplusplus >= 201103L 
        static constexpr uint8_t COLLECT_ONLY_CLOCK_ON_DATA_INVALID = 0xFF;
#endif
};

/**
 *  @brief Mapping of alias type name to underlying type
 */
// Type aliases and/or sizes for ATTR_AUX_FUNC_INVOCATION_TIME_MS attribute
typedef uint8_t AUX_FUNC_INVOCATION_TIME_MS_ATTR;
typedef uint8_t ATTR_AUX_FUNC_INVOCATION_TIME_MS_type;

// Type aliases and/or sizes for ATTR_FREQ_BIAS attribute
typedef int8_t FREQ_BIAS_ATTR;
typedef int8_t ATTR_FREQ_BIAS_type;

// Type aliases and/or sizes for ATTR_VOLTAGE_EXT_BIAS attribute
typedef int8_t VOLTAGE_EXT_BIAS_ATTR[2][8];
typedef int8_t ATTR_VOLTAGE_EXT_BIAS_type[2][8];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 8>, 2> ATTR_VOLTAGE_EXT_BIAS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_VOLTAGE_EXT_VDN_BIAS attribute
typedef int8_t VOLTAGE_EXT_VDN_BIAS_ATTR;
typedef int8_t ATTR_VOLTAGE_EXT_VDN_BIAS_type;

// Type aliases and/or sizes for ATTR_DDR5_VDN_UPLIFT_MV attribute
typedef uint16_t DDR5_VDN_UPLIFT_MV_ATTR;
typedef uint16_t ATTR_DDR5_VDN_UPLIFT_MV_type;

// Type aliases and/or sizes for ATTR_WOF_DCCR_VALUE attribute
typedef uint64_t WOF_DCCR_VALUE_ATTR;
typedef uint64_t ATTR_WOF_DCCR_VALUE_type;

// Type aliases and/or sizes for ATTR_WOF_FLMR_VALUE attribute
typedef uint64_t WOF_FLMR_VALUE_ATTR;
typedef uint64_t ATTR_WOF_FLMR_VALUE_type;

// Type aliases and/or sizes for ATTR_WOF_FMMR_VALUE attribute
typedef uint64_t WOF_FMMR_VALUE_ATTR;
typedef uint64_t ATTR_WOF_FMMR_VALUE_type;

// Type aliases and/or sizes for ATTR_DDS_DELAY_ADJUST attribute
typedef int16_t DDS_DELAY_ADJUST_ATTR[8];
typedef int16_t ATTR_DDS_DELAY_ADJUST_type[8];
#if __cplusplus >= 201103L 
typedef std::array<int16_t, 8> ATTR_DDS_DELAY_ADJUST_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDS_LARGE_DROOP_DETECT_ADJUST attribute
typedef int8_t DDS_LARGE_DROOP_DETECT_ADJUST_ATTR[8];
typedef int8_t ATTR_DDS_LARGE_DROOP_DETECT_ADJUST_type[8];
#if __cplusplus >= 201103L 
typedef std::array<int8_t, 8> ATTR_DDS_LARGE_DROOP_DETECT_ADJUST_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDS_TRIP_OFFSET_ADJUST attribute
typedef int8_t DDS_TRIP_OFFSET_ADJUST_ATTR[8];
typedef int8_t ATTR_DDS_TRIP_OFFSET_ADJUST_type[8];
#if __cplusplus >= 201103L 
typedef std::array<int8_t, 8> ATTR_DDS_TRIP_OFFSET_ADJUST_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDS_DROOP_EXTREME_OVERRIDE attribute
typedef uint8_t DDS_DROOP_EXTREME_OVERRIDE_ATTR[9];
typedef uint8_t ATTR_DDS_DROOP_EXTREME_OVERRIDE_type[9];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 9> ATTR_DDS_DROOP_EXTREME_OVERRIDE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT attribute
typedef uint32_t SAFE_MODE_NODDS_UPLIFT_0P5PCT_ATTR[2];
typedef uint32_t ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 2> ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDS_DPLL_SLEW_MODE attribute
typedef uint8_t DDS_DPLL_SLEW_MODE_ATTR;
typedef uint8_t ATTR_DDS_DPLL_SLEW_MODE_type;

// Type aliases and/or sizes for ATTR_DDS_TRIP_MODE attribute
typedef uint8_t DDS_TRIP_MODE_ATTR;
typedef uint8_t ATTR_DDS_TRIP_MODE_type;

// Type aliases and/or sizes for ATTR_DDS_TRIP_INTERPOLATION_CONTROL attribute
typedef uint8_t DDS_TRIP_INTERPOLATION_CONTROL_ATTR;
typedef uint8_t ATTR_DDS_TRIP_INTERPOLATION_CONTROL_type;

// Type aliases and/or sizes for ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG attribute
typedef uint8_t DUMP_STOP_INFO_ENABLE_ERRORLOG_ATTR;
typedef uint8_t ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG_type;

// Type aliases and/or sizes for ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE attribute
typedef uint8_t DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE_ATTR;
typedef uint8_t ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE_type;

// Type aliases and/or sizes for ATTR_PGPE_HCODE_FUNCTION_ENABLE attribute
typedef uint8_t PGPE_HCODE_FUNCTION_ENABLE_ATTR;
typedef uint8_t ATTR_PGPE_HCODE_FUNCTION_ENABLE_type;

// Type aliases and/or sizes for ATTR_PM_GLOBAL_FIR_TRACE_EN attribute
typedef uint8_t PM_GLOBAL_FIR_TRACE_EN_ATTR;
typedef uint8_t ATTR_PM_GLOBAL_FIR_TRACE_EN_type;

// Type aliases and/or sizes for ATTR_POUND_W_STATIC_DATA_ENABLE attribute
typedef uint8_t POUND_W_STATIC_DATA_ENABLE_ATTR;
typedef uint8_t ATTR_POUND_W_STATIC_DATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_POUND_V_STATIC_DATA_ENABLE attribute
typedef uint8_t POUND_V_STATIC_DATA_ENABLE_ATTR;
typedef uint8_t ATTR_POUND_V_STATIC_DATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_AW_STATIC_DATA_ENABLE attribute
typedef uint8_t AW_STATIC_DATA_ENABLE_ATTR;
typedef uint8_t ATTR_AW_STATIC_DATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_IQ_STATIC_DATA_ENABLE attribute
typedef uint8_t IQ_STATIC_DATA_ENABLE_ATTR;
typedef uint8_t ATTR_IQ_STATIC_DATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_POUNDV_BUCKET_NUM attribute
typedef uint8_t POUNDV_BUCKET_NUM_ATTR;
typedef uint8_t ATTR_POUNDV_BUCKET_NUM_type;

// Type aliases and/or sizes for ATTR_POUNDV_BUCKET_NUM_OVERRIDE attribute
typedef uint8_t POUNDV_BUCKET_NUM_OVERRIDE_ATTR;
typedef uint8_t ATTR_POUNDV_BUCKET_NUM_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_SKIP_WAKEUP attribute
typedef uint8_t SKIP_WAKEUP_ATTR;
typedef uint8_t ATTR_SKIP_WAKEUP_type;

// Type aliases and/or sizes for ATTR_SYS_VRT_STATIC_DATA_ENABLE attribute
typedef uint8_t SYS_VRT_STATIC_DATA_ENABLE_ATTR;
typedef uint8_t ATTR_SYS_VRT_STATIC_DATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE attribute
typedef uint8_t SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_RING_DBG_MODE attribute
typedef uint8_t SYSTEM_RING_DBG_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_RING_DBG_MODE_type;

// Type aliases and/or sizes for ATTR_PM_MALF_ALERT_ENABLE attribute
typedef uint8_t PM_MALF_ALERT_ENABLE_ATTR;
typedef uint8_t ATTR_PM_MALF_ALERT_ENABLE_type;

// Type aliases and/or sizes for ATTR_PM_HALT_FFDC_ENABLE attribute
typedef uint8_t PM_HALT_FFDC_ENABLE_ATTR;
typedef uint8_t ATTR_PM_HALT_FFDC_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_DDS_DISABLE attribute
typedef uint8_t SYSTEM_DDS_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_DDS_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_DDS_FREQ_ENABLE attribute
typedef uint8_t SYSTEM_DDS_FREQ_ENABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_DDS_FREQ_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_AUXILLARY_MODE attribute
typedef uint8_t SYSTEM_AUXILLARY_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_AUXILLARY_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PSTATES_MODE attribute
typedef uint8_t SYSTEM_PSTATES_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_PSTATES_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_SUSPEND_OCC_MODE attribute
typedef uint8_t SYSTEM_SUSPEND_OCC_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_SUSPEND_OCC_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_RESCLK_DISABLE attribute
typedef uint8_t SYSTEM_RESCLK_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_RESCLK_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE attribute
typedef uint8_t SYSTEM_RESCLK_ISTEP4_ENABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_RVRM_DISABLE attribute
typedef uint8_t SYSTEM_RVRM_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_RVRM_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOF_DISABLE attribute
typedef uint8_t SYSTEM_WOF_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_WOF_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOV_OVERV_DISABLE attribute
typedef uint8_t SYSTEM_WOV_OVERV_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_WOV_OVERV_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOV_UNDERV_DISABLE attribute
typedef uint8_t SYSTEM_WOV_UNDERV_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_WOV_UNDERV_DISABLE_type;

// Type aliases and/or sizes for ATTR_WOF_INDEX_SELECT attribute
typedef uint8_t WOF_INDEX_SELECT_ATTR;
typedef uint8_t ATTR_WOF_INDEX_SELECT_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOF_DISABLE_DIMENSION attribute
typedef uint8_t SYSTEM_WOF_DISABLE_DIMENSION_ATTR[5];
typedef uint8_t ATTR_SYSTEM_WOF_DISABLE_DIMENSION_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 5> ATTR_SYSTEM_WOF_DISABLE_DIMENSION_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE attribute
typedef uint8_t WOF_THROTTLE_CONTROL_LOOP_DISABLE_ATTR;
typedef uint8_t ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE_type;

// Type aliases and/or sizes for ATTR_WOF_PITCH_ENABLE attribute
typedef uint8_t WOF_PITCH_ENABLE_ATTR;
typedef uint8_t ATTR_WOF_PITCH_ENABLE_type;

// Type aliases and/or sizes for ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE attribute
typedef uint8_t WOF_THROTTLE_CONTROL_LOOP_MODE_ATTR;
typedef uint8_t ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE_type;

// Type aliases and/or sizes for ATTR_WOF_THROTTLE_CONTROL_KP attribute
typedef uint8_t WOF_THROTTLE_CONTROL_KP_ATTR;
typedef uint8_t ATTR_WOF_THROTTLE_CONTROL_KP_type;

// Type aliases and/or sizes for ATTR_WOF_THROTTLE_CONTROL_KI attribute
typedef uint8_t WOF_THROTTLE_CONTROL_KI_ATTR;
typedef uint8_t ATTR_WOF_THROTTLE_CONTROL_KI_type;

// Type aliases and/or sizes for ATTR_SYSTEM_OCS_DISABLE attribute
typedef uint8_t SYSTEM_OCS_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_OCS_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE attribute
typedef uint8_t SYSTEM_PGPE_CURRENT_READ_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE_type;

// Type aliases and/or sizes for ATTR_WOF_DCM_TRACKING_ENABLE attribute
typedef uint8_t WOF_DCM_TRACKING_ENABLE_ATTR;
typedef uint8_t ATTR_WOF_DCM_TRACKING_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOF_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_WOF_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_WOF_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_WOF_LAB_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PDV_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_PDV_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_PDV_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_PDV_LAB_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PDW_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_PDW_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_PDW_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_IQ_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_IQ_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_IQ_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE attribute
typedef uint8_t SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_ATTR;
typedef uint8_t ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_type;

// Type aliases and/or sizes for ATTR_PBAX_BRDCST_ID_VECTOR attribute
typedef uint8_t PBAX_BRDCST_ID_VECTOR_ATTR;
typedef uint8_t ATTR_PBAX_BRDCST_ID_VECTOR_type;

// Type aliases and/or sizes for ATTR_PBAX_CHIPID attribute
typedef uint8_t PBAX_CHIPID_ATTR;
typedef uint8_t ATTR_PBAX_CHIPID_type;

// Type aliases and/or sizes for ATTR_PBAX_GROUPID attribute
typedef uint8_t PBAX_GROUPID_ATTR;
typedef uint8_t ATTR_PBAX_GROUPID_type;

// Type aliases and/or sizes for ATTR_SPIPSS_FREQUENCY attribute
typedef uint32_t SPIPSS_FREQUENCY_ATTR;
typedef uint32_t ATTR_SPIPSS_FREQUENCY_type;

// Type aliases and/or sizes for ATTR_SPIPSS_SELECT attribute
typedef uint8_t SPIPSS_SELECT_ATTR;
typedef uint8_t ATTR_SPIPSS_SELECT_type;

// Type aliases and/or sizes for ATTR_PROC_R_DISTLOSS_UOHM attribute
typedef uint32_t PROC_R_DISTLOSS_UOHM_ATTR[4];
typedef uint32_t ATTR_PROC_R_DISTLOSS_UOHM_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_PROC_R_DISTLOSS_UOHM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_R_LOADLINE_UOHM attribute
typedef uint32_t PROC_R_LOADLINE_UOHM_ATTR[4];
typedef uint32_t ATTR_PROC_R_LOADLINE_UOHM_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_PROC_R_LOADLINE_UOHM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_VRM_VOFFSET_UV attribute
typedef uint32_t PROC_VRM_VOFFSET_UV_ATTR[4];
typedef uint32_t ATTR_PROC_VRM_VOFFSET_UV_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_PROC_VRM_VOFFSET_UV_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CORE_THROTTLE_ASSERT_COUNT attribute
typedef uint32_t CORE_THROTTLE_ASSERT_COUNT_ATTR;
typedef uint32_t ATTR_CORE_THROTTLE_ASSERT_COUNT_type;

// Type aliases and/or sizes for ATTR_CORE_THROTTLE_DEASSERT_COUNT attribute
typedef uint32_t CORE_THROTTLE_DEASSERT_COUNT_ATTR;
typedef uint32_t ATTR_CORE_THROTTLE_DEASSERT_COUNT_type;

// Type aliases and/or sizes for ATTR_AVSBUS_BUSNUM attribute
typedef uint8_t AVSBUS_BUSNUM_ATTR[4];
typedef uint8_t ATTR_AVSBUS_BUSNUM_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_AVSBUS_BUSNUM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_AVSBUS_FREQUENCY attribute
typedef uint32_t AVSBUS_FREQUENCY_ATTR;
typedef uint32_t ATTR_AVSBUS_FREQUENCY_type;

// Type aliases and/or sizes for ATTR_AVSBUS_RAIL attribute
typedef uint8_t AVSBUS_RAIL_ATTR[4];
typedef uint8_t ATTR_AVSBUS_RAIL_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_AVSBUS_RAIL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXTERNAL_VRM_STEPSIZE attribute
typedef uint32_t EXTERNAL_VRM_STEPSIZE_ATTR[4];
typedef uint32_t ATTR_EXTERNAL_VRM_STEPSIZE_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_EXTERNAL_VRM_STEPSIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US attribute
typedef uint32_t EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US_ATTR[4];
typedef uint32_t ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US attribute
typedef uint32_t EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US_ATTR[4];
typedef uint32_t ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS attribute
typedef uint32_t EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS_ATTR[4];
typedef uint32_t ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXTERNAL_VRM_TRANSITION_START_NS attribute
typedef uint32_t EXTERNAL_VRM_TRANSITION_START_NS_ATTR[4];
typedef uint32_t ATTR_EXTERNAL_VRM_TRANSITION_START_NS_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_EXTERNAL_VRM_TRANSITION_START_NS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE attribute
typedef uint8_t SADDLEBACK_VRM_ROLLOVER_ENABLE_ATTR;
typedef uint8_t ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE_type;

// Type aliases and/or sizes for ATTR_WOF_VRATIO_VDD_10THPCT attribute
typedef uint16_t WOF_VRATIO_VDD_10THPCT_ATTR[8];
typedef uint16_t ATTR_WOF_VRATIO_VDD_10THPCT_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 8> ATTR_WOF_VRATIO_VDD_10THPCT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WOF_VRATIO_VCS_10THPCT attribute
typedef uint16_t WOF_VRATIO_VCS_10THPCT_ATTR[8];
typedef uint16_t ATTR_WOF_VRATIO_VCS_10THPCT_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 8> ATTR_WOF_VRATIO_VCS_10THPCT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WOF_TABLE_IO_POWER_BASE_W attribute
typedef uint8_t WOF_TABLE_IO_POWER_BASE_W_ATTR;
typedef uint8_t ATTR_WOF_TABLE_IO_POWER_BASE_W_type;

// Type aliases and/or sizes for ATTR_WOF_IO_BASE_POWER_0P01W attribute
typedef uint16_t WOF_IO_BASE_POWER_0P01W_ATTR[4];
typedef uint16_t ATTR_WOF_IO_BASE_POWER_0P01W_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_WOF_IO_BASE_POWER_0P01W_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WOV_MAX_DROOP_10THPCT attribute
typedef uint32_t WOV_MAX_DROOP_10THPCT_ATTR;
typedef uint32_t ATTR_WOV_MAX_DROOP_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_MAX_10THPCT attribute
typedef uint8_t WOV_OVERV_MAX_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_OVERV_MAX_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_STEP_DECR_10THPCT attribute
typedef uint8_t WOV_OVERV_STEP_DECR_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_OVERV_STEP_DECR_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_STEP_INCR_10THPCT attribute
typedef uint8_t WOV_OVERV_STEP_INCR_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_OVERV_STEP_INCR_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_VMAX_SETPOINT_MV attribute
typedef uint16_t WOV_OVERV_VMAX_SETPOINT_MV_ATTR;
typedef uint16_t ATTR_WOV_OVERV_VMAX_SETPOINT_MV_type;

// Type aliases and/or sizes for ATTR_WOV_UNDERV_MAX_10THPCT attribute
typedef uint8_t WOV_UNDERV_MAX_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_UNDERV_MAX_10THPCT_type;

// Type aliases and/or sizes for ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE attribute
typedef uint8_t SYSTEM_WOV_DDS_CALIBRATION_ENABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE_type;

// Type aliases and/or sizes for ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT attribute
typedef uint16_t WOV_UNDERV_EXTENDED_MAX_10THPCT_ATTR;
typedef uint16_t ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT attribute
typedef uint16_t WOV_OVERV_EXTENDED_MAX_10THPCT_ATTR;
typedef uint16_t ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT attribute
typedef uint8_t WOV_LIGHT_PERF_LOSS_THRESH_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT attribute
typedef uint8_t WOV_HEAVY_PERF_LOSS_THRESH_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_UNDERV_STEP_DECR_10THPCT attribute
typedef uint8_t WOV_UNDERV_STEP_DECR_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_UNDERV_STEP_DECR_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_UNDERV_STEP_INCR_10THPCT attribute
typedef uint8_t WOV_UNDERV_STEP_INCR_10THPCT_ATTR;
typedef uint8_t ATTR_WOV_UNDERV_STEP_INCR_10THPCT_type;

// Type aliases and/or sizes for ATTR_WOV_UNDERV_VMIN_MV attribute
typedef uint16_t WOV_UNDERV_VMIN_MV_ATTR;
typedef uint16_t ATTR_WOV_UNDERV_VMIN_MV_type;

// Type aliases and/or sizes for ATTR_WOV_DIRTY_UNCURRENT_CONTROL attribute
typedef uint8_t WOV_DIRTY_UNCURRENT_CONTROL_ATTR[2];
typedef uint8_t ATTR_WOV_DIRTY_UNCURRENT_CONTROL_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_WOV_DIRTY_UNCURRENT_CONTROL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_OCS_WITH_DDS_DISABLE attribute
typedef uint8_t OCS_WITH_DDS_DISABLE_ATTR;
typedef uint8_t ATTR_OCS_WITH_DDS_DISABLE_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_WITH_DDS_DISABLE attribute
typedef uint8_t WOV_OVERV_WITH_DDS_DISABLE_ATTR;
typedef uint8_t ATTR_WOV_OVERV_WITH_DDS_DISABLE_type;

// Type aliases and/or sizes for ATTR_DDS_DPLL_FMAX_FAST_DISABLE attribute
typedef uint8_t DDS_DPLL_FMAX_FAST_DISABLE_ATTR;
typedef uint8_t ATTR_DDS_DPLL_FMAX_FAST_DISABLE_type;

// Type aliases and/or sizes for ATTR_DDS_DPLL_FMIN_FAST_DISABLE attribute
typedef uint8_t DDS_DPLL_FMIN_FAST_DISABLE_ATTR;
typedef uint8_t ATTR_DDS_DPLL_FMIN_FAST_DISABLE_type;

// Type aliases and/or sizes for ATTR_DDS_FMAX_OVERRIDE_KHZ attribute
typedef uint16_t DDS_FMAX_OVERRIDE_KHZ_ATTR[9];
typedef uint16_t ATTR_DDS_FMAX_OVERRIDE_KHZ_type[9];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 9> ATTR_DDS_FMAX_OVERRIDE_KHZ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDS_FMIN_OVERRIDE_KHZ attribute
typedef uint16_t DDS_FMIN_OVERRIDE_KHZ_ATTR[5];
typedef uint16_t ATTR_DDS_FMIN_OVERRIDE_KHZ_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 5> ATTR_DDS_FMIN_OVERRIDE_KHZ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK attribute
typedef uint32_t FREQ_PB_MHZ_POUNDV_FALLBACK_ATTR;
typedef uint32_t ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK_type;

// Type aliases and/or sizes for ATTR_SAFE_MODE_FREQUENCY_MHZ attribute
typedef uint32_t SAFE_MODE_FREQUENCY_MHZ_ATTR;
typedef uint32_t ATTR_SAFE_MODE_FREQUENCY_MHZ_type;

// Type aliases and/or sizes for ATTR_SAFE_MODE_VOLTAGE_MV attribute
typedef uint32_t SAFE_MODE_VOLTAGE_MV_ATTR[2];
typedef uint32_t ATTR_SAFE_MODE_VOLTAGE_MV_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 2> ATTR_SAFE_MODE_VOLTAGE_MV_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_VDN_UPLIFT_MV attribute
typedef uint32_t VDN_UPLIFT_MV_ATTR;
typedef uint32_t ATTR_VDN_UPLIFT_MV_type;

// Type aliases and/or sizes for ATTR_PMCR_MOST_RECENT_MODE attribute
typedef uint8_t PMCR_MOST_RECENT_MODE_ATTR;
typedef uint8_t ATTR_PMCR_MOST_RECENT_MODE_type;

// Type aliases and/or sizes for ATTR_UNSECURE_HOMER_ADDRESS attribute
typedef uint64_t UNSECURE_HOMER_ADDRESS_ATTR;
typedef uint64_t ATTR_UNSECURE_HOMER_ADDRESS_type;

// Type aliases and/or sizes for ATTR_UNSECURE_HOMER_SIZE attribute
typedef uint32_t UNSECURE_HOMER_SIZE_ATTR;
typedef uint32_t ATTR_UNSECURE_HOMER_SIZE_type;

// Type aliases and/or sizes for ATTR_FUSED_CORE_PAIRED_MODE_ENABLED attribute
typedef uint8_t FUSED_CORE_PAIRED_MODE_ENABLED_ATTR;
typedef uint8_t ATTR_FUSED_CORE_PAIRED_MODE_ENABLED_type;

// Type aliases and/or sizes for ATTR_SYSTEM_MMA_POWEROFF_DISABLE attribute
typedef uint8_t SYSTEM_MMA_POWEROFF_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_MMA_POWEROFF_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_MMA_POWERON_DISABLE attribute
typedef uint8_t SYSTEM_MMA_POWERON_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_MMA_POWERON_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS attribute
typedef uint8_t SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS_ATTR;
typedef uint8_t ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS_type;

// Type aliases and/or sizes for ATTR_RVRM_VID attribute
typedef uint8_t RVRM_VID_ATTR;
typedef uint8_t ATTR_RVRM_VID_type;

// Type aliases and/or sizes for ATTR_RVRM_DEADZONE_MV attribute
typedef uint8_t RVRM_DEADZONE_MV_ATTR;
typedef uint8_t ATTR_RVRM_DEADZONE_MV_type;

// Type aliases and/or sizes for ATTR_STOP_LEVELS_SUPPORTED attribute
typedef uint16_t STOP_LEVELS_SUPPORTED_ATTR;
typedef uint16_t ATTR_STOP_LEVELS_SUPPORTED_type;

// Type aliases and/or sizes for ATTR_STOP_LEVELS_DISABLED attribute
typedef uint16_t STOP_LEVELS_DISABLED_ATTR;
typedef uint16_t ATTR_STOP_LEVELS_DISABLED_type;

// Type aliases and/or sizes for ATTR_BOOT_VOLTAGE_BIAS_0P5PCT attribute
typedef uint8_t BOOT_VOLTAGE_BIAS_0P5PCT_ATTR;
typedef uint8_t ATTR_BOOT_VOLTAGE_BIAS_0P5PCT_type;

// Type aliases and/or sizes for ATTR_WOF_OMI_FORCE_FREQ_MHZ attribute
typedef uint32_t WOF_OMI_FORCE_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_WOF_OMI_FORCE_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_SRAM_WRITE_ASSIST_MV attribute
typedef uint32_t SRAM_WRITE_ASSIST_MV_ATTR;
typedef uint32_t ATTR_SRAM_WRITE_ASSIST_MV_type;

// Type aliases and/or sizes for ATTR_DDS_THRESHOLD_PSTATE_ENABLE attribute
typedef uint8_t DDS_THRESHOLD_PSTATE_ENABLE_ATTR;
typedef uint8_t ATTR_DDS_THRESHOLD_PSTATE_ENABLE_type;

// Type aliases and/or sizes for ATTR_DDS_COARSE_THROTTLE_ENABLE attribute
typedef uint8_t DDS_COARSE_THROTTLE_ENABLE_ATTR;
typedef uint8_t ATTR_DDS_COARSE_THROTTLE_ENABLE_type;

// Type aliases and/or sizes for ATTR_DDS_FREQ_JUMP_ENABLE attribute
typedef uint8_t DDS_FREQ_JUMP_ENABLE_ATTR;
typedef uint8_t ATTR_DDS_FREQ_JUMP_ENABLE_type;

// Type aliases and/or sizes for ATTR_DDS_BIAS_ENABLE attribute
typedef uint8_t DDS_BIAS_ENABLE_ATTR;
typedef uint8_t ATTR_DDS_BIAS_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT attribute
typedef uint8_t SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT_ATTR;
typedef uint8_t ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT_type;

// Type aliases and/or sizes for ATTR_THROTTLE_TABLE_OVERRIDE attribute
typedef uint32_t THROTTLE_TABLE_OVERRIDE_ATTR[64];
typedef uint32_t ATTR_THROTTLE_TABLE_OVERRIDE_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 64> ATTR_THROTTLE_TABLE_OVERRIDE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_THROTTLE_MODE attribute
typedef uint32_t THROTTLE_MODE_ATTR;
typedef uint32_t ATTR_THROTTLE_MODE_type;

// Type aliases and/or sizes for ATTR_DLR_LINKS_ENABLED attribute
typedef uint16_t DLR_LINKS_ENABLED_ATTR[5];
typedef uint16_t ATTR_DLR_LINKS_ENABLED_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 5> ATTR_DLR_LINKS_ENABLED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DLR_SAMPLE_TIME_MS attribute
typedef uint16_t DLR_SAMPLE_TIME_MS_ATTR;
typedef uint16_t ATTR_DLR_SAMPLE_TIME_MS_type;

// Type aliases and/or sizes for ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE attribute
typedef uint16_t DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE_ATTR;
typedef uint16_t ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_DLR_PLSF_OVERRIDE attribute
typedef uint8_t DLR_PLSF_OVERRIDE_ATTR[32];
typedef uint8_t ATTR_DLR_PLSF_OVERRIDE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_DLR_PLSF_OVERRIDE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SAFE_MODE_XSTOP attribute
typedef uint8_t SAFE_MODE_XSTOP_ATTR;
typedef uint8_t ATTR_SAFE_MODE_XSTOP_type;

// Type aliases and/or sizes for ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT attribute
typedef uint16_t WOF_ALTITUDE_TEMP_ADJUSTMENT_ATTR;
typedef uint16_t ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT_type;

// Type aliases and/or sizes for ATTR_WOF_TDP_ALTITUDE_REFERENCE_M attribute
typedef uint16_t WOF_TDP_ALTITUDE_REFERENCE_M_ATTR;
typedef uint16_t ATTR_WOF_TDP_ALTITUDE_REFERENCE_M_type;

// Type aliases and/or sizes for ATTR_SYSTEM_FMAX_ENABLE attribute
typedef uint8_t SYSTEM_FMAX_ENABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_FMAX_ENABLE_type;

// Type aliases and/or sizes for ATTR_CURRENT_SCALING_FACTOR attribute
typedef uint8_t CURRENT_SCALING_FACTOR_ATTR[8];
typedef uint8_t ATTR_CURRENT_SCALING_FACTOR_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_CURRENT_SCALING_FACTOR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_IO_GROUNDED_CONTROLLERS attribute
typedef uint16_t IO_GROUNDED_CONTROLLERS_ATTR;
typedef uint16_t ATTR_IO_GROUNDED_CONTROLLERS_type;

// Type aliases and/or sizes for ATTR_IO_GROUNDED_LINKS attribute
typedef uint64_t IO_GROUNDED_LINKS_ATTR;
typedef uint64_t ATTR_IO_GROUNDED_LINKS_type;

// Type aliases and/or sizes for ATTR_WOF_IO_POWER_MODE attribute
typedef uint8_t WOF_IO_POWER_MODE_ATTR;
typedef uint8_t ATTR_WOF_IO_POWER_MODE_type;

// Type aliases and/or sizes for ATTR_EXTENDED_FREQ_MODE attribute
typedef uint32_t EXTENDED_FREQ_MODE_ATTR;
typedef uint32_t ATTR_EXTENDED_FREQ_MODE_type;

// Type aliases and/or sizes for ATTR_DVFS_ADJUSTMENT attribute
typedef uint32_t DVFS_ADJUSTMENT_ATTR;
typedef uint32_t ATTR_DVFS_ADJUSTMENT_type;

// Type aliases and/or sizes for ATTR_OCC_START_DISABLE attribute
typedef uint8_t OCC_START_DISABLE_ATTR;
typedef uint8_t ATTR_OCC_START_DISABLE_type;

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY attribute
typedef uint8_t WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY_ATTR[8];
typedef uint8_t ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX attribute
typedef uint8_t WTH_OVERRIDE_CORE_COUNT_INDEX_ATTR;
typedef uint8_t ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_type;

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_EFFICIENCY_ALG attribute
typedef uint8_t WTH_OVERRIDE_EFFICIENCY_ALG_ATTR;
typedef uint8_t ATTR_WTH_OVERRIDE_EFFICIENCY_ALG_type;

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES attribute
typedef uint16_t WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES_ATTR[8][2];
typedef uint16_t ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES_type[8][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 2>, 8> ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH attribute
typedef uint16_t WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH_ATTR[8][2];
typedef uint16_t ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH_type[8][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 2>, 8> ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST attribute
typedef uint8_t WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST_ATTR[8][4];
typedef uint8_t ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST_type[8][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 8> ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS attribute
typedef uint16_t WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS_ATTR[8][4];
typedef uint16_t ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS_type[8][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 4>, 8> ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_WTH_OVERRIDE_TEST_CORE_COUNT attribute
typedef uint8_t WTH_OVERRIDE_TEST_CORE_COUNT_ATTR;
typedef uint8_t ATTR_WTH_OVERRIDE_TEST_CORE_COUNT_type;

// Type aliases and/or sizes for ATTR_RUNN_MODE attribute
typedef uint8_t RUNN_MODE_ATTR;
typedef uint8_t ATTR_RUNN_MODE_type;

// Type aliases and/or sizes for ATTR_RUNN_SRESET_THREADS_BVEC attribute
typedef uint8_t RUNN_SRESET_THREADS_BVEC_ATTR;
typedef uint8_t ATTR_RUNN_SRESET_THREADS_BVEC_type;

// Type aliases and/or sizes for ATTR_RUNN_CYCLE_COUNT attribute
typedef uint64_t RUNN_CYCLE_COUNT_ATTR;
typedef uint64_t ATTR_RUNN_CYCLE_COUNT_type;

// Type aliases and/or sizes for ATTR_RUNN_CHIP_CYCLE_OFFSET attribute
typedef uint64_t RUNN_CHIP_CYCLE_OFFSET_ATTR;
typedef uint64_t ATTR_RUNN_CHIP_CYCLE_OFFSET_type;

// Type aliases and/or sizes for ATTR_RUNN_QUAD_CYCLE_OFFSET attribute
typedef uint64_t RUNN_QUAD_CYCLE_OFFSET_ATTR;
typedef uint64_t ATTR_RUNN_QUAD_CYCLE_OFFSET_type;

// Type aliases and/or sizes for ATTR_RUNN_CORE_CYCLE_OFFSET attribute
typedef uint8_t RUNN_CORE_CYCLE_OFFSET_ATTR;
typedef uint8_t ATTR_RUNN_CORE_CYCLE_OFFSET_type;

// Type aliases and/or sizes for ATTR_RUNN_DO_CONFIG_CHECKS attribute
typedef uint8_t RUNN_DO_CONFIG_CHECKS_ATTR;
typedef uint8_t ATTR_RUNN_DO_CONFIG_CHECKS_type;

// Type aliases and/or sizes for ATTR_RUNN_USE_QME_TIMEBASE attribute
typedef uint8_t RUNN_USE_QME_TIMEBASE_ATTR;
typedef uint8_t ATTR_RUNN_USE_QME_TIMEBASE_type;

// Type aliases and/or sizes for ATTR_RUNN_STOP_ON_XSTOP attribute
typedef uint8_t RUNN_STOP_ON_XSTOP_ATTR;
typedef uint8_t ATTR_RUNN_STOP_ON_XSTOP_type;

// Type aliases and/or sizes for ATTR_RUNN_MASTER_SEED attribute
typedef uint64_t RUNN_MASTER_SEED_ATTR;
typedef uint64_t ATTR_RUNN_MASTER_SEED_type;

// Type aliases and/or sizes for ATTR_RUNN_CORE_SEED_SELECT attribute
typedef uint8_t RUNN_CORE_SEED_SELECT_ATTR;
typedef uint8_t ATTR_RUNN_CORE_SEED_SELECT_type;

// Type aliases and/or sizes for ATTR_RUNN_THREAD_SEEDS attribute
typedef uint64_t RUNN_THREAD_SEEDS_ATTR[4];
typedef uint64_t ATTR_RUNN_THREAD_SEEDS_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 4> ATTR_RUNN_THREAD_SEEDS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_RUNN_STAGGER_DELAY attribute
typedef uint64_t RUNN_STAGGER_DELAY_ATTR;
typedef uint64_t ATTR_RUNN_STAGGER_DELAY_type;

// Type aliases and/or sizes for ATTR_OMI_INBAND_BAR_ENABLE attribute
typedef uint8_t OMI_INBAND_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_OMI_INBAND_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t OMI_INBAND_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_EFF_DRAM_GEN attribute
typedef uint8_t EFF_DRAM_GEN_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_GEN_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_GEN_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DIMM_TYPE attribute
typedef uint8_t EFF_DIMM_TYPE_ATTR[2][2];
typedef uint8_t ATTR_EFF_DIMM_TYPE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DIMM_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_HYBRID_MEMORY_TYPE attribute
typedef uint8_t EFF_HYBRID_MEMORY_TYPE_ATTR[2][2];
typedef uint8_t ATTR_EFF_HYBRID_MEMORY_TYPE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_HYBRID_MEMORY_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_HYBRID attribute
typedef uint8_t EFF_HYBRID_ATTR[2][2];
typedef uint8_t ATTR_EFF_HYBRID_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_HYBRID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_DENSITY attribute
typedef uint8_t EFF_DRAM_DENSITY_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_DENSITY_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_DENSITY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_BANK_BITS attribute
typedef uint8_t EFF_DRAM_BANK_BITS_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_BANK_BITS_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_BANK_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_BANK_GROUP_BITS attribute
typedef uint8_t EFF_DRAM_BANK_GROUP_BITS_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_BANK_GROUP_BITS_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_BANK_GROUP_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_COLUMN_BITS attribute
typedef uint8_t EFF_DRAM_COLUMN_BITS_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_COLUMN_BITS_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_COLUMN_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_ROW_BITS attribute
typedef uint8_t EFF_DRAM_ROW_BITS_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_ROW_BITS_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_ROW_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_PRIM_STACK_TYPE attribute
typedef uint8_t EFF_PRIM_STACK_TYPE_ATTR[2][2];
typedef uint8_t ATTR_EFF_PRIM_STACK_TYPE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_PRIM_STACK_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_PPR attribute
typedef uint8_t EFF_DRAM_PPR_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_PPR_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_PPR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_SOFT_PPR attribute
typedef uint8_t EFF_DRAM_SOFT_PPR_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_SOFT_PPR_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_SOFT_PPR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRCD attribute
typedef uint8_t EFF_DRAM_TRCD_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TRCD_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TRCD_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRP attribute
typedef uint8_t EFF_DRAM_TRP_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TRP_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TRP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRAS attribute
typedef uint8_t EFF_DRAM_TRAS_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TRAS_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TRAS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRC attribute
typedef uint8_t EFF_DRAM_TRC_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TRC_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TRC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRFC attribute
typedef uint16_t EFF_DRAM_TRFC_ATTR[2];
typedef uint16_t ATTR_EFF_DRAM_TRFC_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_EFF_DRAM_TRFC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TFAW attribute
typedef uint8_t EFF_DRAM_TFAW_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TFAW_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TFAW_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRRD_S attribute
typedef uint8_t EFF_DRAM_TRRD_S_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TRRD_S_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TRRD_S_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TRRD_L attribute
typedef uint8_t EFF_DRAM_TRRD_L_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TRRD_L_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TRRD_L_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TCCD_L attribute
typedef uint8_t EFF_DRAM_TCCD_L_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TCCD_L_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TCCD_L_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TWR attribute
typedef uint8_t EFF_DRAM_TWR_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TWR_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TWR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TWTR_S attribute
typedef uint8_t EFF_DRAM_TWTR_S_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TWTR_S_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TWTR_S_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TWTR_L attribute
typedef uint8_t EFF_DRAM_TWTR_L_ATTR[2];
typedef uint8_t ATTR_EFF_DRAM_TWTR_L_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_EFF_DRAM_TWTR_L_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_TMAW attribute
typedef uint16_t EFF_DRAM_TMAW_ATTR[2];
typedef uint16_t ATTR_EFF_DRAM_TMAW_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_EFF_DRAM_TMAW_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_WIDTH attribute
typedef uint8_t EFF_DRAM_WIDTH_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_WIDTH_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_WIDTH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_RANK_MIX attribute
typedef uint8_t EFF_DRAM_RANK_MIX_ATTR[2][2];
typedef uint8_t ATTR_EFF_DRAM_RANK_MIX_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DRAM_RANK_MIX_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_NUM_RANKS_PER_DIMM attribute
typedef uint8_t EFF_NUM_RANKS_PER_DIMM_ATTR[2][2];
typedef uint8_t ATTR_EFF_NUM_RANKS_PER_DIMM_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_NUM_RANKS_PER_DIMM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_REGISTER_TYPE attribute
typedef uint8_t EFF_REGISTER_TYPE_ATTR[2][2];
typedef uint8_t ATTR_EFF_REGISTER_TYPE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_REGISTER_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_DRAM_MFG_ID attribute
typedef uint16_t EFF_DRAM_MFG_ID_ATTR[2][2];
typedef uint16_t ATTR_EFF_DRAM_MFG_ID_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 2>, 2> ATTR_EFF_DRAM_MFG_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_RCD_MFG_ID attribute
typedef uint16_t EFF_RCD_MFG_ID_ATTR[2][2];
typedef uint16_t ATTR_EFF_RCD_MFG_ID_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 2>, 2> ATTR_EFF_RCD_MFG_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_REGISTER_REV attribute
typedef uint8_t EFF_REGISTER_REV_ATTR[2][2];
typedef uint8_t ATTR_EFF_REGISTER_REV_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_REGISTER_REV_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_PACKAGE_RANK_MAP attribute
typedef uint8_t EFF_PACKAGE_RANK_MAP_ATTR[2][2][18];
typedef uint8_t ATTR_EFF_PACKAGE_RANK_MAP_type[2][2][18];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 18>, 2>, 2> ATTR_EFF_PACKAGE_RANK_MAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_NIBBLE_MAP attribute
typedef uint8_t EFF_NIBBLE_MAP_ATTR[2][2][18];
typedef uint8_t ATTR_EFF_NIBBLE_MAP_type[2][2][18];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 18>, 2>, 2> ATTR_EFF_NIBBLE_MAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ROW_REPAIR_SUPPORTED_MRW attribute
typedef uint8_t ROW_REPAIR_SUPPORTED_MRW_ATTR;
typedef uint8_t ATTR_ROW_REPAIR_SUPPORTED_MRW_type;

// Type aliases and/or sizes for ATTR_MEMORY_BAR_REGS attribute
typedef uint64_t MEMORY_BAR_REGS_ATTR[4][10][2];
typedef uint64_t ATTR_MEMORY_BAR_REGS_type[4][10][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint64_t, 2>, 10>, 4> ATTR_MEMORY_BAR_REGS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MEM_BASES attribute
typedef uint64_t PROC_MEM_BASES_ATTR[8];
typedef uint64_t ATTR_PROC_MEM_BASES_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MEM_BASES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MEM_SIZES attribute
typedef uint64_t PROC_MEM_SIZES_ATTR[8];
typedef uint64_t ATTR_PROC_MEM_SIZES_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MEM_SIZES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MIRROR_BASES attribute
typedef uint64_t PROC_MIRROR_BASES_ATTR[8];
typedef uint64_t ATTR_PROC_MIRROR_BASES_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MIRROR_BASES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MIRROR_SIZES attribute
typedef uint64_t PROC_MIRROR_SIZES_ATTR[8];
typedef uint64_t ATTR_PROC_MIRROR_SIZES_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MIRROR_SIZES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MEM_BASES_ACK attribute
typedef uint64_t PROC_MEM_BASES_ACK_ATTR[8];
typedef uint64_t ATTR_PROC_MEM_BASES_ACK_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MEM_BASES_ACK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MEM_SIZES_ACK attribute
typedef uint64_t PROC_MEM_SIZES_ACK_ATTR[8];
typedef uint64_t ATTR_PROC_MEM_SIZES_ACK_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MEM_SIZES_ACK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MIRROR_BASES_ACK attribute
typedef uint64_t PROC_MIRROR_BASES_ACK_ATTR[8];
typedef uint64_t ATTR_PROC_MIRROR_BASES_ACK_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MIRROR_BASES_ACK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MCC_GROUP_32 attribute
typedef uint32_t MSS_MCC_GROUP_32_ATTR[16][21];
typedef uint32_t ATTR_MSS_MCC_GROUP_32_type[16][21];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint32_t, 21>, 16> ATTR_MSS_MCC_GROUP_32_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_HTM_QUEUES attribute
typedef uint8_t HTM_QUEUES_ATTR[8];
typedef uint8_t ATTR_HTM_QUEUES_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_HTM_QUEUES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MIRROR_SIZES_ACK attribute
typedef uint64_t PROC_MIRROR_SIZES_ACK_ATTR[8];
typedef uint64_t ATTR_PROC_MIRROR_SIZES_ACK_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_MIRROR_SIZES_ACK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MEM_MC_IN_GROUP attribute
typedef uint8_t MSS_MEM_MC_IN_GROUP_ATTR[8];
typedef uint8_t ATTR_MSS_MEM_MC_IN_GROUP_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_MSS_MEM_MC_IN_GROUP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_MIRROR_PLACEMENT_POLICY attribute
typedef uint8_t MEM_MIRROR_PLACEMENT_POLICY_ATTR;
typedef uint8_t ATTR_MEM_MIRROR_PLACEMENT_POLICY_type;

// Type aliases and/or sizes for ATTR_MAX_INTERLEAVE_GROUP_SIZE attribute
typedef uint64_t MAX_INTERLEAVE_GROUP_SIZE_ATTR;
typedef uint64_t ATTR_MAX_INTERLEAVE_GROUP_SIZE_type;

// Type aliases and/or sizes for ATTR_MSS_INTERLEAVE_ENABLE attribute
typedef uint8_t MSS_INTERLEAVE_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_INTERLEAVE_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_INTERLEAVE_GRANULARITY attribute
typedef uint8_t MSS_INTERLEAVE_GRANULARITY_ATTR;
typedef uint8_t ATTR_MSS_INTERLEAVE_GRANULARITY_type;

// Type aliases and/or sizes for ATTR_MSS_MEM_IPL_COMPLETE attribute
typedef uint8_t MSS_MEM_IPL_COMPLETE_ATTR;
typedef uint8_t ATTR_MSS_MEM_IPL_COMPLETE_type;

// Type aliases and/or sizes for ATTR_MRW_HW_MIRRORING_ENABLE attribute
typedef uint8_t MRW_HW_MIRRORING_ENABLE_ATTR;
typedef uint8_t ATTR_MRW_HW_MIRRORING_ENABLE_type;

// Type aliases and/or sizes for ATTR_DYNAMIC_INIT_FEATURE_VEC attribute
typedef uint64_t DYNAMIC_INIT_FEATURE_VEC_ATTR[1];
typedef uint64_t ATTR_DYNAMIC_INIT_FEATURE_VEC_type[1];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 1> ATTR_DYNAMIC_INIT_FEATURE_VEC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DYNAMIC_INIT_FEATURE_COUNT attribute
typedef uint64_t DYNAMIC_INIT_FEATURE_COUNT_ATTR;
typedef uint64_t ATTR_DYNAMIC_INIT_FEATURE_COUNT_type;

// Type aliases and/or sizes for ATTR_DYNAMIC_INIT_MODE_VEC attribute
typedef uint64_t DYNAMIC_INIT_MODE_VEC_ATTR[1];
typedef uint64_t ATTR_DYNAMIC_INIT_MODE_VEC_type[1];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 1> ATTR_DYNAMIC_INIT_MODE_VEC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DYNAMIC_INIT_MODE_COUNT attribute
typedef uint64_t DYNAMIC_INIT_MODE_COUNT_ATTR;
typedef uint64_t ATTR_DYNAMIC_INIT_MODE_COUNT_type;

// Type aliases and/or sizes for ATTR_NHTM_TRACE_TYPE attribute
typedef uint8_t NHTM_TRACE_TYPE_ATTR;
typedef uint8_t ATTR_NHTM_TRACE_TYPE_type;

// Type aliases and/or sizes for ATTR_CHTM_TRACE_TYPE attribute
typedef uint8_t CHTM_TRACE_TYPE_ATTR[32];
typedef uint8_t ATTR_CHTM_TRACE_TYPE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_TRACE_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NHTM_HTMSC_MODE_CONTENT_SEL attribute
typedef uint8_t NHTM_HTMSC_MODE_CONTENT_SEL_ATTR;
typedef uint8_t ATTR_NHTM_HTMSC_MODE_CONTENT_SEL_type;

// Type aliases and/or sizes for ATTR_NHTM_HTMSC_MODE_CAPTURE attribute
typedef uint16_t NHTM_HTMSC_MODE_CAPTURE_ATTR;
typedef uint16_t ATTR_NHTM_HTMSC_MODE_CAPTURE_type;

// Type aliases and/or sizes for ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE attribute
typedef uint8_t NHTM_HTMSC_MODE_SYNC_STAMP_FORCE_ATTR;
typedef uint8_t ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE_type;

// Type aliases and/or sizes for ATTR_NHTM_HTMSC_MODE_WRITETOIO attribute
typedef uint8_t NHTM_HTMSC_MODE_WRITETOIO_ATTR;
typedef uint8_t ATTR_NHTM_HTMSC_MODE_WRITETOIO_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_STOP_ON_MATCH attribute
typedef uint8_t HTMSC_FILT_STOP_ON_MATCH_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_STOP_ON_MATCH_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_STOP_CYCLES attribute
typedef uint8_t HTMSC_FILT_STOP_CYCLES_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_STOP_CYCLES_type;

// Type aliases and/or sizes for ATTR_HTMSC_TTYPEFILT_PAT attribute
typedef uint8_t HTMSC_TTYPEFILT_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_TTYPEFILT_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_TSIZEFILT_PAT attribute
typedef uint8_t HTMSC_TSIZEFILT_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_TSIZEFILT_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_TTYPEFILT_MASK attribute
typedef uint8_t HTMSC_TTYPEFILT_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_TTYPEFILT_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_TSIZEFILT_MASK attribute
typedef uint8_t HTMSC_TSIZEFILT_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_TSIZEFILT_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_TTYPEFILT_INVERT attribute
typedef uint8_t HTMSC_TTYPEFILT_INVERT_ATTR;
typedef uint8_t ATTR_HTMSC_TTYPEFILT_INVERT_type;

// Type aliases and/or sizes for ATTR_HTMSC_CRESPFILT_INVERT attribute
typedef uint8_t HTMSC_CRESPFILT_INVERT_ATTR;
typedef uint8_t ATTR_HTMSC_CRESPFILT_INVERT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_ADDR_PAT attribute
typedef uint64_t HTMSC_FILT_ADDR_PAT_ATTR;
typedef uint64_t ATTR_HTMSC_FILT_ADDR_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_ADDR_MASK attribute
typedef uint64_t HTMSC_FILT_ADDR_MASK_ATTR;
typedef uint64_t ATTR_HTMSC_FILT_ADDR_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_TTAG_PAT attribute
typedef uint32_t HTMSC_FILT_TTAG_PAT_ATTR;
typedef uint32_t ATTR_HTMSC_FILT_TTAG_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_OCC_PAT attribute
typedef uint32_t HTMSC_FILT_OCC_PAT_ATTR;
typedef uint32_t ATTR_HTMSC_FILT_OCC_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_SCOPE_PAT attribute
typedef uint8_t HTMSC_FILT_SCOPE_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_SCOPE_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_SOURCE_PAT attribute
typedef uint8_t HTMSC_FILT_SOURCE_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_SOURCE_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_PORT_PAT attribute
typedef uint8_t HTMSC_FILT_PORT_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_PORT_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_PORT1_PAT attribute
typedef uint8_t HTMSC_FILT_PORT1_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_PORT1_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_TTAGFILT_INVERT attribute
typedef uint8_t HTMSC_TTAGFILT_INVERT_ATTR;
typedef uint8_t ATTR_HTMSC_TTAGFILT_INVERT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_CRESP_PAT attribute
typedef uint8_t HTMSC_FILT_CRESP_PAT_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_CRESP_PAT_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_TTAG_MASK attribute
typedef uint32_t HTMSC_FILT_TTAG_MASK_ATTR;
typedef uint32_t ATTR_HTMSC_FILT_TTAG_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_OCC_MASK attribute
typedef uint32_t HTMSC_FILT_OCC_MASK_ATTR;
typedef uint32_t ATTR_HTMSC_FILT_OCC_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_SCOPE_MASK attribute
typedef uint8_t HTMSC_FILT_SCOPE_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_SCOPE_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_SOURCE_MASK attribute
typedef uint8_t HTMSC_FILT_SOURCE_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_SOURCE_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_PORT_MASK attribute
typedef uint8_t HTMSC_FILT_PORT_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_PORT_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_PORT1_MASK attribute
typedef uint8_t HTMSC_FILT_PORT1_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_PORT1_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_FILT_CRESP_MASK attribute
typedef uint8_t HTMSC_FILT_CRESP_MASK_ATTR;
typedef uint8_t ATTR_HTMSC_FILT_CRESP_MASK_type;

// Type aliases and/or sizes for ATTR_HTMSC_MEM_SCOPE attribute
typedef uint8_t HTMSC_MEM_SCOPE_ATTR;
typedef uint8_t ATTR_HTMSC_MEM_SCOPE_type;

// Type aliases and/or sizes for ATTR_HTMSC_MEM_PRIORITY attribute
typedef uint8_t HTMSC_MEM_PRIORITY_ATTR;
typedef uint8_t ATTR_HTMSC_MEM_PRIORITY_type;

// Type aliases and/or sizes for ATTR_NHTM_CTRL_TRIG attribute
typedef uint8_t NHTM_CTRL_TRIG_ATTR;
typedef uint8_t ATTR_NHTM_CTRL_TRIG_type;

// Type aliases and/or sizes for ATTR_NHTM_CTRL_MARK attribute
typedef uint8_t NHTM_CTRL_MARK_ATTR;
typedef uint8_t ATTR_NHTM_CTRL_MARK_type;

// Type aliases and/or sizes for ATTR_CHTM_CTRL_TRIG attribute
typedef uint8_t CHTM_CTRL_TRIG_ATTR;
typedef uint8_t ATTR_CHTM_CTRL_TRIG_type;

// Type aliases and/or sizes for ATTR_CHTM_CTRL_MARK attribute
typedef uint8_t CHTM_CTRL_MARK_ATTR;
typedef uint8_t ATTR_CHTM_CTRL_MARK_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_DBG0_STOP attribute
typedef uint8_t HTMSC_CTRL_DBG0_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_DBG0_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_DBG1_STOP attribute
typedef uint8_t HTMSC_CTRL_DBG1_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_DBG1_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_RUN_STOP attribute
typedef uint8_t HTMSC_CTRL_RUN_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_RUN_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_OTHER_DBG0_STOP attribute
typedef uint8_t HTMSC_CTRL_OTHER_DBG0_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_OTHER_DBG0_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_XSTOP_STOP attribute
typedef uint8_t HTMSC_CTRL_XSTOP_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_XSTOP_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_CHIP0_STOP attribute
typedef uint8_t HTMSC_CTRL_CHIP0_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_CHIP0_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_CTRL_CHIP1_STOP attribute
typedef uint8_t HTMSC_CTRL_CHIP1_STOP_ATTR;
typedef uint8_t ATTR_HTMSC_CTRL_CHIP1_STOP_type;

// Type aliases and/or sizes for ATTR_HTMSC_IMA_PDBAR_SCOPE attribute
typedef uint8_t HTMSC_IMA_PDBAR_SCOPE_ATTR[32];
typedef uint8_t ATTR_HTMSC_IMA_PDBAR_SCOPE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_HTMSC_IMA_PDBAR_SCOPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_HTMSC_IMA_PDBAR_ADDR attribute
typedef uint64_t HTMSC_IMA_PDBAR_ADDR_ATTR[32];
typedef uint64_t ATTR_HTMSC_IMA_PDBAR_ADDR_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 32> ATTR_HTMSC_IMA_PDBAR_ADDR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_HTMSC_MODE_WRAP attribute
typedef uint8_t HTMSC_MODE_WRAP_ATTR;
typedef uint8_t ATTR_HTMSC_MODE_WRAP_type;

// Type aliases and/or sizes for ATTR_HTMSC_MODE_DIS_TSTAMP attribute
typedef uint8_t HTMSC_MODE_DIS_TSTAMP_ATTR;
typedef uint8_t ATTR_HTMSC_MODE_DIS_TSTAMP_type;

// Type aliases and/or sizes for ATTR_HTMSC_MODE_SINGLE_TSTAMP attribute
typedef uint8_t HTMSC_MODE_SINGLE_TSTAMP_ATTR;
typedef uint8_t ATTR_HTMSC_MODE_SINGLE_TSTAMP_type;

// Type aliases and/or sizes for ATTR_HTMSC_MODE_MARKERS_ONLY attribute
typedef uint8_t HTMSC_MODE_MARKERS_ONLY_ATTR;
typedef uint8_t ATTR_HTMSC_MODE_MARKERS_ONLY_type;

// Type aliases and/or sizes for ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE attribute
typedef uint8_t HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_ATTR;
typedef uint8_t ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_type;

// Type aliases and/or sizes for ATTR_HTMSC_MODE_VGTARGET attribute
typedef uint32_t HTMSC_MODE_VGTARGET_ATTR;
typedef uint32_t ATTR_HTMSC_MODE_VGTARGET_type;

// Type aliases and/or sizes for ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS attribute
typedef uint8_t CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS attribute
typedef uint8_t CHTM_MODE_LLAT_CAPTURE_STORE_DIS_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS attribute
typedef uint8_t CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_LLAT_IMBEDDED_TS attribute
typedef uint8_t CHTM_MODE_LLAT_IMBEDDED_TS_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_LLAT_IMBEDDED_TS_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_LLAT_IMBEDDED_TS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR attribute
typedef uint8_t CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE attribute
typedef uint8_t CHTM_MODE_LLAT_PAUSE_ON_PURGE_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_CORE_WRAP attribute
typedef uint8_t CHTM_MODE_CORE_WRAP_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_CORE_WRAP_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_CORE_WRAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_DIS_TSTAMP attribute
typedef uint8_t CHTM_MODE_DIS_TSTAMP_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_DIS_TSTAMP_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_DIS_TSTAMP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_SINGLE_TIME_STAMP attribute
typedef uint8_t CHTM_MODE_SINGLE_TIME_STAMP_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_SINGLE_TIME_STAMP_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_SINGLE_TIME_STAMP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_DIS_STALL attribute
typedef uint8_t CHTM_MODE_DIS_STALL_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_DIS_STALL_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_DIS_STALL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_MARKERS_ONLY attribute
typedef uint8_t CHTM_MODE_MARKERS_ONLY_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_MARKERS_ONLY_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_MARKERS_ONLY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_DIS_GROUP attribute
typedef uint8_t CHTM_MODE_DIS_GROUP_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_DIS_GROUP_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_DIS_GROUP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_MODE_VGTARGET attribute
typedef uint8_t CHTM_MODE_VGTARGET_ATTR[32];
typedef uint8_t ATTR_CHTM_MODE_VGTARGET_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_MODE_VGTARGET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL attribute
typedef uint8_t CHTM_HTMSC_MODE_CORE_INSTR_STALL_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT attribute
typedef uint8_t CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT_ATTR[32];
typedef uint8_t ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_OMI_REFCLOCK_SWIZZLE attribute
typedef uint8_t OMI_REFCLOCK_SWIZZLE_ATTR;
typedef uint8_t ATTR_OMI_REFCLOCK_SWIZZLE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE attribute
typedef uint8_t PROC_FABRIC_TOPOLOGY_ID_TABLE_ATTR[32];
typedef uint8_t ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_SL_DOMAIN attribute
typedef uint8_t PROC_FABRIC_SL_DOMAIN_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_SL_DOMAIN_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_TSNOOP attribute
typedef uint32_t PROC_FABRIC_TSNOOP_ATTR;
typedef uint32_t ATTR_PROC_FABRIC_TSNOOP_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_BROADCAST_MODE attribute
typedef uint8_t PROC_FABRIC_BROADCAST_MODE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_BROADCAST_MODE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_PRESENT_GROUPS attribute
typedef uint8_t PROC_FABRIC_PRESENT_GROUPS_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_PRESENT_GROUPS_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_TOPOLOGY_MODE attribute
typedef uint8_t PROC_FABRIC_TOPOLOGY_MODE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_TOPOLOGY_MODE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_TOPOLOGY_ID attribute
typedef uint8_t PROC_FABRIC_TOPOLOGY_ID_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_TOPOLOGY_ID_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID attribute
typedef uint8_t PROC_FABRIC_EFF_TOPOLOGY_ID_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP attribute
typedef uint8_t PROC_FABRIC_SYSTEM_MASTER_CHIP_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_GROUP_MASTER_CHIP attribute
typedef uint8_t PROC_FABRIC_GROUP_MASTER_CHIP_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_GROUP_MASTER_CHIP_type;

// Type aliases and/or sizes for ATTR_IOHS_CONFIG_MODE attribute
typedef uint8_t IOHS_CONFIG_MODE_ATTR;
typedef uint8_t ATTR_IOHS_CONFIG_MODE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_IOHS_BUS_WIDTH attribute
typedef uint8_t PROC_FABRIC_IOHS_BUS_WIDTH_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_IOHS_BUS_WIDTH_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_IOHS_BUS_WIDTH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_IOHS_DRAWER_INTERCONNECT attribute
typedef uint8_t IOHS_DRAWER_INTERCONNECT_ATTR;
typedef uint8_t ATTR_IOHS_DRAWER_INTERCONNECT_type;

// Type aliases and/or sizes for ATTR_IOHS_SMP9_INTERCONNECT attribute
typedef uint8_t IOHS_SMP9_INTERCONNECT_ATTR;
typedef uint8_t ATTR_IOHS_SMP9_INTERCONNECT_type;

// Type aliases and/or sizes for ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG attribute
typedef uint8_t IOHS_FABRIC_TOD_CROSS_CONFIG_ATTR;
typedef uint8_t ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG_type;

// Type aliases and/or sizes for ATTR_IOHS_FABRIC_LANE_REVERSAL attribute
typedef uint8_t IOHS_FABRIC_LANE_REVERSAL_ATTR;
typedef uint8_t ATTR_IOHS_FABRIC_LANE_REVERSAL_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_LINK_ACTIVE attribute
typedef uint8_t PROC_FABRIC_LINK_ACTIVE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_LINK_ACTIVE_type;

// Type aliases and/or sizes for ATTR_IOHS_LINK_TRAIN attribute
typedef uint8_t IOHS_LINK_TRAIN_ATTR;
typedef uint8_t ATTR_IOHS_LINK_TRAIN_type;

// Type aliases and/or sizes for ATTR_IOHS_LINK_SPLIT attribute
typedef uint8_t IOHS_LINK_SPLIT_ATTR;
typedef uint8_t ATTR_IOHS_LINK_SPLIT_type;

// Type aliases and/or sizes for ATTR_LINK_SPEED attribute
typedef uint16_t LINK_SPEED_ATTR;
typedef uint16_t ATTR_LINK_SPEED_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG attribute
typedef uint8_t PROC_FABRIC_X_ATTACHED_CHIP_CNFG_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_LINKS_CNFG attribute
typedef uint8_t PROC_FABRIC_X_LINKS_CNFG_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_X_LINKS_CNFG_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG attribute
typedef uint8_t PROC_FABRIC_A_ATTACHED_CHIP_CNFG_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_LINKS_CNFG attribute
typedef uint8_t PROC_FABRIC_A_LINKS_CNFG_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_A_LINKS_CNFG_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID attribute
typedef uint8_t PROC_FABRIC_X_ATTACHED_CHIP_ID_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID attribute
typedef uint8_t PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID attribute
typedef uint8_t PROC_FABRIC_X_ATTACHED_LINK_ID_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID attribute
typedef uint8_t PROC_FABRIC_A_ATTACHED_CHIP_ID_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID attribute
typedef uint8_t PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID attribute
typedef uint8_t PROC_FABRIC_A_ATTACHED_LINK_ID_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_AGGREGATE attribute
typedef uint8_t PROC_FABRIC_X_AGGREGATE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_X_AGGREGATE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_ADDR_DIS attribute
typedef uint8_t PROC_FABRIC_X_ADDR_DIS_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_X_ADDR_DIS_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_X_ADDR_DIS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_X_LINK_DELAY attribute
typedef uint32_t PROC_FABRIC_X_LINK_DELAY_ATTR[8];
typedef uint32_t ATTR_PROC_FABRIC_X_LINK_DELAY_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 8> ATTR_PROC_FABRIC_X_LINK_DELAY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_AGGREGATE attribute
typedef uint8_t PROC_FABRIC_A_AGGREGATE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_A_AGGREGATE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_ADDR_DIS attribute
typedef uint8_t PROC_FABRIC_A_ADDR_DIS_ATTR[8];
typedef uint8_t ATTR_PROC_FABRIC_A_ADDR_DIS_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_FABRIC_A_ADDR_DIS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_INDIRECT attribute
typedef uint8_t PROC_FABRIC_A_INDIRECT_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_A_INDIRECT_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_R_INDIRECT_EN attribute
typedef uint8_t PROC_FABRIC_R_INDIRECT_EN_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_R_INDIRECT_EN_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_A_LINK_DELAY attribute
typedef uint32_t PROC_FABRIC_A_LINK_DELAY_ATTR[8];
typedef uint32_t ATTR_PROC_FABRIC_A_LINK_DELAY_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 8> ATTR_PROC_FABRIC_A_LINK_DELAY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE attribute
typedef uint8_t PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE_ATTR[32];
typedef uint8_t ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 32> ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_FABRIC_ASYNC_MODE attribute
typedef uint8_t PROC_FABRIC_ASYNC_MODE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_ASYNC_MODE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_DLR_PSAVE_MODE attribute
typedef uint8_t PROC_FABRIC_DLR_PSAVE_MODE_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_DLR_PSAVE_MODE_type;

// Type aliases and/or sizes for ATTR_PROC_FABRIC_CORE_FREQ_RATIO attribute
typedef uint8_t PROC_FABRIC_CORE_FREQ_RATIO_ATTR;
typedef uint8_t ATTR_PROC_FABRIC_CORE_FREQ_RATIO_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_GB_PERCENTAGE attribute
typedef int8_t PROC_EPS_GB_PERCENTAGE_ATTR;
typedef int8_t ATTR_PROC_EPS_GB_PERCENTAGE_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_TABLE_TYPE attribute
typedef uint8_t PROC_EPS_TABLE_TYPE_ATTR;
typedef uint8_t ATTR_PROC_EPS_TABLE_TYPE_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_READ_CYCLES_T0 attribute
typedef uint32_t PROC_EPS_READ_CYCLES_T0_ATTR;
typedef uint32_t ATTR_PROC_EPS_READ_CYCLES_T0_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_READ_CYCLES_T1 attribute
typedef uint32_t PROC_EPS_READ_CYCLES_T1_ATTR;
typedef uint32_t ATTR_PROC_EPS_READ_CYCLES_T1_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_READ_CYCLES_T2 attribute
typedef uint32_t PROC_EPS_READ_CYCLES_T2_ATTR;
typedef uint32_t ATTR_PROC_EPS_READ_CYCLES_T2_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_WRITE_CYCLES_T1 attribute
typedef uint32_t PROC_EPS_WRITE_CYCLES_T1_ATTR;
typedef uint32_t ATTR_PROC_EPS_WRITE_CYCLES_T1_type;

// Type aliases and/or sizes for ATTR_PROC_EPS_WRITE_CYCLES_T2 attribute
typedef uint32_t PROC_EPS_WRITE_CYCLES_T2_ATTR;
typedef uint32_t ATTR_PROC_EPS_WRITE_CYCLES_T2_type;

// Type aliases and/or sizes for ATTR_MRW_L2_INCREASE_JITTER attribute
typedef uint8_t MRW_L2_INCREASE_JITTER_ATTR;
typedef uint8_t ATTR_MRW_L2_INCREASE_JITTER_type;

// Type aliases and/or sizes for ATTR_MRW_P1PF_MIN_CONFIDENCE_3 attribute
typedef uint8_t MRW_P1PF_MIN_CONFIDENCE_3_ATTR;
typedef uint8_t ATTR_MRW_P1PF_MIN_CONFIDENCE_3_type;

// Type aliases and/or sizes for ATTR_MRW_CONVERT_DCBZ_TO_RWITM attribute
typedef uint8_t MRW_CONVERT_DCBZ_TO_RWITM_ATTR;
typedef uint8_t ATTR_MRW_CONVERT_DCBZ_TO_RWITM_type;

// Type aliases and/or sizes for ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH attribute
typedef uint8_t PROC_FAVOR_AGGRESSIVE_PREFETCH_ATTR;
typedef uint8_t ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH_type;

// Type aliases and/or sizes for ATTR_PROC_LCO_MODE_DISABLE attribute
typedef uint8_t PROC_LCO_MODE_DISABLE_ATTR;
typedef uint8_t ATTR_PROC_LCO_MODE_DISABLE_type;

// Type aliases and/or sizes for ATTR_PROC_LCO_MODE_SETUP attribute
typedef uint8_t PROC_LCO_MODE_SETUP_ATTR;
typedef uint8_t ATTR_PROC_LCO_MODE_SETUP_type;

// Type aliases and/or sizes for ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N attribute
typedef uint32_t PROC_LCO_MODE_SETUP_ADAPTIVE_N_ATTR;
typedef uint32_t ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N_type;

// Type aliases and/or sizes for ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D attribute
typedef uint32_t PROC_LCO_MODE_SETUP_ADAPTIVE_D_ATTR;
typedef uint32_t ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D_type;

// Type aliases and/or sizes for ATTR_PROC_LCO_TARGETS_COUNT attribute
typedef uint8_t PROC_LCO_TARGETS_COUNT_ATTR[3];
typedef uint8_t ATTR_PROC_LCO_TARGETS_COUNT_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_LCO_TARGETS_COUNT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_LCO_TARGETS_VECTOR attribute
typedef uint32_t PROC_LCO_TARGETS_VECTOR_ATTR[3];
typedef uint32_t ATTR_PROC_LCO_TARGETS_VECTOR_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 3> ATTR_PROC_LCO_TARGETS_VECTOR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_LCO_TARGETS_MIN attribute
typedef uint8_t PROC_LCO_TARGETS_MIN_ATTR[3];
typedef uint8_t ATTR_PROC_LCO_TARGETS_MIN_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_LCO_TARGETS_MIN_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_IOHS_PHY_TO_PAU_MAPPING attribute
typedef uint8_t IOHS_PHY_TO_PAU_MAPPING_ATTR;
typedef uint8_t ATTR_IOHS_PHY_TO_PAU_MAPPING_type;

// Type aliases and/or sizes for ATTR_PROC_L2_HASH_DISABLE attribute
typedef uint8_t PROC_L2_HASH_DISABLE_ATTR;
typedef uint8_t ATTR_PROC_L2_HASH_DISABLE_type;

// Type aliases and/or sizes for ATTR_PROC_L3_HASH_DISABLE attribute
typedef uint8_t PROC_L3_HASH_DISABLE_ATTR;
typedef uint8_t ATTR_PROC_L3_HASH_DISABLE_type;

// Type aliases and/or sizes for ATTR_PROC_SBE_MCS_SETUP_REG_STATES attribute
typedef uint64_t PROC_SBE_MCS_SETUP_REG_STATES_ATTR[9];
typedef uint64_t ATTR_PROC_SBE_MCS_SETUP_REG_STATES_type[9];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 9> ATTR_PROC_SBE_MCS_SETUP_REG_STATES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_MEMORY_ENCRYPTION_ENABLED attribute
typedef uint8_t PROC_MEMORY_ENCRYPTION_ENABLED_ATTR;
typedef uint8_t ATTR_PROC_MEMORY_ENCRYPTION_ENABLED_type;

// Type aliases and/or sizes for ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC attribute
typedef uint8_t PROC_SBE_MCS_SETUP_SELECTED_MC_ATTR;
typedef uint8_t ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC_type;

// Type aliases and/or sizes for ATTR_HW543384_WAR_MODE attribute
typedef uint8_t HW543384_WAR_MODE_ATTR;
typedef uint8_t ATTR_HW543384_WAR_MODE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE attribute
typedef uint8_t SYSTEM_FUSED_CORE_PAIRED_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE_type;

// Type aliases and/or sizes for ATTR_QME_STATE_LOSS_CORES attribute
typedef uint32_t QME_STATE_LOSS_CORES_ATTR;
typedef uint32_t ATTR_QME_STATE_LOSS_CORES_type;

// Type aliases and/or sizes for ATTR_PROC_DPLL_DIVIDER attribute
typedef uint32_t PROC_DPLL_DIVIDER_ATTR;
typedef uint32_t ATTR_PROC_DPLL_DIVIDER_type;

// Type aliases and/or sizes for ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET attribute
typedef uint32_t XGPE_BOOT_COPIER_IVPR_OFFSET_ATTR;
typedef uint32_t ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET attribute
typedef uint32_t PGPE_BOOT_COPIER_IVPR_OFFSET_ATTR;
typedef uint32_t ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG attribute
typedef uint8_t PM_SPWUP_IGNORE_XSTOP_FLAG_ATTR;
typedef uint8_t ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG_type;

// Type aliases and/or sizes for ATTR_OCC_LFIRMASK attribute
typedef uint64_t OCC_LFIRMASK_ATTR;
typedef uint64_t ATTR_OCC_LFIRMASK_type;

// Type aliases and/or sizes for ATTR_PBAO_LFIRMASK attribute
typedef uint64_t PBAO_LFIRMASK_ATTR;
typedef uint64_t ATTR_PBAO_LFIRMASK_type;

// Type aliases and/or sizes for ATTR_QME_LFIRMASK attribute
typedef uint64_t QME_LFIRMASK_ATTR;
typedef uint64_t ATTR_QME_LFIRMASK_type;

// Type aliases and/or sizes for ATTR_PBAF_LFIRMASK attribute
typedef uint64_t PBAF_LFIRMASK_ATTR;
typedef uint64_t ATTR_PBAF_LFIRMASK_type;

// Type aliases and/or sizes for ATTR_PM_FIRINIT_DONE_ONCE_FLAG attribute
typedef uint8_t PM_FIRINIT_DONE_ONCE_FLAG_ATTR;
typedef uint8_t ATTR_PM_FIRINIT_DONE_ONCE_FLAG_type;

// Type aliases and/or sizes for ATTR_L3_HASCLOCKS attribute
typedef uint8_t L3_HASCLOCKS_ATTR;
typedef uint8_t ATTR_L3_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_CORE_HASCLOCKS attribute
typedef uint8_t CORE_HASCLOCKS_ATTR;
typedef uint8_t ATTR_CORE_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_L3_HASPOWER attribute
typedef uint8_t L3_HASPOWER_ATTR;
typedef uint8_t ATTR_L3_HASPOWER_type;

// Type aliases and/or sizes for ATTR_CORE_HASPOWER attribute
typedef uint8_t CORE_HASPOWER_ATTR;
typedef uint8_t ATTR_CORE_HASPOWER_type;

// Type aliases and/or sizes for ATTR_PSTATES_ENABLED attribute
typedef uint8_t PSTATES_ENABLED_ATTR;
typedef uint8_t ATTR_PSTATES_ENABLED_type;

// Type aliases and/or sizes for ATTR_RESCLK_ENABLED attribute
typedef uint8_t RESCLK_ENABLED_ATTR;
typedef uint8_t ATTR_RESCLK_ENABLED_type;

// Type aliases and/or sizes for ATTR_DDS_ENABLED attribute
typedef uint8_t DDS_ENABLED_ATTR;
typedef uint8_t ATTR_DDS_ENABLED_type;

// Type aliases and/or sizes for ATTR_RVRM_ENABLED attribute
typedef uint8_t RVRM_ENABLED_ATTR;
typedef uint8_t ATTR_RVRM_ENABLED_type;

// Type aliases and/or sizes for ATTR_WOF_ENABLED attribute
typedef uint8_t WOF_ENABLED_ATTR;
typedef uint8_t ATTR_WOF_ENABLED_type;

// Type aliases and/or sizes for ATTR_OCS_ENABLED attribute
typedef uint8_t OCS_ENABLED_ATTR;
typedef uint8_t ATTR_OCS_ENABLED_type;

// Type aliases and/or sizes for ATTR_WOV_UNDERV_ENABLED attribute
typedef uint8_t WOV_UNDERV_ENABLED_ATTR;
typedef uint8_t ATTR_WOV_UNDERV_ENABLED_type;

// Type aliases and/or sizes for ATTR_WOV_OVERV_ENABLED attribute
typedef uint8_t WOV_OVERV_ENABLED_ATTR;
typedef uint8_t ATTR_WOV_OVERV_ENABLED_type;

// Type aliases and/or sizes for ATTR_WOF_THROTTLE_CONTROL_DISABLED attribute
typedef uint8_t WOF_THROTTLE_CONTROL_DISABLED_ATTR;
typedef uint8_t ATTR_WOF_THROTTLE_CONTROL_DISABLED_type;

// Type aliases and/or sizes for ATTR_XGPE_PHANTOM_HALT_ENABLE attribute
typedef uint8_t XGPE_PHANTOM_HALT_ENABLE_ATTR;
typedef uint8_t ATTR_XGPE_PHANTOM_HALT_ENABLE_type;

// Type aliases and/or sizes for ATTR_PGPE_PHANTOM_HALT_ENABLE attribute
typedef uint8_t PGPE_PHANTOM_HALT_ENABLE_ATTR;
typedef uint8_t ATTR_PGPE_PHANTOM_HALT_ENABLE_type;

// Type aliases and/or sizes for ATTR_QME_STOP_PHANTOM_HALT_ENABLE attribute
typedef uint8_t QME_STOP_PHANTOM_HALT_ENABLE_ATTR;
typedef uint8_t ATTR_QME_STOP_PHANTOM_HALT_ENABLE_type;

// Type aliases and/or sizes for ATTR_CORE_INSIDE_SPECIAL_WAKEUP attribute
typedef uint8_t CORE_INSIDE_SPECIAL_WAKEUP_ATTR;
typedef uint8_t ATTR_CORE_INSIDE_SPECIAL_WAKEUP_type;

// Type aliases and/or sizes for ATTR_INITIATED_PM_HALT attribute
typedef uint8_t INITIATED_PM_HALT_ATTR;
typedef uint8_t ATTR_INITIATED_PM_HALT_type;

// Type aliases and/or sizes for ATTR_PM_RESTART_PHASE attribute
typedef uint8_t PM_RESTART_PHASE_ATTR;
typedef uint8_t ATTR_PM_RESTART_PHASE_type;

// Type aliases and/or sizes for ATTR_PM_MALF_CYCLE attribute
typedef uint8_t PM_MALF_CYCLE_ATTR;
typedef uint8_t ATTR_PM_MALF_CYCLE_type;

// Type aliases and/or sizes for ATTR_BOOT_VOLTAGE attribute
typedef uint32_t BOOT_VOLTAGE_ATTR[4];
typedef uint32_t ATTR_BOOT_VOLTAGE_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_BOOT_VOLTAGE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_QME_BROADSIDE_SCAN attribute
typedef uint8_t QME_BROADSIDE_SCAN_ATTR;
typedef uint8_t ATTR_QME_BROADSIDE_SCAN_type;

// Type aliases and/or sizes for ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ attribute
typedef uint32_t SYSTEM_MAX_OPERATING_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_SYSTEM_PSTATE0_FREQ_MHZ attribute
typedef uint32_t SYSTEM_PSTATE0_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_SYSTEM_PSTATE0_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_HOMER_LOCATION attribute
typedef uint8_t HOMER_LOCATION_ATTR;
typedef uint8_t ATTR_HOMER_LOCATION_type;

// Type aliases and/or sizes for ATTR_QME_BOOT_CONTROL attribute
typedef uint8_t QME_BOOT_CONTROL_ATTR;
typedef uint8_t ATTR_QME_BOOT_CONTROL_type;

// Type aliases and/or sizes for ATTR_PM_SPIPSS_FRAME_SIZE attribute
typedef uint8_t PM_SPIPSS_FRAME_SIZE_ATTR;
typedef uint8_t ATTR_PM_SPIPSS_FRAME_SIZE_type;

// Type aliases and/or sizes for ATTR_PM_SPIPSS_IN_DELAY attribute
typedef uint8_t PM_SPIPSS_IN_DELAY_ATTR;
typedef uint8_t ATTR_PM_SPIPSS_IN_DELAY_type;

// Type aliases and/or sizes for ATTR_PM_SPIPSS_CLOCK_POLARITY attribute
typedef uint8_t PM_SPIPSS_CLOCK_POLARITY_ATTR;
typedef uint8_t ATTR_PM_SPIPSS_CLOCK_POLARITY_type;

// Type aliases and/or sizes for ATTR_PM_SPIPSS_CLOCK_PHASE attribute
typedef uint8_t PM_SPIPSS_CLOCK_PHASE_ATTR;
typedef uint8_t ATTR_PM_SPIPSS_CLOCK_PHASE_type;

// Type aliases and/or sizes for ATTR_PM_SPIPSS_CLOCK_DIVIDER attribute
typedef uint16_t PM_SPIPSS_CLOCK_DIVIDER_ATTR;
typedef uint16_t ATTR_PM_SPIPSS_CLOCK_DIVIDER_type;

// Type aliases and/or sizes for ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING attribute
typedef uint32_t PM_SPIPSS_INTER_FRAME_DELAY_SETTING_ATTR;
typedef uint32_t ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING_type;

// Type aliases and/or sizes for ATTR_INSIDE_SPECIAL_WAKEUP attribute
typedef uint8_t INSIDE_SPECIAL_WAKEUP_ATTR;
typedef uint8_t ATTR_INSIDE_SPECIAL_WAKEUP_type;

// Type aliases and/or sizes for ATTR_SOCKET_POWER_NOMINAL attribute
typedef uint16_t SOCKET_POWER_NOMINAL_ATTR;
typedef uint16_t ATTR_SOCKET_POWER_NOMINAL_type;

// Type aliases and/or sizes for ATTR_SYSTEM_COMPAT_FREQ_MHZ attribute
typedef uint16_t SYSTEM_COMPAT_FREQ_MHZ_ATTR;
typedef uint16_t ATTR_SYSTEM_COMPAT_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_OVERRIDE_UT attribute
typedef uint16_t WOF_TABLE_OVERRIDE_UT_ATTR;
typedef uint16_t ATTR_WOF_TABLE_OVERRIDE_UT_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_OVERRIDE_WB attribute
typedef uint16_t WOF_TABLE_OVERRIDE_WB_ATTR;
typedef uint16_t ATTR_WOF_TABLE_OVERRIDE_WB_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_OVERRIDE_PS attribute
typedef uint16_t WOF_TABLE_OVERRIDE_PS_ATTR;
typedef uint16_t ATTR_WOF_TABLE_OVERRIDE_PS_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_OVERRIDE_FF attribute
typedef uint16_t WOF_TABLE_OVERRIDE_FF_ATTR;
typedef uint16_t ATTR_WOF_TABLE_OVERRIDE_FF_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_OVERRIDE_SP attribute
typedef uint16_t WOF_TABLE_OVERRIDE_SP_ATTR;
typedef uint16_t ATTR_WOF_TABLE_OVERRIDE_SP_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_OVERRIDE_RC attribute
typedef uint16_t WOF_TABLE_OVERRIDE_RC_ATTR;
typedef uint16_t ATTR_WOF_TABLE_OVERRIDE_RC_type;

// Type aliases and/or sizes for ATTR_WOF_IO_START attribute
typedef uint16_t WOF_IO_START_ATTR;
typedef uint16_t ATTR_WOF_IO_START_type;

// Type aliases and/or sizes for ATTR_WOF_IO_STEP attribute
typedef uint16_t WOF_IO_STEP_ATTR;
typedef uint16_t ATTR_WOF_IO_STEP_type;

// Type aliases and/or sizes for ATTR_WOF_IO_COUNT attribute
typedef uint16_t WOF_IO_COUNT_ATTR;
typedef uint16_t ATTR_WOF_IO_COUNT_type;

// Type aliases and/or sizes for ATTR_VDN_VOLTAGE_MV attribute
typedef uint16_t VDN_VOLTAGE_MV_ATTR;
typedef uint16_t ATTR_VDN_VOLTAGE_MV_type;

// Type aliases and/or sizes for ATTR_WOF_TDP_IO_INDEX attribute
typedef uint8_t WOF_TDP_IO_INDEX_ATTR;
typedef uint8_t ATTR_WOF_TDP_IO_INDEX_type;

// Type aliases and/or sizes for ATTR_DEAD_CORE_MODE attribute
typedef uint8_t DEAD_CORE_MODE_ATTR;
typedef uint8_t ATTR_DEAD_CORE_MODE_type;

// Type aliases and/or sizes for ATTR_SAFE_MODE_THROTTLE_IDX attribute
typedef uint8_t SAFE_MODE_THROTTLE_IDX_ATTR;
typedef uint8_t ATTR_SAFE_MODE_THROTTLE_IDX_type;

// Type aliases and/or sizes for ATTR_PDW_TRACE_ENABLE attribute
typedef uint8_t PDW_TRACE_ENABLE_ATTR;
typedef uint8_t ATTR_PDW_TRACE_ENABLE_type;

// Type aliases and/or sizes for ATTR_MIN_PROC_POWER_PER_CHIP attribute
typedef uint16_t MIN_PROC_POWER_PER_CHIP_ATTR;
typedef uint16_t ATTR_MIN_PROC_POWER_PER_CHIP_type;

// Type aliases and/or sizes for ATTR_AVSBUS_VRM_FAIL_OVERRIDE attribute
typedef uint8_t AVSBUS_VRM_FAIL_OVERRIDE_ATTR;
typedef uint8_t ATTR_AVSBUS_VRM_FAIL_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_OMI_SPREAD_SPECTRUM attribute
typedef uint8_t OMI_SPREAD_SPECTRUM_ATTR;
typedef uint8_t ATTR_OMI_SPREAD_SPECTRUM_type;

// Type aliases and/or sizes for ATTR_IOHS_SPREAD_SPECTRUM attribute
typedef uint8_t IOHS_SPREAD_SPECTRUM_ATTR;
typedef uint8_t ATTR_IOHS_SPREAD_SPECTRUM_type;

// Type aliases and/or sizes for ATTR_IOHS_MNFG_BAD_LANE_MAX attribute
typedef uint8_t IOHS_MNFG_BAD_LANE_MAX_ATTR;
typedef uint8_t ATTR_IOHS_MNFG_BAD_LANE_MAX_type;

// Type aliases and/or sizes for ATTR_IOHS_MNFG_BAD_LANE_DURATION attribute
typedef uint8_t IOHS_MNFG_BAD_LANE_DURATION_ATTR;
typedef uint8_t ATTR_IOHS_MNFG_BAD_LANE_DURATION_type;

// Type aliases and/or sizes for ATTR_VIO_SET_POINT_MV attribute
typedef uint32_t VIO_SET_POINT_MV_ATTR;
typedef uint32_t ATTR_VIO_SET_POINT_MV_type;

// Type aliases and/or sizes for ATTR_IOHS_MFG_BAD_LANE_VEC attribute
typedef uint32_t IOHS_MFG_BAD_LANE_VEC_ATTR;
typedef uint32_t ATTR_IOHS_MFG_BAD_LANE_VEC_type;

// Type aliases and/or sizes for ATTR_IOHS_MFG_BAD_LANE_VEC_VALID attribute
typedef uint8_t IOHS_MFG_BAD_LANE_VEC_VALID_ATTR;
typedef uint8_t ATTR_IOHS_MFG_BAD_LANE_VEC_VALID_type;

// Type aliases and/or sizes for ATTR_IO_IOHS_XTALK attribute
typedef uint8_t IO_IOHS_XTALK_ATTR;
typedef uint8_t ATTR_IO_IOHS_XTALK_type;

// Type aliases and/or sizes for ATTR_IO_IOHS_CHANNEL_LOSS attribute
typedef uint8_t IO_IOHS_CHANNEL_LOSS_ATTR;
typedef uint8_t ATTR_IO_IOHS_CHANNEL_LOSS_type;

// Type aliases and/or sizes for ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND attribute
typedef uint8_t IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_ATTR;
typedef uint8_t ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_type;

// Type aliases and/or sizes for ATTR_IO_OMI_CHANNEL_LOSS attribute
typedef uint8_t IO_OMI_CHANNEL_LOSS_ATTR;
typedef uint8_t ATTR_IO_OMI_CHANNEL_LOSS_type;

// Type aliases and/or sizes for ATTR_IO_OMI_PRE1 attribute
typedef uint8_t IO_OMI_PRE1_ATTR;
typedef uint8_t ATTR_IO_OMI_PRE1_type;

// Type aliases and/or sizes for ATTR_IO_OMI_PRE2 attribute
typedef uint8_t IO_OMI_PRE2_ATTR;
typedef uint8_t ATTR_IO_OMI_PRE2_type;

// Type aliases and/or sizes for ATTR_IO_IOHS_PRE1 attribute
typedef uint8_t IO_IOHS_PRE1_ATTR;
typedef uint8_t ATTR_IO_IOHS_PRE1_type;

// Type aliases and/or sizes for ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND attribute
typedef uint8_t IO_IOHS_PRE1_ISC1_WORKAROUND_ATTR;
typedef uint8_t ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND_type;

// Type aliases and/or sizes for ATTR_IO_IOHS_PRE2 attribute
typedef uint8_t IO_IOHS_PRE2_ATTR;
typedef uint8_t ATTR_IO_IOHS_PRE2_type;

// Type aliases and/or sizes for ATTR_OMI_DL_GROUP_POS attribute
typedef uint8_t OMI_DL_GROUP_POS_ATTR;
typedef uint8_t ATTR_OMI_DL_GROUP_POS_type;

// Type aliases and/or sizes for ATTR_OMI_DL_NUM attribute
typedef uint8_t OMI_DL_NUM_ATTR;
typedef uint8_t ATTR_OMI_DL_NUM_type;

// Type aliases and/or sizes for ATTR_OCMB_COUNTER attribute
typedef uint32_t OCMB_COUNTER_ATTR;
typedef uint32_t ATTR_OCMB_COUNTER_type;

// Type aliases and/or sizes for ATTR_VIO_RAILS_NOT_POWERED attribute
typedef uint8_t VIO_RAILS_NOT_POWERED_ATTR;
typedef uint8_t ATTR_VIO_RAILS_NOT_POWERED_type;

// Type aliases and/or sizes for ATTR_SAVED_PB_PTL_FIR_MASK attribute
typedef uint64_t SAVED_PB_PTL_FIR_MASK_ATTR;
typedef uint64_t ATTR_SAVED_PB_PTL_FIR_MASK_type;

// Type aliases and/or sizes for ATTR_SAVED_DLP_FIR_MASK attribute
typedef uint64_t SAVED_DLP_FIR_MASK_ATTR;
typedef uint64_t ATTR_SAVED_DLP_FIR_MASK_type;

// Type aliases and/or sizes for ATTR_INTERPOSER_REV attribute
typedef uint8_t INTERPOSER_REV_ATTR;
typedef uint8_t ATTR_INTERPOSER_REV_type;

// Type aliases and/or sizes for ATTR_INTERPOSER_FEATURE_HW632898 attribute
typedef uint8_t INTERPOSER_FEATURE_HW632898_ATTR;
typedef uint8_t ATTR_INTERPOSER_FEATURE_HW632898_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_PHB_ACTIVE attribute
typedef uint8_t PROC_PCIE_PHB_ACTIVE_ATTR[3];
typedef uint8_t ATTR_PROC_PCIE_PHB_ACTIVE_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_PCIE_PHB_ACTIVE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_LANE_REVERSAL attribute
typedef uint8_t PROC_PCIE_LANE_REVERSAL_ATTR[3];
typedef uint8_t ATTR_PROC_PCIE_LANE_REVERSAL_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_PCIE_LANE_REVERSAL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_BAR_ENABLE attribute
typedef uint8_t PROC_PCIE_BAR_ENABLE_ATTR[3];
typedef uint8_t ATTR_PROC_PCIE_BAR_ENABLE_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_PCIE_BAR_ENABLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET_ATTR[6];
typedef uint64_t ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET_type[6];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 6> ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET_ATTR[6];
typedef uint64_t ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET_type[6];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 6> ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET_ATTR[6];
typedef uint64_t ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET_type[6];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 6> ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_BAR_SIZE attribute
typedef uint64_t PROC_PCIE_BAR_SIZE_ATTR[3];
typedef uint64_t ATTR_PROC_PCIE_BAR_SIZE_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 3> ATTR_PROC_PCIE_BAR_SIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_FW_VERSION_0 attribute
typedef uint16_t PROC_PCIE_FW_VERSION_0_ATTR;
typedef uint16_t ATTR_PROC_PCIE_FW_VERSION_0_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_FW_VERSION_1 attribute
typedef uint16_t PROC_PCIE_FW_VERSION_1_ATTR;
typedef uint16_t ATTR_PROC_PCIE_FW_VERSION_1_type;

// Type aliases and/or sizes for ATTR_SYS0_REFCLOCK_RCVR_TERM attribute
typedef uint8_t SYS0_REFCLOCK_RCVR_TERM_ATTR;
typedef uint8_t ATTR_SYS0_REFCLOCK_RCVR_TERM_type;

// Type aliases and/or sizes for ATTR_SYS1_REFCLOCK_RCVR_TERM attribute
typedef uint8_t SYS1_REFCLOCK_RCVR_TERM_ATTR;
typedef uint8_t ATTR_SYS1_REFCLOCK_RCVR_TERM_type;

// Type aliases and/or sizes for ATTR_PCI0_REFCLOCK_RCVR_TERM attribute
typedef uint8_t PCI0_REFCLOCK_RCVR_TERM_ATTR;
typedef uint8_t ATTR_PCI0_REFCLOCK_RCVR_TERM_type;

// Type aliases and/or sizes for ATTR_PCI1_REFCLOCK_RCVR_TERM attribute
typedef uint8_t PCI1_REFCLOCK_RCVR_TERM_ATTR;
typedef uint8_t ATTR_PCI1_REFCLOCK_RCVR_TERM_type;

// Type aliases and/or sizes for ATTR_SYS_CLK_NE_TERMINATION_SITE attribute
typedef uint8_t SYS_CLK_NE_TERMINATION_SITE_ATTR;
typedef uint8_t ATTR_SYS_CLK_NE_TERMINATION_SITE_type;

// Type aliases and/or sizes for ATTR_SYS_CLK_NE_TERMINATION_STRENGTH attribute
typedef uint8_t SYS_CLK_NE_TERMINATION_STRENGTH_ATTR;
typedef uint8_t ATTR_SYS_CLK_NE_TERMINATION_STRENGTH_type;

// Type aliases and/or sizes for ATTR_CP_REFCLOCK_SELECT attribute
typedef uint8_t CP_REFCLOCK_SELECT_ATTR;
typedef uint8_t ATTR_CP_REFCLOCK_SELECT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX0A_RCS_PLL_INPUT attribute
typedef uint8_t CLOCK_MUX0A_RCS_PLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX0A_RCS_PLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX0B_RCS_PLL_INPUT attribute
typedef uint8_t CLOCK_MUX0B_RCS_PLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX0B_RCS_PLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX0C_RCS_PLL_INPUT attribute
typedef uint8_t CLOCK_MUX0C_RCS_PLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX0C_RCS_PLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX0D_RCS_PLL_INPUT attribute
typedef uint8_t CLOCK_MUX0D_RCS_PLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX0D_RCS_PLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX1_INPUT attribute
typedef uint8_t CLOCK_MUX1_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX1_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX2A_INPUT attribute
typedef uint8_t CLOCK_MUX2A_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX2A_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX2B_INPUT attribute
typedef uint8_t CLOCK_MUX2B_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX2B_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX3_INPUT attribute
typedef uint8_t CLOCK_MUX3_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX3_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX10_PAU_DPLL_INPUT attribute
typedef uint8_t CLOCK_MUX10_PAU_DPLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX10_PAU_DPLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX11_NEST_DPLL_INPUT attribute
typedef uint8_t CLOCK_MUX11_NEST_DPLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX11_NEST_DPLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT attribute
typedef uint8_t CLOCK_MUX12_OMI_LCPLL_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT attribute
typedef uint8_t CLOCK_MUX13_OPT_133_SOURCE_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT attribute
typedef uint8_t CLOCK_MUX14_OPT_156_SOURCE_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT attribute
typedef uint8_t CLOCK_MUX_IOHS_LCPLL_INPUT_ATTR[8];
typedef uint8_t ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CLOCK_MUX23_PCI_INPUT attribute
typedef uint8_t CLOCK_MUX23_PCI_INPUT_ATTR;
typedef uint8_t ATTR_CLOCK_MUX23_PCI_INPUT_type;

// Type aliases and/or sizes for ATTR_CLOCK_MUX_PCI_LCPLL_INPUT attribute
typedef uint8_t CLOCK_MUX_PCI_LCPLL_INPUT_ATTR[2];
typedef uint8_t ATTR_CLOCK_MUX_PCI_LCPLL_INPUT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_CLOCK_MUX_PCI_LCPLL_INPUT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CLOCK_PLL_MUX_TOD attribute
typedef uint8_t CLOCK_PLL_MUX_TOD_ATTR;
typedef uint8_t ATTR_CLOCK_PLL_MUX_TOD_type;

// Type aliases and/or sizes for ATTR_HW543822_WAR_MODE attribute
typedef uint8_t HW543822_WAR_MODE_ATTR;
typedef uint8_t ATTR_HW543822_WAR_MODE_type;

// Type aliases and/or sizes for ATTR_DISABLE_TOD_SYNC_SPREAD attribute
typedef uint8_t DISABLE_TOD_SYNC_SPREAD_ATTR;
typedef uint8_t ATTR_DISABLE_TOD_SYNC_SPREAD_type;

// Type aliases and/or sizes for ATTR_PROC_FORCE_MC_PLL_BANDSEL attribute
typedef uint8_t PROC_FORCE_MC_PLL_BANDSEL_ATTR;
typedef uint8_t ATTR_PROC_FORCE_MC_PLL_BANDSEL_type;

// Type aliases and/or sizes for ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE attribute
typedef uint8_t PROC_MC_PLL_BANDSEL_OVERRIDE_ATTR[8];
typedef uint8_t ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SYSTEM_IPL_PHASE attribute
typedef uint8_t SYSTEM_IPL_PHASE_ATTR;
typedef uint8_t ATTR_SYSTEM_IPL_PHASE_type;

// Type aliases and/or sizes for ATTR_PROC_CHIP_IPL_PHASE attribute
typedef uint8_t PROC_CHIP_IPL_PHASE_ATTR;
typedef uint8_t ATTR_PROC_CHIP_IPL_PHASE_type;

// Type aliases and/or sizes for ATTR_IPL_TYPE attribute
typedef uint8_t IPL_TYPE_ATTR;
typedef uint8_t ATTR_IPL_TYPE_type;

// Type aliases and/or sizes for ATTR_CONTAINED_IPL_TYPE attribute
typedef uint8_t CONTAINED_IPL_TYPE_ATTR;
typedef uint8_t ATTR_CONTAINED_IPL_TYPE_type;

// Type aliases and/or sizes for ATTR_CONTAINED_LOAD_PATH attribute
typedef uint8_t CONTAINED_LOAD_PATH_ATTR;
typedef uint8_t ATTR_CONTAINED_LOAD_PATH_type;

// Type aliases and/or sizes for ATTR_SBE_RUNTIME_MODE attribute
typedef uint8_t SBE_RUNTIME_MODE_ATTR;
typedef uint8_t ATTR_SBE_RUNTIME_MODE_type;

// Type aliases and/or sizes for ATTR_IS_SP_MODE attribute
typedef uint8_t IS_SP_MODE_ATTR;
typedef uint8_t ATTR_IS_SP_MODE_type;

// Type aliases and/or sizes for ATTR_DISABLE_HBBL_VECTORS attribute
typedef uint8_t DISABLE_HBBL_VECTORS_ATTR;
typedef uint8_t ATTR_DISABLE_HBBL_VECTORS_type;

// Type aliases and/or sizes for ATTR_BACKUP_SEEPROM_SELECT attribute
typedef uint8_t BACKUP_SEEPROM_SELECT_ATTR;
typedef uint8_t ATTR_BACKUP_SEEPROM_SELECT_type;

// Type aliases and/or sizes for ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT attribute
typedef uint8_t BACKUP_MEASUREMENT_SEEPROM_SELECT_ATTR;
typedef uint8_t ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT_type;

// Type aliases and/or sizes for ATTR_BOOT_FLAGS attribute
typedef uint32_t BOOT_FLAGS_ATTR;
typedef uint32_t ATTR_BOOT_FLAGS_type;

// Type aliases and/or sizes for ATTR_ALLOW_ATTR_OVERRIDES attribute
typedef uint8_t ALLOW_ATTR_OVERRIDES_ATTR;
typedef uint8_t ATTR_ALLOW_ATTR_OVERRIDES_type;

// Type aliases and/or sizes for ATTR_NO_XSCOM_ENFORCEMENT attribute
typedef uint8_t NO_XSCOM_ENFORCEMENT_ATTR;
typedef uint8_t ATTR_NO_XSCOM_ENFORCEMENT_type;

// Type aliases and/or sizes for ATTR_SECURITY_ENABLE attribute
typedef uint8_t SECURITY_ENABLE_ATTR;
typedef uint8_t ATTR_SECURITY_ENABLE_type;

// Type aliases and/or sizes for ATTR_SBE_SELECT_EX_POLICY attribute
typedef uint8_t SBE_SELECT_EX_POLICY_ATTR;
typedef uint8_t ATTR_SBE_SELECT_EX_POLICY_type;

// Type aliases and/or sizes for ATTR_MASTER_CORE attribute
typedef uint8_t MASTER_CORE_ATTR;
typedef uint8_t ATTR_MASTER_CORE_type;

// Type aliases and/or sizes for ATTR_ACTIVE_CORES_VEC attribute
typedef uint32_t ACTIVE_CORES_VEC_ATTR;
typedef uint32_t ATTR_ACTIVE_CORES_VEC_type;

// Type aliases and/or sizes for ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC attribute
typedef uint32_t CHIP_CONTAINED_ACTIVE_CORES_VEC_ATTR;
typedef uint32_t ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC_type;

// Type aliases and/or sizes for ATTR_BACKING_CACHES_VEC attribute
typedef uint32_t BACKING_CACHES_VEC_ATTR;
typedef uint32_t ATTR_BACKING_CACHES_VEC_type;

// Type aliases and/or sizes for ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC attribute
typedef uint32_t CHIP_CONTAINED_BACKING_CACHES_VEC_ATTR;
typedef uint32_t ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC_type;

// Type aliases and/or sizes for ATTR_ACTIVE_CORES_NUM attribute
typedef uint8_t ACTIVE_CORES_NUM_ATTR;
typedef uint8_t ATTR_ACTIVE_CORES_NUM_type;

// Type aliases and/or sizes for ATTR_BACKING_CACHES_NUM attribute
typedef uint8_t BACKING_CACHES_NUM_ATTR;
typedef uint8_t ATTR_BACKING_CACHES_NUM_type;

// Type aliases and/or sizes for ATTR_CORE_LPAR_MODE_POLICY attribute
typedef uint8_t CORE_LPAR_MODE_POLICY_ATTR;
typedef uint8_t ATTR_CORE_LPAR_MODE_POLICY_type;

// Type aliases and/or sizes for ATTR_CORE_LPAR_MODE attribute
typedef uint8_t CORE_LPAR_MODE_ATTR;
typedef uint8_t ATTR_CORE_LPAR_MODE_type;

// Type aliases and/or sizes for ATTR_ZERO_CORE_CHIP attribute
typedef uint8_t ZERO_CORE_CHIP_ATTR;
typedef uint8_t ATTR_ZERO_CORE_CHIP_type;

// Type aliases and/or sizes for ATTR_HB_FALLBACK_CORES attribute
typedef uint32_t HB_FALLBACK_CORES_ATTR;
typedef uint32_t ATTR_HB_FALLBACK_CORES_type;

// Type aliases and/or sizes for ATTR_PVR_82_MODE attribute
typedef uint8_t PVR_82_MODE_ATTR;
typedef uint8_t ATTR_PVR_82_MODE_type;

// Type aliases and/or sizes for ATTR_IS_IOSCM attribute
typedef uint8_t IS_IOSCM_ATTR;
typedef uint8_t ATTR_IS_IOSCM_type;

// Type aliases and/or sizes for ATTR_PG_MVPD attribute
typedef uint32_t PG_MVPD_ATTR;
typedef uint32_t ATTR_PG_MVPD_type;

// Type aliases and/or sizes for ATTR_ECO_MODE attribute
typedef uint8_t ECO_MODE_ATTR;
typedef uint8_t ATTR_ECO_MODE_type;

// Type aliases and/or sizes for ATTR_PROC_SBE_MASTER_CHIP attribute
typedef uint8_t PROC_SBE_MASTER_CHIP_ATTR;
typedef uint8_t ATTR_PROC_SBE_MASTER_CHIP_type;

// Type aliases and/or sizes for ATTR_SECTOR_BUFFER_STRENGTH attribute
typedef uint8_t SECTOR_BUFFER_STRENGTH_ATTR;
typedef uint8_t ATTR_SECTOR_BUFFER_STRENGTH_type;

// Type aliases and/or sizes for ATTR_NDL_MESHCTRL_SETUP attribute
typedef uint8_t NDL_MESHCTRL_SETUP_ATTR;
typedef uint8_t ATTR_NDL_MESHCTRL_SETUP_type;

// Type aliases and/or sizes for ATTR_MC_PLL_BUCKET attribute
typedef uint8_t MC_PLL_BUCKET_ATTR[4];
typedef uint8_t ATTR_MC_PLL_BUCKET_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_MC_PLL_BUCKET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_IOHS_PLL_BUCKET attribute
typedef uint8_t IOHS_PLL_BUCKET_ATTR[8];
typedef uint8_t ATTR_IOHS_PLL_BUCKET_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_IOHS_PLL_BUCKET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_FILTER_PLL_BUCKET attribute
typedef uint8_t FILTER_PLL_BUCKET_ATTR;
typedef uint8_t ATTR_FILTER_PLL_BUCKET_type;

// Type aliases and/or sizes for ATTR_PCI_PLL_BUCKET attribute
typedef uint8_t PCI_PLL_BUCKET_ATTR;
typedef uint8_t ATTR_PCI_PLL_BUCKET_type;

// Type aliases and/or sizes for ATTR_CP_PLLTODFLT_BYPASS attribute
typedef uint8_t CP_PLLTODFLT_BYPASS_ATTR;
typedef uint8_t ATTR_CP_PLLTODFLT_BYPASS_type;

// Type aliases and/or sizes for ATTR_CP_PLLNESTFLT_BYPASS attribute
typedef uint8_t CP_PLLNESTFLT_BYPASS_ATTR;
typedef uint8_t ATTR_CP_PLLNESTFLT_BYPASS_type;

// Type aliases and/or sizes for ATTR_CP_PLLIOFLT_BYPASS attribute
typedef uint8_t CP_PLLIOFLT_BYPASS_ATTR;
typedef uint8_t ATTR_CP_PLLIOFLT_BYPASS_type;

// Type aliases and/or sizes for ATTR_CP_PLLIOSSFLT_BYPASS attribute
typedef uint8_t CP_PLLIOSSFLT_BYPASS_ATTR;
typedef uint8_t ATTR_CP_PLLIOSSFLT_BYPASS_type;

// Type aliases and/or sizes for ATTR_PAU_DPLL_BYPASS attribute
typedef uint8_t PAU_DPLL_BYPASS_ATTR;
typedef uint8_t ATTR_PAU_DPLL_BYPASS_type;

// Type aliases and/or sizes for ATTR_NEST_DPLL_BYPASS attribute
typedef uint8_t NEST_DPLL_BYPASS_ATTR;
typedef uint8_t ATTR_NEST_DPLL_BYPASS_type;

// Type aliases and/or sizes for ATTR_IO_TANK_PLL_BYPASS attribute
typedef uint8_t IO_TANK_PLL_BYPASS_ATTR;
typedef uint8_t ATTR_IO_TANK_PLL_BYPASS_type;

// Type aliases and/or sizes for ATTR_SKEWADJ_BYPASS attribute
typedef uint8_t SKEWADJ_BYPASS_ATTR;
typedef uint8_t ATTR_SKEWADJ_BYPASS_type;

// Type aliases and/or sizes for ATTR_SKEWADJ_CORE_PDLY_OVERRIDE attribute
typedef uint16_t SKEWADJ_CORE_PDLY_OVERRIDE_ATTR;
typedef uint16_t ATTR_SKEWADJ_CORE_PDLY_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE attribute
typedef uint16_t SKEWADJ_CACHE_PDLY_OVERRIDE_ATTR;
typedef uint16_t ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_DCADJ_BYPASS attribute
typedef uint8_t DCADJ_BYPASS_ATTR;
typedef uint8_t ATTR_DCADJ_BYPASS_type;

// Type aliases and/or sizes for ATTR_DCADJ_DCC_OVERRIDE attribute
typedef uint16_t DCADJ_DCC_OVERRIDE_ATTR;
typedef uint16_t ATTR_DCADJ_DCC_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_DCADJ_TARGET_OVERRIDE attribute
typedef uint16_t DCADJ_TARGET_OVERRIDE_ATTR;
typedef uint16_t ATTR_DCADJ_TARGET_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_ECID attribute
typedef uint64_t ECID_ATTR[2];
typedef uint64_t ATTR_ECID_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 2> ATTR_ECID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_INTERPOSER_ECID attribute
typedef uint64_t INTERPOSER_ECID_ATTR;
typedef uint64_t ATTR_INTERPOSER_ECID_type;

// Type aliases and/or sizes for ATTR_LPC_CONSOLE_CNFG attribute
typedef uint8_t LPC_CONSOLE_CNFG_ATTR;
typedef uint8_t ATTR_LPC_CONSOLE_CNFG_type;

// Type aliases and/or sizes for ATTR_SBE_SYS_CONFIG attribute
typedef uint64_t SBE_SYS_CONFIG_ATTR;
typedef uint64_t ATTR_SBE_SYS_CONFIG_type;

// Type aliases and/or sizes for ATTR_EC_GARD attribute
typedef uint32_t EC_GARD_ATTR;
typedef uint32_t ATTR_EC_GARD_type;

// Type aliases and/or sizes for ATTR_CLOCKSTOP_ON_XSTOP attribute
typedef uint8_t CLOCKSTOP_ON_XSTOP_ATTR;
typedef uint8_t ATTR_CLOCKSTOP_ON_XSTOP_type;

// Type aliases and/or sizes for ATTR_XSTOP_ON_SPATTN attribute
typedef uint8_t XSTOP_ON_SPATTN_ATTR;
typedef uint8_t ATTR_XSTOP_ON_SPATTN_type;

// Type aliases and/or sizes for ATTR_BOOT_PAU_DPLL_BYPASS attribute
typedef uint8_t BOOT_PAU_DPLL_BYPASS_ATTR;
typedef uint8_t ATTR_BOOT_PAU_DPLL_BYPASS_type;

// Type aliases and/or sizes for ATTR_ORIG_FIR_SETTINGS_ACTION0 attribute
typedef uint64_t ORIG_FIR_SETTINGS_ACTION0_ATTR;
typedef uint64_t ATTR_ORIG_FIR_SETTINGS_ACTION0_type;

// Type aliases and/or sizes for ATTR_ORIG_FIR_SETTINGS_ACTION1 attribute
typedef uint64_t ORIG_FIR_SETTINGS_ACTION1_ATTR;
typedef uint64_t ATTR_ORIG_FIR_SETTINGS_ACTION1_type;

// Type aliases and/or sizes for ATTR_QME_HCODE_OFFSET attribute
typedef uint32_t QME_HCODE_OFFSET_ATTR;
typedef uint32_t ATTR_QME_HCODE_OFFSET_type;

// Type aliases and/or sizes for ATTR_QME_HCODE_BLOCK_COUNT attribute
typedef uint32_t QME_HCODE_BLOCK_COUNT_ATTR;
typedef uint32_t ATTR_QME_HCODE_BLOCK_COUNT_type;

// Type aliases and/or sizes for ATTR_FREQ_CP_REFCLOCK_KHZ attribute
typedef uint32_t FREQ_CP_REFCLOCK_KHZ_ATTR;
typedef uint32_t ATTR_FREQ_CP_REFCLOCK_KHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_DPLL_REFCLOCK_KHZ attribute
typedef uint32_t FREQ_DPLL_REFCLOCK_KHZ_ATTR;
typedef uint32_t ATTR_FREQ_DPLL_REFCLOCK_KHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_IO_REFCLOCK_KHZ attribute
typedef uint32_t FREQ_IO_REFCLOCK_KHZ_ATTR;
typedef uint32_t ATTR_FREQ_IO_REFCLOCK_KHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_CORE_FLOOR_MHZ attribute
typedef uint32_t FREQ_CORE_FLOOR_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_CORE_FLOOR_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ attribute
typedef uint32_t FREQ_SYSTEM_CORE_FLOOR_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_type;

// Type aliases and/or sizes for ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ attribute
typedef uint32_t MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ_ATTR;
typedef uint32_t ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ attribute
typedef uint32_t FREQ_SYSTEM_CORE_CEILING_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE attribute
typedef uint32_t FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE_ATTR;
typedef uint32_t ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE attribute
typedef uint32_t FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE_ATTR;
typedef uint32_t ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL attribute
typedef uint32_t FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL_ATTR;
typedef uint32_t ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL_type;

// Type aliases and/or sizes for ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL attribute
typedef uint32_t FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL_ATTR;
typedef uint32_t ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL_type;

// Type aliases and/or sizes for ATTR_FREQ_CORE_BOOT_MHZ attribute
typedef uint32_t FREQ_CORE_BOOT_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_CORE_BOOT_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_MC_MHZ attribute
typedef uint32_t FREQ_MC_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_MC_MHZ_type;

// Type aliases and/or sizes for ATTR_PLL_BUCKET_BUILD_INDEX attribute
typedef uint8_t PLL_BUCKET_BUILD_INDEX_ATTR;
typedef uint8_t ATTR_PLL_BUCKET_BUILD_INDEX_type;

// Type aliases and/or sizes for ATTR_FREQ_OMI_MHZ attribute
typedef uint32_t FREQ_OMI_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_OMI_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_IOHS_MHZ attribute
typedef uint32_t FREQ_IOHS_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_IOHS_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_IOHS_LINK_MHZ attribute
typedef uint32_t FREQ_IOHS_LINK_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_IOHS_LINK_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_PROC_IOHS_MHZ attribute
typedef uint32_t FREQ_PROC_IOHS_MHZ_ATTR[8];
typedef uint32_t ATTR_FREQ_PROC_IOHS_MHZ_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 8> ATTR_FREQ_PROC_IOHS_MHZ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_FREQ_PAU_MHZ attribute
typedef uint32_t FREQ_PAU_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_PAU_MHZ_type;

// Type aliases and/or sizes for ATTR_INCREASED_PAU_FREQ attribute
typedef uint8_t INCREASED_PAU_FREQ_ATTR;
typedef uint8_t ATTR_INCREASED_PAU_FREQ_type;

// Type aliases and/or sizes for ATTR_FREQ_PCIE_MHZ attribute
typedef uint32_t FREQ_PCIE_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_PCIE_MHZ_type;

// Type aliases and/or sizes for ATTR_SPI_BUS_DIV_REF attribute
typedef uint16_t SPI_BUS_DIV_REF_ATTR;
typedef uint16_t ATTR_SPI_BUS_DIV_REF_type;

// Type aliases and/or sizes for ATTR_TPM_SPI_BUS_DIV attribute
typedef uint16_t TPM_SPI_BUS_DIV_ATTR;
typedef uint16_t ATTR_TPM_SPI_BUS_DIV_type;

// Type aliases and/or sizes for ATTR_MAX_ALLOWED_DIMM_FREQ attribute
typedef uint32_t MAX_ALLOWED_DIMM_FREQ_ATTR[5];
typedef uint32_t ATTR_MAX_ALLOWED_DIMM_FREQ_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 5> ATTR_MAX_ALLOWED_DIMM_FREQ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_REQUIRED_SYNCH_MODE attribute
typedef uint8_t REQUIRED_SYNCH_MODE_ATTR;
typedef uint8_t ATTR_REQUIRED_SYNCH_MODE_type;

// Type aliases and/or sizes for ATTR_NOMINAL_FREQ_MHZ attribute
typedef uint32_t NOMINAL_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_NOMINAL_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_WOFBASE_FREQ_MHZ attribute
typedef uint32_t WOFBASE_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_WOFBASE_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_PAU_VPD_MHZ attribute
typedef uint32_t FREQ_PAU_VPD_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_PAU_VPD_MHZ_type;

// Type aliases and/or sizes for ATTR_SBE_BOOTLOADER_OFFSET attribute
typedef uint64_t SBE_BOOTLOADER_OFFSET_ATTR;
typedef uint64_t ATTR_SBE_BOOTLOADER_OFFSET_type;

// Type aliases and/or sizes for ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET attribute
typedef uint64_t SBE_LOAD_BOOTLOADER_CHUNK_OFFSET_ATTR;
typedef uint64_t ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET_type;

// Type aliases and/or sizes for ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE attribute
typedef uint64_t SBE_LOAD_BOOTLOADER_HBBL_SIZE_ATTR;
typedef uint64_t ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE_type;

// Type aliases and/or sizes for ATTR_SBE_MASTER_HRMOR_ADDRESS attribute
typedef uint64_t SBE_MASTER_HRMOR_ADDRESS_ATTR;
typedef uint64_t ATTR_SBE_MASTER_HRMOR_ADDRESS_type;

// Type aliases and/or sizes for ATTR_HOSTBOOT_HRMOR_OFFSET attribute
typedef uint64_t HOSTBOOT_HRMOR_OFFSET_ATTR;
typedef uint64_t ATTR_HOSTBOOT_HRMOR_OFFSET_type;

// Type aliases and/or sizes for ATTR_SBE_BOOT_SIDE attribute
typedef uint8_t SBE_BOOT_SIDE_ATTR;
typedef uint8_t ATTR_SBE_BOOT_SIDE_type;

// Type aliases and/or sizes for ATTR_LPC_CONSOLE_INITIALIZED attribute
typedef uint8_t LPC_CONSOLE_INITIALIZED_ATTR;
typedef uint8_t ATTR_LPC_CONSOLE_INITIALIZED_type;

// Type aliases and/or sizes for ATTR_SECURE_SETTINGS attribute
typedef uint8_t SECURE_SETTINGS_ATTR;
typedef uint8_t ATTR_SECURE_SETTINGS_type;

// Type aliases and/or sizes for ATTR_SBE_HBBL_EXCEPTION_INSTRUCT attribute
typedef uint32_t SBE_HBBL_EXCEPTION_INSTRUCT_ATTR;
typedef uint32_t ATTR_SBE_HBBL_EXCEPTION_INSTRUCT_type;

// Type aliases and/or sizes for ATTR_SBE_ADDR_KEY_STASH_ADDR attribute
typedef uint64_t SBE_ADDR_KEY_STASH_ADDR_ATTR;
typedef uint64_t ATTR_SBE_ADDR_KEY_STASH_ADDR_type;

// Type aliases and/or sizes for ATTR_NUM_KEY_ADDR_PAIR attribute
typedef uint8_t NUM_KEY_ADDR_PAIR_ATTR;
typedef uint8_t ATTR_NUM_KEY_ADDR_PAIR_type;

// Type aliases and/or sizes for ATTR_SBE_MEASUREMENT_SEEPROM_VERSION attribute
typedef uint32_t SBE_MEASUREMENT_SEEPROM_VERSION_ATTR;
typedef uint32_t ATTR_SBE_MEASUREMENT_SEEPROM_VERSION_type;

// Type aliases and/or sizes for ATTR_SBE_HW_KEY_HASH_ADDR attribute
typedef uint64_t SBE_HW_KEY_HASH_ADDR_ATTR;
typedef uint64_t ATTR_SBE_HW_KEY_HASH_ADDR_type;

// Type aliases and/or sizes for ATTR_SBE_MINIMUM_SECURE_VERSION attribute
typedef uint8_t SBE_MINIMUM_SECURE_VERSION_ATTR;
typedef uint8_t ATTR_SBE_MINIMUM_SECURE_VERSION_type;

// Type aliases and/or sizes for ATTR_SBE_SECURE_BOOT_MODE attribute
typedef uint8_t SBE_SECURE_BOOT_MODE_ATTR;
typedef uint8_t ATTR_SBE_SECURE_BOOT_MODE_type;

// Type aliases and/or sizes for ATTR_SBE_IMAGE_MINIMUM_VALID_ECS attribute
typedef uint8_t SBE_IMAGE_MINIMUM_VALID_ECS_ATTR;
typedef uint8_t ATTR_SBE_IMAGE_MINIMUM_VALID_ECS_type;

// Type aliases and/or sizes for ATTR_MAX_SBE_SEEPROM_SIZE attribute
typedef uint32_t MAX_SBE_SEEPROM_SIZE_ATTR;
typedef uint32_t ATTR_MAX_SBE_SEEPROM_SIZE_type;

// Type aliases and/or sizes for ATTR_SBE_CUST_FORCE_MVPD_ONLY attribute
typedef uint8_t SBE_CUST_FORCE_MVPD_ONLY_ATTR;
typedef uint8_t ATTR_SBE_CUST_FORCE_MVPD_ONLY_type;

// Type aliases and/or sizes for ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS attribute
typedef uint8_t PROC_DSTLCFG_MMIO_ADDRBIT_POS_ATTR;
typedef uint8_t ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS_type;

// Type aliases and/or sizes for ATTR_PROC_ENABLE_DL_TMPL_1 attribute
typedef uint8_t PROC_ENABLE_DL_TMPL_1_ATTR;
typedef uint8_t ATTR_PROC_ENABLE_DL_TMPL_1_type;

// Type aliases and/or sizes for ATTR_PROC_ENABLE_DL_TMPL_4 attribute
typedef uint8_t PROC_ENABLE_DL_TMPL_4_ATTR;
typedef uint8_t ATTR_PROC_ENABLE_DL_TMPL_4_type;

// Type aliases and/or sizes for ATTR_PROC_ENABLE_DL_TMPL_7 attribute
typedef uint8_t PROC_ENABLE_DL_TMPL_7_ATTR;
typedef uint8_t ATTR_PROC_ENABLE_DL_TMPL_7_type;

// Type aliases and/or sizes for ATTR_PROC_ENABLE_DL_TMPL_A attribute
typedef uint8_t PROC_ENABLE_DL_TMPL_A_ATTR;
typedef uint8_t ATTR_PROC_ENABLE_DL_TMPL_A_type;

// Type aliases and/or sizes for ATTR_PROC_TMPL_0_PACING attribute
typedef uint8_t PROC_TMPL_0_PACING_ATTR;
typedef uint8_t ATTR_PROC_TMPL_0_PACING_type;

// Type aliases and/or sizes for ATTR_PROC_TMPL_1_PACING attribute
typedef uint8_t PROC_TMPL_1_PACING_ATTR;
typedef uint8_t ATTR_PROC_TMPL_1_PACING_type;

// Type aliases and/or sizes for ATTR_PROC_TMPL_4_PACING attribute
typedef uint8_t PROC_TMPL_4_PACING_ATTR;
typedef uint8_t ATTR_PROC_TMPL_4_PACING_type;

// Type aliases and/or sizes for ATTR_PROC_TMPL_7_PACING attribute
typedef uint8_t PROC_TMPL_7_PACING_ATTR;
typedef uint8_t ATTR_PROC_TMPL_7_PACING_type;

// Type aliases and/or sizes for ATTR_PROC_TMPL_A_PACING attribute
typedef uint8_t PROC_TMPL_A_PACING_ATTR;
typedef uint8_t ATTR_PROC_TMPL_A_PACING_type;

// Type aliases and/or sizes for ATTR_SYS_DISABLE_MCU_TIMEOUTS attribute
typedef uint8_t SYS_DISABLE_MCU_TIMEOUTS_ATTR;
typedef uint8_t ATTR_SYS_DISABLE_MCU_TIMEOUTS_type;

// Type aliases and/or sizes for ATTR_SYS_DISABLE_HWFM attribute
typedef uint8_t SYS_DISABLE_HWFM_ATTR;
typedef uint8_t ATTR_SYS_DISABLE_HWFM_type;

// Type aliases and/or sizes for ATTR_SYS_ENABLE_MC_HW520600_X4CTR attribute
typedef uint8_t SYS_ENABLE_MC_HW520600_X4CTR_ATTR;
typedef uint8_t ATTR_SYS_ENABLE_MC_HW520600_X4CTR_type;

// Type aliases and/or sizes for ATTR_PROC_OMI_OC_MAJOR_VER attribute
typedef uint8_t PROC_OMI_OC_MAJOR_VER_ATTR;
typedef uint8_t ATTR_PROC_OMI_OC_MAJOR_VER_type;

// Type aliases and/or sizes for ATTR_PROC_OMI_OC_MINOR_VER attribute
typedef uint8_t PROC_OMI_OC_MINOR_VER_ATTR;
typedef uint8_t ATTR_PROC_OMI_OC_MINOR_VER_type;

// Type aliases and/or sizes for ATTR_OMI_CHANNEL_FAIL_ACTION attribute
typedef uint8_t OMI_CHANNEL_FAIL_ACTION_ATTR;
typedef uint8_t ATTR_OMI_CHANNEL_FAIL_ACTION_type;

// Type aliases and/or sizes for ATTR_MFG_SCREEN_OMI_CRC_ALLOWED attribute
typedef uint16_t MFG_SCREEN_OMI_CRC_ALLOWED_ATTR;
typedef uint16_t ATTR_MFG_SCREEN_OMI_CRC_ALLOWED_type;

// Type aliases and/or sizes for ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED attribute
typedef uint16_t MFG_SCREEN_OMI_EDPL_ALLOWED_ATTR;
typedef uint16_t ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED_type;

// Type aliases and/or sizes for ATTR_MSS_MNFG_EDPL_TIME attribute
typedef uint8_t MSS_MNFG_EDPL_TIME_ATTR;
typedef uint8_t ATTR_MSS_MNFG_EDPL_TIME_type;

// Type aliases and/or sizes for ATTR_MSS_MNFG_EDPL_THRESHOLD attribute
typedef uint8_t MSS_MNFG_EDPL_THRESHOLD_ATTR;
typedef uint8_t ATTR_MSS_MNFG_EDPL_THRESHOLD_type;

// Type aliases and/or sizes for ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_XSCOM_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_LPC_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_FSP_BAR_ENABLE attribute
typedef uint8_t PROC_FSP_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_FSP_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_FSP_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_FSP_BAR_SIZE attribute
typedef uint64_t PROC_FSP_BAR_SIZE_ATTR;
typedef uint64_t ATTR_PROC_FSP_BAR_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_FSP_MMIO_MASK_SIZE attribute
typedef uint8_t PROC_FSP_MMIO_MASK_SIZE_ATTR;
typedef uint8_t ATTR_PROC_FSP_MMIO_MASK_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_PAU_MMIO_BAR_ENABLE attribute
typedef uint8_t PROC_PAU_MMIO_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_PAU_MMIO_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET_ATTR[8];
typedef uint64_t ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 8> ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PSI_BRIDGE_BAR_ENABLE attribute
typedef uint8_t PROC_PSI_BRIDGE_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_PSI_BRIDGE_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_NX_RNG_BAR_ENABLE attribute
typedef uint8_t PROC_NX_RNG_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_NX_RNG_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_NX_RNG_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_NX_RNG_FAILED_INT_ENABLE attribute
typedef uint8_t PROC_NX_RNG_FAILED_INT_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_NX_RNG_FAILED_INT_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_NX_RNG_FAILED_INT_ADDR attribute
typedef uint64_t PROC_NX_RNG_FAILED_INT_ADDR_ATTR;
typedef uint64_t ATTR_PROC_NX_RNG_FAILED_INT_ADDR_type;

// Type aliases and/or sizes for ATTR_PROC_NHTM_BAR_BASE_ADDR attribute
typedef uint64_t PROC_NHTM_BAR_BASE_ADDR_ATTR;
typedef uint64_t ATTR_PROC_NHTM_BAR_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_PROC_NHTM_BAR_SIZE attribute
typedef uint64_t PROC_NHTM_BAR_SIZE_ATTR;
typedef uint64_t ATTR_PROC_NHTM_BAR_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_CHTM_BAR_BASE_ADDR attribute
typedef uint64_t PROC_CHTM_BAR_BASE_ADDR_ATTR[32];
typedef uint64_t ATTR_PROC_CHTM_BAR_BASE_ADDR_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 32> ATTR_PROC_CHTM_BAR_BASE_ADDR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_CHTM_BAR_SIZES attribute
typedef uint64_t PROC_CHTM_BAR_SIZES_ATTR[32];
typedef uint64_t ATTR_PROC_CHTM_BAR_SIZES_type[32];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 32> ATTR_PROC_CHTM_BAR_SIZES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_SMF_BAR_BASE_ADDR attribute
typedef uint64_t PROC_SMF_BAR_BASE_ADDR_ATTR;
typedef uint64_t ATTR_PROC_SMF_BAR_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_PROC_SMF_BAR_SIZE attribute
typedef uint64_t PROC_SMF_BAR_SIZE_ATTR;
typedef uint64_t ATTR_PROC_SMF_BAR_SIZE_type;

// Type aliases and/or sizes for ATTR_SMF_CONFIG attribute
typedef uint8_t SMF_CONFIG_ATTR;
typedef uint8_t ATTR_SMF_CONFIG_type;

// Type aliases and/or sizes for ATTR_PROC_OCC_SANDBOX_BASE_ADDR attribute
typedef uint64_t PROC_OCC_SANDBOX_BASE_ADDR_ATTR;
typedef uint64_t ATTR_PROC_OCC_SANDBOX_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_PROC_OCC_SANDBOX_SIZE attribute
typedef uint64_t PROC_OCC_SANDBOX_SIZE_ATTR;
typedef uint64_t ATTR_PROC_OCC_SANDBOX_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_IC_BAR_ENABLE attribute
typedef uint8_t PROC_INT_IC_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_INT_IC_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_INT_IC_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_INT_IC_BAR_PAGE_SIZE attribute
typedef uint8_t PROC_INT_IC_BAR_PAGE_SIZE_ATTR;
typedef uint8_t ATTR_PROC_INT_IC_BAR_PAGE_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_TM_BAR_ENABLE attribute
typedef uint8_t PROC_INT_TM_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_INT_TM_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_INT_TM_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_INT_TM_BAR_PAGE_SIZE attribute
typedef uint8_t PROC_INT_TM_BAR_PAGE_SIZE_ATTR;
typedef uint8_t ATTR_PROC_INT_TM_BAR_PAGE_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVPG_BAR_ENABLE attribute
typedef uint8_t PROC_INT_NVPG_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_INT_NVPG_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE attribute
typedef uint8_t PROC_INT_NVPG_BAR_PAGE_SIZE_ATTR;
typedef uint8_t ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR attribute
typedef uint8_t PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_ATTR;
typedef uint8_t ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVPG_BAR_RANGE attribute
typedef uint8_t PROC_INT_NVPG_BAR_RANGE_ATTR;
typedef uint8_t ATTR_PROC_INT_NVPG_BAR_RANGE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVC_BAR_ENABLE attribute
typedef uint8_t PROC_INT_NVC_BAR_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_INT_NVC_BAR_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVC_BAR_PAGE_SIZE attribute
typedef uint8_t PROC_INT_NVC_BAR_PAGE_SIZE_ATTR;
typedef uint8_t ATTR_PROC_INT_NVC_BAR_PAGE_SIZE_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET attribute
typedef uint64_t PROC_INT_NVC_BAR_BASE_ADDR_OFFSET_ATTR;
typedef uint64_t ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR attribute
typedef uint8_t PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_ATTR;
typedef uint8_t ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_type;

// Type aliases and/or sizes for ATTR_PROC_INT_NVC_BAR_RANGE attribute
typedef uint8_t PROC_INT_NVC_BAR_RANGE_ATTR;
typedef uint8_t ATTR_PROC_INT_NVC_BAR_RANGE_type;

// Type aliases and/or sizes for ATTR_I2C_DEV_TYPE attribute
typedef uint8_t I2C_DEV_TYPE_ATTR;
typedef uint8_t ATTR_I2C_DEV_TYPE_type;

// Type aliases and/or sizes for ATTR_I2C_SUB_POS attribute
typedef uint8_t I2C_SUB_POS_ATTR;
typedef uint8_t ATTR_I2C_SUB_POS_type;

// Type aliases and/or sizes for ATTR_FAPI_POS attribute
typedef uint32_t FAPI_POS_ATTR;
typedef uint32_t ATTR_FAPI_POS_type;

// Type aliases and/or sizes for ATTR_BUS_POS attribute
typedef uint8_t BUS_POS_ATTR;
typedef uint8_t ATTR_BUS_POS_type;

// Type aliases and/or sizes for ATTR_IS_SIMULATION attribute
typedef uint8_t IS_SIMULATION_ATTR;
typedef uint8_t ATTR_IS_SIMULATION_type;

// Type aliases and/or sizes for ATTR_EXECUTION_PLATFORM attribute
typedef uint8_t EXECUTION_PLATFORM_ATTR;
typedef uint8_t ATTR_EXECUTION_PLATFORM_type;

// Type aliases and/or sizes for ATTR_MFG_FLAGS attribute
typedef uint32_t MFG_FLAGS_ATTR[4];
typedef uint32_t ATTR_MFG_FLAGS_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_MFG_FLAGS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_RECONFIGURE_LOOP attribute
typedef uint8_t RECONFIGURE_LOOP_ATTR;
typedef uint8_t ATTR_RECONFIGURE_LOOP_type;

// Type aliases and/or sizes for ATTR_MINI_EC attribute
typedef uint8_t MINI_EC_ATTR;
typedef uint8_t ATTR_MINI_EC_type;

// Type aliases and/or sizes for ATTR_SCAN_CHIPLET_OVERRIDE attribute
typedef uint8_t SCAN_CHIPLET_OVERRIDE_ATTR;
typedef uint8_t ATTR_SCAN_CHIPLET_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_SLOW_MEM_POOL_TEST attribute
typedef uint8_t SLOW_MEM_POOL_TEST_ATTR;
typedef uint8_t ATTR_SLOW_MEM_POOL_TEST_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL attribute
typedef uint8_t MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_HALF_DIMM_MODE attribute
typedef uint8_t MSS_OCMB_HALF_DIMM_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_HALF_DIMM_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE attribute
typedef uint8_t MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_MEM_DRAM_CWL attribute
typedef uint8_t MEM_DRAM_CWL_ATTR;
typedef uint8_t ATTR_MEM_DRAM_CWL_type;

// Type aliases and/or sizes for ATTR_MEM_RDIMM_BUFFER_DELAY attribute
typedef uint8_t MEM_RDIMM_BUFFER_DELAY_ATTR;
typedef uint8_t ATTR_MEM_RDIMM_BUFFER_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_REORDER_QUEUE_SETTING attribute
typedef uint8_t MEM_REORDER_QUEUE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_REORDER_QUEUE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_THERMAL_INIT_COMPLETE attribute
typedef uint8_t MEM_THERMAL_INIT_COMPLETE_ATTR;
typedef uint8_t ATTR_MEM_THERMAL_INIT_COMPLETE_type;

// Type aliases and/or sizes for ATTR_MEM_2N_MODE attribute
typedef uint8_t MEM_2N_MODE_ATTR;
typedef uint8_t ATTR_MEM_2N_MODE_type;

// Type aliases and/or sizes for ATTR_MEM_VPD_DQ_MAP attribute
typedef uint8_t MEM_VPD_DQ_MAP_ATTR[80];
typedef uint8_t ATTR_MEM_VPD_DQ_MAP_type[80];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 80> ATTR_MEM_VPD_DQ_MAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC0F attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC0F_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC0F_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC0F_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_CS_CMD_LATENCY attribute
typedef uint8_t MEM_CS_CMD_LATENCY_ATTR[2];
typedef uint8_t ATTR_MEM_CS_CMD_LATENCY_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_CS_CMD_LATENCY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_CA_PARITY_LATENCY attribute
typedef uint8_t MEM_CA_PARITY_LATENCY_ATTR[2];
typedef uint8_t ATTR_MEM_CA_PARITY_LATENCY_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_CA_PARITY_LATENCY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC02 attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC02_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC02_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC02_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC03 attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC03_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC03_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC03_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC04 attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC04_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC04_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC04_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC05 attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC05_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC05_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC05_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC0B attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC0B_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC0B_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC0B_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC1X attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC1X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC1X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC1X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F0RC7X attribute
typedef uint8_t MEM_DIMM_DDR4_F0RC7X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F0RC7X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F0RC7X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC00 attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC00_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC00_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC00_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC02 attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC02_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC02_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC02_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC03 attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC03_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC03_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC03_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC04 attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC04_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC04_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC04_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC05 attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC05_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC05_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC05_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_POS_METADATA attribute
typedef uint32_t MEM_DIMM_POS_METADATA_ATTR;
typedef uint32_t ATTR_MEM_DIMM_POS_METADATA_type;

// Type aliases and/or sizes for ATTR_MEM_DRAM_GEN_METADATA attribute
typedef uint8_t MEM_DRAM_GEN_METADATA_ATTR;
typedef uint8_t ATTR_MEM_DRAM_GEN_METADATA_type;

// Type aliases and/or sizes for ATTR_MEM_DIMM_TYPE_METADATA attribute
typedef uint8_t MEM_DIMM_TYPE_METADATA_ATTR;
typedef uint8_t ATTR_MEM_DIMM_TYPE_METADATA_type;

// Type aliases and/or sizes for ATTR_MSS_OMI_EDPL_DISABLE attribute
typedef uint8_t MSS_OMI_EDPL_DISABLE_ATTR;
typedef uint8_t ATTR_MSS_OMI_EDPL_DISABLE_type;

// Type aliases and/or sizes for ATTR_MEM_OVERRIDE_FREQ_LIMITATION attribute
typedef uint8_t MEM_OVERRIDE_FREQ_LIMITATION_ATTR;
typedef uint8_t ATTR_MEM_OVERRIDE_FREQ_LIMITATION_type;

// Type aliases and/or sizes for ATTR_MEM_IGNORE_PLUG_RULES attribute
typedef uint8_t MEM_IGNORE_PLUG_RULES_ATTR;
typedef uint8_t ATTR_MEM_IGNORE_PLUG_RULES_type;

// Type aliases and/or sizes for ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX attribute
typedef uint8_t MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_ATTR;
typedef uint8_t ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_type;

// Type aliases and/or sizes for ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX attribute
typedef uint8_t MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_ATTR;
typedef uint8_t ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_type;

// Type aliases and/or sizes for ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK attribute
typedef uint8_t MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_ATTR;
typedef uint8_t ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION attribute
typedef uint8_t MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED attribute
typedef uint8_t MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_ATTR;
typedef uint8_t ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_type;

// Type aliases and/or sizes for ATTR_OMI_X4_DEGRADE_ACTION attribute
typedef uint8_t OMI_X4_DEGRADE_ACTION_ATTR;
typedef uint8_t ATTR_OMI_X4_DEGRADE_ACTION_type;

// Type aliases and/or sizes for ATTR_OMI_CRC_DEBUG attribute
typedef uint8_t OMI_CRC_DEBUG_ATTR;
typedef uint8_t ATTR_OMI_CRC_DEBUG_type;

// Type aliases and/or sizes for ATTR_ENABLE_FIR_UNMASKING attribute
typedef uint8_t ENABLE_FIR_UNMASKING_ATTR;
typedef uint8_t ATTR_ENABLE_FIR_UNMASKING_type;

// Type aliases and/or sizes for ATTR_MSS_IS_APOLLO attribute
typedef uint8_t MSS_IS_APOLLO_ATTR;
typedef uint8_t ATTR_MSS_IS_APOLLO_type;

// Type aliases and/or sizes for ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST attribute
typedef uint8_t MSS_POST_MEMDIAGS_READ_SUBTEST_ATTR;
typedef uint8_t ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_type;

// Type aliases and/or sizes for ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR attribute
typedef uint8_t MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_ATTR;
typedef uint8_t ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_type;

// Type aliases and/or sizes for ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL attribute
typedef uint32_t MSS_SAFEMODE_DRAM_DATABUS_UTIL_ATTR;
typedef uint32_t ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE attribute
typedef uint64_t MSS_OCMB_CHECKSTOP_OBJ_HANDLE_ATTR;
typedef uint64_t ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_RECOV_OBJ_HANDLE attribute
typedef uint64_t MSS_OCMB_RECOV_OBJ_HANDLE_ATTR;
typedef uint64_t ATTR_MSS_OCMB_RECOV_OBJ_HANDLE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE attribute
typedef uint64_t MSS_OCMB_SPECATTN_OBJ_HANDLE_ATTR;
typedef uint64_t ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE attribute
typedef uint64_t MSS_OCMB_APPINTR_OBJ_HANDLE_ATTR;
typedef uint64_t ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE_type;

// Type aliases and/or sizes for ATTR_MEM_DRAM_ADDRESS_MIRRORING attribute
typedef uint8_t MEM_DRAM_ADDRESS_MIRRORING_ATTR[2];
typedef uint8_t ATTR_MEM_DRAM_ADDRESS_MIRRORING_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DRAM_ADDRESS_MIRRORING_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ECS_ERROR_COUNT_THRESHOLD attribute
typedef uint8_t ECS_ERROR_COUNT_THRESHOLD_ATTR;
typedef uint8_t ATTR_ECS_ERROR_COUNT_THRESHOLD_type;

// Type aliases and/or sizes for ATTR_MSS_CONFIG_FREQ_LIMIT attribute
typedef uint32_t MSS_CONFIG_FREQ_LIMIT_ATTR;
typedef uint32_t ATTR_MSS_CONFIG_FREQ_LIMIT_type;

// Type aliases and/or sizes for ATTR_MSS_OMI_VDD_UPLIFT_APPLIED attribute
typedef uint8_t MSS_OMI_VDD_UPLIFT_APPLIED_ATTR;
typedef uint8_t ATTR_MSS_OMI_VDD_UPLIFT_APPLIED_type;

// Type aliases and/or sizes for ATTR_MEM_SI_SIGNATURE_HASH attribute
typedef uint32_t MEM_SI_SIGNATURE_HASH_ATTR;
typedef uint32_t ATTR_MEM_SI_SIGNATURE_HASH_type;

// Type aliases and/or sizes for ATTR_MEM_SI_DIMM_RCD_IBT_CA attribute
typedef uint8_t MEM_SI_DIMM_RCD_IBT_CA_ATTR[2];
typedef uint8_t ATTR_MEM_SI_DIMM_RCD_IBT_CA_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_SI_DIMM_RCD_IBT_CA_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DIMM_RCD_IBT_CKE attribute
typedef uint8_t MEM_SI_DIMM_RCD_IBT_CKE_ATTR[2];
typedef uint8_t ATTR_MEM_SI_DIMM_RCD_IBT_CKE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_SI_DIMM_RCD_IBT_CKE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DIMM_RCD_IBT_CS attribute
typedef uint8_t MEM_SI_DIMM_RCD_IBT_CS_ATTR[2];
typedef uint8_t ATTR_MEM_SI_DIMM_RCD_IBT_CS_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_SI_DIMM_RCD_IBT_CS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DIMM_RCD_IBT_ODT attribute
typedef uint8_t MEM_SI_DIMM_RCD_IBT_ODT_ATTR[2];
typedef uint8_t ATTR_MEM_SI_DIMM_RCD_IBT_ODT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_SI_DIMM_RCD_IBT_ODT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS attribute
typedef uint8_t MEM_SI_DRAM_DRV_IMP_DQ_DQS_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DRAM_PREAMBLE attribute
typedef uint8_t MEM_SI_DRAM_PREAMBLE_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_DRAM_PREAMBLE_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_DRAM_PREAMBLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DRAM_RTT_NOM attribute
typedef uint8_t MEM_SI_DRAM_RTT_NOM_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_DRAM_RTT_NOM_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_DRAM_RTT_NOM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DRAM_RTT_PARK attribute
typedef uint8_t MEM_SI_DRAM_RTT_PARK_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_DRAM_RTT_PARK_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_DRAM_RTT_PARK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_DRAM_RTT_WR attribute
typedef uint8_t MEM_SI_DRAM_RTT_WR_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_DRAM_RTT_WR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_DRAM_RTT_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_GEARDOWN_MODE attribute
typedef uint8_t MEM_SI_GEARDOWN_MODE_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_GEARDOWN_MODE_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_GEARDOWN_MODE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_DQ_DQS attribute
typedef uint8_t MEM_SI_MC_DRV_DQ_DQS_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_DQ_DQS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_DQ_DQS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS attribute
typedef uint8_t MEM_SI_MC_RCV_EQ_DQ_DQS_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS attribute
typedef uint8_t MEM_SI_MC_DRV_EQ_DQ_DQS_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_PHY_EQUALIZATION attribute
typedef uint8_t MEM_SI_PHY_EQUALIZATION_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_PHY_EQUALIZATION_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_PHY_EQUALIZATION_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_IMP_CLK attribute
typedef uint8_t MEM_SI_MC_DRV_IMP_CLK_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_IMP_CLK_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_IMP_CLK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR attribute
typedef uint8_t MEM_SI_MC_DRV_IMP_CMD_ADDR_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_IMP_CNTL attribute
typedef uint8_t MEM_SI_MC_DRV_IMP_CNTL_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_IMP_CNTL_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_IMP_CNTL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_IMP_CSCID attribute
typedef uint8_t MEM_SI_MC_DRV_IMP_CSCID_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_IMP_CSCID_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_IMP_CSCID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN attribute
typedef uint16_t MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_ATTR[2][4];
typedef uint16_t ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 4>, 2> ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP attribute
typedef uint16_t MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_ATTR[2][4];
typedef uint16_t ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 4>, 2> ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK attribute
typedef uint8_t MEM_SI_MC_DRV_SLEW_RATE_CLK_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR attribute
typedef uint8_t MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL attribute
typedef uint8_t MEM_SI_MC_DRV_SLEW_RATE_CNTL_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID attribute
typedef uint8_t MEM_SI_MC_DRV_SLEW_RATE_CSCID_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS attribute
typedef uint8_t MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_RCV_IMP_ALERT_N attribute
typedef uint8_t MEM_SI_MC_RCV_IMP_ALERT_N_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_MC_RCV_IMP_ALERT_N_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_MC_RCV_IMP_ALERT_N_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS attribute
typedef uint16_t MEM_SI_MC_RCV_IMP_DQ_DQS_ATTR[2][4];
typedef uint16_t ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 4>, 2> ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_ODT_RD attribute
typedef uint8_t MEM_SI_ODT_RD_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_ODT_RD_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_ODT_RD_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_ODT_WR attribute
typedef uint8_t MEM_SI_ODT_WR_ATTR[2][4];
typedef uint8_t ATTR_MEM_SI_ODT_WR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_SI_ODT_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_VREF_DRAM_WR attribute
typedef uint8_t MEM_SI_VREF_DRAM_WR_ATTR;
typedef uint8_t ATTR_MEM_SI_VREF_DRAM_WR_type;

// Type aliases and/or sizes for ATTR_MEM_SI_VREF_MC_RD attribute
typedef uint32_t MEM_SI_VREF_MC_RD_ATTR;
typedef uint32_t ATTR_MEM_SI_VREF_MC_RD_type;

// Type aliases and/or sizes for ATTR_MEM_SI_WINDAGE_RD_CTR attribute
typedef int16_t MEM_SI_WINDAGE_RD_CTR_ATTR;
typedef int16_t ATTR_MEM_SI_WINDAGE_RD_CTR_type;

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC1X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC1X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC1X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC1X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC2X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC2X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC2X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC2X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC3X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC3X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC3X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC3X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC4X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC4X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC4X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC4X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC5X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC5X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC5X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC5X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC6X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC6X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC6X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC6X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DIMM_DDR4_F1RC7X attribute
typedef uint8_t MEM_DIMM_DDR4_F1RC7X_ATTR[2];
typedef uint8_t ATTR_MEM_DIMM_DDR4_F1RC7X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_DIMM_DDR4_F1RC7X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP attribute
typedef uint16_t MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_ATTR;
typedef uint16_t ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_type;

// Type aliases and/or sizes for ATTR_MEM_BURST_LENGTH attribute
typedef uint8_t MEM_BURST_LENGTH_ATTR;
typedef uint8_t ATTR_MEM_BURST_LENGTH_type;

// Type aliases and/or sizes for ATTR_MEM_MPSM attribute
typedef uint8_t MEM_MPSM_ATTR;
typedef uint8_t ATTR_MEM_MPSM_type;

// Type aliases and/or sizes for ATTR_MEM_CS_ASSERT_IN_MPC attribute
typedef uint8_t MEM_CS_ASSERT_IN_MPC_ATTR;
typedef uint8_t ATTR_MEM_CS_ASSERT_IN_MPC_type;

// Type aliases and/or sizes for ATTR_MEM_DEVICE15_MPSM attribute
typedef uint8_t MEM_DEVICE15_MPSM_ATTR;
typedef uint8_t ATTR_MEM_DEVICE15_MPSM_type;

// Type aliases and/or sizes for ATTR_MEM_INTERNAL_WR_TIMING_MODE attribute
typedef uint8_t MEM_INTERNAL_WR_TIMING_MODE_ATTR;
typedef uint8_t ATTR_MEM_INTERNAL_WR_TIMING_MODE_type;

// Type aliases and/or sizes for ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT attribute
typedef uint8_t MEM_WL_INTERNAL_CYCLE_ALIGNMENT_ATTR[2][4][20];
typedef uint8_t ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_REF_INTERVAL_RATE_INDIC attribute
typedef uint8_t MEM_REF_INTERVAL_RATE_INDIC_ATTR;
typedef uint8_t ATTR_MEM_REF_INTERVAL_RATE_INDIC_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_MIN_REF_RATE attribute
typedef uint8_t MEM_DDR5_MIN_REF_RATE_ATTR;
typedef uint8_t ATTR_MEM_DDR5_MIN_REF_RATE_type;

// Type aliases and/or sizes for ATTR_MEM_REF_WIDE_RANGE attribute
typedef uint8_t MEM_REF_WIDE_RANGE_ATTR;
typedef uint8_t ATTR_MEM_REF_WIDE_RANGE_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_REF_TUF attribute
typedef uint8_t MEM_DDR5_REF_TUF_ATTR;
typedef uint8_t ATTR_MEM_DDR5_REF_TUF_type;

// Type aliases and/or sizes for ATTR_DRAM_PU_DRV_IMP attribute
typedef uint8_t DRAM_PU_DRV_IMP_ATTR[2][4];
typedef uint8_t ATTR_DRAM_PU_DRV_IMP_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_DRAM_PU_DRV_IMP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_TEST_MODE attribute
typedef uint8_t DDR5_DRAM_TEST_MODE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_TEST_MODE_type;

// Type aliases and/or sizes for ATTR_DRAM_PD_DRV_IMP attribute
typedef uint8_t DRAM_PD_DRV_IMP_ATTR[2][4];
typedef uint8_t ATTR_DRAM_PD_DRV_IMP_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_DRAM_PD_DRV_IMP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_RD_PREAMBLE attribute
typedef uint8_t DDR5_DRAM_RD_PREAMBLE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_RD_PREAMBLE_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_WR_PREAMBLE attribute
typedef uint8_t DDR5_DRAM_WR_PREAMBLE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_WR_PREAMBLE_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_RD_POSTAMBLE attribute
typedef uint8_t DDR5_DRAM_RD_POSTAMBLE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_RD_POSTAMBLE_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_WR_POSTAMBLE attribute
typedef uint8_t DDR5_DRAM_WR_POSTAMBLE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_WR_POSTAMBLE_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_WR_VREFDQ attribute
typedef uint8_t DDR5_DRAM_WR_VREFDQ_ATTR[2][4][20];
typedef uint8_t ATTR_DDR5_DRAM_WR_VREFDQ_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_DDR5_DRAM_WR_VREFDQ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_VREFCA attribute
typedef uint8_t DDR5_DRAM_VREFCA_ATTR[2][4][20];
typedef uint8_t ATTR_DDR5_DRAM_VREFCA_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_DDR5_DRAM_VREFCA_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_VREFCS attribute
typedef uint8_t DDR5_DRAM_VREFCS_ATTR[2][4][20];
typedef uint8_t ATTR_DDR5_DRAM_VREFCS_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_DDR5_DRAM_VREFCS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_MODE attribute
typedef uint8_t DDR5_DRAM_ECS_MODE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_MODE_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_RESET_COUNTER attribute
typedef uint8_t DDR5_DRAM_ECS_RESET_COUNTER_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_RESET_COUNTER_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_COUNT_MODE attribute
typedef uint8_t DDR5_DRAM_ECS_COUNT_MODE_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_COUNT_MODE_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_SRANK_SELECT attribute
typedef uint8_t DDR5_DRAM_ECS_SRANK_SELECT_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_SRANK_SELECT_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT attribute
typedef uint8_t DDR5_DRAM_ECS_THRESHOLD_COUNT_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH attribute
typedef uint8_t DDR5_DRAM_ECS_IN_SELF_REFRESH_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_WRITEBACK attribute
typedef uint8_t DDR5_DRAM_ECS_WRITEBACK_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_WRITEBACK_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ECS_X4_WRITES attribute
typedef uint8_t DDR5_DRAM_ECS_X4_WRITES_ATTR;
typedef uint8_t ATTR_DDR5_DRAM_ECS_X4_WRITES_type;

// Type aliases and/or sizes for ATTR_DDR5_DRAM_CK_ODT attribute
typedef uint16_t DDR5_DRAM_CK_ODT_ATTR[2][4][2];
typedef uint16_t ATTR_DDR5_DRAM_CK_ODT_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint16_t, 2>, 4>, 2> ATTR_DDR5_DRAM_CK_ODT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_CS_ODT attribute
typedef uint16_t DDR5_DRAM_CS_ODT_ATTR[2][4][2];
typedef uint16_t ATTR_DDR5_DRAM_CS_ODT_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint16_t, 2>, 4>, 2> ATTR_DDR5_DRAM_CS_ODT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_CK_ODT_PER_DRAM attribute
typedef uint16_t DDR5_DRAM_CK_ODT_PER_DRAM_ATTR[2][4][20];
typedef uint16_t ATTR_DDR5_DRAM_CK_ODT_PER_DRAM_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint16_t, 20>, 4>, 2> ATTR_DDR5_DRAM_CK_ODT_PER_DRAM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_CS_ODT_PER_DRAM attribute
typedef uint16_t DDR5_DRAM_CS_ODT_PER_DRAM_ATTR[2][4][20];
typedef uint16_t ATTR_DDR5_DRAM_CS_ODT_PER_DRAM_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint16_t, 20>, 4>, 2> ATTR_DDR5_DRAM_CS_ODT_PER_DRAM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_CA_ODT attribute
typedef uint16_t DDR5_DRAM_CA_ODT_ATTR[2][4][2];
typedef uint16_t ATTR_DDR5_DRAM_CA_ODT_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint16_t, 2>, 4>, 2> ATTR_DDR5_DRAM_CA_ODT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_DQS_RTT_PARK attribute
typedef uint8_t DDR5_DRAM_DQS_RTT_PARK_ATTR[2][4][2];
typedef uint8_t ATTR_DDR5_DRAM_DQS_RTT_PARK_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> ATTR_DDR5_DRAM_DQS_RTT_PARK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_CA_ODT_PER_DRAM attribute
typedef uint16_t DDR5_DRAM_CA_ODT_PER_DRAM_ATTR[2][4][20];
typedef uint16_t ATTR_DDR5_DRAM_CA_ODT_PER_DRAM_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint16_t, 20>, 4>, 2> ATTR_DDR5_DRAM_CA_ODT_PER_DRAM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM attribute
typedef uint8_t DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_ATTR[2][4][20];
typedef uint8_t ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_RTT_WR attribute
typedef uint8_t DDR5_DRAM_RTT_WR_ATTR[2][4][2];
typedef uint8_t ATTR_DDR5_DRAM_RTT_WR_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> ATTR_DDR5_DRAM_RTT_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_RTT_PARK attribute
typedef uint8_t DDR5_DRAM_RTT_PARK_ATTR[2][4][2];
typedef uint8_t ATTR_DDR5_DRAM_RTT_PARK_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> ATTR_DDR5_DRAM_RTT_PARK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_RTT_NOM_WR attribute
typedef uint8_t DDR5_DRAM_RTT_NOM_WR_ATTR[2][4][2];
typedef uint8_t ATTR_DDR5_DRAM_RTT_NOM_WR_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> ATTR_DDR5_DRAM_RTT_NOM_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_RTT_NOM_RD attribute
typedef uint8_t DDR5_DRAM_RTT_NOM_RD_ATTR[2][4][2];
typedef uint8_t ATTR_DDR5_DRAM_RTT_NOM_RD_type[2][4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 2>, 4>, 2> ATTR_DDR5_DRAM_RTT_NOM_RD_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ODTLON_WR attribute
typedef int8_t DDR5_DRAM_ODTLON_WR_ATTR[2][4];
typedef int8_t ATTR_DDR5_DRAM_ODTLON_WR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 4>, 2> ATTR_DDR5_DRAM_ODTLON_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ODTLOFF_WR attribute
typedef int8_t DDR5_DRAM_ODTLOFF_WR_ATTR[2][4];
typedef int8_t ATTR_DDR5_DRAM_ODTLOFF_WR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 4>, 2> ATTR_DDR5_DRAM_ODTLOFF_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ODTLON_WR_NT attribute
typedef int8_t DDR5_DRAM_ODTLON_WR_NT_ATTR[2][4];
typedef int8_t ATTR_DDR5_DRAM_ODTLON_WR_NT_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 4>, 2> ATTR_DDR5_DRAM_ODTLON_WR_NT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ODTLOFF_WR_NT attribute
typedef int8_t DDR5_DRAM_ODTLOFF_WR_NT_ATTR[2][4];
typedef int8_t ATTR_DDR5_DRAM_ODTLOFF_WR_NT_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 4>, 2> ATTR_DDR5_DRAM_ODTLOFF_WR_NT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ODTLON_RD_NT attribute
typedef int8_t DDR5_DRAM_ODTLON_RD_NT_ATTR[2][4];
typedef int8_t ATTR_DDR5_DRAM_ODTLON_RD_NT_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 4>, 2> ATTR_DDR5_DRAM_ODTLON_RD_NT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DDR5_DRAM_ODTLOFF_RD_NT attribute
typedef int8_t DDR5_DRAM_ODTLOFF_RD_NT_ATTR[2][4];
typedef int8_t ATTR_DDR5_DRAM_ODTLOFF_RD_NT_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<int8_t, 4>, 2> ATTR_DDR5_DRAM_ODTLOFF_RD_NT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DDR5_WR_CRC_ERR_STATUS attribute
typedef uint8_t MEM_DDR5_WR_CRC_ERR_STATUS_ATTR;
typedef uint8_t ATTR_MEM_DDR5_WR_CRC_ERR_STATUS_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE attribute
typedef uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_ATTR;
typedef uint8_t ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS attribute
typedef uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_ATTR;
typedef uint8_t ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD attribute
typedef uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD_ATTR;
typedef uint8_t ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW attribute
typedef uint8_t MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW_ATTR;
typedef uint8_t ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_GLOBAL_DFE_GAIN attribute
typedef uint8_t MEM_DDR5_GLOBAL_DFE_GAIN_ATTR;
typedef uint8_t ATTR_MEM_DDR5_GLOBAL_DFE_GAIN_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_GLOBAL_DFE_TAP1 attribute
typedef uint8_t MEM_DDR5_GLOBAL_DFE_TAP1_ATTR;
typedef uint8_t ATTR_MEM_DDR5_GLOBAL_DFE_TAP1_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_GLOBAL_DFE_TAP2 attribute
typedef uint8_t MEM_DDR5_GLOBAL_DFE_TAP2_ATTR;
typedef uint8_t ATTR_MEM_DDR5_GLOBAL_DFE_TAP2_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_GLOBAL_DFE_TAP3 attribute
typedef uint8_t MEM_DDR5_GLOBAL_DFE_TAP3_ATTR;
typedef uint8_t ATTR_MEM_DDR5_GLOBAL_DFE_TAP3_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_GLOBAL_DFE_TAP4 attribute
typedef uint8_t MEM_DDR5_GLOBAL_DFE_TAP4_ATTR;
typedef uint8_t ATTR_MEM_DDR5_GLOBAL_DFE_TAP4_type;

// Type aliases and/or sizes for ATTR_MEM_DDR5_DFE_GAIN_BIAS attribute
typedef uint8_t MEM_DDR5_DFE_GAIN_BIAS_ATTR[2][4];
typedef uint8_t ATTR_MEM_DDR5_DFE_GAIN_BIAS_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_DDR5_DFE_GAIN_BIAS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DDR5_DFE_SIGN_BIT attribute
typedef uint8_t MEM_DDR5_DFE_SIGN_BIT_ATTR[2][4];
typedef uint8_t ATTR_MEM_DDR5_DFE_SIGN_BIT_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_DDR5_DFE_SIGN_BIT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_GEN attribute
typedef uint8_t MEM_EFF_DRAM_GEN_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_GEN_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_GEN_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_TYPE attribute
typedef uint8_t MEM_EFF_DIMM_TYPE_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DIMM_TYPE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DIMM_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_HYBRID_MEMORY_TYPE attribute
typedef uint8_t MEM_EFF_HYBRID_MEMORY_TYPE_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_HYBRID_MEMORY_TYPE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_HYBRID_MEMORY_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_HYBRID attribute
typedef uint8_t MEM_EFF_HYBRID_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_HYBRID_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_HYBRID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO attribute
typedef uint8_t MEM_EFF_HOST_TO_DDR_SPEED_RATIO_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_DENSITY attribute
typedef uint8_t MEM_EFF_DRAM_DENSITY_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_DENSITY_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_DENSITY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_BANK_BITS attribute
typedef uint8_t MEM_EFF_DRAM_BANK_BITS_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_BANK_BITS_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_BANK_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS attribute
typedef uint8_t MEM_EFF_DRAM_BANK_GROUP_BITS_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_COLUMN_BITS attribute
typedef uint8_t MEM_EFF_DRAM_COLUMN_BITS_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_COLUMN_BITS_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_COLUMN_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_ROW_BITS attribute
typedef uint8_t MEM_EFF_DRAM_ROW_BITS_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_ROW_BITS_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_ROW_BITS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_PRIM_DIE_COUNT attribute
typedef uint8_t MEM_EFF_PRIM_DIE_COUNT_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_PRIM_DIE_COUNT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_PRIM_DIE_COUNT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_PRIM_STACK_TYPE attribute
typedef uint8_t MEM_EFF_PRIM_STACK_TYPE_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_PRIM_STACK_TYPE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_PRIM_STACK_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_PRIM_BUS_WIDTH attribute
typedef uint8_t MEM_EFF_PRIM_BUS_WIDTH_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_PRIM_BUS_WIDTH_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_PRIM_BUS_WIDTH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_CHANNELS_PER_DIMM attribute
typedef uint8_t MEM_EFF_CHANNELS_PER_DIMM_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_CHANNELS_PER_DIMM_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_CHANNELS_PER_DIMM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_PPR attribute
typedef uint8_t MEM_EFF_DRAM_PPR_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_PPR_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_PPR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_SOFT_PPR attribute
typedef uint8_t MEM_EFF_DRAM_SOFT_PPR_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_SOFT_PPR_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_SOFT_PPR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRCD attribute
typedef uint8_t MEM_EFF_DRAM_TRCD_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRCD_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRP attribute
typedef uint8_t MEM_EFF_DRAM_TRP_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRP_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRAS attribute
typedef uint8_t MEM_EFF_DRAM_TRAS_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRAS_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRC attribute
typedef uint8_t MEM_EFF_DRAM_TRC_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRC_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRFC attribute
typedef uint16_t MEM_EFF_DRAM_TRFC_ATTR;
typedef uint16_t ATTR_MEM_EFF_DRAM_TRFC_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TFAW attribute
typedef uint8_t MEM_EFF_DRAM_TFAW_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TFAW_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRRD_S attribute
typedef uint8_t MEM_EFF_DRAM_TRRD_S_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRRD_S_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRRD_L attribute
typedef uint8_t MEM_EFF_DRAM_TRRD_L_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRRD_L_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRRD_DLR attribute
typedef uint8_t MEM_EFF_DRAM_TRRD_DLR_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRRD_DLR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TCCD_L attribute
typedef uint8_t MEM_EFF_DRAM_TCCD_L_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TCCD_L_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TCCD_L_WR attribute
typedef uint8_t MEM_EFF_DRAM_TCCD_L_WR_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TCCD_L_WR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TWR attribute
typedef uint8_t MEM_EFF_DRAM_TWR_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TWR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TWTR_S attribute
typedef uint8_t MEM_EFF_DRAM_TWTR_S_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TWTR_S_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TWTR_L attribute
typedef uint8_t MEM_EFF_DRAM_TWTR_L_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TWTR_L_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TMAW attribute
typedef uint16_t MEM_EFF_DRAM_TMAW_ATTR;
typedef uint16_t ATTR_MEM_EFF_DRAM_TMAW_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_WIDTH attribute
typedef uint8_t MEM_EFF_DRAM_WIDTH_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DRAM_WIDTH_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DRAM_WIDTH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM attribute
typedef uint8_t MEM_EFF_LOGICAL_RANKS_PER_DIMM_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_3DS_HEIGHT attribute
typedef uint16_t MEM_3DS_HEIGHT_ATTR[2];
typedef uint16_t ATTR_MEM_3DS_HEIGHT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_3DS_HEIGHT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_REGISTER_TYPE attribute
typedef uint8_t MEM_EFF_REGISTER_TYPE_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_REGISTER_TYPE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_REGISTER_TYPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_MODULE_MFG_ID attribute
typedef uint16_t MEM_EFF_MODULE_MFG_ID_ATTR[2];
typedef uint16_t ATTR_MEM_EFF_MODULE_MFG_ID_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EFF_MODULE_MFG_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_MFG_ID attribute
typedef uint16_t MEM_EFF_DRAM_MFG_ID_ATTR[2];
typedef uint16_t ATTR_MEM_EFF_DRAM_MFG_ID_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EFF_DRAM_MFG_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_MODULE_HEIGHT attribute
typedef uint8_t MEM_EFF_DRAM_MODULE_HEIGHT_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_MODULE_HEIGHT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_RCD_MFG_ID attribute
typedef uint16_t MEM_EFF_RCD_MFG_ID_ATTR[2];
typedef uint16_t ATTR_MEM_EFF_RCD_MFG_ID_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EFF_RCD_MFG_ID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_REGISTER_REV attribute
typedef uint8_t MEM_EFF_REGISTER_REV_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_REGISTER_REV_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_REGISTER_REV_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_PACKAGE_RANK_MAP attribute
typedef uint8_t MEM_EFF_PACKAGE_RANK_MAP_ATTR[2][20];
typedef uint8_t ATTR_MEM_EFF_PACKAGE_RANK_MAP_type[2][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 20>, 2> ATTR_MEM_EFF_PACKAGE_RANK_MAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_NIBBLE_MAP attribute
typedef uint8_t MEM_EFF_NIBBLE_MAP_ATTR[2][20];
typedef uint8_t ATTR_MEM_EFF_NIBBLE_MAP_type[2][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 20>, 2> ATTR_MEM_EFF_NIBBLE_MAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_SIZE attribute
typedef uint32_t MEM_EFF_DIMM_SIZE_ATTR[2];
typedef uint32_t ATTR_MEM_EFF_DIMM_SIZE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 2> ATTR_MEM_EFF_DIMM_SIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_SPARE attribute
typedef uint8_t MEM_EFF_DIMM_SPARE_ATTR[2][4];
typedef uint8_t ATTR_MEM_EFF_DIMM_SPARE_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_EFF_DIMM_SPARE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_CL attribute
typedef uint8_t MEM_EFF_DRAM_CL_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_CL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_MDS attribute
typedef uint8_t MEM_EFF_DRAM_MDS_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_MDS_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM attribute
typedef uint8_t MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_RANKS_CONFIGED attribute
typedef uint8_t MEM_EFF_DIMM_RANKS_CONFIGED_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DIMM_RANKS_CONFIGED_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DIMM_RANKS_CONFIGED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TREFI attribute
typedef uint16_t MEM_EFF_DRAM_TREFI_ATTR;
typedef uint16_t ATTR_MEM_EFF_DRAM_TREFI_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRTP attribute
typedef uint8_t MEM_EFF_DRAM_TRTP_ATTR;
typedef uint8_t ATTR_MEM_EFF_DRAM_TRTP_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DRAM_TRFC_DLR attribute
typedef uint16_t MEM_EFF_DRAM_TRFC_DLR_ATTR;
typedef uint16_t ATTR_MEM_EFF_DRAM_TRFC_DLR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_FREQ attribute
typedef uint64_t MEM_EFF_FREQ_ATTR;
typedef uint64_t ATTR_MEM_EFF_FREQ_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_VOLT_VDDR attribute
typedef uint32_t MEM_EFF_VOLT_VDDR_ATTR;
typedef uint32_t ATTR_MEM_EFF_VOLT_VDDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_VOLT_VDDQ attribute
typedef uint32_t MEM_EFF_VOLT_VDDQ_ATTR;
typedef uint32_t ATTR_MEM_EFF_VOLT_VDDQ_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_VOLT_VPP attribute
typedef uint32_t MEM_EFF_VOLT_VPP_ATTR;
typedef uint32_t ATTR_MEM_EFF_VOLT_VPP_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_SPD_REVISION attribute
typedef uint8_t MEM_EFF_SPD_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_SPD_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_SPD_CONTENT_REVISION attribute
typedef uint8_t MEM_EFF_SPD_CONTENT_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_SPD_CONTENT_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_SUPPORTED_RCD attribute
typedef uint8_t MEM_EFF_SUPPORTED_RCD_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_SUPPORTED_RCD_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_SUPPORTED_RCD_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_BYTE_ENABLES attribute
typedef uint16_t MEM_EFF_BYTE_ENABLES_ATTR[2];
typedef uint16_t ATTR_MEM_EFF_BYTE_ENABLES_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EFF_BYTE_ENABLES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_NIBBLE_ENABLES attribute
typedef uint32_t MEM_EFF_NIBBLE_ENABLES_ATTR[2];
typedef uint32_t ATTR_MEM_EFF_NIBBLE_ENABLES_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 2> ATTR_MEM_EFF_NIBBLE_ENABLES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_Z_MODE attribute
typedef uint8_t MEM_EFF_Z_MODE_ATTR;
typedef uint8_t ATTR_MEM_EFF_Z_MODE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_SERIAL_NUMBER attribute
typedef uint8_t MEM_EFF_DIMM_SERIAL_NUMBER_ATTR[26];
typedef uint8_t ATTR_MEM_EFF_DIMM_SERIAL_NUMBER_type[26];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 26> ATTR_MEM_EFF_DIMM_SERIAL_NUMBER_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN attribute
typedef uint8_t MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN_ATTR;
typedef uint8_t ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION attribute
typedef uint8_t MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_MODULE_THERMAL_SENSORS attribute
typedef uint8_t MEM_EFF_MODULE_THERMAL_SENSORS_ATTR;
typedef uint8_t ATTR_MEM_EFF_MODULE_THERMAL_SENSORS_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_TYPE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_TYPE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_TYPE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_USAGE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_USAGE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_USAGE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_TYPE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_TYPE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_TYPE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_USAGE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_USAGE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_USAGE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_2_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_2_TYPE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_2_TYPE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_2_TYPE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_2_USAGE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_2_USAGE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_2_USAGE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_2_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_3_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_3_TYPE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_3_TYPE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_3_TYPE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_3_USAGE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_3_USAGE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_3_USAGE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_3_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_DIFF_AVAIL_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_DIFF_TYPE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_DIFF_USAGE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_3_LOCATION_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_2_LOCATION_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_1_LOCATION_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_0_LOCATION_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE attribute
typedef uint8_t MEM_EFF_THERM_SENSOR_READ_OVERRIDE_ATTR;
typedef uint8_t ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
typedef uint16_t ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT_ATTR;
typedef uint16_t ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT_type;

// Type aliases and/or sizes for ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
typedef uint16_t ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT_ATTR;
typedef uint16_t ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type;

// Type aliases and/or sizes for ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
typedef uint16_t ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_ATTR;
typedef uint16_t ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_type;

// Type aliases and/or sizes for ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
typedef uint16_t ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_ATTR;
typedef uint16_t ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type;

// Type aliases and/or sizes for ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
typedef uint16_t EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT_ATTR;
typedef uint16_t ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT_type;

// Type aliases and/or sizes for ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
typedef uint16_t EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT_ATTR;
typedef uint16_t ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type;

// Type aliases and/or sizes for ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
typedef uint16_t EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_ATTR;
typedef uint16_t ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_type;

// Type aliases and/or sizes for ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
typedef uint16_t EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_ATTR;
typedef uint16_t ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type;

// Type aliases and/or sizes for ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
typedef uint16_t EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_ATTR;
typedef uint16_t ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_type;

// Type aliases and/or sizes for ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS attribute
typedef uint32_t EXP_RUNTIME_MEM_M_DRAM_CLOCKS_ATTR;
typedef uint32_t ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS_type;

// Type aliases and/or sizes for ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE attribute
typedef uint64_t EXP_MEM_PORT_POS_OF_FAIL_THROTTLE_ATTR;
typedef uint64_t ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE_type;

// Type aliases and/or sizes for ATTR_EXP_MEM_WATT_TARGET attribute
typedef uint32_t EXP_MEM_WATT_TARGET_ATTR[2];
typedef uint32_t ATTR_EXP_MEM_WATT_TARGET_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 2> ATTR_EXP_MEM_WATT_TARGET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXP_TOTAL_PWR_SLOPE attribute
typedef uint16_t EXP_TOTAL_PWR_SLOPE_ATTR[2];
typedef uint16_t ATTR_EXP_TOTAL_PWR_SLOPE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_EXP_TOTAL_PWR_SLOPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXP_TOTAL_PWR_INTERCEPT attribute
typedef uint16_t EXP_TOTAL_PWR_INTERCEPT_ATTR[2];
typedef uint16_t ATTR_EXP_TOTAL_PWR_INTERCEPT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_EXP_TOTAL_PWR_INTERCEPT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EXP_PORT_MAXPOWER attribute
typedef uint32_t EXP_PORT_MAXPOWER_ATTR;
typedef uint32_t ATTR_EXP_PORT_MAXPOWER_type;

// Type aliases and/or sizes for ATTR_EXP_DIMM_THERMAL_LIMIT attribute
typedef uint32_t EXP_DIMM_THERMAL_LIMIT_ATTR[2];
typedef uint32_t ATTR_EXP_DIMM_THERMAL_LIMIT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 2> ATTR_EXP_DIMM_THERMAL_LIMIT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_MRW_IS_PLANAR attribute
typedef uint8_t MEM_MRW_IS_PLANAR_ATTR;
typedef uint8_t ATTR_MEM_MRW_IS_PLANAR_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_CONFIG_FREQ_LIMIT attribute
typedef uint16_t MSS_MRW_CONFIG_FREQ_LIMIT_ATTR[8];
typedef uint16_t ATTR_MSS_MRW_CONFIG_FREQ_LIMIT_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 8> ATTR_MSS_MRW_CONFIG_FREQ_LIMIT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
typedef uint16_t MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_ATTR;
typedef uint16_t ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_PWR_INTERCEPT attribute
typedef uint64_t MSS_MRW_PWR_INTERCEPT_ATTR[100];
typedef uint64_t ATTR_MSS_MRW_PWR_INTERCEPT_type[100];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 100> ATTR_MSS_MRW_PWR_INTERCEPT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_PWR_SLOPE attribute
typedef uint64_t MSS_MRW_PWR_SLOPE_ATTR[100];
typedef uint64_t ATTR_MSS_MRW_PWR_SLOPE_type[100];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 100> ATTR_MSS_MRW_PWR_SLOPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_REFRESH_RATE_REQUEST attribute
typedef uint8_t MSS_MRW_REFRESH_RATE_REQUEST_ATTR;
typedef uint8_t ATTR_MSS_MRW_REFRESH_RATE_REQUEST_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT attribute
typedef uint8_t MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_ATTR;
typedef uint8_t ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE attribute
typedef uint8_t MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS attribute
typedef uint32_t MSS_MRW_MEM_M_DRAM_CLOCKS_ATTR;
typedef uint32_t ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL attribute
typedef uint32_t MSS_MRW_MAX_DRAM_DATABUS_UTIL_ATTR;
typedef uint32_t ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL attribute
typedef uint32_t MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL_ATTR;
typedef uint32_t ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_POWER_CONTROL_REQUESTED attribute
typedef uint8_t MSS_MRW_POWER_CONTROL_REQUESTED_ATTR;
typedef uint8_t ATTR_MSS_MRW_POWER_CONTROL_REQUESTED_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED attribute
typedef uint8_t MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_ATTR;
typedef uint8_t ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE attribute
typedef uint8_t MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_type;

// Type aliases and/or sizes for ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3 attribute
typedef uint32_t MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3_ATTR;
typedef uint32_t ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3_type;

// Type aliases and/or sizes for ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4 attribute
typedef uint32_t MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4_ATTR;
typedef uint32_t ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR attribute
typedef uint8_t MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR_ATTR;
typedef uint8_t ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_AVDD_OFFSET_ENABLE attribute
typedef uint8_t MSS_MRW_AVDD_OFFSET_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_AVDD_OFFSET_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_VDD_OFFSET_ENABLE attribute
typedef uint8_t MSS_MRW_VDD_OFFSET_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_VDD_OFFSET_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_VCS_OFFSET_ENABLE attribute
typedef uint8_t MSS_MRW_VCS_OFFSET_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_VCS_OFFSET_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_VPP_OFFSET_ENABLE attribute
typedef uint8_t MSS_MRW_VPP_OFFSET_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_VPP_OFFSET_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_VDDR_OFFSET_ENABLE attribute
typedef uint8_t MSS_MRW_VDDR_OFFSET_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_MRW_VDDR_OFFSET_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_FINE_REFRESH_MODE attribute
typedef uint8_t MSS_MRW_FINE_REFRESH_MODE_ATTR;
typedef uint8_t ATTR_MSS_MRW_FINE_REFRESH_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_TEMP_REFRESH_RANGE attribute
typedef uint8_t MSS_MRW_TEMP_REFRESH_RANGE_ATTR;
typedef uint8_t ATTR_MSS_MRW_TEMP_REFRESH_RANGE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL attribute
typedef uint8_t MSS_MRW_RESET_DELAY_BEFORE_CAL_ATTR;
typedef uint8_t ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS attribute
typedef uint16_t MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS_ATTR;
typedef uint16_t ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS attribute
typedef uint16_t MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS_ATTR;
typedef uint16_t ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DRAM_2N_MODE attribute
typedef uint8_t MSS_MRW_DRAM_2N_MODE_ATTR;
typedef uint8_t ATTR_MSS_MRW_DRAM_2N_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DRAM_WRITE_CRC attribute
typedef uint8_t MSS_MRW_DRAM_WRITE_CRC_ATTR;
typedef uint8_t ATTR_MSS_MRW_DRAM_WRITE_CRC_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DDR5_DRAM_READ_CRC attribute
typedef uint8_t MSS_MRW_DDR5_DRAM_READ_CRC_ATTR;
typedef uint8_t ATTR_MSS_MRW_DDR5_DRAM_READ_CRC_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_TEMP_REFRESH_MODE attribute
typedef uint8_t MSS_MRW_TEMP_REFRESH_MODE_ATTR;
typedef uint8_t ATTR_MSS_MRW_TEMP_REFRESH_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_FORCE_BCMODE_OFF attribute
typedef uint8_t MSS_MRW_FORCE_BCMODE_OFF_ATTR;
typedef uint8_t ATTR_MSS_MRW_FORCE_BCMODE_OFF_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_NVDIMM_PLUG_RULES attribute
typedef uint64_t MSS_MRW_NVDIMM_PLUG_RULES_ATTR;
typedef uint64_t ATTR_MSS_MRW_NVDIMM_PLUG_RULES_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW attribute
typedef uint8_t MSS_MRW_ALLOW_UNSUPPORTED_RCW_ATTR;
typedef uint8_t ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH attribute
typedef uint8_t MSS_MRW_SUPPORTED_DRAM_WIDTH_ATTR;
typedef uint8_t ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT attribute
typedef uint64_t MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT_ATTR[25];
typedef uint64_t ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT_type[25];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 25> ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_OCMB_PWR_SLOPE attribute
typedef uint64_t MSS_MRW_OCMB_PWR_SLOPE_ATTR[50];
typedef uint64_t ATTR_MSS_MRW_OCMB_PWR_SLOPE_type[50];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 50> ATTR_MSS_MRW_OCMB_PWR_SLOPE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_OCMB_PWR_INTERCEPT attribute
typedef uint64_t MSS_MRW_OCMB_PWR_INTERCEPT_ATTR[50];
typedef uint64_t ATTR_MSS_MRW_OCMB_PWR_INTERCEPT_type[50];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 50> ATTR_MSS_MRW_OCMB_PWR_INTERCEPT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT attribute
typedef uint64_t MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT_ATTR[25];
typedef uint64_t ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT_type[25];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 25> ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL attribute
typedef uint32_t MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL_ATTR;
typedef uint32_t ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD attribute
typedef uint16_t MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD_ATTR;
typedef uint16_t ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW attribute
typedef uint8_t MSS_MRW_DIMM_SLOT_AIRFLOW_ATTR;
typedef uint8_t ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW_type;

// Type aliases and/or sizes for ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE attribute
typedef uint64_t MEM_PORT_POS_OF_FAIL_THROTTLE_ATTR;
typedef uint64_t ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_OCMB_RESET_GROUP attribute
typedef uint8_t MSS_MRW_OCMB_RESET_GROUP_ATTR;
typedef uint8_t ATTR_MSS_MRW_OCMB_RESET_GROUP_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY attribute
typedef uint8_t MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_ATTR;
typedef uint8_t ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_SUPPORTED_FREQ attribute
typedef uint32_t MSS_MRW_SUPPORTED_FREQ_ATTR[4];
typedef uint32_t ATTR_MSS_MRW_SUPPORTED_FREQ_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_MSS_MRW_SUPPORTED_FREQ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT attribute
typedef uint64_t MSS_MRW_THERMAL_MEMORY_POWER_LIMIT_ATTR[10];
typedef uint64_t ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT_type[10];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 10> ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE attribute
typedef uint8_t MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_ATTR;
typedef uint8_t ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY attribute
typedef uint64_t MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY_ATTR[50];
typedef uint64_t ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY_type[50];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 50> ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_MRW_ALLOW_DDR5 attribute
typedef uint8_t MSS_MRW_ALLOW_DDR5_ATTR;
typedef uint8_t ATTR_MSS_MRW_ALLOW_DDR5_type;

// Type aliases and/or sizes for ATTR_MRW_MAX_DDR_FREQ_PER_SLOT attribute
typedef uint16_t MRW_MAX_DDR_FREQ_PER_SLOT_ATTR;
typedef uint16_t ATTR_MRW_MAX_DDR_FREQ_PER_SLOT_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF attribute
typedef uint16_t MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF_ATTR;
typedef uint16_t ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME attribute
typedef uint16_t MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_ATTR;
typedef uint16_t ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_ENTER_STR_TIME attribute
typedef uint16_t MSS_MRW_ENTER_STR_TIME_ATTR;
typedef uint16_t ATTR_MSS_MRW_ENTER_STR_TIME_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME attribute
typedef uint16_t MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME_ATTR;
typedef uint16_t ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME_type;

// Type aliases and/or sizes for ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME attribute
typedef uint16_t MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME_ATTR;
typedef uint16_t ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME_type;

// Type aliases and/or sizes for ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM attribute
typedef uint16_t MRW_MAX_DDR_FREQ_ON_IOSCM_ATTR;
typedef uint16_t ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ attribute
typedef uint8_t MEM_EFF_DDR5_TX_SLEW_RISE_DQ_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ attribute
typedef uint8_t MEM_EFF_DDR5_TX_SLEW_FALL_DQ_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC attribute
typedef uint8_t MEM_EFF_DDR5_TX_SLEW_RISE_AC_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC attribute
typedef uint8_t MEM_EFF_DDR5_TX_SLEW_FALL_AC_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK attribute
typedef uint8_t MEM_EFF_DDR5_TX_SLEW_RISE_CK_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK attribute
typedef uint8_t MEM_EFF_DDR5_TX_SLEW_FALL_CK_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK_type;

// Type aliases and/or sizes for ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0 attribute
typedef uint8_t DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_ATTR;
typedef uint8_t ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_type;

// Type aliases and/or sizes for ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1 attribute
typedef uint8_t DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_ATTR;
typedef uint8_t ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_type;

// Type aliases and/or sizes for ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN attribute
typedef uint8_t DDR5_EN_TX_DM_PREAMBLE_PATTERN_ATTR;
typedef uint8_t ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN_type;

// Type aliases and/or sizes for ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0 attribute
typedef uint8_t DDR5_TX_DQ_PREAMBLE_PATTERN_U0_ATTR;
typedef uint8_t ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0_type;

// Type aliases and/or sizes for ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1 attribute
typedef uint8_t DDR5_TX_DQ_PREAMBLE_PATTERN_U1_ATTR;
typedef uint8_t ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1_type;

// Type aliases and/or sizes for ATTR_DDR5_TX_DM_PREAMBLE_PATTERN attribute
typedef uint8_t DDR5_TX_DM_PREAMBLE_PATTERN_ATTR;
typedef uint8_t ATTR_DDR5_TX_DM_PREAMBLE_PATTERN_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_REDUNDANT_CS_EN attribute
typedef uint8_t MEM_EFF_REDUNDANT_CS_EN_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_REDUNDANT_CS_EN_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_REDUNDANT_CS_EN_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_RXEN_ADJ attribute
typedef uint8_t MEM_EFF_DDR5_RXEN_ADJ_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_RXEN_ADJ_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_WL_ADJ_START attribute
typedef uint16_t MEM_EFF_DDR5_WL_ADJ_START_ATTR;
typedef uint16_t ATTR_MEM_EFF_DDR5_WL_ADJ_START_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_WL_ADJ_END attribute
typedef uint16_t MEM_EFF_DDR5_WL_ADJ_END_ATTR;
typedef uint16_t ATTR_MEM_EFF_DDR5_WL_ADJ_END_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_PHY_VREF_RD attribute
typedef uint8_t MEM_EFF_DDR5_PHY_VREF_RD_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_PHY_VREF_RD_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_RTT_PARK_RD attribute
typedef uint8_t MEM_EFF_DDR5_RTT_PARK_RD_ATTR[2][4];
typedef uint8_t ATTR_MEM_EFF_DDR5_RTT_PARK_RD_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_EFF_DDR5_RTT_PARK_RD_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_RTT_PARK_WR attribute
typedef uint8_t MEM_EFF_DDR5_RTT_PARK_WR_ATTR[2][4];
typedef uint8_t ATTR_MEM_EFF_DDR5_RTT_PARK_WR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_EFF_DDR5_RTT_PARK_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_DDR5_SPD_CL_SUPPORTED attribute
typedef uint64_t MEM_DDR5_SPD_CL_SUPPORTED_ATTR;
typedef uint64_t ATTR_MEM_DDR5_SPD_CL_SUPPORTED_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_CHB_ACTIVE attribute
typedef uint8_t MEM_EFF_DDR5_CHB_ACTIVE_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_CHB_ACTIVE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE attribute
typedef uint8_t MEM_EFF_DDR5_MEM_PORT_ENABLE_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH attribute
typedef uint8_t MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN attribute
typedef uint8_t MEM_EFF_DDR5_VREFCS_SWEEP_MIN_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX attribute
typedef uint8_t MEM_EFF_DDR5_VREFCS_SWEEP_MAX_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN attribute
typedef uint8_t MEM_EFF_DDR5_VREFCA_SWEEP_MIN_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX attribute
typedef uint8_t MEM_EFF_DDR5_VREFCA_SWEEP_MAX_ATTR;
typedef uint8_t ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX_type;

// Type aliases and/or sizes for ATTR_RCW00_CHA_D0 attribute
typedef uint8_t RCW00_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW00_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW01_CHA_D0 attribute
typedef uint8_t RCW01_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW01_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW05_CHA_D0 attribute
typedef uint8_t RCW05_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW05_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW08_CHA_D0 attribute
typedef uint8_t RCW08_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW08_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW09_CHA_D0 attribute
typedef uint8_t RCW09_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW09_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW0A_CHA_D0 attribute
typedef uint8_t RCW0A_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW0A_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW0C_CHA_D0 attribute
typedef uint8_t RCW0C_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW0C_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW0D_CHA_D0 attribute
typedef uint8_t RCW0D_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW0D_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW0E_CHA_D0 attribute
typedef uint8_t RCW0E_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW0E_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW0F_CHA_D0 attribute
typedef uint8_t RCW0F_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW0F_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW40_CHA_D0 attribute
typedef uint8_t RCW40_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW40_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW41_CHA_D0 attribute
typedef uint8_t RCW41_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW41_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW42_CHA_D0 attribute
typedef uint8_t RCW42_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW42_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW43_CHA_D0 attribute
typedef uint8_t RCW43_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW43_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW44_CHA_D0 attribute
typedef uint8_t RCW44_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW44_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW45_CHA_D0 attribute
typedef uint8_t RCW45_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW45_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW46_CHA_D0 attribute
typedef uint8_t RCW46_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW46_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW47_CHA_D0 attribute
typedef uint8_t RCW47_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW47_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW48_CHA_D0 attribute
typedef uint8_t RCW48_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW48_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW49_CHA_D0 attribute
typedef uint8_t RCW49_CHA_D0_ATTR;
typedef uint8_t ATTR_RCW49_CHA_D0_type;

// Type aliases and/or sizes for ATTR_RCW00_CHA_D1 attribute
typedef uint8_t RCW00_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW00_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW01_CHA_D1 attribute
typedef uint8_t RCW01_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW01_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW05_CHA_D1 attribute
typedef uint8_t RCW05_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW05_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW08_CHA_D1 attribute
typedef uint8_t RCW08_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW08_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW09_CHA_D1 attribute
typedef uint8_t RCW09_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW09_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW0A_CHA_D1 attribute
typedef uint8_t RCW0A_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW0A_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW0C_CHA_D1 attribute
typedef uint8_t RCW0C_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW0C_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW0D_CHA_D1 attribute
typedef uint8_t RCW0D_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW0D_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW0E_CHA_D1 attribute
typedef uint8_t RCW0E_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW0E_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW0F_CHA_D1 attribute
typedef uint8_t RCW0F_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW0F_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW40_CHA_D1 attribute
typedef uint8_t RCW40_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW40_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW41_CHA_D1 attribute
typedef uint8_t RCW41_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW41_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW42_CHA_D1 attribute
typedef uint8_t RCW42_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW42_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW43_CHA_D1 attribute
typedef uint8_t RCW43_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW43_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW44_CHA_D1 attribute
typedef uint8_t RCW44_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW44_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW45_CHA_D1 attribute
typedef uint8_t RCW45_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW45_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW46_CHA_D1 attribute
typedef uint8_t RCW46_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW46_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW47_CHA_D1 attribute
typedef uint8_t RCW47_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW47_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW48_CHA_D1 attribute
typedef uint8_t RCW48_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW48_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW49_CHA_D1 attribute
typedef uint8_t RCW49_CHA_D1_ATTR;
typedef uint8_t ATTR_RCW49_CHA_D1_type;

// Type aliases and/or sizes for ATTR_RCW00_CHB_D0 attribute
typedef uint8_t RCW00_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW00_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW01_CHB_D0 attribute
typedef uint8_t RCW01_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW01_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW05_CHB_D0 attribute
typedef uint8_t RCW05_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW05_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW08_CHB_D0 attribute
typedef uint8_t RCW08_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW08_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW09_CHB_D0 attribute
typedef uint8_t RCW09_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW09_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW0A_CHB_D0 attribute
typedef uint8_t RCW0A_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW0A_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW0C_CHB_D0 attribute
typedef uint8_t RCW0C_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW0C_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW0D_CHB_D0 attribute
typedef uint8_t RCW0D_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW0D_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW0E_CHB_D0 attribute
typedef uint8_t RCW0E_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW0E_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW0F_CHB_D0 attribute
typedef uint8_t RCW0F_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW0F_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW40_CHB_D0 attribute
typedef uint8_t RCW40_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW40_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW41_CHB_D0 attribute
typedef uint8_t RCW41_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW41_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW42_CHB_D0 attribute
typedef uint8_t RCW42_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW42_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW43_CHB_D0 attribute
typedef uint8_t RCW43_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW43_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW44_CHB_D0 attribute
typedef uint8_t RCW44_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW44_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW45_CHB_D0 attribute
typedef uint8_t RCW45_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW45_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW46_CHB_D0 attribute
typedef uint8_t RCW46_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW46_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW47_CHB_D0 attribute
typedef uint8_t RCW47_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW47_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW48_CHB_D0 attribute
typedef uint8_t RCW48_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW48_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW49_CHB_D0 attribute
typedef uint8_t RCW49_CHB_D0_ATTR;
typedef uint8_t ATTR_RCW49_CHB_D0_type;

// Type aliases and/or sizes for ATTR_RCW00_CHB_D1 attribute
typedef uint8_t RCW00_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW00_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW01_CHB_D1 attribute
typedef uint8_t RCW01_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW01_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW05_CHB_D1 attribute
typedef uint8_t RCW05_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW05_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW08_CHB_D1 attribute
typedef uint8_t RCW08_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW08_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW09_CHB_D1 attribute
typedef uint8_t RCW09_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW09_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW0A_CHB_D1 attribute
typedef uint8_t RCW0A_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW0A_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW0C_CHB_D1 attribute
typedef uint8_t RCW0C_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW0C_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW0D_CHB_D1 attribute
typedef uint8_t RCW0D_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW0D_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW0E_CHB_D1 attribute
typedef uint8_t RCW0E_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW0E_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW0F_CHB_D1 attribute
typedef uint8_t RCW0F_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW0F_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW40_CHB_D1 attribute
typedef uint8_t RCW40_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW40_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW41_CHB_D1 attribute
typedef uint8_t RCW41_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW41_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW42_CHB_D1 attribute
typedef uint8_t RCW42_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW42_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW43_CHB_D1 attribute
typedef uint8_t RCW43_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW43_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW44_CHB_D1 attribute
typedef uint8_t RCW44_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW44_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW45_CHB_D1 attribute
typedef uint8_t RCW45_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW45_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW46_CHB_D1 attribute
typedef uint8_t RCW46_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW46_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW47_CHB_D1 attribute
typedef uint8_t RCW47_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW47_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW48_CHB_D1 attribute
typedef uint8_t RCW48_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW48_CHB_D1_type;

// Type aliases and/or sizes for ATTR_RCW49_CHB_D1 attribute
typedef uint8_t RCW49_CHB_D1_ATTR;
typedef uint8_t ATTR_RCW49_CHB_D1_type;

// Type aliases and/or sizes for ATTR_EXPLR_ENABLE_US_TMPL_1 attribute
typedef uint8_t EXPLR_ENABLE_US_TMPL_1_ATTR;
typedef uint8_t ATTR_EXPLR_ENABLE_US_TMPL_1_type;

// Type aliases and/or sizes for ATTR_EXPLR_ENABLE_US_TMPL_5 attribute
typedef uint8_t EXPLR_ENABLE_US_TMPL_5_ATTR;
typedef uint8_t ATTR_EXPLR_ENABLE_US_TMPL_5_type;

// Type aliases and/or sizes for ATTR_EXPLR_ENABLE_US_TMPL_9 attribute
typedef uint8_t EXPLR_ENABLE_US_TMPL_9_ATTR;
typedef uint8_t ATTR_EXPLR_ENABLE_US_TMPL_9_type;

// Type aliases and/or sizes for ATTR_EXPLR_ENABLE_US_TMPL_A attribute
typedef uint8_t EXPLR_ENABLE_US_TMPL_A_ATTR;
typedef uint8_t ATTR_EXPLR_ENABLE_US_TMPL_A_type;

// Type aliases and/or sizes for ATTR_EXPLR_ENABLE_US_TMPL_B attribute
typedef uint8_t EXPLR_ENABLE_US_TMPL_B_ATTR;
typedef uint8_t ATTR_EXPLR_ENABLE_US_TMPL_B_type;

// Type aliases and/or sizes for ATTR_EXPLR_TMPL_0_PACING attribute
typedef uint8_t EXPLR_TMPL_0_PACING_ATTR;
typedef uint8_t ATTR_EXPLR_TMPL_0_PACING_type;

// Type aliases and/or sizes for ATTR_EXPLR_TMPL_1_PACING attribute
typedef uint8_t EXPLR_TMPL_1_PACING_ATTR;
typedef uint8_t ATTR_EXPLR_TMPL_1_PACING_type;

// Type aliases and/or sizes for ATTR_EXPLR_TMPL_5_PACING attribute
typedef uint8_t EXPLR_TMPL_5_PACING_ATTR;
typedef uint8_t ATTR_EXPLR_TMPL_5_PACING_type;

// Type aliases and/or sizes for ATTR_EXPLR_TMPL_9_PACING attribute
typedef uint8_t EXPLR_TMPL_9_PACING_ATTR;
typedef uint8_t ATTR_EXPLR_TMPL_9_PACING_type;

// Type aliases and/or sizes for ATTR_EXPLR_TMPL_B_PACING attribute
typedef uint8_t EXPLR_TMPL_B_PACING_ATTR;
typedef uint8_t ATTR_EXPLR_TMPL_B_PACING_type;

// Type aliases and/or sizes for ATTR_EXPLR_SHRT_BACKOFF_TIMER attribute
typedef uint8_t EXPLR_SHRT_BACKOFF_TIMER_ATTR;
typedef uint8_t ATTR_EXPLR_SHRT_BACKOFF_TIMER_type;

// Type aliases and/or sizes for ATTR_EXPLR_METADATA_ENABLE attribute
typedef uint8_t EXPLR_METADATA_ENABLE_ATTR;
typedef uint8_t ATTR_EXPLR_METADATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_EXPLR_PASID_BASE attribute
typedef uint32_t EXPLR_PASID_BASE_ATTR;
typedef uint32_t ATTR_EXPLR_PASID_BASE_type;

// Type aliases and/or sizes for ATTR_EXPLR_ACTAG_BASE attribute
typedef uint32_t EXPLR_ACTAG_BASE_ATTR;
typedef uint32_t ATTR_EXPLR_ACTAG_BASE_type;

// Type aliases and/or sizes for ATTR_EXPLR_AFU_ACTAG_LEN attribute
typedef uint32_t EXPLR_AFU_ACTAG_LEN_ATTR;
typedef uint32_t ATTR_EXPLR_AFU_ACTAG_LEN_type;

// Type aliases and/or sizes for ATTR_EXPLR_PASID_LEN attribute
typedef uint8_t EXPLR_PASID_LEN_ATTR;
typedef uint8_t ATTR_EXPLR_PASID_LEN_type;

// Type aliases and/or sizes for ATTR_IS_IBM_SIMULATION attribute
typedef uint8_t IS_IBM_SIMULATION_ATTR;
typedef uint8_t ATTR_IS_IBM_SIMULATION_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_ENTERPRISE_MODE attribute
typedef uint8_t MSS_OCMB_ENTERPRISE_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_ENTERPRISE_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_ENTERPRISE_POLICY attribute
typedef uint8_t MSS_OCMB_ENTERPRISE_POLICY_ATTR;
typedef uint8_t ATTR_MSS_OCMB_ENTERPRISE_POLICY_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE attribute
typedef uint8_t MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_MEM_EXP_INIT_VREF_DQ attribute
typedef uint8_t MEM_EXP_INIT_VREF_DQ_ATTR[2][4];
typedef uint8_t ATTR_MEM_EXP_INIT_VREF_DQ_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_EXP_INIT_VREF_DQ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_INIT_PHY_VREF attribute
typedef uint8_t MEM_EXP_INIT_PHY_VREF_ATTR[2][4];
typedef uint8_t ATTR_MEM_EXP_INIT_PHY_VREF_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MEM_EXP_INIT_PHY_VREF_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_RCD_DIC attribute
typedef uint16_t MEM_EXP_RCD_DIC_ATTR[2];
typedef uint16_t ATTR_MEM_EXP_RCD_DIC_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EXP_RCD_DIC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_RCD_VOLTAGE_CTRL attribute
typedef uint16_t MEM_EXP_RCD_VOLTAGE_CTRL_ATTR[2];
typedef uint16_t ATTR_MEM_EXP_RCD_VOLTAGE_CTRL_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EXP_RCD_VOLTAGE_CTRL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING attribute
typedef uint8_t MEM_EXP_DRAM_ADDRESS_MIRRORING_ATTR[2];
typedef uint8_t ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_RCD_SLEW_RATE attribute
typedef uint16_t MEM_EXP_RCD_SLEW_RATE_ATTR[2];
typedef uint16_t ATTR_MEM_EXP_RCD_SLEW_RATE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MEM_EXP_RCD_SLEW_RATE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_SPD_CL_SUPPORTED attribute
typedef uint32_t MEM_EXP_SPD_CL_SUPPORTED_ATTR;
typedef uint32_t ATTR_MEM_EXP_SPD_CL_SUPPORTED_type;

// Type aliases and/or sizes for ATTR_MEM_EXP_SPD_TAA_MIN attribute
typedef uint16_t MEM_EXP_SPD_TAA_MIN_ATTR;
typedef uint16_t ATTR_MEM_EXP_SPD_TAA_MIN_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_REORDER_QUEUE_SETTING attribute
typedef uint8_t MSS_EXP_REORDER_QUEUE_SETTING_ATTR;
typedef uint8_t ATTR_MSS_EXP_REORDER_QUEUE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE attribute
typedef uint8_t MEM_EXP_FIRMWARE_EMULATION_MODE_ATTR;
typedef uint8_t ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL attribute
typedef uint8_t MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN attribute
typedef uint8_t MSS_OCMB_EXP_STRUCT_ENDIAN_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP attribute
typedef uint8_t MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_ECID attribute
typedef uint16_t MSS_OCMB_ECID_ATTR[14];
typedef uint16_t ATTR_MSS_OCMB_ECID_type[14];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 14> ATTR_MSS_OCMB_ECID_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EXP_DFIMRL_CLK attribute
typedef uint8_t MEM_EXP_DFIMRL_CLK_ATTR;
typedef uint8_t ATTR_MEM_EXP_DFIMRL_CLK_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_ATXDLY_A attribute
typedef uint8_t MEM_EFF_ATXDLY_A_ATTR[8];
typedef uint8_t ATTR_MEM_EFF_ATXDLY_A_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_MEM_EFF_ATXDLY_A_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_ATXDLY_B attribute
typedef uint8_t MEM_EFF_ATXDLY_B_ATTR[8];
typedef uint8_t ATTR_MEM_EFF_ATXDLY_B_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_MEM_EFF_ATXDLY_B_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_OCMB_PHY_INIT_MODE attribute
typedef uint8_t MSS_OCMB_PHY_INIT_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_PHY_INIT_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_CHECK_FOR_READY_TIMEOUT attribute
typedef uint16_t MSS_CHECK_FOR_READY_TIMEOUT_ATTR;
typedef uint16_t ATTR_MSS_CHECK_FOR_READY_TIMEOUT_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ attribute
typedef uint8_t MSS_OCMB_DISABLE_THERM_INIT_READ_ATTR;
typedef uint8_t ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_FW_API_VERSION attribute
typedef uint8_t MSS_EXP_FW_API_VERSION_ATTR;
typedef uint8_t ATTR_MSS_EXP_FW_API_VERSION_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_FW_VERSION_A attribute
typedef uint32_t MSS_EXP_FW_VERSION_A_ATTR;
typedef uint32_t ATTR_MSS_EXP_FW_VERSION_A_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_FW_VERSION_B attribute
typedef uint32_t MSS_EXP_FW_VERSION_B_ATTR;
typedef uint32_t ATTR_MSS_EXP_FW_VERSION_B_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_FW_PARTITION_ID attribute
typedef uint32_t MSS_EXP_FW_PARTITION_ID_ATTR;
typedef uint32_t ATTR_MSS_EXP_FW_PARTITION_ID_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A attribute
typedef uint8_t MSS_EXP_FW_FAILED_AUTHENTICATION_A_ATTR;
typedef uint8_t ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B attribute
typedef uint8_t MSS_EXP_FW_FAILED_AUTHENTICATION_B_ATTR;
typedef uint8_t ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_COMM_STATE attribute
typedef uint8_t MSS_EXP_COMM_STATE_ATTR;
typedef uint8_t ATTR_MSS_EXP_COMM_STATE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC00 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC00_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC00_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC00_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC01 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC01_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC01_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC01_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC03 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC03_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC03_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC03_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC04 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC04_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC04_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC04_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC05 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC05_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC05_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC05_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC0B attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC0B_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC0B_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC0B_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC0E attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC0E_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC0E_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC0E_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC0F attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC0F_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC0F_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC0F_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC1X attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC1X_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC1X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC1X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F0RC7X attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F0RC7X_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F0RC7X_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F0RC7X_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F1RC00 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F1RC00_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F1RC00_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F1RC00_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F1RC02 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F1RC02_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F1RC02_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F1RC02_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F1RC03 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F1RC03_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F1RC03_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F1RC03_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F1RC04 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F1RC04_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F1RC04_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F1RC04_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DDR4_F1RC05 attribute
typedef uint8_t MSS_EXP_RESP_DDR4_F1RC05_ATTR[2];
typedef uint8_t ATTR_MSS_EXP_RESP_DDR4_F1RC05_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EXP_RESP_DDR4_F1RC05_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_RBT attribute
typedef uint8_t MSS_EXP_RESP_DRAM_RBT_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_RBT_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_TM attribute
typedef uint8_t MSS_EXP_RESP_DRAM_TM_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_TM_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_DLL_RESET attribute
typedef uint8_t MSS_EXP_RESP_DRAM_DLL_RESET_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_DLL_RESET_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH attribute
typedef uint8_t MSS_EXP_RESP_DRAM_BURST_LENGTH_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE attribute
typedef uint8_t MSS_EXP_RESP_DRAM_DLL_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_ODIC attribute
typedef uint8_t MSS_EXP_RESP_DRAM_ODIC_ATTR[2][4];
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_ODIC_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MSS_EXP_RESP_DRAM_ODIC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_AL attribute
typedef uint8_t MSS_EXP_RESP_DRAM_AL_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_AL_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE attribute
typedef uint8_t MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_RTT_NOM attribute
typedef uint8_t MSS_EXP_RESP_DRAM_RTT_NOM_ATTR[2][4];
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_RTT_NOM_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MSS_EXP_RESP_DRAM_RTT_NOM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_RTT_PARK attribute
typedef uint8_t MSS_EXP_RESP_DRAM_RTT_PARK_ATTR[2][4];
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_RTT_PARK_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MSS_EXP_RESP_DRAM_RTT_PARK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_TDQS attribute
typedef uint8_t MSS_EXP_RESP_DRAM_TDQS_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_TDQS_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER attribute
typedef uint8_t MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_LPASR attribute
typedef uint8_t MSS_EXP_RESP_DRAM_LPASR_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_LPASR_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DRAM_RTT_WR attribute
typedef uint8_t MSS_EXP_RESP_DRAM_RTT_WR_ATTR[2][4];
typedef uint8_t ATTR_MSS_EXP_RESP_DRAM_RTT_WR_type[2][4];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 4>, 2> ATTR_MSS_EXP_RESP_DRAM_RTT_WR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_MPR_PAGE attribute
typedef uint8_t MSS_EXP_RESP_MPR_PAGE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_MPR_PAGE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_MPR_MODE attribute
typedef uint8_t MSS_EXP_RESP_MPR_MODE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_MPR_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_GEARDOWN_MODE attribute
typedef uint8_t MSS_EXP_RESP_GEARDOWN_MODE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_GEARDOWN_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS attribute
typedef uint8_t MSS_EXP_RESP_PER_DRAM_ACCESS_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_TEMP_READOUT attribute
typedef uint8_t MSS_EXP_RESP_TEMP_READOUT_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_TEMP_READOUT_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_CRC_WR_LATENCY attribute
typedef uint8_t MSS_EXP_RESP_CRC_WR_LATENCY_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_CRC_WR_LATENCY_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_MPR_RD_FORMAT attribute
typedef uint8_t MSS_EXP_RESP_MPR_RD_FORMAT_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_MPR_RD_FORMAT_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE attribute
typedef uint8_t MSS_EXP_RESP_MAX_POWERDOWN_MODE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR attribute
typedef uint8_t MSS_EXP_RESP_INTERNAL_VREF_MONITOR_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_SELF_REF_ABORT attribute
typedef uint8_t MSS_EXP_RESP_SELF_REF_ABORT_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_SELF_REF_ABORT_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN attribute
typedef uint8_t MSS_EXP_RESP_RD_PREAMBLE_TRAIN_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_RD_PREAMBLE attribute
typedef uint8_t MSS_EXP_RESP_RD_PREAMBLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_RD_PREAMBLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_WR_PREAMBLE attribute
typedef uint8_t MSS_EXP_RESP_WR_PREAMBLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_WR_PREAMBLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR attribute
typedef uint8_t MSS_EXP_RESP_CRC_ERROR_CLEAR_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS attribute
typedef uint8_t MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF attribute
typedef uint8_t MSS_EXP_RESP_ODT_INPUT_BUFF_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_CA_PARITY attribute
typedef uint8_t MSS_EXP_RESP_CA_PARITY_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_CA_PARITY_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_DATA_MASK attribute
typedef uint8_t MSS_EXP_RESP_DATA_MASK_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_DATA_MASK_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_WRITE_DBI attribute
typedef uint8_t MSS_EXP_RESP_WRITE_DBI_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_WRITE_DBI_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_READ_DBI attribute
typedef uint8_t MSS_EXP_RESP_READ_DBI_ATTR;
typedef uint8_t ATTR_MSS_EXP_RESP_READ_DBI_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE attribute
typedef uint8_t MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE_ATTR[2][4][20];
typedef uint8_t ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE attribute
typedef uint8_t MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_ATTR[2][4][20];
typedef uint8_t ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE attribute
typedef uint8_t MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_ATTR[2][4][20];
typedef uint8_t ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_type[2][4][20];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 20>, 4>, 2> ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE attribute
typedef uint8_t MSS_EXP_CDR_BW_OVERRIDE_ENABLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE attribute
typedef uint8_t MSS_EXP_CDR_BW_OVERRIDE_VALUE_ATTR;
typedef uint8_t ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE attribute
typedef uint8_t MSS_EXP_OMI_CDR_BW_OVERRIDE_ATTR;
typedef uint8_t ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT attribute
typedef uint32_t MSS_EXP_OMI_SETUP_POLL_COUNT_ATTR;
typedef uint32_t ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_OMI_CDR_OFFSET attribute
typedef uint8_t MSS_EXP_OMI_CDR_OFFSET_ATTR;
typedef uint8_t ATTR_MSS_EXP_OMI_CDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK attribute
typedef uint8_t MSS_EXP_OMI_CDR_OFFSET_LANE_MASK_ATTR;
typedef uint8_t ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_INTR_MASK_DISABLE attribute
typedef uint8_t MSS_EXP_INTR_MASK_DISABLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_INTR_MASK_DISABLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE attribute
typedef uint8_t MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_ATTR;
typedef uint8_t ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_type;

// Type aliases and/or sizes for ATTR_MSS_EXP_SERIAL_NUMBER attribute
typedef uint8_t MSS_EXP_SERIAL_NUMBER_ATTR[26];
typedef uint8_t ATTR_MSS_EXP_SERIAL_NUMBER_type[26];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 26> ATTR_MSS_EXP_SERIAL_NUMBER_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_PSTATES attribute
typedef uint8_t MEM_EFF_PSTATES_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_PSTATES_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_PSTATES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_FOUR_RANK_MODE attribute
typedef uint8_t MEM_EFF_FOUR_RANK_MODE_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_FOUR_RANK_MODE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_FOUR_RANK_MODE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_MRAM_SUPPORT attribute
typedef uint8_t MEM_EFF_MRAM_SUPPORT_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_MRAM_SUPPORT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_MRAM_SUPPORT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_DDP_COMPATIBILITY attribute
typedef uint8_t MEM_EFF_DDP_COMPATIBILITY_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_DDP_COMPATIBILITY_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_DDP_COMPATIBILITY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_TSV_8H_SUPPORT attribute
typedef uint8_t MEM_EFF_TSV_8H_SUPPORT_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_TSV_8H_SUPPORT_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_TSV_8H_SUPPORT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MEM_EFF_MDS_DDIMM attribute
typedef uint8_t MEM_EFF_MDS_DDIMM_ATTR[2];
typedef uint8_t ATTR_MEM_EFF_MDS_DDIMM_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MEM_EFF_MDS_DDIMM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_OMI_DL_PREIPL_PRBS_TIME attribute
typedef uint32_t OMI_DL_PREIPL_PRBS_TIME_ATTR;
typedef uint32_t ATTR_OMI_DL_PREIPL_PRBS_TIME_type;

// Type aliases and/or sizes for ATTR_EXP_DATABUS_UTIL attribute
typedef uint32_t EXP_DATABUS_UTIL_ATTR;
typedef uint32_t ATTR_EXP_DATABUS_UTIL_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE attribute
typedef uint8_t MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_ATTR;
typedef uint8_t ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_type;

// Type aliases and/or sizes for ATTR_OMI_FFE_SETTINGS_COMMAND attribute
typedef uint8_t OMI_FFE_SETTINGS_COMMAND_ATTR;
typedef uint8_t ATTR_OMI_FFE_SETTINGS_COMMAND_type;

// Type aliases and/or sizes for ATTR_OMI_FFE_PRE_CURSOR attribute
typedef uint32_t OMI_FFE_PRE_CURSOR_ATTR;
typedef uint32_t ATTR_OMI_FFE_PRE_CURSOR_type;

// Type aliases and/or sizes for ATTR_OMI_FFE_POST_CURSOR attribute
typedef uint32_t OMI_FFE_POST_CURSOR_ATTR;
typedef uint32_t ATTR_OMI_FFE_POST_CURSOR_type;

// Type aliases and/or sizes for ATTR_ODY_ENABLE_US_TMPL_1 attribute
typedef uint8_t ODY_ENABLE_US_TMPL_1_ATTR;
typedef uint8_t ATTR_ODY_ENABLE_US_TMPL_1_type;

// Type aliases and/or sizes for ATTR_ODY_ENABLE_US_TMPL_5 attribute
typedef uint8_t ODY_ENABLE_US_TMPL_5_ATTR;
typedef uint8_t ATTR_ODY_ENABLE_US_TMPL_5_type;

// Type aliases and/or sizes for ATTR_ODY_ENABLE_US_TMPL_9 attribute
typedef uint8_t ODY_ENABLE_US_TMPL_9_ATTR;
typedef uint8_t ATTR_ODY_ENABLE_US_TMPL_9_type;

// Type aliases and/or sizes for ATTR_ODY_ENABLE_US_TMPL_A attribute
typedef uint8_t ODY_ENABLE_US_TMPL_A_ATTR;
typedef uint8_t ATTR_ODY_ENABLE_US_TMPL_A_type;

// Type aliases and/or sizes for ATTR_ODY_ENABLE_US_TMPL_B attribute
typedef uint8_t ODY_ENABLE_US_TMPL_B_ATTR;
typedef uint8_t ATTR_ODY_ENABLE_US_TMPL_B_type;

// Type aliases and/or sizes for ATTR_ODY_TMPL_0_PACING attribute
typedef uint8_t ODY_TMPL_0_PACING_ATTR;
typedef uint8_t ATTR_ODY_TMPL_0_PACING_type;

// Type aliases and/or sizes for ATTR_ODY_TMPL_1_PACING attribute
typedef uint8_t ODY_TMPL_1_PACING_ATTR;
typedef uint8_t ATTR_ODY_TMPL_1_PACING_type;

// Type aliases and/or sizes for ATTR_ODY_TMPL_5_PACING attribute
typedef uint8_t ODY_TMPL_5_PACING_ATTR;
typedef uint8_t ATTR_ODY_TMPL_5_PACING_type;

// Type aliases and/or sizes for ATTR_ODY_TMPL_9_PACING attribute
typedef uint8_t ODY_TMPL_9_PACING_ATTR;
typedef uint8_t ATTR_ODY_TMPL_9_PACING_type;

// Type aliases and/or sizes for ATTR_ODY_TMPL_B_PACING attribute
typedef uint8_t ODY_TMPL_B_PACING_ATTR;
typedef uint8_t ATTR_ODY_TMPL_B_PACING_type;

// Type aliases and/or sizes for ATTR_ODY_SHRT_BACKOFF_TIMER attribute
typedef uint8_t ODY_SHRT_BACKOFF_TIMER_ATTR;
typedef uint8_t ATTR_ODY_SHRT_BACKOFF_TIMER_type;

// Type aliases and/or sizes for ATTR_ODY_METADATA_ENABLE attribute
typedef uint8_t ODY_METADATA_ENABLE_ATTR;
typedef uint8_t ATTR_ODY_METADATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_ODY_PASID_BASE attribute
typedef uint32_t ODY_PASID_BASE_ATTR;
typedef uint32_t ATTR_ODY_PASID_BASE_type;

// Type aliases and/or sizes for ATTR_ODY_ACTAG_BASE attribute
typedef uint32_t ODY_ACTAG_BASE_ATTR;
typedef uint32_t ATTR_ODY_ACTAG_BASE_type;

// Type aliases and/or sizes for ATTR_ODY_AFU_ACTAG_LEN attribute
typedef uint32_t ODY_AFU_ACTAG_LEN_ATTR;
typedef uint32_t ATTR_ODY_AFU_ACTAG_LEN_type;

// Type aliases and/or sizes for ATTR_ODY_PASID_LEN attribute
typedef uint8_t ODY_PASID_LEN_ATTR;
typedef uint8_t ATTR_ODY_PASID_LEN_type;

// Type aliases and/or sizes for ATTR_SPPE_TARGET_STATE attribute
typedef uint8_t SPPE_TARGET_STATE_ATTR;
typedef uint8_t ATTR_SPPE_TARGET_STATE_type;

// Type aliases and/or sizes for ATTR_SPPE_I2C_DEV_ADDR attribute
typedef uint8_t SPPE_I2C_DEV_ADDR_ATTR;
typedef uint8_t ATTR_SPPE_I2C_DEV_ADDR_type;

// Type aliases and/or sizes for ATTR_SPPE_I2C_ENGINE attribute
typedef uint8_t SPPE_I2C_ENGINE_ATTR;
typedef uint8_t ATTR_SPPE_I2C_ENGINE_type;

// Type aliases and/or sizes for ATTR_SPPE_I2C_PORT attribute
typedef uint8_t SPPE_I2C_PORT_ATTR;
typedef uint8_t ATTR_SPPE_I2C_PORT_type;

// Type aliases and/or sizes for ATTR_SPPE_I2C_MAX_RETRY_COUNT attribute
typedef uint8_t SPPE_I2C_MAX_RETRY_COUNT_ATTR;
typedef uint8_t ATTR_SPPE_I2C_MAX_RETRY_COUNT_type;

// Type aliases and/or sizes for ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL attribute
typedef uint8_t MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_ATTR;
typedef uint8_t ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_type;

// Type aliases and/or sizes for ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT attribute
typedef uint8_t MSS_ODY_PASSED_SWIZZLE_DETECT_ATTR;
typedef uint8_t ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT_type;

// Type aliases and/or sizes for ATTR_MSS_ODY_PHY_IMAGE_SELECT attribute
typedef uint8_t MSS_ODY_PHY_IMAGE_SELECT_ATTR;
typedef uint8_t ATTR_MSS_ODY_PHY_IMAGE_SELECT_type;

// Type aliases and/or sizes for ATTR_ODY_MSG_BLOCK_DATA_SOURCE attribute
typedef uint8_t ODY_MSG_BLOCK_DATA_SOURCE_ATTR;
typedef uint8_t ATTR_ODY_MSG_BLOCK_DATA_SOURCE_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE attribute
typedef uint8_t ODY_DRAMINIT_ERROR_ON_FAILURE_ATTR;
typedef uint8_t ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_RECOVERY_ENABLE attribute
typedef uint8_t ODY_DRAMINIT_RECOVERY_ENABLE_ATTR;
typedef uint8_t ATTR_ODY_DRAMINIT_RECOVERY_ENABLE_type;

// Type aliases and/or sizes for ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE attribute
typedef uint16_t ODY_SWIZZLE_DETECT_FAIL_VALUE_ATTR;
typedef uint16_t ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE attribute
typedef uint8_t ODY_DRAMINIT_FIR_CHECK_ENABLE_ATTR;
typedef uint8_t ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_STEP_ENABLE attribute
typedef uint8_t ODY_DRAMINIT_STEP_ENABLE_ATTR;
typedef uint8_t ATTR_ODY_DRAMINIT_STEP_ENABLE_type;

// Type aliases and/or sizes for ATTR_ODY_SENSOR_POLLING_PERIOD_MS attribute
typedef uint32_t ODY_SENSOR_POLLING_PERIOD_MS_ATTR;
typedef uint32_t ATTR_ODY_SENSOR_POLLING_PERIOD_MS_type;

// Type aliases and/or sizes for ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT attribute
typedef uint32_t ODY_SENSOR_POLLING_PERIOD_MS_INIT_ATTR;
typedef uint32_t ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET attribute
typedef uint8_t ODY_DQS_TRACKING_HALF_DIMM_TARGET_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_PERIOD attribute
typedef uint8_t ODY_DQS_TRACKING_PERIOD_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_PERIOD_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_PERIOD_INIT attribute
typedef uint8_t ODY_DQS_TRACKING_PERIOD_INIT_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_PERIOD_INIT_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD attribute
typedef uint8_t ODY_DQS_TRACKING_TEMP_THRESHOLD_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD attribute
typedef uint16_t ODY_DQS_TRACKING_COUNT_THRESHOLD_ATTR;
typedef uint16_t ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL attribute
typedef uint16_t ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL_ATTR;
typedef uint16_t ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_RECAL_COUNT attribute
typedef uint16_t ODY_DQS_TRACKING_RECAL_COUNT_ATTR;
typedef uint16_t ATTR_ODY_DQS_TRACKING_RECAL_COUNT_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_LOG attribute
typedef uint64_t ODY_DQS_TRACKING_LOG_ATTR[24];
typedef uint64_t ATTR_ODY_DQS_TRACKING_LOG_type[24];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 24> ATTR_ODY_DQS_TRACKING_LOG_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE attribute
typedef int16_t ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE_ATTR;
typedef int16_t ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_SUSPENDED attribute
typedef uint8_t ODY_DQS_TRACKING_SUSPENDED_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_SUSPENDED_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT attribute
typedef uint8_t ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT_type;

// Type aliases and/or sizes for ATTR_ODY_DQS_TRACKING_FAILED attribute
typedef uint8_t ODY_DQS_TRACKING_FAILED_ATTR;
typedef uint8_t ATTR_ODY_DQS_TRACKING_FAILED_type;

// Type aliases and/or sizes for ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE attribute
typedef int16_t ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE_ATTR;
typedef int16_t ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE attribute
typedef int16_t ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE_ATTR;
typedef int16_t ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE attribute
typedef int16_t ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE_ATTR;
typedef int16_t ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE attribute
typedef int16_t ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE_ATTR;
typedef int16_t ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_SENSOR_READ_FIRST_FAIL attribute
typedef uint8_t ODY_SENSOR_READ_FIRST_FAIL_ATTR[5];
typedef uint8_t ATTR_ODY_SENSOR_READ_FIRST_FAIL_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 5> ATTR_ODY_SENSOR_READ_FIRST_FAIL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_VERBOSITY attribute
typedef uint8_t ODY_DRAMINIT_VERBOSITY_ATTR;
typedef uint8_t ATTR_ODY_DRAMINIT_VERBOSITY_type;

// Type aliases and/or sizes for ATTR_PHY_GET_MAIL_TIMEOUT attribute
typedef uint64_t PHY_GET_MAIL_TIMEOUT_ATTR;
typedef uint64_t ATTR_PHY_GET_MAIL_TIMEOUT_type;

// Type aliases and/or sizes for ATTR_DRAMINIT_TRAINING_TIMEOUT attribute
typedef uint64_t DRAMINIT_TRAINING_TIMEOUT_ATTR;
typedef uint64_t ATTR_DRAMINIT_TRAINING_TIMEOUT_type;

// Type aliases and/or sizes for ATTR_MAIL_MESSAGE_BITMAP attribute
typedef uint32_t MAIL_MESSAGE_BITMAP_ATTR;
typedef uint32_t ATTR_MAIL_MESSAGE_BITMAP_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_ARDPTRINITVAL attribute
typedef uint8_t MEM_EFF_ARDPTRINITVAL_ATTR;
typedef uint8_t ATTR_MEM_EFF_ARDPTRINITVAL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_ARDPTRINITVALOVR attribute
typedef uint8_t MEM_EFF_ARDPTRINITVALOVR_ATTR;
typedef uint8_t ATTR_MEM_EFF_ARDPTRINITVALOVR_type;

// Type aliases and/or sizes for ATTR_ODY_DIS_PTRINITCLR_TXTRACKING attribute
typedef uint8_t ODY_DIS_PTRINITCLR_TXTRACKING_ATTR;
typedef uint8_t ATTR_ODY_DIS_PTRINITCLR_TXTRACKING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EXTCALRESVAL attribute
typedef uint8_t MEM_EFF_EXTCALRESVAL_ATTR;
typedef uint8_t ATTR_MEM_EFF_EXTCALRESVAL_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_MEMALERTEN attribute
typedef uint8_t MEM_EFF_MEMALERTEN_ATTR;
typedef uint8_t ATTR_MEM_EFF_MEMALERTEN_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_MSTRTRAIN_INTERVAL attribute
typedef uint8_t ODY_PHY_MSTRTRAIN_INTERVAL_ATTR;
typedef uint8_t ATTR_ODY_PHY_MSTRTRAIN_INTERVAL_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_MSTRMAXREQTOACK attribute
typedef uint8_t ODY_PHY_MSTRMAXREQTOACK_ATTR;
typedef uint8_t ATTR_ODY_PHY_MSTRMAXREQTOACK_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_MSTRCTRLMODE attribute
typedef uint8_t ODY_PHY_MSTRCTRLMODE_ATTR;
typedef uint8_t ATTR_ODY_PHY_MSTRCTRLMODE_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_CALINTERVAL attribute
typedef uint8_t ODY_PHY_CALINTERVAL_ATTR;
typedef uint8_t ATTR_ODY_PHY_CALINTERVAL_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_CALONCE attribute
typedef uint8_t ODY_PHY_CALONCE_ATTR;
typedef uint8_t ATTR_ODY_PHY_CALONCE_type;

// Type aliases and/or sizes for ATTR_ODY_IS_HIGHVDD attribute
typedef uint8_t ODY_IS_HIGHVDD_ATTR;
typedef uint8_t ATTR_ODY_IS_HIGHVDD_type;

// Type aliases and/or sizes for ATTR_ODY_EN_TDQS2DQ_TRACKING attribute
typedef uint8_t ODY_EN_TDQS2DQ_TRACKING_ATTR[4];
typedef uint8_t ATTR_ODY_EN_TDQS2DQ_TRACKING_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_ODY_EN_TDQS2DQ_TRACKING_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ODY_DQS_OSC_RUNTIME_SEL attribute
typedef uint16_t ODY_DQS_OSC_RUNTIME_SEL_ATTR;
typedef uint16_t ATTR_ODY_DQS_OSC_RUNTIME_SEL_type;

// Type aliases and/or sizes for ATTR_ODY_EN_RXDQS_TRACKING attribute
typedef uint8_t ODY_EN_RXDQS_TRACKING_ATTR;
typedef uint8_t ATTR_ODY_EN_RXDQS_TRACKING_type;

// Type aliases and/or sizes for ATTR_ODY_DISABLE_PMU_ECC attribute
typedef uint8_t ODY_DISABLE_PMU_ECC_ATTR;
typedef uint8_t ATTR_ODY_DISABLE_PMU_ECC_type;

// Type aliases and/or sizes for ATTR_ODY_ENABLE_MALERT_ASYNC attribute
typedef uint8_t ODY_ENABLE_MALERT_ASYNC_ATTR;
typedef uint8_t ATTR_ODY_ENABLE_MALERT_ASYNC_type;

// Type aliases and/or sizes for ATTR_ODY_ALERT_RECOV_ENABLE attribute
typedef uint8_t ODY_ALERT_RECOV_ENABLE_ATTR;
typedef uint8_t ATTR_ODY_ALERT_RECOV_ENABLE_type;

// Type aliases and/or sizes for ATTR_ODY_RST_RXTRK_STATE attribute
typedef uint8_t ODY_RST_RXTRK_STATE_ATTR;
typedef uint8_t ATTR_ODY_RST_RXTRK_STATE_type;

// Type aliases and/or sizes for ATTR_ODY_UPPERNIBBLE_OVERRIDE attribute
typedef uint8_t ODY_UPPERNIBBLE_OVERRIDE_ATTR;
typedef uint8_t ATTR_ODY_UPPERNIBBLE_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_ODY_UPPERNIBBLE_TG attribute
typedef uint16_t ODY_UPPERNIBBLE_TG_ATTR[4];
typedef uint16_t ATTR_ODY_UPPERNIBBLE_TG_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_ODY_UPPERNIBBLE_TG_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ODY_DFIPHYUPDCNT attribute
typedef uint8_t ODY_DFIPHYUPDCNT_ATTR;
typedef uint8_t ATTR_ODY_DFIPHYUPDCNT_type;

// Type aliases and/or sizes for ATTR_ODY_DFIPHYUPDRESP attribute
typedef uint8_t ODY_DFIPHYUPDRESP_ATTR;
typedef uint8_t ATTR_ODY_DFIPHYUPDRESP_type;

// Type aliases and/or sizes for ATTR_ODY_SIM_TDQS2DQ attribute
typedef uint16_t ODY_SIM_TDQS2DQ_ATTR;
typedef uint16_t ATTR_ODY_SIM_TDQS2DQ_type;

// Type aliases and/or sizes for ATTR_ODY_SIM_TDQSCK attribute
typedef uint16_t ODY_SIM_TDQSCK_ATTR;
typedef uint16_t ATTR_ODY_SIM_TDQSCK_type;

// Type aliases and/or sizes for ATTR_ODY_SIM_TSTAOFF attribute
typedef uint16_t ODY_SIM_TSTAOFF_ATTR;
typedef uint16_t ATTR_ODY_SIM_TSTAOFF_type;

// Type aliases and/or sizes for ATTR_ODY_SIM_TPDM attribute
typedef uint16_t ODY_SIM_TPDM_ATTR;
typedef uint16_t ATTR_ODY_SIM_TPDM_type;

// Type aliases and/or sizes for ATTR_ODY_SIM_TCASL_OVERRIDE attribute
typedef uint8_t ODY_SIM_TCASL_OVERRIDE_ATTR;
typedef uint8_t ATTR_ODY_SIM_TCASL_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_ODY_SIM_TCASL_ADD attribute
typedef uint16_t ODY_SIM_TCASL_ADD_ATTR[4];
typedef uint16_t ATTR_ODY_SIM_TCASL_ADD_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_ODY_SIM_TCASL_ADD_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ODY_POWERDOWN_ANIBS attribute
typedef uint16_t ODY_POWERDOWN_ANIBS_ATTR;
typedef uint16_t ATTR_ODY_POWERDOWN_ANIBS_type;

// Type aliases and/or sizes for ATTR_ODY_LP2_PWRSAVINGS attribute
typedef uint8_t ODY_LP2_PWRSAVINGS_ATTR;
typedef uint8_t ATTR_ODY_LP2_PWRSAVINGS_type;

// Type aliases and/or sizes for ATTR_ODY_SPECIAL_OFFSET_VALUE attribute
typedef uint16_t ODY_SPECIAL_OFFSET_VALUE_ATTR;
typedef uint16_t ATTR_ODY_SPECIAL_OFFSET_VALUE_type;

// Type aliases and/or sizes for ATTR_ODY_ADV_TRAIN_OPT attribute
typedef uint8_t ODY_ADV_TRAIN_OPT_ATTR;
typedef uint8_t ATTR_ODY_ADV_TRAIN_OPT_type;

// Type aliases and/or sizes for ATTR_ODY_MSG_MISC attribute
typedef uint8_t ODY_MSG_MISC_ATTR;
typedef uint8_t ATTR_ODY_MSG_MISC_type;

// Type aliases and/or sizes for ATTR_ODY_PLL_BYPASS_EN attribute
typedef uint8_t ODY_PLL_BYPASS_EN_ATTR;
typedef uint8_t ATTR_ODY_PLL_BYPASS_EN_type;

// Type aliases and/or sizes for ATTR_ODY_RX2D_DFE_MISC attribute
typedef uint8_t ODY_RX2D_DFE_MISC_ATTR;
typedef uint8_t ATTR_ODY_RX2D_DFE_MISC_type;

// Type aliases and/or sizes for ATTR_ODY_D5MISC attribute
typedef uint8_t ODY_D5MISC_ATTR;
typedef uint8_t ATTR_ODY_D5MISC_type;

// Type aliases and/or sizes for ATTR_ODY_WL_ADJ attribute
typedef uint8_t ODY_WL_ADJ_ATTR;
typedef uint8_t ATTR_ODY_WL_ADJ_type;

// Type aliases and/or sizes for ATTR_ODY_SEQUENCE_CTRL attribute
typedef uint16_t ODY_SEQUENCE_CTRL_ATTR;
typedef uint16_t ATTR_ODY_SEQUENCE_CTRL_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_CFG attribute
typedef uint8_t ODY_PHY_CFG_ATTR;
typedef uint8_t ATTR_ODY_PHY_CFG_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_DFIMRL_MARGIN attribute
typedef uint8_t ODY_PHY_DFIMRL_MARGIN_ATTR;
typedef uint8_t ATTR_ODY_PHY_DFIMRL_MARGIN_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_USE_BROADCAST_MR attribute
typedef uint8_t ODY_PHY_USE_BROADCAST_MR_ATTR;
typedef uint8_t ATTR_ODY_PHY_USE_BROADCAST_MR_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_DISABLED_DBYTE attribute
typedef uint8_t ODY_PHY_DISABLED_DBYTE_ATTR;
typedef uint8_t ATTR_ODY_PHY_DISABLED_DBYTE_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_CA_TRAIN_OPTIONS attribute
typedef uint8_t ODY_PHY_CA_TRAIN_OPTIONS_ATTR;
typedef uint8_t ATTR_ODY_PHY_CA_TRAIN_OPTIONS_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS attribute
typedef uint8_t ODY_PHY_CA_DFE_TRAIN_OPTIONS_ATTR;
typedef uint8_t ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_TX2D_DFE_MISC attribute
typedef uint8_t ODY_PHY_TX2D_DFE_MISC_ATTR;
typedef uint8_t ATTR_ODY_PHY_TX2D_DFE_MISC_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_RX2D_TRAIN_OPT attribute
typedef uint8_t ODY_PHY_RX2D_TRAIN_OPT_ATTR;
typedef uint8_t ATTR_ODY_PHY_RX2D_TRAIN_OPT_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_TX2D_TRAIN_OPT attribute
typedef uint8_t ODY_PHY_TX2D_TRAIN_OPT_ATTR;
typedef uint8_t ATTR_ODY_PHY_TX2D_TRAIN_OPT_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS attribute
typedef uint8_t ODY_PHY_DEBUG_TRAIN_OPTIONS_ATTR;
typedef uint8_t ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_CONFIG_OVERRIDE attribute
typedef uint16_t ODY_PHY_CONFIG_OVERRIDE_ATTR;
typedef uint16_t ATTR_ODY_PHY_CONFIG_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_ENABLED_DQ_CHA attribute
typedef uint8_t ODY_PHY_ENABLED_DQ_CHA_ATTR;
typedef uint8_t ATTR_ODY_PHY_ENABLED_DQ_CHA_type;

// Type aliases and/or sizes for ATTR_ODY_PHY_ENABLED_DQ_CHB attribute
typedef uint8_t ODY_PHY_ENABLED_DQ_CHB_ATTR;
typedef uint8_t ATTR_ODY_PHY_ENABLED_DQ_CHB_type;

// Type aliases and/or sizes for ATTR_ODY_TX_IMPEDANCE_CTRL1 attribute
typedef uint16_t ODY_TX_IMPEDANCE_CTRL1_ATTR;
typedef uint16_t ATTR_ODY_TX_IMPEDANCE_CTRL1_type;

// Type aliases and/or sizes for ATTR_ODY_TX_IMPEDANCE_CTRL2 attribute
typedef uint16_t ODY_TX_IMPEDANCE_CTRL2_ATTR;
typedef uint16_t ATTR_ODY_TX_IMPEDANCE_CTRL2_type;

// Type aliases and/or sizes for ATTR_ODY_MRR_ODT_TERM attribute
typedef uint8_t ODY_MRR_ODT_TERM_ATTR;
typedef uint8_t ATTR_ODY_MRR_ODT_TERM_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_FW_REVISION attribute
typedef uint16_t ODY_DRAMINIT_FW_REVISION_ATTR;
typedef uint16_t ATTR_ODY_DRAMINIT_FW_REVISION_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0 attribute
typedef uint16_t ODY_DRAMINIT_INTERNAL_FW_REVISION0_ATTR;
typedef uint16_t ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1 attribute
typedef uint16_t ODY_DRAMINIT_INTERNAL_FW_REVISION1_ATTR;
typedef uint16_t ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1_type;

// Type aliases and/or sizes for ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET attribute
typedef uint16_t ODY_DRAMINIT_FW_DATA_ADDR_OFFSET_ATTR;
typedef uint16_t ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET_type;

// Type aliases and/or sizes for ATTR_ODY_DMEM_FIRST_LOAD attribute
typedef uint8_t ODY_DMEM_FIRST_LOAD_ATTR;
typedef uint8_t ATTR_ODY_DMEM_FIRST_LOAD_type;

// Type aliases and/or sizes for ATTR_ODY_PSRO attribute
typedef uint64_t ODY_PSRO_ATTR;
typedef uint64_t ATTR_ODY_PSRO_type;

// Type aliases and/or sizes for ATTR_ODY_SETUP_SAFEMODE_THROTTLES attribute
typedef uint8_t ODY_SETUP_SAFEMODE_THROTTLES_ATTR;
typedef uint8_t ATTR_ODY_SETUP_SAFEMODE_THROTTLES_type;

// Type aliases and/or sizes for ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0 attribute
typedef uint8_t ODY_DISABLE_DRAM_WITH_BAD_DQ0_ATTR;
typedef uint8_t ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0_type;

// Type aliases and/or sizes for ATTR_OMI_RX_LANES attribute
typedef uint32_t OMI_RX_LANES_ATTR;
typedef uint32_t ATTR_OMI_RX_LANES_type;

// Type aliases and/or sizes for ATTR_OMI_TX_LANES attribute
typedef uint32_t OMI_TX_LANES_ATTR;
typedef uint32_t ATTR_OMI_TX_LANES_type;

// Type aliases and/or sizes for ATTR_OMI_BIST_ESD_TEST attribute
typedef uint8_t OMI_BIST_ESD_TEST_ATTR;
typedef uint8_t ATTR_OMI_BIST_ESD_TEST_type;

// Type aliases and/or sizes for ATTR_OMI_BIST_DAC_TEST attribute
typedef uint8_t OMI_BIST_DAC_TEST_ATTR;
typedef uint8_t ATTR_OMI_BIST_DAC_TEST_type;

// Type aliases and/or sizes for ATTR_OMI_BIST_TIMER attribute
typedef uint8_t OMI_BIST_TIMER_ATTR;
typedef uint8_t ATTR_OMI_BIST_TIMER_type;

// Type aliases and/or sizes for ATTR_OMI_CHANNEL_LENGTH attribute
typedef uint32_t OMI_CHANNEL_LENGTH_ATTR;
typedef uint32_t ATTR_OMI_CHANNEL_LENGTH_type;

// Type aliases and/or sizes for ATTR_OMI_RX_LTEG attribute
typedef int32_t OMI_RX_LTEG_ATTR;
typedef int32_t ATTR_OMI_RX_LTEG_type;

// Type aliases and/or sizes for ATTR_OMI_RX_LTEZ attribute
typedef int32_t OMI_RX_LTEZ_ATTR;
typedef int32_t ATTR_OMI_RX_LTEZ_type;

// Type aliases and/or sizes for ATTR_OMI_TX_PRE1 attribute
typedef uint8_t OMI_TX_PRE1_ATTR;
typedef uint8_t ATTR_OMI_TX_PRE1_type;

// Type aliases and/or sizes for ATTR_OMI_TX_PRE2 attribute
typedef uint8_t OMI_TX_PRE2_ATTR;
typedef uint8_t ATTR_OMI_TX_PRE2_type;

// Type aliases and/or sizes for ATTR_OMI_TX_POST attribute
typedef uint8_t OMI_TX_POST_ATTR;
typedef uint8_t ATTR_OMI_TX_POST_type;

// Type aliases and/or sizes for ATTR_OMI_RX_VERT_OFFSET attribute
typedef uint8_t OMI_RX_VERT_OFFSET_ATTR;
typedef uint8_t ATTR_OMI_RX_VERT_OFFSET_type;

// Type aliases and/or sizes for ATTR_OMI_RX_HORIZ_DATA_OFFSET attribute
typedef uint8_t OMI_RX_HORIZ_DATA_OFFSET_ATTR;
typedef uint8_t ATTR_OMI_RX_HORIZ_DATA_OFFSET_type;

// Type aliases and/or sizes for ATTR_OMI_RX_HORIZ_EDGE_OFFSET attribute
typedef uint8_t OMI_RX_HORIZ_EDGE_OFFSET_ATTR;
typedef uint8_t ATTR_OMI_RX_HORIZ_EDGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_OMI_EDPL attribute
typedef uint8_t OMI_EDPL_ATTR;
typedef uint8_t ATTR_OMI_EDPL_type;

// Type aliases and/or sizes for ATTR_HOTPLUG attribute
typedef uint8_t HOTPLUG_ATTR;
typedef uint8_t ATTR_HOTPLUG_type;

// Type aliases and/or sizes for ATTR_HOTPLUG_MASK attribute
typedef uint64_t HOTPLUG_MASK_ATTR;
typedef uint64_t ATTR_HOTPLUG_MASK_type;

// Type aliases and/or sizes for ATTR_OCMB_REL_POS attribute
typedef uint8_t OCMB_REL_POS_ATTR;
typedef uint8_t ATTR_OCMB_REL_POS_type;

// Type aliases and/or sizes for ATTR_OCMB_PLL_BUCKET attribute
typedef uint8_t OCMB_PLL_BUCKET_ATTR;
typedef uint8_t ATTR_OCMB_PLL_BUCKET_type;

// Type aliases and/or sizes for ATTR_OCMB_PLL_BUCKET_SIM attribute
typedef uint8_t OCMB_PLL_BUCKET_SIM_ATTR;
typedef uint8_t ATTR_OCMB_PLL_BUCKET_SIM_type;

// Type aliases and/or sizes for ATTR_SIM_CHIPLET_MASK attribute
typedef uint64_t SIM_CHIPLET_MASK_ATTR;
typedef uint64_t ATTR_SIM_CHIPLET_MASK_type;

// Type aliases and/or sizes for ATTR_SCAN0_SCAN_RATIO attribute
typedef uint8_t SCAN0_SCAN_RATIO_ATTR;
typedef uint8_t ATTR_SCAN0_SCAN_RATIO_type;

// Type aliases and/or sizes for ATTR_SPPE_BOOT_SIDE attribute
typedef uint8_t SPPE_BOOT_SIDE_ATTR;
typedef uint8_t ATTR_SPPE_BOOT_SIDE_type;

// Type aliases and/or sizes for ATTR_OCMB_BOOT_FLAGS attribute
typedef uint32_t OCMB_BOOT_FLAGS_ATTR;
typedef uint32_t ATTR_OCMB_BOOT_FLAGS_type;

// Type aliases and/or sizes for ATTR_ENABLE_LBIST attribute
typedef uint8_t ENABLE_LBIST_ATTR;
typedef uint8_t ATTR_ENABLE_LBIST_type;

// Type aliases and/or sizes for ATTR_ENABLE_ABIST attribute
typedef uint8_t ENABLE_ABIST_ATTR;
typedef uint8_t ATTR_ENABLE_ABIST_type;

// Type aliases and/or sizes for ATTR_SECURITY_LEVEL attribute
typedef uint8_t SECURITY_LEVEL_ATTR;
typedef uint8_t ATTR_SECURITY_LEVEL_type;

// Type aliases and/or sizes for ATTR_RTG_SCAN_ORDER attribute
typedef uint8_t RTG_SCAN_ORDER_ATTR;
typedef uint8_t ATTR_RTG_SCAN_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_PMIC_4U_N_MODE attribute
typedef uint8_t MEM_PMIC_4U_N_MODE_ATTR;
typedef uint8_t ATTR_MEM_PMIC_4U_N_MODE_type;

// Type aliases and/or sizes for ATTR_MEM_PMIC_FORCE_N_MODE attribute
typedef uint8_t MEM_PMIC_FORCE_N_MODE_ATTR;
typedef uint8_t ATTR_MEM_PMIC_FORCE_N_MODE_type;

// Type aliases and/or sizes for ATTR_I2C_FAIL_COUNT attribute
typedef uint8_t I2C_FAIL_COUNT_ATTR;
typedef uint8_t ATTR_I2C_FAIL_COUNT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_MFG_ID attribute
typedef uint16_t MEM_EFF_PMIC0_MFG_ID_ATTR;
typedef uint16_t ATTR_MEM_EFF_PMIC0_MFG_ID_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40 attribute
typedef uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG0_R40_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41 attribute
typedef uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG1_R41_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42 attribute
typedef uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG2_R42_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43 attribute
typedef uint8_t MEM_EFF_PMIC0_SEQUENCE_CFG3_R43_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_MFG_ID attribute
typedef uint16_t MEM_EFF_PMIC1_MFG_ID_ATTR;
typedef uint16_t ATTR_MEM_EFF_PMIC1_MFG_ID_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40 attribute
typedef uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG0_R40_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41 attribute
typedef uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG1_R41_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42 attribute
typedef uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG2_R42_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43 attribute
typedef uint8_t MEM_EFF_PMIC1_SEQUENCE_CFG3_R43_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_MFG_ID attribute
typedef uint16_t MEM_EFF_PMIC2_MFG_ID_ATTR;
typedef uint16_t ATTR_MEM_EFF_PMIC2_MFG_ID_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40 attribute
typedef uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG0_R40_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41 attribute
typedef uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG1_R41_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42 attribute
typedef uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG2_R42_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43 attribute
typedef uint8_t MEM_EFF_PMIC2_SEQUENCE_CFG3_R43_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_MFG_ID attribute
typedef uint16_t MEM_EFF_PMIC3_MFG_ID_ATTR;
typedef uint16_t ATTR_MEM_EFF_PMIC3_MFG_ID_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40 attribute
typedef uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG0_R40_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41 attribute
typedef uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG1_R41_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42 attribute
typedef uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG2_R42_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING attribute
typedef uint8_t MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT attribute
typedef uint8_t MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET attribute
typedef uint8_t MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY attribute
typedef uint8_t MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER attribute
typedef uint8_t MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43 attribute
typedef uint8_t MEM_EFF_PMIC3_SEQUENCE_CFG3_R43_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_REDUNDANCY attribute
typedef uint8_t MEM_EFF_PMIC0_REDUNDANCY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_REDUNDANCY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_REVISION attribute
typedef uint8_t MEM_EFF_PMIC0_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_PHASE_COMB attribute
typedef uint8_t MEM_EFF_PMIC0_PHASE_COMB_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_PHASE_COMB_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SEQUENCE attribute
typedef uint8_t MEM_EFF_PMIC0_SEQUENCE_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SEQUENCE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC0_SWA_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC0_SWB_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC0_SWC_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC0_SWD_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_REDUNDANCY attribute
typedef uint8_t MEM_EFF_PMIC1_REDUNDANCY_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_REDUNDANCY_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_REVISION attribute
typedef uint8_t MEM_EFF_PMIC1_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_PHASE_COMB attribute
typedef uint8_t MEM_EFF_PMIC1_PHASE_COMB_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_PHASE_COMB_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SEQUENCE attribute
typedef uint8_t MEM_EFF_PMIC1_SEQUENCE_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SEQUENCE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC1_SWA_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC1_SWB_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC1_SWC_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC1_SWD_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_REVISION attribute
typedef uint8_t MEM_EFF_PMIC2_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_PHASE_COMB attribute
typedef uint8_t MEM_EFF_PMIC2_PHASE_COMB_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_PHASE_COMB_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SEQUENCE attribute
typedef uint8_t MEM_EFF_PMIC2_SEQUENCE_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SEQUENCE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC2_SWA_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC2_SWB_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC2_SWC_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC2_SWD_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_REVISION attribute
typedef uint8_t MEM_EFF_PMIC3_REVISION_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_REVISION_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_PHASE_COMB attribute
typedef uint8_t MEM_EFF_PMIC3_PHASE_COMB_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_PHASE_COMB_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SEQUENCE attribute
typedef uint8_t MEM_EFF_PMIC3_SEQUENCE_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SEQUENCE_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET attribute
typedef int8_t MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET_ATTR;
typedef int8_t ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC3_SWA_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC3_SWB_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC3_SWC_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING attribute
typedef uint8_t MEM_EFF_PMIC3_SWD_CURRENT_WARNING_ATTR;
typedef uint8_t ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING_type;

// Type aliases and/or sizes for ATTR_FREQ_PB_MHZ attribute
typedef uint32_t FREQ_PB_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_PB_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_X_MHZ attribute
typedef uint32_t FREQ_X_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_X_MHZ_type;

// Type aliases and/or sizes for ATTR_MC_SYNC_MODE attribute
typedef uint8_t MC_SYNC_MODE_ATTR;
typedef uint8_t ATTR_MC_SYNC_MODE_type;

// Type aliases and/or sizes for ATTR_FREQ_CORE_NOMINAL_MHZ attribute
typedef uint32_t FREQ_CORE_NOMINAL_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_CORE_NOMINAL_MHZ_type;

// Type aliases and/or sizes for ATTR_BOOT_FREQ_MHZ attribute
typedef uint32_t BOOT_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_BOOT_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_RISK_LEVEL attribute
typedef uint8_t RISK_LEVEL_ATTR;
typedef uint8_t ATTR_RISK_LEVEL_type;

// Type aliases and/or sizes for ATTR_PM_RESET_FFDC_ENABLE attribute
typedef uint8_t PM_RESET_FFDC_ENABLE_ATTR;
typedef uint8_t ATTR_PM_RESET_FFDC_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_EFF_FABRIC_GROUP_ID attribute
typedef uint8_t PROC_EFF_FABRIC_GROUP_ID_ATTR;
typedef uint8_t ATTR_PROC_EFF_FABRIC_GROUP_ID_type;

// Type aliases and/or sizes for ATTR_HB_HRMOR_BYTES attribute
typedef uint64_t HB_HRMOR_BYTES_ATTR;
typedef uint64_t ATTR_HB_HRMOR_BYTES_type;

// Type aliases and/or sizes for ATTR_PROC_EFF_FABRIC_CHIP_ID attribute
typedef uint8_t PROC_EFF_FABRIC_CHIP_ID_ATTR;
typedef uint8_t ATTR_PROC_EFF_FABRIC_CHIP_ID_type;

// Type aliases and/or sizes for ATTR_FREQ_O_MHZ attribute
typedef uint32_t FREQ_O_MHZ_ATTR[4];
typedef uint32_t ATTR_FREQ_O_MHZ_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 4> ATTR_FREQ_O_MHZ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_OPTICS_CONFIG_MODE attribute
typedef uint8_t OPTICS_CONFIG_MODE_ATTR;
typedef uint8_t ATTR_OPTICS_CONFIG_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_RDVREF_CAL_ENABLE attribute
typedef uint16_t MSS_RDVREF_CAL_ENABLE_ATTR[2];
typedef uint16_t ATTR_MSS_RDVREF_CAL_ENABLE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 2> ATTR_MSS_RDVREF_CAL_ENABLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SKIP_HW_VREF_CAL attribute
typedef uint8_t SKIP_HW_VREF_CAL_ATTR;
typedef uint8_t ATTR_SKIP_HW_VREF_CAL_type;

// Type aliases and/or sizes for ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE attribute
typedef uint8_t SKIP_RD_VREF_VREFSENSE_OVERRIDE_ATTR;
typedef uint8_t ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE attribute
typedef uint8_t MSS_RTT_NOM_OVERRIDE_DISABLE_ATTR[2][2];
typedef uint8_t ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PERF_24x7_INVOCATION_TIME_MS attribute
typedef uint8_t PERF_24x7_INVOCATION_TIME_MS_ATTR;
typedef uint8_t ATTR_PERF_24x7_INVOCATION_TIME_MS_type;

// Type aliases and/or sizes for ATTR_CME_INSTRUCTION_TRACE_ENABLE attribute
typedef uint8_t CME_INSTRUCTION_TRACE_ENABLE_ATTR;
typedef uint8_t ATTR_CME_INSTRUCTION_TRACE_ENABLE_type;

// Type aliases and/or sizes for ATTR_SYS_VFRT_STATIC_DATA_ENABLE attribute
typedef uint8_t SYS_VFRT_STATIC_DATA_ENABLE_ATTR;
typedef uint8_t ATTR_SYS_VFRT_STATIC_DATA_ENABLE_type;

// Type aliases and/or sizes for ATTR_IO_OBUS_DCCAL_FLAGS attribute
typedef uint8_t IO_OBUS_DCCAL_FLAGS_ATTR;
typedef uint8_t ATTR_IO_OBUS_DCCAL_FLAGS_type;

// Type aliases and/or sizes for ATTR_IO_O_DEBUG attribute
typedef uint8_t IO_O_DEBUG_ATTR;
typedef uint8_t ATTR_IO_O_DEBUG_type;

// Type aliases and/or sizes for ATTR_IO_OBUS_TX_MARGIN_RATIO attribute
typedef uint8_t IO_OBUS_TX_MARGIN_RATIO_ATTR;
typedef uint8_t ATTR_IO_OBUS_TX_MARGIN_RATIO_type;

// Type aliases and/or sizes for ATTR_IO_OBUS_TX_FFE_PRECURSOR attribute
typedef uint8_t IO_OBUS_TX_FFE_PRECURSOR_ATTR;
typedef uint8_t ATTR_IO_OBUS_TX_FFE_PRECURSOR_type;

// Type aliases and/or sizes for ATTR_IO_OBUS_TX_FFE_POSTCURSOR attribute
typedef uint8_t IO_OBUS_TX_FFE_POSTCURSOR_ATTR;
typedef uint8_t ATTR_IO_OBUS_TX_FFE_POSTCURSOR_type;

// Type aliases and/or sizes for ATTR_EFF_RANK_GROUP_OVERRIDE attribute
typedef uint16_t EFF_RANK_GROUP_OVERRIDE_ATTR[2][2];
typedef uint16_t ATTR_EFF_RANK_GROUP_OVERRIDE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 2>, 2> ATTR_EFF_RANK_GROUP_OVERRIDE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_IO_X_MFG_CHK attribute
typedef uint8_t IO_X_MFG_CHK_ATTR;
typedef uint8_t ATTR_IO_X_MFG_CHK_type;

// Type aliases and/or sizes for ATTR_IO_X_MFG_MIN_EYE_WIDTH attribute
typedef uint8_t IO_X_MFG_MIN_EYE_WIDTH_ATTR;
typedef uint8_t ATTR_IO_X_MFG_MIN_EYE_WIDTH_type;

// Type aliases and/or sizes for ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN attribute
typedef uint8_t IO_O_MFG_STRESS_PR_OFFSET_EVEN_ATTR;
typedef uint8_t ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN_type;

// Type aliases and/or sizes for ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD attribute
typedef uint8_t IO_O_MFG_STRESS_PR_OFFSET_ODD_ATTR;
typedef uint8_t ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD_type;

// Type aliases and/or sizes for ATTR_CME_CHTM_TRACE_ENABLE attribute
typedef uint8_t CME_CHTM_TRACE_ENABLE_ATTR;
typedef uint8_t ATTR_CME_CHTM_TRACE_ENABLE_type;

// Type aliases and/or sizes for ATTR_CME_CHTM_TRACE_MEMORY_CONFIG attribute
typedef uint64_t CME_CHTM_TRACE_MEMORY_CONFIG_ATTR;
typedef uint64_t ATTR_CME_CHTM_TRACE_MEMORY_CONFIG_type;

// Type aliases and/or sizes for ATTR_SYSTEM_VDM_DISABLE attribute
typedef uint8_t SYSTEM_VDM_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_VDM_DISABLE_type;

// Type aliases and/or sizes for ATTR_VDM_ENABLED attribute
typedef uint8_t VDM_ENABLED_ATTR;
typedef uint8_t ATTR_VDM_ENABLED_type;

// Type aliases and/or sizes for ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA attribute
typedef uint32_t IO_XBUS_GRP0_PRE_BAD_LANE_DATA_ATTR;
typedef uint32_t ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA_type;

// Type aliases and/or sizes for ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA attribute
typedef uint32_t IO_XBUS_GRP1_PRE_BAD_LANE_DATA_ATTR;
typedef uint32_t ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA_type;

// Type aliases and/or sizes for ATTR_SYSTEM_IVRM_DISABLE attribute
typedef uint8_t SYSTEM_IVRM_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_IVRM_DISABLE_type;

// Type aliases and/or sizes for ATTR_IVRM_ENABLED attribute
typedef uint8_t IVRM_ENABLED_ATTR;
typedef uint8_t ATTR_IVRM_ENABLED_type;

// Type aliases and/or sizes for ATTR_WOF_ENABLE_FRATIO attribute
typedef uint8_t WOF_ENABLE_FRATIO_ATTR;
typedef uint8_t ATTR_WOF_ENABLE_FRATIO_type;

// Type aliases and/or sizes for ATTR_WOF_ENABLE_VRATIO attribute
typedef uint8_t WOF_ENABLE_VRATIO_ATTR;
typedef uint8_t ATTR_WOF_ENABLE_VRATIO_type;

// Type aliases and/or sizes for ATTR_WOF_VRATIO_SELECT attribute
typedef uint8_t WOF_VRATIO_SELECT_ATTR;
typedef uint8_t ATTR_WOF_VRATIO_SELECT_type;

// Type aliases and/or sizes for ATTR_NEST_LEAKAGE_PERCENT attribute
typedef uint8_t NEST_LEAKAGE_PERCENT_ATTR;
typedef uint8_t ATTR_NEST_LEAKAGE_PERCENT_type;

// Type aliases and/or sizes for ATTR_MSS_RUN_DCD_CALIBRATION attribute
typedef uint8_t MSS_RUN_DCD_CALIBRATION_ATTR;
typedef uint8_t ATTR_MSS_RUN_DCD_CALIBRATION_type;

// Type aliases and/or sizes for ATTR_MSS_EFF_WR_CRC attribute
typedef uint8_t MSS_EFF_WR_CRC_ATTR[2];
typedef uint8_t ATTR_MSS_EFF_WR_CRC_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_EFF_WR_CRC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_IO_O_MFG_CHK attribute
typedef uint8_t IO_O_MFG_CHK_ATTR;
typedef uint8_t ATTR_IO_O_MFG_CHK_type;

// Type aliases and/or sizes for ATTR_IO_O_MFG_MIN_EYE_WIDTH attribute
typedef uint8_t IO_O_MFG_MIN_EYE_WIDTH_ATTR;
typedef uint8_t ATTR_IO_O_MFG_MIN_EYE_WIDTH_type;

// Type aliases and/or sizes for ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE attribute
typedef uint8_t SYSTEM_CORECACHE_SKEWADJ_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE attribute
typedef uint8_t SYSTEM_CORECACHE_DCADJ_DISABLE_ATTR;
typedef uint8_t ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE_type;

// Type aliases and/or sizes for ATTR_EQ_INSIDE_SPECIAL_WAKEUP attribute
typedef uint8_t EQ_INSIDE_SPECIAL_WAKEUP_ATTR;
typedef uint8_t ATTR_EQ_INSIDE_SPECIAL_WAKEUP_type;

// Type aliases and/or sizes for ATTR_MSS_VPD_MT_MC_BIAS_TRIM attribute
typedef uint8_t MSS_VPD_MT_MC_BIAS_TRIM_ATTR[2];
typedef uint8_t ATTR_MSS_VPD_MT_MC_BIAS_TRIM_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_VPD_MT_MC_BIAS_TRIM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EX_INSIDE_SPECIAL_WAKEUP attribute
typedef uint8_t EX_INSIDE_SPECIAL_WAKEUP_ATTR;
typedef uint8_t ATTR_EX_INSIDE_SPECIAL_WAKEUP_type;

// Type aliases and/or sizes for ATTR_IO_XBUS_CHAN_EQ attribute
typedef uint8_t IO_XBUS_CHAN_EQ_ATTR;
typedef uint8_t ATTR_IO_XBUS_CHAN_EQ_type;

// Type aliases and/or sizes for ATTR_IO_O_CHANNEL_TYPE attribute
typedef uint8_t IO_O_CHANNEL_TYPE_ATTR;
typedef uint8_t ATTR_IO_O_CHANNEL_TYPE_type;

// Type aliases and/or sizes for ATTR_NEST_PLL_BUCKET attribute
typedef uint8_t NEST_PLL_BUCKET_ATTR;
typedef uint8_t ATTR_NEST_PLL_BUCKET_type;

// Type aliases and/or sizes for ATTR_AFFINITY_PATH attribute
typedef EntityPath AFFINITY_PATH_ATTR;
typedef EntityPath ATTR_AFFINITY_PATH_type;

// Type aliases and/or sizes for ATTR_ALLOW_EEPROM_WRITES attribute
typedef uint8_t ALLOW_EEPROM_WRITES_ATTR;
typedef uint8_t ATTR_ALLOW_EEPROM_WRITES_type;

// Type aliases and/or sizes for ATTR_ALL_MCS_IN_INTERLEAVING_GROUP attribute
typedef uint8_t ALL_MCS_IN_INTERLEAVING_GROUP_ATTR;
typedef uint8_t ATTR_ALL_MCS_IN_INTERLEAVING_GROUP_type;

// Type aliases and/or sizes for ATTR_ALTFSI_MASTER_CHIP attribute
typedef EntityPath ALTFSI_MASTER_CHIP_ATTR;
typedef EntityPath ATTR_ALTFSI_MASTER_CHIP_type;

// Type aliases and/or sizes for ATTR_ALTFSI_MASTER_PORT attribute
typedef uint8_t ALTFSI_MASTER_PORT_ATTR;
typedef uint8_t ATTR_ALTFSI_MASTER_PORT_type;

// Type aliases and/or sizes for ATTR_ASYNC_NEST_FREQ_MHZ attribute
typedef uint32_t ASYNC_NEST_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_ASYNC_NEST_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_ATTN_AREA_1_ADDR attribute
typedef uint64_t ATTN_AREA_1_ADDR_ATTR;
typedef uint64_t ATTR_ATTN_AREA_1_ADDR_type;

// Type aliases and/or sizes for ATTR_ATTN_AREA_2_ADDR attribute
typedef uint64_t ATTN_AREA_2_ADDR_ATTR;
typedef uint64_t ATTR_ATTN_AREA_2_ADDR_type;

// Type aliases and/or sizes for ATTR_AVDD_ID attribute
typedef uint16_t AVDD_ID_ATTR;
typedef uint16_t ATTR_AVDD_ID_type;

// Type aliases and/or sizes for ATTR_BLOCK_SPEC_DECONFIG attribute
typedef uint8_t BLOCK_SPEC_DECONFIG_ATTR;
typedef uint8_t ATTR_BLOCK_SPEC_DECONFIG_type;

// Type aliases and/or sizes for ATTR_BMC_FRU_ID attribute
typedef uint32_t BMC_FRU_ID_ATTR;
typedef uint32_t ATTR_BMC_FRU_ID_type;

// Type aliases and/or sizes for ATTR_CDM_DOMAIN attribute
typedef CDM_DOMAIN CDM_DOMAIN_ATTR;
typedef CDM_DOMAIN ATTR_CDM_DOMAIN_type;

// Type aliases and/or sizes for ATTR_CDM_POLICIES attribute
typedef uint8_t CDM_POLICIES_ATTR;
typedef uint8_t ATTR_CDM_POLICIES_type;

// Type aliases and/or sizes for ATTR_CEC_IPL_TYPE attribute
typedef CecIplType CEC_IPL_TYPE_ATTR;
typedef CecIplType ATTR_CEC_IPL_TYPE_type;

// Type aliases and/or sizes for ATTR_CENTAUR_ECID_FRU_ID attribute
typedef uint32_t CENTAUR_ECID_FRU_ID_ATTR;
typedef uint32_t ATTR_CENTAUR_ECID_FRU_ID_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_AVDD_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VCS_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VDDR_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VDD_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VPP_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS attribute
typedef uint32_t CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_CHASSIS_LOCATION_CODE attribute
typedef char CHASSIS_LOCATION_CODE_ATTR[64];
typedef char ATTR_CHASSIS_LOCATION_CODE_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_CHASSIS_LOCATION_CODE_typeStdArr;
#endif
const size_t ATTR_CHASSIS_LOCATION_CODE_max_chars = 63;

// Type aliases and/or sizes for ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL attribute
typedef CHECK_ATTN_AFTER_ISTEP_FAIL CHECK_ATTN_AFTER_ISTEP_FAIL_ATTR;
typedef CHECK_ATTN_AFTER_ISTEP_FAIL ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL_type;

// Type aliases and/or sizes for ATTR_CHIPLET_ID attribute
typedef uint8_t CHIPLET_ID_ATTR;
typedef uint8_t ATTR_CHIPLET_ID_type;

// Type aliases and/or sizes for ATTR_CHIP_FAN_CFM attribute
typedef uint16_t CHIP_FAN_CFM_ATTR;
typedef uint16_t ATTR_CHIP_FAN_CFM_type;

// Type aliases and/or sizes for ATTR_CHIP_ID attribute
typedef uint32_t CHIP_ID_ATTR;
typedef uint32_t ATTR_CHIP_ID_type;

// Type aliases and/or sizes for ATTR_CHIP_UNIT attribute
typedef uint8_t CHIP_UNIT_ATTR;
typedef uint8_t ATTR_CHIP_UNIT_type;

// Type aliases and/or sizes for ATTR_CLASS attribute
typedef CLASS CLASS_ATTR;
typedef CLASS ATTR_CLASS_type;

// Type aliases and/or sizes for ATTR_COLLECT_SBE_SCRATCH_DATA attribute
typedef uint8_t COLLECT_SBE_SCRATCH_DATA_ATTR;
typedef uint8_t ATTR_COLLECT_SBE_SCRATCH_DATA_type;

// Type aliases and/or sizes for ATTR_CORE_IS_SPARE attribute
typedef uint8_t CORE_IS_SPARE_ATTR;
typedef uint8_t ATTR_CORE_IS_SPARE_type;

// Type aliases and/or sizes for ATTR_CPU_ATTR attribute
typedef uint32_t CPU_ATTR_ATTR;
typedef uint32_t ATTR_CPU_ATTR_type;

// Type aliases and/or sizes for ATTR_DATA_CACHE_LINE_SIZE attribute
typedef uint32_t DATA_CACHE_LINE_SIZE_ATTR;
typedef uint32_t ATTR_DATA_CACHE_LINE_SIZE_type;

// Type aliases and/or sizes for ATTR_DATA_CACHE_SIZE attribute
typedef uint32_t DATA_CACHE_SIZE_ATTR;
typedef uint32_t ATTR_DATA_CACHE_SIZE_type;

// Type aliases and/or sizes for ATTR_DCACHE_ASSOC_SETS attribute
typedef uint32_t DCACHE_ASSOC_SETS_ATTR;
typedef uint32_t ATTR_DCACHE_ASSOC_SETS_type;

// Type aliases and/or sizes for ATTR_DCACHE_LINE_SIZE attribute
typedef uint32_t DCACHE_LINE_SIZE_ATTR;
typedef uint32_t ATTR_DCACHE_LINE_SIZE_type;

// Type aliases and/or sizes for ATTR_DEBUG_OCMB_LOGS attribute
typedef DebugOcmbLogs DEBUG_OCMB_LOGS_ATTR;
typedef DebugOcmbLogs ATTR_DEBUG_OCMB_LOGS_type;

// Type aliases and/or sizes for ATTR_DEBUG_ODY_HRESET_CONTROL attribute
typedef uint8_t DEBUG_ODY_HRESET_CONTROL_ATTR;
typedef uint8_t ATTR_DEBUG_ODY_HRESET_CONTROL_type;

// Type aliases and/or sizes for ATTR_DECONFIG_GARDABLE attribute
typedef uint8_t DECONFIG_GARDABLE_ATTR;
typedef uint8_t ATTR_DECONFIG_GARDABLE_type;

// Type aliases and/or sizes for ATTR_DIMM_POWER attribute
typedef uint32_t DIMM_POWER_ATTR[12];
typedef uint32_t ATTR_DIMM_POWER_type[12];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 12> ATTR_DIMM_POWER_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DIMM_POWER_UTIL attribute
typedef uint8_t DIMM_POWER_UTIL_ATTR[12];
typedef uint8_t ATTR_DIMM_POWER_UTIL_type[12];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 12> ATTR_DIMM_POWER_UTIL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS attribute
typedef uint8_t DIMM_POWER_UTIL_INTERMEDIATE_POINTS_ATTR[10];
typedef uint8_t ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS_type[10];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 10> ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DIMM_PREHEAT_POWER attribute
typedef uint32_t DIMM_PREHEAT_POWER_ATTR[12];
typedef uint32_t ATTR_DIMM_PREHEAT_POWER_type[12];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 12> ATTR_DIMM_PREHEAT_POWER_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DISABLE_PLD_WAIT attribute
typedef uint8_t DISABLE_PLD_WAIT_ATTR;
typedef uint8_t ATTR_DISABLE_PLD_WAIT_type;

// Type aliases and/or sizes for ATTR_DISABLE_PREDICTIVE_MEM_GUARD attribute
typedef uint8_t DISABLE_PREDICTIVE_MEM_GUARD_ATTR;
typedef uint8_t ATTR_DISABLE_PREDICTIVE_MEM_GUARD_type;

// Type aliases and/or sizes for ATTR_DUMMY_HEAP_ZERO_DEFAULT attribute
typedef uint8_t DUMMY_HEAP_ZERO_DEFAULT_ATTR;
typedef uint8_t ATTR_DUMMY_HEAP_ZERO_DEFAULT_type;

// Type aliases and/or sizes for ATTR_DUMMY_RO attribute
typedef uint8_t DUMMY_RO_ATTR;
typedef uint8_t ATTR_DUMMY_RO_type;

// Type aliases and/or sizes for ATTR_DUMMY_RW attribute
typedef uint8_t DUMMY_RW_ATTR[1][3][5];
typedef uint8_t ATTR_DUMMY_RW_type[1][3][5];
#if __cplusplus >= 201103L 
typedef std::array<std::array<std::array<uint8_t, 5>, 3>, 1> ATTR_DUMMY_RW_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_DUMMY_WO attribute
typedef uint8_t DUMMY_WO_ATTR;
typedef uint8_t ATTR_DUMMY_WO_type;

// Type aliases and/or sizes for ATTR_EC attribute
typedef uint8_t EC_ATTR;
typedef uint8_t ATTR_EC_type;

// Type aliases and/or sizes for ATTR_EECACHE_DISABLE_AUTO_RESET attribute
typedef uint8_t EECACHE_DISABLE_AUTO_RESET_ATTR;
typedef uint8_t ATTR_EECACHE_DISABLE_AUTO_RESET_type;

// Type aliases and/or sizes for ATTR_EECACHE_VPD_STATE attribute
typedef EECACHE_VPD_STATE EECACHE_VPD_STATE_ATTR;
typedef EECACHE_VPD_STATE ATTR_EECACHE_VPD_STATE_type;

// Type aliases and/or sizes for ATTR_EEPROM_CONTENT_TYPE attribute
typedef EEPROM_CONTENT_TYPE EEPROM_CONTENT_TYPE_ATTR;
typedef EEPROM_CONTENT_TYPE ATTR_EEPROM_CONTENT_TYPE_type;

// Type aliases and/or sizes for ATTR_EEPROM_NV_INFO attribute
typedef EepromNvInfo EEPROM_NV_INFO_ATTR;
typedef EepromNvInfo ATTR_EEPROM_NV_INFO_type;

// Type aliases and/or sizes for ATTR_EEPROM_SBE_BACKUP_INFO attribute
typedef EepromSbeBackupInfo EEPROM_SBE_BACKUP_INFO_ATTR;
typedef EepromSbeBackupInfo ATTR_EEPROM_SBE_BACKUP_INFO_type;

// Type aliases and/or sizes for ATTR_EEPROM_SBE_PRIMARY_INFO attribute
typedef EepromSbePrimaryInfo EEPROM_SBE_PRIMARY_INFO_ATTR;
typedef EepromSbePrimaryInfo ATTR_EEPROM_SBE_PRIMARY_INFO_type;

// Type aliases and/or sizes for ATTR_EEPROM_VPD_ACCESSIBILITY attribute
typedef EEPROM_VPD_ACCESSIBILITY EEPROM_VPD_ACCESSIBILITY_ATTR;
typedef EEPROM_VPD_ACCESSIBILITY ATTR_EEPROM_VPD_ACCESSIBILITY_type;

// Type aliases and/or sizes for ATTR_EEPROM_VPD_ACTIVE_COPY attribute
typedef uint8_t EEPROM_VPD_ACTIVE_COPY_ATTR;
typedef uint8_t ATTR_EEPROM_VPD_ACTIVE_COPY_type;

// Type aliases and/or sizes for ATTR_EEPROM_VPD_BACKUP_INFO attribute
typedef EepromVpdBackupInfo EEPROM_VPD_BACKUP_INFO_ATTR;
typedef EepromVpdBackupInfo ATTR_EEPROM_VPD_BACKUP_INFO_type;

// Type aliases and/or sizes for ATTR_EEPROM_VPD_PRIMARY_INFO attribute
typedef EepromVpdPrimaryInfo EEPROM_VPD_PRIMARY_INFO_ATTR;
typedef EepromVpdPrimaryInfo ATTR_EEPROM_VPD_PRIMARY_INFO_type;

// Type aliases and/or sizes for ATTR_EEPROM_VPD_REDUNDANCY attribute
typedef EEPROM_VPD_REDUNDANCY EEPROM_VPD_REDUNDANCY_ATTR;
typedef EEPROM_VPD_REDUNDANCY ATTR_EEPROM_VPD_REDUNDANCY_type;

// Type aliases and/or sizes for ATTR_EFFECTIVE_EC attribute
typedef uint8_t EFFECTIVE_EC_ATTR;
typedef uint8_t ATTR_EFFECTIVE_EC_type;

// Type aliases and/or sizes for ATTR_ENABLED_THREADS attribute
typedef uint64_t ENABLED_THREADS_ATTR;
typedef uint64_t ATTR_ENABLED_THREADS_type;

// Type aliases and/or sizes for ATTR_ENGINE_TYPE attribute
typedef ENGINE_TYPE ENGINE_TYPE_ATTR;
typedef ENGINE_TYPE ATTR_ENGINE_TYPE_type;

// Type aliases and/or sizes for ATTR_FABRIC_CHIP_ID attribute
typedef uint8_t FABRIC_CHIP_ID_ATTR;
typedef uint8_t ATTR_FABRIC_CHIP_ID_type;

// Type aliases and/or sizes for ATTR_FABRIC_GROUP_ID attribute
typedef uint8_t FABRIC_GROUP_ID_ATTR;
typedef uint8_t ATTR_FABRIC_GROUP_ID_type;

// Type aliases and/or sizes for ATTR_FABRIC_PRESENT_GROUPS attribute
typedef uint8_t FABRIC_PRESENT_GROUPS_ATTR;
typedef uint8_t ATTR_FABRIC_PRESENT_GROUPS_type;

// Type aliases and/or sizes for ATTR_FABRIC_TO_PHYSICAL_NODE_MAP attribute
typedef uint8_t FABRIC_TO_PHYSICAL_NODE_MAP_ATTR[8];
typedef uint8_t ATTR_FABRIC_TO_PHYSICAL_NODE_MAP_type[8];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 8> ATTR_FABRIC_TO_PHYSICAL_NODE_MAP_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_FAPI_I2C_CONTROL_INFO attribute
typedef FapiI2cControlInfo FAPI_I2C_CONTROL_INFO_ATTR;
typedef FapiI2cControlInfo ATTR_FAPI_I2C_CONTROL_INFO_type;

// Type aliases and/or sizes for ATTR_FAPI_NAME attribute
typedef char FAPI_NAME_ATTR[64];
typedef char ATTR_FAPI_NAME_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_FAPI_NAME_typeStdArr;
#endif
const size_t ATTR_FAPI_NAME_max_chars = 63;

// Type aliases and/or sizes for ATTR_FIELD_CORE_OVERRIDE attribute
typedef uint32_t FIELD_CORE_OVERRIDE_ATTR;
typedef uint32_t ATTR_FIELD_CORE_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_FIELD_TH_L2_LINE_DELETES attribute
typedef uint8_t FIELD_TH_L2_LINE_DELETES_ATTR;
typedef uint8_t ATTR_FIELD_TH_L2_LINE_DELETES_type;

// Type aliases and/or sizes for ATTR_FIELD_TH_L3_LINE_DELETES attribute
typedef uint8_t FIELD_TH_L3_LINE_DELETES_ATTR;
typedef uint8_t ATTR_FIELD_TH_L3_LINE_DELETES_type;

// Type aliases and/or sizes for ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION attribute
typedef uint8_t FORCE_SBE_SCRATCH_DATA_COLLECTION_ATTR;
typedef uint8_t ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION_type;

// Type aliases and/or sizes for ATTR_FORCE_SERIAL_ISTEPS attribute
typedef uint8_t FORCE_SERIAL_ISTEPS_ATTR;
typedef uint8_t ATTR_FORCE_SERIAL_ISTEPS_type;

// Type aliases and/or sizes for ATTR_FORCE_SRAM_MMIO_OVER_I2C attribute
typedef uint8_t FORCE_SRAM_MMIO_OVER_I2C_ATTR;
typedef uint8_t ATTR_FORCE_SRAM_MMIO_OVER_I2C_type;

// Type aliases and/or sizes for ATTR_FOUND_PRESENT_BY_SP attribute
typedef FOUND_PRESENT_BY_SP FOUND_PRESENT_BY_SP_ATTR;
typedef FOUND_PRESENT_BY_SP ATTR_FOUND_PRESENT_BY_SP_type;

// Type aliases and/or sizes for ATTR_FREQ_CORE_CEILING_MHZ attribute
typedef uint32_t FREQ_CORE_CEILING_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_CORE_CEILING_MHZ_type;

// Type aliases and/or sizes for ATTR_FREQ_PROC_REFCLOCK attribute
typedef uint32_t FREQ_PROC_REFCLOCK_ATTR;
typedef uint32_t ATTR_FREQ_PROC_REFCLOCK_type;

// Type aliases and/or sizes for ATTR_FRU_ID attribute
typedef uint32_t FRU_ID_ATTR;
typedef uint32_t ATTR_FRU_ID_type;

// Type aliases and/or sizes for ATTR_FSI_MASTER_CHIP attribute
typedef EntityPath FSI_MASTER_CHIP_ATTR;
typedef EntityPath ATTR_FSI_MASTER_CHIP_type;

// Type aliases and/or sizes for ATTR_FSI_MASTER_PORT attribute
typedef uint8_t FSI_MASTER_PORT_ATTR;
typedef uint8_t ATTR_FSI_MASTER_PORT_type;

// Type aliases and/or sizes for ATTR_FSI_MASTER_TYPE attribute
typedef FSI_MASTER_TYPE FSI_MASTER_TYPE_ATTR;
typedef FSI_MASTER_TYPE ATTR_FSI_MASTER_TYPE_type;

// Type aliases and/or sizes for ATTR_FSI_OPTION_FLAGS attribute
typedef FsiOptionFlags FSI_OPTION_FLAGS_ATTR;
typedef FsiOptionFlags ATTR_FSI_OPTION_FLAGS_type;

// Type aliases and/or sizes for ATTR_FSI_SLAVE_CASCADE attribute
typedef uint8_t FSI_SLAVE_CASCADE_ATTR;
typedef uint8_t ATTR_FSI_SLAVE_CASCADE_type;

// Type aliases and/or sizes for ATTR_FSP_BAR_SIZE attribute
typedef uint64_t FSP_BAR_SIZE_ATTR;
typedef uint64_t ATTR_FSP_BAR_SIZE_type;

// Type aliases and/or sizes for ATTR_FSP_BASE_ADDR attribute
typedef uint64_t FSP_BASE_ADDR_ATTR;
typedef uint64_t ATTR_FSP_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_FUSED_CORE_MODE_HB attribute
typedef uint8_t FUSED_CORE_MODE_HB_ATTR;
typedef uint8_t ATTR_FUSED_CORE_MODE_HB_type;

// Type aliases and/or sizes for ATTR_FUSED_CORE_OPTION attribute
typedef uint8_t FUSED_CORE_OPTION_ATTR;
typedef uint8_t ATTR_FUSED_CORE_OPTION_type;

// Type aliases and/or sizes for ATTR_HBRT_HYP_ID attribute
typedef uint64_t HBRT_HYP_ID_ATTR;
typedef uint64_t ATTR_HBRT_HYP_ID_type;

// Type aliases and/or sizes for ATTR_HB_HRMOR_NODAL_BASE attribute
typedef uint64_t HB_HRMOR_NODAL_BASE_ATTR;
typedef uint64_t ATTR_HB_HRMOR_NODAL_BASE_type;

// Type aliases and/or sizes for ATTR_HB_MIN_BACKING_CACHE_FC attribute
typedef uint8_t HB_MIN_BACKING_CACHE_FC_ATTR;
typedef uint8_t ATTR_HB_MIN_BACKING_CACHE_FC_type;

// Type aliases and/or sizes for ATTR_HB_RSV_MEM_SIZE_MB attribute
typedef uint32_t HB_RSV_MEM_SIZE_MB_ATTR;
typedef uint32_t ATTR_HB_RSV_MEM_SIZE_MB_type;

// Type aliases and/or sizes for ATTR_HB_SETTINGS attribute
typedef HbSettings HB_SETTINGS_ATTR;
typedef HbSettings ATTR_HB_SETTINGS_type;

// Type aliases and/or sizes for ATTR_HB_SETTINGS_OVERRIDE attribute
typedef uint8_t HB_SETTINGS_OVERRIDE_ATTR;
typedef uint8_t ATTR_HB_SETTINGS_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_HDAT_EC attribute
typedef uint8_t HDAT_EC_ATTR;
typedef uint8_t ATTR_HDAT_EC_type;

// Type aliases and/or sizes for ATTR_HDAT_HBRT_NUM_SECTIONS attribute
typedef uint32_t HDAT_HBRT_NUM_SECTIONS_ATTR;
typedef uint32_t ATTR_HDAT_HBRT_NUM_SECTIONS_type;

// Type aliases and/or sizes for ATTR_HDAT_HBRT_SECTION_SIZE attribute
typedef uint64_t HDAT_HBRT_SECTION_SIZE_ATTR[9];
typedef uint64_t ATTR_HDAT_HBRT_SECTION_SIZE_type[9];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 9> ATTR_HDAT_HBRT_SECTION_SIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_HDAT_RSV_MEM_NUM_SECTIONS attribute
typedef uint32_t HDAT_RSV_MEM_NUM_SECTIONS_ATTR;
typedef uint32_t ATTR_HDAT_RSV_MEM_NUM_SECTIONS_type;

// Type aliases and/or sizes for ATTR_HDDW_ORDER attribute
typedef uint8_t HDDW_ORDER_ATTR;
typedef uint8_t ATTR_HDDW_ORDER_type;

// Type aliases and/or sizes for ATTR_HOMER_PHYS_ADDR attribute
typedef uint64_t HOMER_PHYS_ADDR_ATTR;
typedef uint64_t ATTR_HOMER_PHYS_ADDR_type;

// Type aliases and/or sizes for ATTR_HOSTSVC_PLID attribute
typedef uint32_t HOSTSVC_PLID_ATTR;
typedef uint32_t ATTR_HOSTSVC_PLID_type;

// Type aliases and/or sizes for ATTR_HOT_PLUG_POWER_CONTROLLER_INFO attribute
typedef uint8_t HOT_PLUG_POWER_CONTROLLER_INFO_ATTR[8][8];
typedef uint8_t ATTR_HOT_PLUG_POWER_CONTROLLER_INFO_type[8][8];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 8>, 8> ATTR_HOT_PLUG_POWER_CONTROLLER_INFO_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_HUID attribute
typedef uint32_t HUID_ATTR;
typedef uint32_t ATTR_HUID_type;

// Type aliases and/or sizes for ATTR_HWAS_STATE attribute
typedef HwasState HWAS_STATE_ATTR;
typedef HwasState ATTR_HWAS_STATE_type;

// Type aliases and/or sizes for ATTR_HWAS_STATE_CHANGED_FLAG attribute
typedef uint64_t HWAS_STATE_CHANGED_FLAG_ATTR;
typedef uint64_t ATTR_HWAS_STATE_CHANGED_FLAG_type;

// Type aliases and/or sizes for ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK attribute
typedef uint64_t HWAS_STATE_CHANGED_SUBSCRIPTION_MASK_ATTR;
typedef uint64_t ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK_type;

// Type aliases and/or sizes for ATTR_HWAS_STATE_TESTSAVE attribute
typedef HwasStateTestsave HWAS_STATE_TESTSAVE_ATTR;
typedef HwasStateTestsave ATTR_HWAS_STATE_TESTSAVE_type;

// Type aliases and/or sizes for ATTR_I2C_BUS_SPEED_ARRAY attribute
typedef uint16_t I2C_BUS_SPEED_ARRAY_ATTR[4][16];
typedef uint16_t ATTR_I2C_BUS_SPEED_ARRAY_type[4][16];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint16_t, 16>, 4> ATTR_I2C_BUS_SPEED_ARRAY_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_I2C_CONTROL_INFO attribute
typedef I2cControlInfo I2C_CONTROL_INFO_ATTR;
typedef I2cControlInfo ATTR_I2C_CONTROL_INFO_type;

// Type aliases and/or sizes for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A attribute
typedef uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A_ATTR;
typedef uint8_t ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A_type;

// Type aliases and/or sizes for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B attribute
typedef uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B_ATTR;
typedef uint8_t ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B_type;

// Type aliases and/or sizes for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C attribute
typedef uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C_ATTR;
typedef uint8_t ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C_type;

// Type aliases and/or sizes for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D attribute
typedef uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D_ATTR;
typedef uint8_t ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D_type;

// Type aliases and/or sizes for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E attribute
typedef uint8_t I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E_ATTR;
typedef uint8_t ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E_type;

// Type aliases and/or sizes for ATTR_I2C_SWITCHES attribute
typedef I2cSwitches I2C_SWITCHES_ATTR;
typedef I2cSwitches ATTR_I2C_SWITCHES_type;

// Type aliases and/or sizes for ATTR_IBSCOM_MCS_BASE_ADDR attribute
typedef uint64_t IBSCOM_MCS_BASE_ADDR_ATTR;
typedef uint64_t ATTR_IBSCOM_MCS_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_IBSCOM_PROC_BASE_ADDR attribute
typedef uint64_t IBSCOM_PROC_BASE_ADDR_ATTR;
typedef uint64_t ATTR_IBSCOM_PROC_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_ICACHE_ASSOC_SETS attribute
typedef uint32_t ICACHE_ASSOC_SETS_ATTR;
typedef uint32_t ATTR_ICACHE_ASSOC_SETS_type;

// Type aliases and/or sizes for ATTR_ICACHE_BLOCK_SIZE attribute
typedef uint32_t ICACHE_BLOCK_SIZE_ATTR;
typedef uint32_t ATTR_ICACHE_BLOCK_SIZE_type;

// Type aliases and/or sizes for ATTR_ICACHE_LINE_SIZE attribute
typedef uint32_t ICACHE_LINE_SIZE_ATTR;
typedef uint32_t ATTR_ICACHE_LINE_SIZE_type;

// Type aliases and/or sizes for ATTR_ICACHE_SIZE attribute
typedef uint32_t ICACHE_SIZE_ATTR;
typedef uint32_t ATTR_ICACHE_SIZE_type;

// Type aliases and/or sizes for ATTR_INIT_TO_AVAILABLE attribute
typedef uint8_t INIT_TO_AVAILABLE_ATTR;
typedef uint8_t ATTR_INIT_TO_AVAILABLE_type;

// Type aliases and/or sizes for ATTR_INT_CQ_TM_BAR_ADDR attribute
typedef uint64_t INT_CQ_TM_BAR_ADDR_ATTR;
typedef uint64_t ATTR_INT_CQ_TM_BAR_ADDR_type;

// Type aliases and/or sizes for ATTR_ISTEP_CALLOUT_INJECT_ACTION attribute
typedef uint64_t ISTEP_CALLOUT_INJECT_ACTION_ATTR;
typedef uint64_t ATTR_ISTEP_CALLOUT_INJECT_ACTION_type;

// Type aliases and/or sizes for ATTR_ISTEP_CALLOUT_INJECT_ENABLE attribute
typedef uint8_t ISTEP_CALLOUT_INJECT_ENABLE_ATTR;
typedef uint8_t ATTR_ISTEP_CALLOUT_INJECT_ENABLE_type;

// Type aliases and/or sizes for ATTR_ISTEP_MODE attribute
typedef uint8_t ISTEP_MODE_ATTR;
typedef uint8_t ATTR_ISTEP_MODE_type;

// Type aliases and/or sizes for ATTR_ISTEP_PAUSE_CONFIG attribute
typedef uint64_t ISTEP_PAUSE_CONFIG_ATTR;
typedef uint64_t ATTR_ISTEP_PAUSE_CONFIG_type;

// Type aliases and/or sizes for ATTR_ISTEP_PAUSE_ENABLE attribute
typedef uint8_t ISTEP_PAUSE_ENABLE_ATTR;
typedef uint8_t ATTR_ISTEP_PAUSE_ENABLE_type;

// Type aliases and/or sizes for ATTR_IS_INTER_ENCLOSURE_BUS attribute
typedef uint8_t IS_INTER_ENCLOSURE_BUS_ATTR;
typedef uint8_t ATTR_IS_INTER_ENCLOSURE_BUS_type;

// Type aliases and/or sizes for ATTR_IS_STANDALONE attribute
typedef uint8_t IS_STANDALONE_ATTR;
typedef uint8_t ATTR_IS_STANDALONE_type;

// Type aliases and/or sizes for ATTR_KEY_CLEAR_REQUEST attribute
typedef KEY_CLEAR_REQUEST KEY_CLEAR_REQUEST_ATTR;
typedef KEY_CLEAR_REQUEST ATTR_KEY_CLEAR_REQUEST_type;

// Type aliases and/or sizes for ATTR_KEY_TRANSITION_STATE attribute
typedef KEY_TRANSITION_STATE KEY_TRANSITION_STATE_ATTR;
typedef KEY_TRANSITION_STATE ATTR_KEY_TRANSITION_STATE_type;

// Type aliases and/or sizes for ATTR_L2_CACHE_ASSOC_SETS attribute
typedef uint32_t L2_CACHE_ASSOC_SETS_ATTR;
typedef uint32_t ATTR_L2_CACHE_ASSOC_SETS_type;

// Type aliases and/or sizes for ATTR_L2_CACHE_LINE_SIZE attribute
typedef uint32_t L2_CACHE_LINE_SIZE_ATTR;
typedef uint32_t ATTR_L2_CACHE_LINE_SIZE_type;

// Type aliases and/or sizes for ATTR_L2_CACHE_SIZE attribute
typedef uint32_t L2_CACHE_SIZE_ATTR;
typedef uint32_t ATTR_L2_CACHE_SIZE_type;

// Type aliases and/or sizes for ATTR_L3_CACHE_LINE_SIZE attribute
typedef uint32_t L3_CACHE_LINE_SIZE_ATTR;
typedef uint32_t ATTR_L3_CACHE_LINE_SIZE_type;

// Type aliases and/or sizes for ATTR_L3_CACHE_SIZE attribute
typedef uint32_t L3_CACHE_SIZE_ATTR;
typedef uint32_t ATTR_L3_CACHE_SIZE_type;

// Type aliases and/or sizes for ATTR_LAST_IPLTIME_EID attribute
typedef uint32_t LAST_IPLTIME_EID_ATTR;
typedef uint32_t ATTR_LAST_IPLTIME_EID_type;

// Type aliases and/or sizes for ATTR_LMB_SIZE attribute
typedef uint8_t LMB_SIZE_ATTR;
typedef uint8_t ATTR_LMB_SIZE_type;

// Type aliases and/or sizes for ATTR_LOCATION_CODE attribute
typedef char LOCATION_CODE_ATTR[64];
typedef char ATTR_LOCATION_CODE_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_LOCATION_CODE_typeStdArr;
#endif
const size_t ATTR_LOCATION_CODE_max_chars = 63;

// Type aliases and/or sizes for ATTR_LPC_BUS_ADDR attribute
typedef uint64_t LPC_BUS_ADDR_ATTR;
typedef uint64_t ATTR_LPC_BUS_ADDR_type;

// Type aliases and/or sizes for ATTR_MAX_CHIPLETS_PER_PROC attribute
typedef uint8_t MAX_CHIPLETS_PER_PROC_ATTR;
typedef uint8_t ATTR_MAX_CHIPLETS_PER_PROC_type;

// Type aliases and/or sizes for ATTR_MAX_COMPUTE_NODES_PER_SYSTEM attribute
typedef uint8_t MAX_COMPUTE_NODES_PER_SYSTEM_ATTR;
typedef uint8_t ATTR_MAX_COMPUTE_NODES_PER_SYSTEM_type;

// Type aliases and/or sizes for ATTR_MAX_DIMMS_PER_MBA_PORT attribute
typedef uint8_t MAX_DIMMS_PER_MBA_PORT_ATTR;
typedef uint8_t ATTR_MAX_DIMMS_PER_MBA_PORT_type;

// Type aliases and/or sizes for ATTR_MAX_DIMM_POWER attribute
typedef uint32_t MAX_DIMM_POWER_ATTR;
typedef uint32_t ATTR_MAX_DIMM_POWER_type;

// Type aliases and/or sizes for ATTR_MAX_DMI_PER_PROC attribute
typedef uint8_t MAX_DMI_PER_PROC_ATTR;
typedef uint8_t ATTR_MAX_DMI_PER_PROC_type;

// Type aliases and/or sizes for ATTR_MAX_EXS_PER_PROC_CHIP attribute
typedef uint8_t MAX_EXS_PER_PROC_CHIP_ATTR;
typedef uint8_t ATTR_MAX_EXS_PER_PROC_CHIP_type;

// Type aliases and/or sizes for ATTR_MAX_MBAS_PER_MEMBUF_CHIP attribute
typedef uint8_t MAX_MBAS_PER_MEMBUF_CHIP_ATTR;
typedef uint8_t ATTR_MAX_MBAS_PER_MEMBUF_CHIP_type;

// Type aliases and/or sizes for ATTR_MAX_MBA_PORTS_PER_MBA attribute
typedef uint8_t MAX_MBA_PORTS_PER_MBA_ATTR;
typedef uint8_t ATTR_MAX_MBA_PORTS_PER_MBA_type;

// Type aliases and/or sizes for ATTR_MAX_MCS_PER_SYSTEM attribute
typedef uint8_t MAX_MCS_PER_SYSTEM_ATTR;
typedef uint8_t ATTR_MAX_MCS_PER_SYSTEM_type;

// Type aliases and/or sizes for ATTR_MAX_POWER attribute
typedef uint8_t MAX_POWER_ATTR;
typedef uint8_t ATTR_MAX_POWER_type;

// Type aliases and/or sizes for ATTR_MAX_PROC_CHIPS_PER_NODE attribute
typedef uint8_t MAX_PROC_CHIPS_PER_NODE_ATTR;
typedef uint8_t ATTR_MAX_PROC_CHIPS_PER_NODE_type;

// Type aliases and/or sizes for ATTR_MBA_DIMM attribute
typedef uint8_t MBA_DIMM_ATTR;
typedef uint8_t ATTR_MBA_DIMM_type;

// Type aliases and/or sizes for ATTR_MBA_PORT attribute
typedef uint8_t MBA_PORT_ATTR;
typedef uint8_t ATTR_MBA_PORT_type;

// Type aliases and/or sizes for ATTR_MEM_AVDD_OFFSET_MILLIVOLTS attribute
typedef uint32_t MEM_AVDD_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MEM_AVDD_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MEM_BASE attribute
typedef uint64_t MEM_BASE_ATTR;
typedef uint64_t ATTR_MEM_BASE_type;

// Type aliases and/or sizes for ATTR_MEM_PORT attribute
typedef uint8_t MEM_PORT_ATTR;
typedef uint8_t ATTR_MEM_PORT_type;

// Type aliases and/or sizes for ATTR_MEM_VCS_OFFSET_MILLIVOLTS attribute
typedef uint32_t MEM_VCS_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MEM_VCS_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MEM_VDDR_OFFSET_MILLIVOLTS attribute
typedef uint32_t MEM_VDDR_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MEM_VDDR_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MEM_VDD_OFFSET_MILLIVOLTS attribute
typedef uint32_t MEM_VDD_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MEM_VDD_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MEM_VPP_OFFSET_MILLIVOLTS attribute
typedef uint32_t MEM_VPP_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MEM_VPP_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MFG_TRACE_ENABLE attribute
typedef uint8_t MFG_TRACE_ENABLE_ATTR;
typedef uint8_t ATTR_MFG_TRACE_ENABLE_type;

// Type aliases and/or sizes for ATTR_MGC_LOAD_SOURCE attribute
typedef uint8_t MGC_LOAD_SOURCE_ATTR;
typedef uint8_t ATTR_MGC_LOAD_SOURCE_type;

// Type aliases and/or sizes for ATTR_MIN_FREQ_MHZ attribute
typedef uint32_t MIN_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_MIN_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_MIRROR_BASE_ADDRESS attribute
typedef uint64_t MIRROR_BASE_ADDRESS_ATTR;
typedef uint64_t ATTR_MIRROR_BASE_ADDRESS_type;

// Type aliases and/or sizes for ATTR_MMIO_PHYS_ADDR attribute
typedef uint64_t MMIO_PHYS_ADDR_ATTR;
typedef uint64_t ATTR_MMIO_PHYS_ADDR_type;

// Type aliases and/or sizes for ATTR_MNFG_ABUS_MIN_EYE_HEIGHT attribute
typedef uint8_t MNFG_ABUS_MIN_EYE_HEIGHT_ATTR;
typedef uint8_t ATTR_MNFG_ABUS_MIN_EYE_HEIGHT_type;

// Type aliases and/or sizes for ATTR_MNFG_ABUS_MIN_EYE_WIDTH attribute
typedef uint8_t MNFG_ABUS_MIN_EYE_WIDTH_ATTR;
typedef uint8_t ATTR_MNFG_ABUS_MIN_EYE_WIDTH_type;

// Type aliases and/or sizes for ATTR_MNFG_DMI_MIN_EYE_HEIGHT attribute
typedef uint8_t MNFG_DMI_MIN_EYE_HEIGHT_ATTR;
typedef uint8_t ATTR_MNFG_DMI_MIN_EYE_HEIGHT_type;

// Type aliases and/or sizes for ATTR_MNFG_DMI_MIN_EYE_WIDTH attribute
typedef uint8_t MNFG_DMI_MIN_EYE_WIDTH_ATTR;
typedef uint8_t ATTR_MNFG_DMI_MIN_EYE_WIDTH_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_L2_CACHE_CES attribute
typedef uint8_t MNFG_TH_L2_CACHE_CES_ATTR;
typedef uint8_t ATTR_MNFG_TH_L2_CACHE_CES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_L2_DIR_CES attribute
typedef uint8_t MNFG_TH_L2_DIR_CES_ATTR;
typedef uint8_t ATTR_MNFG_TH_L2_DIR_CES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_L2_LINE_DELETES attribute
typedef uint8_t MNFG_TH_L2_LINE_DELETES_ATTR;
typedef uint8_t ATTR_MNFG_TH_L2_LINE_DELETES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_L3_CACHE_CES attribute
typedef uint8_t MNFG_TH_L3_CACHE_CES_ATTR;
typedef uint8_t ATTR_MNFG_TH_L3_CACHE_CES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_L3_DIR_CES attribute
typedef uint8_t MNFG_TH_L3_DIR_CES_ATTR;
typedef uint8_t ATTR_MNFG_TH_L3_DIR_CES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_L3_LINE_DELETES attribute
typedef uint8_t MNFG_TH_L3_LINE_DELETES_ATTR;
typedef uint8_t ATTR_MNFG_TH_L3_LINE_DELETES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_MEMORY_IMPES attribute
typedef uint8_t MNFG_TH_MEMORY_IMPES_ATTR;
typedef uint8_t ATTR_MNFG_TH_MEMORY_IMPES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO attribute
typedef uint8_t MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO_ATTR;
typedef uint8_t ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_MEMORY_IUES attribute
typedef uint8_t MNFG_TH_MEMORY_IUES_ATTR;
typedef uint8_t ATTR_MNFG_TH_MEMORY_IUES_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS attribute
typedef uint8_t MNFG_TH_MEMORY_RCD_PARITY_ERRORS_ATTR;
typedef uint8_t ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK attribute
typedef uint8_t MNFG_TH_MEMORY_RT_RCE_PER_RANK_ATTR;
typedef uint8_t ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK_type;

// Type aliases and/or sizes for ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO attribute
typedef uint8_t MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO_ATTR;
typedef uint8_t ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO_type;

// Type aliases and/or sizes for ATTR_MNFG_XBUS_MIN_EYE_WIDTH attribute
typedef uint8_t MNFG_XBUS_MIN_EYE_WIDTH_ATTR;
typedef uint8_t ATTR_MNFG_XBUS_MIN_EYE_WIDTH_type;

// Type aliases and/or sizes for ATTR_MODEL attribute
typedef MODEL MODEL_ATTR;
typedef MODEL ATTR_MODEL_type;

// Type aliases and/or sizes for ATTR_MRU_ID attribute
typedef uint32_t MRU_ID_ATTR;
typedef uint32_t ATTR_MRU_ID_type;

// Type aliases and/or sizes for ATTR_MRW_DDR3_VDDR_MAX_LIMIT attribute
typedef uint32_t MRW_DDR3_VDDR_MAX_LIMIT_ATTR;
typedef uint32_t ATTR_MRW_DDR3_VDDR_MAX_LIMIT_type;

// Type aliases and/or sizes for ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT attribute
typedef uint32_t MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MRW_DDR4_VDDR_MAX_LIMIT attribute
typedef uint32_t MRW_DDR4_VDDR_MAX_LIMIT_ATTR;
typedef uint32_t ATTR_MRW_DDR4_VDDR_MAX_LIMIT_type;

// Type aliases and/or sizes for ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT attribute
typedef uint32_t MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MRW_DEFAULT_RISK_LEVEL attribute
typedef uint32_t MRW_DEFAULT_RISK_LEVEL_ATTR;
typedef uint32_t ATTR_MRW_DEFAULT_RISK_LEVEL_type;

// Type aliases and/or sizes for ATTR_MRW_MEM_THROTTLE_DENOMINATOR attribute
typedef uint32_t MRW_MEM_THROTTLE_DENOMINATOR_ATTR;
typedef uint32_t ATTR_MRW_MEM_THROTTLE_DENOMINATOR_type;

// Type aliases and/or sizes for ATTR_MSL_FIELD_SUPPORTED attribute
typedef uint16_t MSL_FIELD_SUPPORTED_ATTR[12];
typedef uint16_t ATTR_MSL_FIELD_SUPPORTED_type[12];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 12> ATTR_MSL_FIELD_SUPPORTED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSL_MFG_ALLOW attribute
typedef uint16_t MSL_MFG_ALLOW_ATTR[12];
typedef uint16_t ATTR_MSL_MFG_ALLOW_type[12];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 12> ATTR_MSL_MFG_ALLOW_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_AVDD_PROGRAM attribute
typedef uint8_t MSS_AVDD_PROGRAM_ATTR;
typedef uint8_t ATTR_MSS_AVDD_PROGRAM_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_AVDD_INTERCEPT attribute
typedef uint32_t MSS_CENT_AVDD_INTERCEPT_ATTR;
typedef uint32_t ATTR_MSS_CENT_AVDD_INTERCEPT_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE attribute
typedef uint32_t MSS_CENT_AVDD_SLOPE_ACTIVE_ATTR;
typedef uint32_t ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE attribute
typedef uint32_t MSS_CENT_AVDD_SLOPE_INACTIVE_ATTR;
typedef uint32_t ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_VCS_INTERCEPT attribute
typedef uint32_t MSS_CENT_VCS_INTERCEPT_ATTR;
typedef uint32_t ATTR_MSS_CENT_VCS_INTERCEPT_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_VCS_SLOPE_ACTIVE attribute
typedef uint32_t MSS_CENT_VCS_SLOPE_ACTIVE_ATTR;
typedef uint32_t ATTR_MSS_CENT_VCS_SLOPE_ACTIVE_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_VCS_SLOPE_INACTIVE attribute
typedef uint32_t MSS_CENT_VCS_SLOPE_INACTIVE_ATTR;
typedef uint32_t ATTR_MSS_CENT_VCS_SLOPE_INACTIVE_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_VDD_INTERCEPT attribute
typedef uint32_t MSS_CENT_VDD_INTERCEPT_ATTR;
typedef uint32_t ATTR_MSS_CENT_VDD_INTERCEPT_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_VDD_SLOPE_ACTIVE attribute
typedef uint32_t MSS_CENT_VDD_SLOPE_ACTIVE_ATTR;
typedef uint32_t ATTR_MSS_CENT_VDD_SLOPE_ACTIVE_type;

// Type aliases and/or sizes for ATTR_MSS_CENT_VDD_SLOPE_INACTIVE attribute
typedef uint32_t MSS_CENT_VDD_SLOPE_INACTIVE_ATTR;
typedef uint32_t ATTR_MSS_CENT_VDD_SLOPE_INACTIVE_type;

// Type aliases and/or sizes for ATTR_MSS_DATABUS_UTIL_PER_MBA attribute
typedef uint8_t MSS_DATABUS_UTIL_PER_MBA_ATTR;
typedef uint8_t ATTR_MSS_DATABUS_UTIL_PER_MBA_type;

// Type aliases and/or sizes for ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT attribute
typedef uint8_t MSS_MBA_ADDR_INTERLEAVE_BIT_ATTR;
typedef uint8_t ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT_type;

// Type aliases and/or sizes for ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE attribute
typedef uint8_t MSS_MBA_CACHELINE_INTERLEAVE_MODE_ATTR;
typedef uint8_t ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE_type;

// Type aliases and/or sizes for ATTR_MSS_PHY_SEQ_REFRESH attribute
typedef uint8_t MSS_PHY_SEQ_REFRESH_ATTR[2];
typedef uint8_t ATTR_MSS_PHY_SEQ_REFRESH_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_MSS_PHY_SEQ_REFRESH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_VCS_PROGRAM attribute
typedef uint8_t MSS_VCS_PROGRAM_ATTR;
typedef uint8_t ATTR_MSS_VCS_PROGRAM_type;

// Type aliases and/or sizes for ATTR_MSS_VDDR_PROGRAM attribute
typedef uint8_t MSS_VDDR_PROGRAM_ATTR;
typedef uint8_t ATTR_MSS_VDDR_PROGRAM_type;

// Type aliases and/or sizes for ATTR_MSS_VDD_PROGRAM attribute
typedef uint8_t MSS_VDD_PROGRAM_ATTR;
typedef uint8_t ATTR_MSS_VDD_PROGRAM_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_AVDD_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_AVDD_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_AVDD_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT attribute
typedef uint32_t MSS_VOLT_DDR3_VDDR_INTERCEPT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT attribute
typedef uint32_t MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR3_VDDR_SLOPE attribute
typedef uint32_t MSS_VOLT_DDR3_VDDR_SLOPE_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT attribute
typedef uint32_t MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT attribute
typedef uint32_t MSS_VOLT_DDR4_VDDR_INTERCEPT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT attribute
typedef uint32_t MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR4_VDDR_SLOPE attribute
typedef uint32_t MSS_VOLT_DDR4_VDDR_SLOPE_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT attribute
typedef uint32_t MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VCS_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VCS_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VCS_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VCS_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VDDR_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VDDR_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VDDR_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VDD_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VDD_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VDD_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VDD_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VPP_INTERCEPT attribute
typedef uint32_t MSS_VOLT_VPP_INTERCEPT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VPP_INTERCEPT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT attribute
typedef uint32_t MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VPP_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VPP_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VPP_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS attribute
typedef uint32_t MSS_VOLT_VPP_OFFSET_MILLIVOLTS_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VPP_SLOPE attribute
typedef uint32_t MSS_VOLT_VPP_SLOPE_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VPP_SLOPE_type;

// Type aliases and/or sizes for ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT attribute
typedef uint32_t MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT_ATTR;
typedef uint32_t ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT_type;

// Type aliases and/or sizes for ATTR_MSS_VPP_PROGRAM attribute
typedef uint8_t MSS_VPP_PROGRAM_ATTR;
typedef uint8_t ATTR_MSS_VPP_PROGRAM_type;

// Type aliases and/or sizes for ATTR_NEST_PLL_FREQ_BUCKETS attribute
typedef uint8_t NEST_PLL_FREQ_BUCKETS_ATTR;
typedef uint8_t ATTR_NEST_PLL_FREQ_BUCKETS_type;

// Type aliases and/or sizes for ATTR_NEST_PLL_FREQ_I2CDIV_LIST attribute
typedef uint32_t NEST_PLL_FREQ_I2CDIV_LIST_ATTR[5];
typedef uint32_t ATTR_NEST_PLL_FREQ_I2CDIV_LIST_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 5> ATTR_NEST_PLL_FREQ_I2CDIV_LIST_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NEST_PLL_FREQ_LIST attribute
typedef uint32_t NEST_PLL_FREQ_LIST_ATTR[5];
typedef uint32_t ATTR_NEST_PLL_FREQ_LIST_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 5> ATTR_NEST_PLL_FREQ_LIST_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NEST_VCS_ID attribute
typedef uint16_t NEST_VCS_ID_ATTR;
typedef uint16_t ATTR_NEST_VCS_ID_type;

// Type aliases and/or sizes for ATTR_NEST_VDDR_ID attribute
typedef uint16_t NEST_VDDR_ID_ATTR;
typedef uint16_t ATTR_NEST_VDDR_ID_type;

// Type aliases and/or sizes for ATTR_NEST_VDD_ID attribute
typedef uint16_t NEST_VDD_ID_ATTR;
typedef uint16_t ATTR_NEST_VDD_ID_type;

// Type aliases and/or sizes for ATTR_NEST_VDN_ID attribute
typedef uint16_t NEST_VDN_ID_ATTR;
typedef uint16_t ATTR_NEST_VDN_ID_type;

// Type aliases and/or sizes for ATTR_NEST_VIO_ID attribute
typedef uint16_t NEST_VIO_ID_ATTR;
typedef uint16_t ATTR_NEST_VIO_ID_type;

// Type aliases and/or sizes for ATTR_NO_RECONFIG_ON_DECONFIG attribute
typedef uint8_t NO_RECONFIG_ON_DECONFIG_ATTR;
typedef uint8_t ATTR_NO_RECONFIG_ON_DECONFIG_type;

// Type aliases and/or sizes for ATTR_NPU_MMIO_BAR_BASE_ADDR attribute
typedef uint64_t NPU_MMIO_BAR_BASE_ADDR_ATTR[4][2];
typedef uint64_t ATTR_NPU_MMIO_BAR_BASE_ADDR_type[4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint64_t, 2>, 4> ATTR_NPU_MMIO_BAR_BASE_ADDR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NPU_MMIO_BAR_SIZE attribute
typedef uint64_t NPU_MMIO_BAR_SIZE_ATTR[4][2];
typedef uint64_t ATTR_NPU_MMIO_BAR_SIZE_type[4][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint64_t, 2>, 4> ATTR_NPU_MMIO_BAR_SIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NUMERIC_POD_TYPE_TEST attribute
typedef NumericPodTypeTest NUMERIC_POD_TYPE_TEST_ATTR;
typedef NumericPodTypeTest ATTR_NUMERIC_POD_TYPE_TEST_type;

// Type aliases and/or sizes for ATTR_NVDIMM_ARMED attribute
typedef NvdimmArmed NVDIMM_ARMED_ATTR;
typedef NvdimmArmed ATTR_NVDIMM_ARMED_type;

// Type aliases and/or sizes for ATTR_NV_OPS_TIMEOUT_MSEC attribute
typedef uint32_t NV_OPS_TIMEOUT_MSEC_ATTR[6];
typedef uint32_t ATTR_NV_OPS_TIMEOUT_MSEC_type[6];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 6> ATTR_NV_OPS_TIMEOUT_MSEC_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NV_STATUS_FLAG attribute
typedef uint8_t NV_STATUS_FLAG_ATTR;
typedef uint8_t ATTR_NV_STATUS_FLAG_type;

// Type aliases and/or sizes for ATTR_OBUS_BRICK_LANE_MASK attribute
typedef uint32_t OBUS_BRICK_LANE_MASK_ATTR;
typedef uint32_t ATTR_OBUS_BRICK_LANE_MASK_type;

// Type aliases and/or sizes for ATTR_OBUS_SLOT_INDEX attribute
typedef uint8_t OBUS_SLOT_INDEX_ATTR;
typedef uint8_t ATTR_OBUS_SLOT_INDEX_type;

// Type aliases and/or sizes for ATTR_OCC_MASTER_CAPABLE attribute
typedef uint8_t OCC_MASTER_CAPABLE_ATTR;
typedef uint8_t ATTR_OCC_MASTER_CAPABLE_type;

// Type aliases and/or sizes for ATTR_OCMB_BOOT_SIDE attribute
typedef uint8_t OCMB_BOOT_SIDE_ATTR;
typedef uint8_t ATTR_OCMB_BOOT_SIDE_type;

// Type aliases and/or sizes for ATTR_OCMB_CODE_LEVEL_SUMMARY attribute
typedef char OCMB_CODE_LEVEL_SUMMARY_ATTR[256];
typedef char ATTR_OCMB_CODE_LEVEL_SUMMARY_type[256];
#if __cplusplus >= 201103L 
typedef std::array<char, 256> ATTR_OCMB_CODE_LEVEL_SUMMARY_typeStdArr;
#endif
const size_t ATTR_OCMB_CODE_LEVEL_SUMMARY_max_chars = 255;

// Type aliases and/or sizes for ATTR_OCMB_CODE_UPDATED attribute
typedef uint8_t OCMB_CODE_UPDATED_ATTR;
typedef uint8_t ATTR_OCMB_CODE_UPDATED_type;

// Type aliases and/or sizes for ATTR_OCMB_FORCE_IMAGE_SYNC attribute
typedef uint8_t OCMB_FORCE_IMAGE_SYNC_ATTR;
typedef uint8_t ATTR_OCMB_FORCE_IMAGE_SYNC_type;

// Type aliases and/or sizes for ATTR_OCMB_FW_STATE attribute
typedef OCMB_FW_STATE OCMB_FW_STATE_ATTR;
typedef OCMB_FW_STATE ATTR_OCMB_FW_STATE_type;

// Type aliases and/or sizes for ATTR_OCMB_FW_UPDATE_OVERRIDE attribute
typedef uint8_t OCMB_FW_UPDATE_OVERRIDE_ATTR;
typedef uint8_t ATTR_OCMB_FW_UPDATE_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_OCMB_FW_UPDATE_STATUS attribute
typedef OcmbFwUpdateStatus OCMB_FW_UPDATE_STATUS_ATTR;
typedef OcmbFwUpdateStatus ATTR_OCMB_FW_UPDATE_STATUS_type;

// Type aliases and/or sizes for ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED attribute
typedef uint8_t OCMB_GOLDEN_BOOT_ATTEMPTED_ATTR;
typedef uint8_t ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED_type;

// Type aliases and/or sizes for ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE attribute
typedef uint8_t OCMB_IGNORE_SCOM_CHECK_DISABLE_ATTR;
typedef uint8_t ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE_type;

// Type aliases and/or sizes for ATTR_OCMB_ISTEP_MODE attribute
typedef uint8_t OCMB_ISTEP_MODE_ATTR;
typedef uint8_t ATTR_OCMB_ISTEP_MODE_type;

// Type aliases and/or sizes for ATTR_OCMB_RESET_DELAY_SEC attribute
typedef uint8_t OCMB_RESET_DELAY_SEC_ATTR;
typedef uint8_t ATTR_OCMB_RESET_DELAY_SEC_type;

// Type aliases and/or sizes for ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE attribute
typedef uint64_t ODYSSEY_PRIORITY_CODE_UPDATE_RULE_ATTR[2];
typedef uint64_t ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 2> ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ODY_PNOR_COMBINED_IMAGES_HASH attribute
typedef uint8_t ODY_PNOR_COMBINED_IMAGES_HASH_ATTR[64];
typedef uint8_t ATTR_ODY_PNOR_COMBINED_IMAGES_HASH_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 64> ATTR_ODY_PNOR_COMBINED_IMAGES_HASH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_ORDINAL_ID attribute
typedef uint32_t ORDINAL_ID_ATTR;
typedef uint32_t ATTR_ORDINAL_ID_type;

// Type aliases and/or sizes for ATTR_PARENT_DECONFIG_RULES attribute
typedef ParentDeconfigRules PARENT_DECONFIG_RULES_ATTR;
typedef ParentDeconfigRules ATTR_PARENT_DECONFIG_RULES_type;

// Type aliases and/or sizes for ATTR_PAYLOAD_BASE attribute
typedef uint64_t PAYLOAD_BASE_ATTR;
typedef uint64_t ATTR_PAYLOAD_BASE_type;

// Type aliases and/or sizes for ATTR_PAYLOAD_ENTRY attribute
typedef uint64_t PAYLOAD_ENTRY_ATTR;
typedef uint64_t ATTR_PAYLOAD_ENTRY_type;

// Type aliases and/or sizes for ATTR_PAYLOAD_IN_MIRROR_MEM attribute
typedef uint8_t PAYLOAD_IN_MIRROR_MEM_ATTR;
typedef uint8_t ATTR_PAYLOAD_IN_MIRROR_MEM_type;

// Type aliases and/or sizes for ATTR_PAYLOAD_KIND attribute
typedef PAYLOAD_KIND PAYLOAD_KIND_ATTR;
typedef PAYLOAD_KIND ATTR_PAYLOAD_KIND_type;

// Type aliases and/or sizes for ATTR_PCIE_32BIT_DMA_SIZE attribute
typedef uint8_t PCIE_32BIT_DMA_SIZE_ATTR;
typedef uint8_t ATTR_PCIE_32BIT_DMA_SIZE_type;

// Type aliases and/or sizes for ATTR_PCIE_32BIT_MMIO_SIZE attribute
typedef uint8_t PCIE_32BIT_MMIO_SIZE_ATTR;
typedef uint8_t ATTR_PCIE_32BIT_MMIO_SIZE_type;

// Type aliases and/or sizes for ATTR_PCIE_64BIT_DMA_SIZE attribute
typedef uint8_t PCIE_64BIT_DMA_SIZE_ATTR;
typedef uint8_t ATTR_PCIE_64BIT_DMA_SIZE_type;

// Type aliases and/or sizes for ATTR_PCIE_64BIT_MMIO_SIZE attribute
typedef uint8_t PCIE_64BIT_MMIO_SIZE_ATTR;
typedef uint8_t ATTR_PCIE_64BIT_MMIO_SIZE_type;

// Type aliases and/or sizes for ATTR_PCIE_CAPABILITES attribute
typedef uint8_t PCIE_CAPABILITES_ATTR;
typedef uint8_t ATTR_PCIE_CAPABILITES_type;

// Type aliases and/or sizes for ATTR_PCIE_NVME_CCIN attribute
typedef uint64_t PCIE_NVME_CCIN_ATTR;
typedef uint64_t ATTR_PCIE_NVME_CCIN_type;

// Type aliases and/or sizes for ATTR_PCIE_NVME_PHB_CONFIG attribute
typedef uint64_t PCIE_NVME_PHB_CONFIG_ATTR[2][2];
typedef uint64_t ATTR_PCIE_NVME_PHB_CONFIG_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint64_t, 2>, 2> ATTR_PCIE_NVME_PHB_CONFIG_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PCI_REFCLOCK_RCVR_TERM attribute
typedef uint8_t PCI_REFCLOCK_RCVR_TERM_ATTR;
typedef uint8_t ATTR_PCI_REFCLOCK_RCVR_TERM_type;

// Type aliases and/or sizes for ATTR_PEC_IS_BIFURCATABLE attribute
typedef uint8_t PEC_IS_BIFURCATABLE_ATTR;
typedef uint8_t ATTR_PEC_IS_BIFURCATABLE_type;

// Type aliases and/or sizes for ATTR_PEC_PCIE_HX_KEYWORD_DATA attribute
typedef uint8_t PEC_PCIE_HX_KEYWORD_DATA_ATTR[9];
typedef uint8_t ATTR_PEC_PCIE_HX_KEYWORD_DATA_type[9];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 9> ATTR_PEC_PCIE_HX_KEYWORD_DATA_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PEC_PCIE_IOP_REVERSAL attribute
typedef uint8_t PEC_PCIE_IOP_REVERSAL_ATTR[4];
typedef uint8_t ATTR_PEC_PCIE_IOP_REVERSAL_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_PEC_PCIE_IOP_REVERSAL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED attribute
typedef uint8_t PEC_PCIE_IOP_REVERSAL_BIFURCATED_ATTR[4];
typedef uint8_t ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED attribute
typedef uint8_t PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED_ATTR[4];
typedef uint8_t ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED attribute
typedef uint8_t PEC_PCIE_IOP_SWAP_BIFURCATED_ATTR;
typedef uint8_t ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED_type;

// Type aliases and/or sizes for ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED attribute
typedef uint8_t PEC_PCIE_IOP_SWAP_NON_BIFURCATED_ATTR;
typedef uint8_t ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED_type;

// Type aliases and/or sizes for ATTR_PEC_PCIE_LANE_MASK_BIFURCATED attribute
typedef uint16_t PEC_PCIE_LANE_MASK_BIFURCATED_ATTR[4];
typedef uint16_t ATTR_PEC_PCIE_LANE_MASK_BIFURCATED_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_PEC_PCIE_LANE_MASK_BIFURCATED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED attribute
typedef uint16_t PEC_PCIE_LANE_MASK_NON_BIFURCATED_ATTR[4];
typedef uint16_t ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PEER_PATH attribute
typedef EntityPath PEER_PATH_ATTR;
typedef EntityPath ATTR_PEER_PATH_type;

// Type aliases and/or sizes for ATTR_PEER_TARGET attribute
typedef TARGETING::Target* PEER_TARGET_ATTR;
typedef TARGETING::Target* ATTR_PEER_TARGET_type;

// Type aliases and/or sizes for ATTR_PG attribute
typedef uint32_t PG_ATTR;
typedef uint32_t ATTR_PG_type;

// Type aliases and/or sizes for ATTR_PG_SAVED attribute
typedef uint32_t PG_SAVED_ATTR;
typedef uint32_t ATTR_PG_SAVED_type;

// Type aliases and/or sizes for ATTR_PHB_BASE_ADDRS attribute
typedef uint64_t PHB_BASE_ADDRS_ATTR[4];
typedef uint64_t ATTR_PHB_BASE_ADDRS_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 4> ATTR_PHB_BASE_ADDRS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PHYS_PATH attribute
typedef EntityPath PHYS_PATH_ATTR;
typedef EntityPath ATTR_PHYS_PATH_type;

// Type aliases and/or sizes for ATTR_PIB_I2C_NEST_PLL attribute
typedef uint32_t PIB_I2C_NEST_PLL_ATTR;
typedef uint32_t ATTR_PIB_I2C_NEST_PLL_type;

// Type aliases and/or sizes for ATTR_PIB_I2C_REFCLOCK attribute
typedef uint32_t PIB_I2C_REFCLOCK_ATTR;
typedef uint32_t ATTR_PIB_I2C_REFCLOCK_type;

// Type aliases and/or sizes for ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST attribute
typedef uint8_t PLCK_IPL_ATTR_OVERRIDES_EXIST_ATTR;
typedef uint8_t ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST_type;

// Type aliases and/or sizes for ATTR_PMIC_CALLBACK_STAGGER_TIME attribute
typedef uint32_t PMIC_CALLBACK_STAGGER_TIME_ATTR;
typedef uint32_t ATTR_PMIC_CALLBACK_STAGGER_TIME_type;

// Type aliases and/or sizes for ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER attribute
typedef uint32_t PMIC_HEALTH_CHECK_DDR5_TIMER_ATTR;
typedef uint32_t ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER_type;

// Type aliases and/or sizes for ATTR_PMIC_HEALTH_CHECK_TIMER attribute
typedef uint32_t PMIC_HEALTH_CHECK_TIMER_ATTR;
typedef uint32_t ATTR_PMIC_HEALTH_CHECK_TIMER_type;

// Type aliases and/or sizes for ATTR_PNOR_FLASH_WORKAROUNDS attribute
typedef uint32_t PNOR_FLASH_WORKAROUNDS_ATTR;
typedef uint32_t ATTR_PNOR_FLASH_WORKAROUNDS_type;

// Type aliases and/or sizes for ATTR_POSITION attribute
typedef uint16_t POSITION_ATTR;
typedef uint16_t ATTR_POSITION_type;

// Type aliases and/or sizes for ATTR_POS_ON_MEM_PORT attribute
typedef uint8_t POS_ON_MEM_PORT_ATTR;
typedef uint8_t ATTR_POS_ON_MEM_PORT_type;

// Type aliases and/or sizes for ATTR_POWERVS_P10_FW_VER attribute
typedef uint8_t POWERVS_P10_FW_VER_ATTR[3][3];
typedef uint8_t ATTR_POWERVS_P10_FW_VER_type[3][3];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 3>, 3> ATTR_POWERVS_P10_FW_VER_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_POWER_PATH attribute
typedef EntityPath POWER_PATH_ATTR;
typedef EntityPath ATTR_POWER_PATH_type;

// Type aliases and/or sizes for ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE attribute
typedef uint8_t PRD_DD1_OMI_DEGRADE_PREDICTIVE_ATTR;
typedef uint8_t ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE_type;

// Type aliases and/or sizes for ATTR_PRD_HWP_PLID attribute
typedef uint32_t PRD_HWP_PLID_ATTR;
typedef uint32_t ATTR_PRD_HWP_PLID_type;

// Type aliases and/or sizes for ATTR_PREHEAT_PERCENT attribute
typedef uint16_t PREHEAT_PERCENT_ATTR;
typedef uint16_t ATTR_PREHEAT_PERCENT_type;

// Type aliases and/or sizes for ATTR_PRIMARY_CAPABILITIES attribute
typedef PrimaryCapabilities PRIMARY_CAPABILITIES_ATTR;
typedef PrimaryCapabilities ATTR_PRIMARY_CAPABILITIES_type;

// Type aliases and/or sizes for ATTR_PROC_COMPATIBILITY_REQ attribute
typedef PROC_COMPATIBILITY_REQ PROC_COMPATIBILITY_REQ_ATTR;
typedef PROC_COMPATIBILITY_REQ ATTR_PROC_COMPATIBILITY_REQ_type;

// Type aliases and/or sizes for ATTR_PROC_DCM_INSTALLED attribute
typedef uint8_t PROC_DCM_INSTALLED_ATTR;
typedef uint8_t ATTR_PROC_DCM_INSTALLED_type;

// Type aliases and/or sizes for ATTR_PROC_MASTER_TYPE attribute
typedef uint8_t PROC_MASTER_TYPE_ATTR;
typedef uint8_t ATTR_PROC_MASTER_TYPE_type;

// Type aliases and/or sizes for ATTR_PROC_MODULE_TYPE attribute
typedef PROC_MODULE_TYPE PROC_MODULE_TYPE_ATTR;
typedef PROC_MODULE_TYPE ATTR_PROC_MODULE_TYPE_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_IOP_CONFIG attribute
typedef uint8_t PROC_PCIE_IOP_CONFIG_ATTR;
typedef uint8_t ATTR_PROC_PCIE_IOP_CONFIG_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_IOVALID_ENABLE attribute
typedef uint8_t PROC_PCIE_IOVALID_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_PCIE_IOVALID_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_IS_SLOT attribute
typedef uint8_t PROC_PCIE_IS_SLOT_ATTR[4];
typedef uint8_t ATTR_PROC_PCIE_IS_SLOT_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 4> ATTR_PROC_PCIE_IS_SLOT_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3 attribute
typedef uint16_t PROC_PCIE_LANE_EQUALIZATION_GEN3_ATTR[16];
typedef uint16_t ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3_type[16];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 16> ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4 attribute
typedef uint16_t PROC_PCIE_LANE_EQUALIZATION_GEN4_ATTR[16];
typedef uint16_t ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4_type[16];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 16> ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5 attribute
typedef uint16_t PROC_PCIE_LANE_EQUALIZATION_GEN5_ATTR[16];
typedef uint16_t ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5_type[16];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 16> ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_LANE_MASK attribute
typedef uint16_t PROC_PCIE_LANE_MASK_ATTR[4];
typedef uint16_t ATTR_PROC_PCIE_LANE_MASK_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_PROC_PCIE_LANE_MASK_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_LANE_REVERSAL_BASE attribute
typedef uint8_t PROC_PCIE_LANE_REVERSAL_BASE_ATTR[3];
typedef uint8_t ATTR_PROC_PCIE_LANE_REVERSAL_BASE_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_PCIE_LANE_REVERSAL_BASE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_NUM_PEC attribute
typedef uint8_t PROC_PCIE_NUM_PEC_ATTR;
typedef uint8_t ATTR_PROC_PCIE_NUM_PEC_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL attribute
typedef uint16_t PROC_PCIE_PCS_RX_LOFF_CONTROL_ATTR[4];
typedef uint16_t ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL attribute
typedef uint16_t PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL_ATTR;
typedef uint16_t ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL attribute
typedef uint16_t PROC_PCIE_PCS_RX_SIGDET_CNTL_ATTR;
typedef uint16_t ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3 attribute
typedef uint16_t PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3_ATTR[4];
typedef uint16_t ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3_type[4];
#if __cplusplus >= 201103L 
typedef std::array<uint16_t, 4> ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_PHB_ACTIVE_BASE attribute
typedef uint8_t PROC_PCIE_PHB_ACTIVE_BASE_ATTR[3];
typedef uint8_t ATTR_PROC_PCIE_PHB_ACTIVE_BASE_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PROC_PCIE_PHB_ACTIVE_BASE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PROC_PCIE_REFCLOCK_ENABLE attribute
typedef uint8_t PROC_PCIE_REFCLOCK_ENABLE_ATTR;
typedef uint8_t ATTR_PROC_PCIE_REFCLOCK_ENABLE_type;

// Type aliases and/or sizes for ATTR_PROC_REFCLOCK_RCVR_TERM attribute
typedef uint8_t PROC_REFCLOCK_RCVR_TERM_ATTR;
typedef uint8_t ATTR_PROC_REFCLOCK_RCVR_TERM_type;

// Type aliases and/or sizes for ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE attribute
typedef uint8_t PROC_SELECT_BOOT_SEEPROM_IMAGE_ATTR;
typedef uint8_t ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE_type;

// Type aliases and/or sizes for ATTR_PROC_SELECT_SEEPROM_IMAGE attribute
typedef uint8_t PROC_SELECT_SEEPROM_IMAGE_ATTR;
typedef uint8_t ATTR_PROC_SELECT_SEEPROM_IMAGE_type;

// Type aliases and/or sizes for ATTR_PSI_BRIDGE_BASE_ADDR attribute
typedef uint64_t PSI_BRIDGE_BASE_ADDR_ATTR;
typedef uint64_t ATTR_PSI_BRIDGE_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_PSI_HB_ESB_ADDR attribute
typedef uint64_t PSI_HB_ESB_ADDR_ATTR;
typedef uint64_t ATTR_PSI_HB_ESB_ADDR_type;

// Type aliases and/or sizes for ATTR_RAW_MTM attribute
typedef char RAW_MTM_ATTR[64];
typedef char ATTR_RAW_MTM_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_RAW_MTM_typeStdArr;
#endif
const size_t ATTR_RAW_MTM_max_chars = 63;

// Type aliases and/or sizes for ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED attribute
typedef uint8_t RCD_PARITY_RECONFIG_LOOPS_ALLOWED_ATTR;
typedef uint8_t ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED_type;

// Type aliases and/or sizes for ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT attribute
typedef uint8_t RCD_PARITY_RECONFIG_LOOP_COUNT_ATTR;
typedef uint8_t ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT_type;

// Type aliases and/or sizes for ATTR_RECONFIG_LOOP_TESTS attribute
typedef uint64_t RECONFIG_LOOP_TESTS_ATTR[5];
typedef uint64_t ATTR_RECONFIG_LOOP_TESTS_type[5];
#if __cplusplus >= 201103L 
typedef std::array<uint64_t, 5> ATTR_RECONFIG_LOOP_TESTS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_RECONFIG_LOOP_TESTS_ENABLE attribute
typedef uint8_t RECONFIG_LOOP_TESTS_ENABLE_ATTR;
typedef uint8_t ATTR_RECONFIG_LOOP_TESTS_ENABLE_type;

// Type aliases and/or sizes for ATTR_REDUNDANT_CLOCKS attribute
typedef uint8_t REDUNDANT_CLOCKS_ATTR;
typedef uint8_t ATTR_REDUNDANT_CLOCKS_type;

// Type aliases and/or sizes for ATTR_REL_POS attribute
typedef uint8_t REL_POS_ATTR;
typedef uint8_t ATTR_REL_POS_type;

// Type aliases and/or sizes for ATTR_REPLACED_BY_SPARE attribute
typedef uint8_t REPLACED_BY_SPARE_ATTR;
typedef uint8_t ATTR_REPLACED_BY_SPARE_type;

// Type aliases and/or sizes for ATTR_RESOURCE_IS_CRITICAL attribute
typedef uint8_t RESOURCE_IS_CRITICAL_ATTR;
typedef uint8_t ATTR_RESOURCE_IS_CRITICAL_type;

// Type aliases and/or sizes for ATTR_RISK_LEVEL_ORIGIN attribute
typedef RISK_LEVEL_ORIGIN RISK_LEVEL_ORIGIN_ATTR;
typedef RISK_LEVEL_ORIGIN ATTR_RISK_LEVEL_ORIGIN_type;

// Type aliases and/or sizes for ATTR_RNG_BAR_SIZE attribute
typedef uint64_t RNG_BAR_SIZE_ATTR;
typedef uint64_t ATTR_RNG_BAR_SIZE_type;

// Type aliases and/or sizes for ATTR_RNG_BASE_ADDR attribute
typedef uint64_t RNG_BASE_ADDR_ATTR;
typedef uint64_t ATTR_RNG_BASE_ADDR_type;

// Type aliases and/or sizes for ATTR_RUN_MAX_MEM_PATTERNS attribute
typedef uint8_t RUN_MAX_MEM_PATTERNS_ATTR;
typedef uint8_t ATTR_RUN_MAX_MEM_PATTERNS_type;

// Type aliases and/or sizes for ATTR_RUN_ODY_HWP_FROM_HOST attribute
typedef uint8_t RUN_ODY_HWP_FROM_HOST_ATTR;
typedef uint8_t ATTR_RUN_ODY_HWP_FROM_HOST_type;

// Type aliases and/or sizes for ATTR_SAVED_STATE_UINT8 attribute
typedef uint8_t SAVED_STATE_UINT8_ATTR;
typedef uint8_t ATTR_SAVED_STATE_UINT8_type;

// Type aliases and/or sizes for ATTR_SBE_BOOTLOADER_CODELEVEL attribute
typedef uint8_t SBE_BOOTLOADER_CODELEVEL_ATTR[64];
typedef uint8_t ATTR_SBE_BOOTLOADER_CODELEVEL_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 64> ATTR_SBE_BOOTLOADER_CODELEVEL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SBE_BUILD_TAG attribute
typedef char SBE_BUILD_TAG_ATTR[21];
typedef char ATTR_SBE_BUILD_TAG_type[21];
#if __cplusplus >= 201103L 
typedef std::array<char, 21> ATTR_SBE_BUILD_TAG_typeStdArr;
#endif
const size_t ATTR_SBE_BUILD_TAG_max_chars = 20;

// Type aliases and/or sizes for ATTR_SBE_COMMIT_ID attribute
typedef uint32_t SBE_COMMIT_ID_ATTR;
typedef uint32_t ATTR_SBE_COMMIT_ID_type;

// Type aliases and/or sizes for ATTR_SBE_EKB_BUILD_TAG attribute
typedef char SBE_EKB_BUILD_TAG_ATTR[21];
typedef char ATTR_SBE_EKB_BUILD_TAG_type[21];
#if __cplusplus >= 201103L 
typedef std::array<char, 21> ATTR_SBE_EKB_BUILD_TAG_typeStdArr;
#endif
const size_t ATTR_SBE_EKB_BUILD_TAG_max_chars = 20;

// Type aliases and/or sizes for ATTR_SBE_FIFO_CAPABILITIES attribute
typedef uint32_t SBE_FIFO_CAPABILITIES_ATTR[40];
typedef uint32_t ATTR_SBE_FIFO_CAPABILITIES_type[40];
#if __cplusplus >= 201103L 
typedef std::array<uint32_t, 40> ATTR_SBE_FIFO_CAPABILITIES_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SBE_HANDLES_SMP_TPM_EXTEND attribute
typedef uint8_t SBE_HANDLES_SMP_TPM_EXTEND_ATTR;
typedef uint8_t ATTR_SBE_HANDLES_SMP_TPM_EXTEND_type;

// Type aliases and/or sizes for ATTR_SBE_IS_STARTED attribute
typedef uint8_t SBE_IS_STARTED_ATTR;
typedef uint8_t ATTR_SBE_IS_STARTED_type;

// Type aliases and/or sizes for ATTR_SBE_NUM_CAPABILITIES attribute
typedef uint32_t SBE_NUM_CAPABILITIES_ATTR;
typedef uint32_t ATTR_SBE_NUM_CAPABILITIES_type;

// Type aliases and/or sizes for ATTR_SBE_NUM_IMAGES attribute
typedef uint32_t SBE_NUM_IMAGES_ATTR;
typedef uint32_t ATTR_SBE_NUM_IMAGES_type;

// Type aliases and/or sizes for ATTR_SBE_RELEASE_TAG attribute
typedef char SBE_RELEASE_TAG_ATTR[21];
typedef char ATTR_SBE_RELEASE_TAG_type[21];
#if __cplusplus >= 201103L 
typedef std::array<char, 21> ATTR_SBE_RELEASE_TAG_typeStdArr;
#endif
const size_t ATTR_SBE_RELEASE_TAG_max_chars = 20;

// Type aliases and/or sizes for ATTR_SBE_RUNTIME_CODELEVEL attribute
typedef uint8_t SBE_RUNTIME_CODELEVEL_ATTR[64];
typedef uint8_t ATTR_SBE_RUNTIME_CODELEVEL_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 64> ATTR_SBE_RUNTIME_CODELEVEL_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SBE_UPDATE_DISABLE attribute
typedef uint8_t SBE_UPDATE_DISABLE_ATTR;
typedef uint8_t ATTR_SBE_UPDATE_DISABLE_type;

// Type aliases and/or sizes for ATTR_SBE_VERSION_INFO attribute
typedef uint32_t SBE_VERSION_INFO_ATTR;
typedef uint32_t ATTR_SBE_VERSION_INFO_type;

// Type aliases and/or sizes for ATTR_SCOM_SWITCHES attribute
typedef ScomSwitches SCOM_SWITCHES_ATTR;
typedef ScomSwitches ATTR_SCOM_SWITCHES_type;

// Type aliases and/or sizes for ATTR_SCRATCH_UINT32_1 attribute
typedef uint32_t SCRATCH_UINT32_1_ATTR;
typedef uint32_t ATTR_SCRATCH_UINT32_1_type;

// Type aliases and/or sizes for ATTR_SCRATCH_UINT32_2 attribute
typedef uint32_t SCRATCH_UINT32_2_ATTR;
typedef uint32_t ATTR_SCRATCH_UINT32_2_type;

// Type aliases and/or sizes for ATTR_SCRATCH_UINT64_1 attribute
typedef uint64_t SCRATCH_UINT64_1_ATTR;
typedef uint64_t ATTR_SCRATCH_UINT64_1_type;

// Type aliases and/or sizes for ATTR_SCRATCH_UINT64_2 attribute
typedef uint64_t SCRATCH_UINT64_2_ATTR;
typedef uint64_t ATTR_SCRATCH_UINT64_2_type;

// Type aliases and/or sizes for ATTR_SCRATCH_UINT8_1 attribute
typedef uint8_t SCRATCH_UINT8_1_ATTR;
typedef uint8_t ATTR_SCRATCH_UINT8_1_type;

// Type aliases and/or sizes for ATTR_SCRATCH_UINT8_2 attribute
typedef uint8_t SCRATCH_UINT8_2_ATTR;
typedef uint8_t ATTR_SCRATCH_UINT8_2_type;

// Type aliases and/or sizes for ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM attribute
typedef uint8_t SECUREBOOT_PROTECT_DECONFIGURED_TPM_ATTR;
typedef uint8_t ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM_type;

// Type aliases and/or sizes for ATTR_SECURE_VERSION_LOCKIN_POLICY attribute
typedef uint8_t SECURE_VERSION_LOCKIN_POLICY_ATTR;
typedef uint8_t ATTR_SECURE_VERSION_LOCKIN_POLICY_type;

// Type aliases and/or sizes for ATTR_SECURE_VERSION_NUM attribute
typedef uint8_t SECURE_VERSION_NUM_ATTR;
typedef uint8_t ATTR_SECURE_VERSION_NUM_type;

// Type aliases and/or sizes for ATTR_SECURE_VERSION_SEEPROM attribute
typedef uint8_t SECURE_VERSION_SEEPROM_ATTR;
typedef uint8_t ATTR_SECURE_VERSION_SEEPROM_type;

// Type aliases and/or sizes for ATTR_SKIP_HBRT_ATTR_UPDATE attribute
typedef uint8_t SKIP_HBRT_ATTR_UPDATE_ATTR;
typedef uint8_t ATTR_SKIP_HBRT_ATTR_UPDATE_type;

// Type aliases and/or sizes for ATTR_SLOT_INDEX attribute
typedef uint8_t SLOT_INDEX_ATTR;
typedef uint8_t ATTR_SLOT_INDEX_type;

// Type aliases and/or sizes for ATTR_SLOT_NAME attribute
typedef uint8_t SLOT_NAME_ATTR;
typedef uint8_t ATTR_SLOT_NAME_type;

// Type aliases and/or sizes for ATTR_SMF_MEM_AMT_REQUESTED attribute
typedef uint64_t SMF_MEM_AMT_REQUESTED_ATTR;
typedef uint64_t ATTR_SMF_MEM_AMT_REQUESTED_type;

// Type aliases and/or sizes for ATTR_SOCKET_POWER_TURBO attribute
typedef uint32_t SOCKET_POWER_TURBO_ATTR;
typedef uint32_t ATTR_SOCKET_POWER_TURBO_type;

// Type aliases and/or sizes for ATTR_SPARE_CORES attribute
typedef uint8_t SPARE_CORES_ATTR;
typedef uint8_t ATTR_SPARE_CORES_type;

// Type aliases and/or sizes for ATTR_SPARE_CORES_DEPLOYED attribute
typedef uint8_t SPARE_CORES_DEPLOYED_ATTR;
typedef uint8_t ATTR_SPARE_CORES_DEPLOYED_type;

// Type aliases and/or sizes for ATTR_SPARE_CORE_ACTIONS_DISABLED attribute
typedef uint8_t SPARE_CORE_ACTIONS_DISABLED_ATTR;
typedef uint8_t ATTR_SPARE_CORE_ACTIONS_DISABLED_type;

// Type aliases and/or sizes for ATTR_SPI_EEPROM_SPARE_INFO attribute
typedef SpiEepromSpareInfo SPI_EEPROM_SPARE_INFO_ATTR;
typedef SpiEepromSpareInfo ATTR_SPI_EEPROM_SPARE_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_EEPROM_VPD_BACKUP_INFO attribute
typedef SpiEepromVpdBackupInfo SPI_EEPROM_VPD_BACKUP_INFO_ATTR;
typedef SpiEepromVpdBackupInfo ATTR_SPI_EEPROM_VPD_BACKUP_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_EEPROM_VPD_PRIMARY_INFO attribute
typedef SpiEepromVpdPrimaryInfo SPI_EEPROM_VPD_PRIMARY_INFO_ATTR;
typedef SpiEepromVpdPrimaryInfo ATTR_SPI_EEPROM_VPD_PRIMARY_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_KEYSTORE_INFO_HOSTBOOT attribute
typedef SpiKeystoreInfoHostboot SPI_KEYSTORE_INFO_HOSTBOOT_ATTR;
typedef SpiKeystoreInfoHostboot ATTR_SPI_KEYSTORE_INFO_HOSTBOOT_type;

// Type aliases and/or sizes for ATTR_SPI_KEYSTORE_INFO_OPAL_0 attribute
typedef SpiKeystoreInfoOpal0 SPI_KEYSTORE_INFO_OPAL_0_ATTR;
typedef SpiKeystoreInfoOpal0 ATTR_SPI_KEYSTORE_INFO_OPAL_0_type;

// Type aliases and/or sizes for ATTR_SPI_KEYSTORE_INFO_OPAL_1 attribute
typedef SpiKeystoreInfoOpal1 SPI_KEYSTORE_INFO_OPAL_1_ATTR;
typedef SpiKeystoreInfoOpal1 ATTR_SPI_KEYSTORE_INFO_OPAL_1_type;

// Type aliases and/or sizes for ATTR_SPI_KEYSTORE_INFO_OPAL_2 attribute
typedef SpiKeystoreInfoOpal2 SPI_KEYSTORE_INFO_OPAL_2_ATTR;
typedef SpiKeystoreInfoOpal2 ATTR_SPI_KEYSTORE_INFO_OPAL_2_type;

// Type aliases and/or sizes for ATTR_SPI_KEYSTORE_INFO_PHYP attribute
typedef SpiKeystoreInfoPhyp SPI_KEYSTORE_INFO_PHYP_ATTR;
typedef SpiKeystoreInfoPhyp ATTR_SPI_KEYSTORE_INFO_PHYP_type;

// Type aliases and/or sizes for ATTR_SPI_MVPD_BACKUP_INFO attribute
typedef SpiMvpdBackupInfo SPI_MVPD_BACKUP_INFO_ATTR;
typedef SpiMvpdBackupInfo ATTR_SPI_MVPD_BACKUP_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_MVPD_PRIMARY_INFO attribute
typedef SpiMvpdPrimaryInfo SPI_MVPD_PRIMARY_INFO_ATTR;
typedef SpiMvpdPrimaryInfo ATTR_SPI_MVPD_PRIMARY_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO attribute
typedef SpiSbeBootCodeBackupInfo SPI_SBE_BOOT_CODE_BACKUP_INFO_ATTR;
typedef SpiSbeBootCodeBackupInfo ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO attribute
typedef SpiSbeBootCodePrimaryInfo SPI_SBE_BOOT_CODE_PRIMARY_INFO_ATTR;
typedef SpiSbeBootCodePrimaryInfo ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO attribute
typedef SpiSbeMeasurementCodeBackupInfo SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO_ATTR;
typedef SpiSbeMeasurementCodeBackupInfo ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO attribute
typedef SpiSbeMeasurementCodePrimaryInfo SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO_ATTR;
typedef SpiSbeMeasurementCodePrimaryInfo ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_SWITCHES attribute
typedef SpiSwitches SPI_SWITCHES_ATTR;
typedef SpiSwitches ATTR_SPI_SWITCHES_type;

// Type aliases and/or sizes for ATTR_SPI_TPM_INFO attribute
typedef SpiTpmInfo SPI_TPM_INFO_ATTR;
typedef SpiTpmInfo ATTR_SPI_TPM_INFO_type;

// Type aliases and/or sizes for ATTR_SPI_WOF_DATA_INFO attribute
typedef SpiWofDataInfo SPI_WOF_DATA_INFO_ATTR;
typedef SpiWofDataInfo ATTR_SPI_WOF_DATA_INFO_type;

// Type aliases and/or sizes for ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH attribute
typedef uint8_t SPPE_BOOTLOADER_MEASUREMENT_HASH_ATTR[64];
typedef uint8_t ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 64> ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SPPE_RUNTIME_MEASUREMENT_HASH attribute
typedef uint8_t SPPE_RUNTIME_MEASUREMENT_HASH_ATTR[64];
typedef uint8_t ATTR_SPPE_RUNTIME_MEASUREMENT_HASH_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 64> ATTR_SPPE_RUNTIME_MEASUREMENT_HASH_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_SP_FUNCTIONS attribute
typedef SpFunctions SP_FUNCTIONS_ATTR;
typedef SpFunctions ATTR_SP_FUNCTIONS_type;

// Type aliases and/or sizes for ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN attribute
typedef uint64_t START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN_ATTR;
typedef uint64_t ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN_type;

// Type aliases and/or sizes for ATTR_STOP5_DISABLE attribute
typedef uint8_t STOP5_DISABLE_ATTR;
typedef uint8_t ATTR_STOP5_DISABLE_type;

// Type aliases and/or sizes for ATTR_SUPPORTED_STOP_STATES attribute
typedef uint32_t SUPPORTED_STOP_STATES_ATTR;
typedef uint32_t ATTR_SUPPORTED_STOP_STATES_type;

// Type aliases and/or sizes for ATTR_SUPPORTS_DYNAMIC_MEM_VOLT attribute
typedef uint8_t SUPPORTS_DYNAMIC_MEM_VOLT_ATTR;
typedef uint8_t ATTR_SUPPORTS_DYNAMIC_MEM_VOLT_type;

// Type aliases and/or sizes for ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG attribute
typedef uint64_t SW511706_CHECKSTOP_ON_GTE_LV1_HANG_ATTR;
typedef uint64_t ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG_type;

// Type aliases and/or sizes for ATTR_SYNC_BETWEEN_STEPS attribute
typedef uint8_t SYNC_BETWEEN_STEPS_ATTR;
typedef uint8_t ATTR_SYNC_BETWEEN_STEPS_type;

// Type aliases and/or sizes for ATTR_SYSTEM_FAMILY attribute
typedef char SYSTEM_FAMILY_ATTR[64];
typedef char ATTR_SYSTEM_FAMILY_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_SYSTEM_FAMILY_typeStdArr;
#endif
const size_t ATTR_SYSTEM_FAMILY_max_chars = 63;

// Type aliases and/or sizes for ATTR_SYSTEM_THERMAL_RESISTANCE attribute
typedef uint32_t SYSTEM_THERMAL_RESISTANCE_ATTR;
typedef uint32_t ATTR_SYSTEM_THERMAL_RESISTANCE_type;

// Type aliases and/or sizes for ATTR_SYSTEM_TYPE attribute
typedef char SYSTEM_TYPE_ATTR[64];
typedef char ATTR_SYSTEM_TYPE_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_SYSTEM_TYPE_typeStdArr;
#endif
const size_t ATTR_SYSTEM_TYPE_max_chars = 63;

// Type aliases and/or sizes for ATTR_SYS_LOCATION_CODE attribute
typedef char SYS_LOCATION_CODE_ATTR[64];
typedef char ATTR_SYS_LOCATION_CODE_type[64];
#if __cplusplus >= 201103L 
typedef std::array<char, 64> ATTR_SYS_LOCATION_CODE_typeStdArr;
#endif
const size_t ATTR_SYS_LOCATION_CODE_max_chars = 63;

// Type aliases and/or sizes for ATTR_TCE_START_TOKEN_FOR_HDAT attribute
typedef uint32_t TCE_START_TOKEN_FOR_HDAT_ATTR;
typedef uint32_t ATTR_TCE_START_TOKEN_FOR_HDAT_type;

// Type aliases and/or sizes for ATTR_TCE_START_TOKEN_FOR_PAYLOAD attribute
typedef uint32_t TCE_START_TOKEN_FOR_PAYLOAD_ATTR;
typedef uint32_t ATTR_TCE_START_TOKEN_FOR_PAYLOAD_type;

// Type aliases and/or sizes for ATTR_TEMP_SENSOR_I2C_CONFIG attribute
typedef TempSensorI2cConfig TEMP_SENSOR_I2C_CONFIG_ATTR;
typedef TempSensorI2cConfig ATTR_TEMP_SENSOR_I2C_CONFIG_type;

// Type aliases and/or sizes for ATTR_TEST_MAX_STRING attribute
typedef char TEST_MAX_STRING_ATTR[4];
typedef char ATTR_TEST_MAX_STRING_type[4];
#if __cplusplus >= 201103L 
typedef std::array<char, 4> ATTR_TEST_MAX_STRING_typeStdArr;
#endif
const size_t ATTR_TEST_MAX_STRING_max_chars = 3;

// Type aliases and/or sizes for ATTR_TEST_MIN_STRING attribute
typedef char TEST_MIN_STRING_ATTR[10];
typedef char ATTR_TEST_MIN_STRING_type[10];
#if __cplusplus >= 201103L 
typedef std::array<char, 10> ATTR_TEST_MIN_STRING_typeStdArr;
#endif
const size_t ATTR_TEST_MIN_STRING_max_chars = 9;

// Type aliases and/or sizes for ATTR_TEST_NEGATIVE_FCN attribute
typedef int8_t TEST_NEGATIVE_FCN_ATTR;
typedef int8_t ATTR_TEST_NEGATIVE_FCN_type;

// Type aliases and/or sizes for ATTR_TEST_NO_DEFAULT_STRING attribute
typedef char TEST_NO_DEFAULT_STRING_ATTR[10];
typedef char ATTR_TEST_NO_DEFAULT_STRING_type[10];
#if __cplusplus >= 201103L 
typedef std::array<char, 10> ATTR_TEST_NO_DEFAULT_STRING_typeStdArr;
#endif
const size_t ATTR_TEST_NO_DEFAULT_STRING_max_chars = 9;

// Type aliases and/or sizes for ATTR_TEST_NULL_STRING attribute
typedef char TEST_NULL_STRING_ATTR[10];
typedef char ATTR_TEST_NULL_STRING_type[10];
#if __cplusplus >= 201103L 
typedef std::array<char, 10> ATTR_TEST_NULL_STRING_typeStdArr;
#endif
const size_t ATTR_TEST_NULL_STRING_max_chars = 9;

// Type aliases and/or sizes for ATTR_THREAD_COUNT attribute
typedef uint32_t THREAD_COUNT_ATTR;
typedef uint32_t ATTR_THREAD_COUNT_type;

// Type aliases and/or sizes for ATTR_TIME_BASE attribute
typedef uint32_t TIME_BASE_ATTR;
typedef uint32_t ATTR_TIME_BASE_type;

// Type aliases and/or sizes for ATTR_TLB_DATA_ASSOC_SETS attribute
typedef uint32_t TLB_DATA_ASSOC_SETS_ATTR;
typedef uint32_t ATTR_TLB_DATA_ASSOC_SETS_type;

// Type aliases and/or sizes for ATTR_TLB_DATA_ENTRIES attribute
typedef uint32_t TLB_DATA_ENTRIES_ATTR;
typedef uint32_t ATTR_TLB_DATA_ENTRIES_type;

// Type aliases and/or sizes for ATTR_TLB_INSTR_ASSOC_SETS attribute
typedef uint32_t TLB_INSTR_ASSOC_SETS_ATTR;
typedef uint32_t ATTR_TLB_INSTR_ASSOC_SETS_type;

// Type aliases and/or sizes for ATTR_TLB_INSTR_ENTRIES attribute
typedef uint32_t TLB_INSTR_ENTRIES_ATTR;
typedef uint32_t ATTR_TLB_INSTR_ENTRIES_type;

// Type aliases and/or sizes for ATTR_TLB_RESERVE_SIZE attribute
typedef uint32_t TLB_RESERVE_SIZE_ATTR;
typedef uint32_t ATTR_TLB_RESERVE_SIZE_type;

// Type aliases and/or sizes for ATTR_TOD_CPU_DATA attribute
typedef uint8_t TOD_CPU_DATA_ATTR[44];
typedef uint8_t ATTR_TOD_CPU_DATA_type[44];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 44> ATTR_TOD_CPU_DATA_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_TOD_ROLE attribute
typedef uint8_t TOD_ROLE_ATTR;
typedef uint8_t ATTR_TOD_ROLE_type;

// Type aliases and/or sizes for ATTR_TPM_ENABLED attribute
typedef uint8_t TPM_ENABLED_ATTR;
typedef uint8_t ATTR_TPM_ENABLED_type;

// Type aliases and/or sizes for ATTR_TPM_POISONED attribute
typedef uint8_t TPM_POISONED_ATTR;
typedef uint8_t ATTR_TPM_POISONED_type;

// Type aliases and/or sizes for ATTR_TPM_REQUIRED attribute
typedef uint8_t TPM_REQUIRED_ATTR;
typedef uint8_t ATTR_TPM_REQUIRED_type;

// Type aliases and/or sizes for ATTR_TPM_UNUSABLE attribute
typedef uint8_t TPM_UNUSABLE_ATTR;
typedef uint8_t ATTR_TPM_UNUSABLE_type;

// Type aliases and/or sizes for ATTR_TYPE attribute
typedef TYPE TYPE_ATTR;
typedef TYPE ATTR_TYPE_type;

// Type aliases and/or sizes for ATTR_UCD_MFR_REVISION_OVERRIDE attribute
typedef uint16_t UCD_MFR_REVISION_OVERRIDE_ATTR;
typedef uint16_t ATTR_UCD_MFR_REVISION_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_ULTRA_TURBO_FREQ_MHZ attribute
typedef uint32_t ULTRA_TURBO_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_ULTRA_TURBO_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_USE_11S_SPD attribute
typedef uint8_t USE_11S_SPD_ATTR;
typedef uint8_t ATTR_USE_11S_SPD_type;

// Type aliases and/or sizes for ATTR_USE_PIPE_FIFO attribute
typedef uint8_t USE_PIPE_FIFO_ATTR;
typedef uint8_t ATTR_USE_PIPE_FIFO_type;

// Type aliases and/or sizes for ATTR_USE_TCES_FOR_DMAS attribute
typedef uint8_t USE_TCES_FOR_DMAS_ATTR;
typedef uint8_t ATTR_USE_TCES_FOR_DMAS_type;

// Type aliases and/or sizes for ATTR_VCS_ID attribute
typedef uint16_t VCS_ID_ATTR;
typedef uint16_t ATTR_VCS_ID_type;

// Type aliases and/or sizes for ATTR_VDDR_ID attribute
typedef uint16_t VDDR_ID_ATTR;
typedef uint16_t ATTR_VDDR_ID_type;

// Type aliases and/or sizes for ATTR_VDD_ID attribute
typedef uint16_t VDD_ID_ATTR;
typedef uint16_t ATTR_VDD_ID_type;

// Type aliases and/or sizes for ATTR_VENDOR_ID attribute
typedef uint8_t VENDOR_ID_ATTR;
typedef uint8_t ATTR_VENDOR_ID_type;

// Type aliases and/or sizes for ATTR_VPD_REC_NUM attribute
typedef uint16_t VPD_REC_NUM_ATTR;
typedef uint16_t ATTR_VPD_REC_NUM_type;

// Type aliases and/or sizes for ATTR_VPP_ID attribute
typedef uint16_t VPP_ID_ATTR;
typedef uint16_t ATTR_VPP_ID_type;

// Type aliases and/or sizes for ATTR_WOF_POWER_LIMIT attribute
typedef uint8_t WOF_POWER_LIMIT_ATTR;
typedef uint8_t ATTR_WOF_POWER_LIMIT_type;

// Type aliases and/or sizes for ATTR_WOF_TABLE_LID_NUMBER attribute
typedef uint32_t WOF_TABLE_LID_NUMBER_ATTR;
typedef uint32_t ATTR_WOF_TABLE_LID_NUMBER_type;

// Type aliases and/or sizes for ATTR_XIVE_CONTROLLER_BAR_ADDR attribute
typedef uint64_t XIVE_CONTROLLER_BAR_ADDR_ATTR;
typedef uint64_t ATTR_XIVE_CONTROLLER_BAR_ADDR_type;

// Type aliases and/or sizes for ATTR_XSCOM_BASE_ADDRESS attribute
typedef uint64_t XSCOM_BASE_ADDRESS_ATTR;
typedef uint64_t ATTR_XSCOM_BASE_ADDRESS_type;

// Type aliases and/or sizes for ATTR_I2C_CHIP_INFO attribute
typedef I2cChipInfo I2C_CHIP_INFO_ATTR;
typedef I2cChipInfo ATTR_I2C_CHIP_INFO_type;

// Type aliases and/or sizes for ATTR_SBE_STATE attribute
typedef SBE_STATE SBE_STATE_ATTR;
typedef SBE_STATE ATTR_SBE_STATE_type;

// Type aliases and/or sizes for ATTR_HCSI_CHIP_SBE_INTERFACE_PTR attribute
typedef uint32_t HCSI_CHIP_SBE_INTERFACE_PTR_ATTR;
typedef uint32_t ATTR_HCSI_CHIP_SBE_INTERFACE_PTR_type;

// Type aliases and/or sizes for ATTR_HCSI_CHIP_INTERFACE_PTR attribute
typedef uint32_t HCSI_CHIP_INTERFACE_PTR_ATTR;
typedef uint32_t ATTR_HCSI_CHIP_INTERFACE_PTR_type;

// Type aliases and/or sizes for ATTR_SCANRING_FACTORY_PTR attribute
typedef uint32_t SCANRING_FACTORY_PTR_ATTR;
typedef uint32_t ATTR_SCANRING_FACTORY_PTR_type;

// Type aliases and/or sizes for ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER attribute
typedef uint32_t ALG_TYPE_TO_ALG_TOKEN_CONTAINER_ATTR;
typedef uint32_t ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER_type;

// Type aliases and/or sizes for ATTR_ECMD_TARGET attribute
typedef uint8_t ECMD_TARGET_ATTR[64];
typedef uint8_t ATTR_ECMD_TARGET_type[64];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 64> ATTR_ECMD_TARGET_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_RID attribute
typedef uint32_t RID_ATTR;
typedef uint32_t ATTR_RID_type;

// Type aliases and/or sizes for ATTR_FSP_SCOM_DEVICE_PATH attribute
typedef char FSP_SCOM_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_SCOM_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_SCOM_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_SCOM_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_A_SCOM_DEVICE_PATH attribute
typedef char FSP_A_SCOM_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_A_SCOM_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_A_SCOM_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_SCOM_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_B_SCOM_DEVICE_PATH attribute
typedef char FSP_B_SCOM_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_B_SCOM_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_B_SCOM_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_SCOM_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_SCAN_DEVICE_PATH attribute
typedef char FSP_SCAN_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_SCAN_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_SCAN_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_SCAN_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_A_SCAN_DEVICE_PATH attribute
typedef char FSP_A_SCAN_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_A_SCAN_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_A_SCAN_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_SCAN_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_B_SCAN_DEVICE_PATH attribute
typedef char FSP_B_SCAN_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_B_SCAN_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_B_SCAN_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_SCAN_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_MBOX_DEVICE_PATH attribute
typedef char FSP_MBOX_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_MBOX_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_MBOX_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_MBOX_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_A_MBOX_DEVICE_PATH attribute
typedef char FSP_A_MBOX_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_A_MBOX_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_A_MBOX_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_MBOX_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_B_MBOX_DEVICE_PATH attribute
typedef char FSP_B_MBOX_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_B_MBOX_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_B_MBOX_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_MBOX_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_SBEFIFO_DEVICE_PATH attribute
typedef char FSP_SBEFIFO_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_SBEFIFO_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_SBEFIFO_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_SBEFIFO_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_A_SBEFIFO_DEVICE_PATH attribute
typedef char FSP_A_SBEFIFO_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_A_SBEFIFO_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_A_SBEFIFO_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_SBEFIFO_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_FSP_B_SBEFIFO_DEVICE_PATH attribute
typedef char FSP_B_SBEFIFO_DEVICE_PATH_ATTR[38];
typedef char ATTR_FSP_B_SBEFIFO_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_FSP_B_SBEFIFO_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_SBEFIFO_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_MAX_MS_ADDR attribute
typedef uint64_t MAX_MS_ADDR_ATTR;
typedef uint64_t ATTR_MAX_MS_ADDR_type;

// Type aliases and/or sizes for ATTR_PAYLOAD_STATE attribute
typedef PAYLOAD_STATE PAYLOAD_STATE_ATTR;
typedef PAYLOAD_STATE ATTR_PAYLOAD_STATE_type;

// Type aliases and/or sizes for ATTR_PAYLOAD_STARTED attribute
typedef uint8_t PAYLOAD_STARTED_ATTR;
typedef uint8_t ATTR_PAYLOAD_STARTED_type;

// Type aliases and/or sizes for ATTR_HB_RUNNING attribute
typedef uint8_t HB_RUNNING_ATTR;
typedef uint8_t ATTR_HB_RUNNING_type;

// Type aliases and/or sizes for ATTR_RESUME_PAYLOAD attribute
typedef uint8_t RESUME_PAYLOAD_ATTR;
typedef uint8_t ATTR_RESUME_PAYLOAD_type;

// Type aliases and/or sizes for ATTR_PSI_LINK_STATE attribute
typedef PSI_LINK_STATE PSI_LINK_STATE_ATTR;
typedef PSI_LINK_STATE ATTR_PSI_LINK_STATE_type;

// Type aliases and/or sizes for ATTR_PSI_DEVICE_PATH attribute
typedef char PSI_DEVICE_PATH_ATTR[38];
typedef char ATTR_PSI_DEVICE_PATH_type[38];
#if __cplusplus >= 201103L 
typedef std::array<char, 38> ATTR_PSI_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_PSI_DEVICE_PATH_max_chars = 37;

// Type aliases and/or sizes for ATTR_HOST_MAILBOX_DEV_PATH attribute
typedef char HOST_MAILBOX_DEV_PATH_ATTR[17];
typedef char ATTR_HOST_MAILBOX_DEV_PATH_type[17];
#if __cplusplus >= 201103L 
typedef std::array<char, 17> ATTR_HOST_MAILBOX_DEV_PATH_typeStdArr;
#endif
const size_t ATTR_HOST_MAILBOX_DEV_PATH_max_chars = 16;

// Type aliases and/or sizes for ATTR_FSP_MTD_DEVICE_PATH attribute
typedef char FSP_MTD_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_MTD_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_MTD_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_MTD_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_MTDBLOCK_DEVICE_PATH attribute
typedef char FSP_MTDBLOCK_DEVICE_PATH_ATTR[30];
typedef char ATTR_FSP_MTDBLOCK_DEVICE_PATH_type[30];
#if __cplusplus >= 201103L 
typedef std::array<char, 30> ATTR_FSP_MTDBLOCK_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_MTDBLOCK_DEVICE_PATH_max_chars = 29;

// Type aliases and/or sizes for ATTR_EFF_HOSTBOOT_IMG_OFFSET attribute
typedef uint32_t EFF_HOSTBOOT_IMG_OFFSET_ATTR;
typedef uint32_t ATTR_EFF_HOSTBOOT_IMG_OFFSET_type;

// Type aliases and/or sizes for ATTR_PROC_HW_TOPOLOGY attribute
typedef uint16_t PROC_HW_TOPOLOGY_ATTR;
typedef uint16_t ATTR_PROC_HW_TOPOLOGY_type;

// Type aliases and/or sizes for ATTR_FSP_VMEM_DEVICE_PATH attribute
typedef char FSP_VMEM_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VMEM_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VMEM_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VMEM_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VMEM_I2C_ADDR attribute
typedef uint8_t FSP_VMEM_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VMEM_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_VDDR_DEVICE_PATH attribute
typedef char FSP_VDDR_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VDDR_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VDDR_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VDDR_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VDDR_I2C_ADDR attribute
typedef uint8_t FSP_VDDR_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VDDR_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_VDD_DEVICE_PATH attribute
typedef char FSP_VDD_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VDD_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VDD_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VDD_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VDD_I2C_ADDR attribute
typedef uint8_t FSP_VDD_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VDD_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_AVDD_DEVICE_PATH attribute
typedef char FSP_AVDD_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_AVDD_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_AVDD_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_AVDD_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_AVDD_I2C_ADDR attribute
typedef uint8_t FSP_AVDD_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_AVDD_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_VCS_DEVICE_PATH attribute
typedef char FSP_VCS_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VCS_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VCS_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VCS_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VCS_I2C_ADDR attribute
typedef uint8_t FSP_VCS_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VCS_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_VPP_DEVICE_PATH attribute
typedef char FSP_VPP_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VPP_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VPP_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VPP_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VPP_I2C_ADDR attribute
typedef uint8_t FSP_VPP_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VPP_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_VIO_DEVICE_PATH attribute
typedef char FSP_VIO_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VIO_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VIO_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VIO_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VIO_I2C_ADDR attribute
typedef uint8_t FSP_VIO_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VIO_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_FSP_VDN_DEVICE_PATH attribute
typedef char FSP_VDN_DEVICE_PATH_ATTR[25];
typedef char ATTR_FSP_VDN_DEVICE_PATH_type[25];
#if __cplusplus >= 201103L 
typedef std::array<char, 25> ATTR_FSP_VDN_DEVICE_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_VDN_DEVICE_PATH_max_chars = 24;

// Type aliases and/or sizes for ATTR_FSP_VDN_I2C_ADDR attribute
typedef uint8_t FSP_VDN_I2C_ADDR_ATTR;
typedef uint8_t ATTR_FSP_VDN_I2C_ADDR_type;

// Type aliases and/or sizes for ATTR_IS_MPIPL attribute
typedef uint8_t IS_MPIPL_ATTR;
typedef uint8_t ATTR_IS_MPIPL_type;

// Type aliases and/or sizes for ATTR_MSL_CHECK attribute
typedef uint8_t MSL_CHECK_ATTR;
typedef uint8_t ATTR_MSL_CHECK_type;

// Type aliases and/or sizes for ATTR_PRIMARY_SBE_SEEPROM_ADDRESS attribute
typedef char PRIMARY_SBE_SEEPROM_ADDRESS_ATTR[50];
typedef char ATTR_PRIMARY_SBE_SEEPROM_ADDRESS_type[50];
#if __cplusplus >= 201103L 
typedef std::array<char, 50> ATTR_PRIMARY_SBE_SEEPROM_ADDRESS_typeStdArr;
#endif
const size_t ATTR_PRIMARY_SBE_SEEPROM_ADDRESS_max_chars = 49;

// Type aliases and/or sizes for ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS attribute
typedef char FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS_ATTR[50];
typedef char ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS_type[50];
#if __cplusplus >= 201103L 
typedef std::array<char, 50> ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS_typeStdArr;
#endif
const size_t ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS_max_chars = 49;

// Type aliases and/or sizes for ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS attribute
typedef char FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS_ATTR[50];
typedef char ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS_type[50];
#if __cplusplus >= 201103L 
typedef std::array<char, 50> ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS_typeStdArr;
#endif
const size_t ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS_max_chars = 49;

// Type aliases and/or sizes for ATTR_SECONDARY_SBE_SEEPROM_ADDRESS attribute
typedef char SECONDARY_SBE_SEEPROM_ADDRESS_ATTR[50];
typedef char ATTR_SECONDARY_SBE_SEEPROM_ADDRESS_type[50];
#if __cplusplus >= 201103L 
typedef std::array<char, 50> ATTR_SECONDARY_SBE_SEEPROM_ADDRESS_typeStdArr;
#endif
const size_t ATTR_SECONDARY_SBE_SEEPROM_ADDRESS_max_chars = 49;

// Type aliases and/or sizes for ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS attribute
typedef char FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS_ATTR[50];
typedef char ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS_type[50];
#if __cplusplus >= 201103L 
typedef std::array<char, 50> ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS_typeStdArr;
#endif
const size_t ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS_max_chars = 49;

// Type aliases and/or sizes for ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS attribute
typedef char FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS_ATTR[50];
typedef char ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS_type[50];
#if __cplusplus >= 201103L 
typedef std::array<char, 50> ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS_typeStdArr;
#endif
const size_t ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS_max_chars = 49;

// Type aliases and/or sizes for ATTR_PROC_SELECT_CLOCK_MUX_MODE attribute
typedef uint8_t PROC_SELECT_CLOCK_MUX_MODE_ATTR;
typedef uint8_t ATTR_PROC_SELECT_CLOCK_MUX_MODE_type;

// Type aliases and/or sizes for ATTR_POWERSAVE_FREQ_MHZ attribute
typedef uint32_t POWERSAVE_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_POWERSAVE_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_TURBO_FREQ_MHZ attribute
typedef uint32_t TURBO_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_TURBO_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_FFO_FREQ_MHZ attribute
typedef uint32_t FFO_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_FFO_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_OCC_MIN_FREQ_MHZ attribute
typedef uint32_t OCC_MIN_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_OCC_MIN_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_MAX_NUM_PSI_LINKS_PER_FSP attribute
typedef uint8_t MAX_NUM_PSI_LINKS_PER_FSP_ATTR;
typedef uint8_t ATTR_MAX_NUM_PSI_LINKS_PER_FSP_type;

// Type aliases and/or sizes for ATTR_MIN_NUM_PSI_LINKS_PER_FSP attribute
typedef uint8_t MIN_NUM_PSI_LINKS_PER_FSP_ATTR;
typedef uint8_t ATTR_MIN_NUM_PSI_LINKS_PER_FSP_type;

// Type aliases and/or sizes for ATTR_PRIORITY_PSI_LINK_SELECTION attribute
typedef uint32_t PRIORITY_PSI_LINK_SELECTION_ATTR;
typedef uint32_t ATTR_PRIORITY_PSI_LINK_SELECTION_type;

// Type aliases and/or sizes for ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT attribute
typedef uint8_t MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT_ATTR;
typedef uint8_t ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT_type;

// Type aliases and/or sizes for ATTR_MODEL_EC attribute
typedef uint32_t MODEL_EC_ATTR;
typedef uint32_t ATTR_MODEL_EC_type;

// Type aliases and/or sizes for ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ attribute
typedef uint32_t VPD_POWERSAVE_MIN_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_IS_MASTER_NODE attribute
typedef uint8_t IS_MASTER_NODE_ATTR;
typedef uint8_t ATTR_IS_MASTER_NODE_type;

// Type aliases and/or sizes for ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS attribute
typedef uint8_t IS_PNOR_ECC_RECOVERY_IN_PROGRESS_ATTR;
typedef uint8_t ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS_type;

// Type aliases and/or sizes for ATTR_UPDATE_SLW_SCOM_TO_PHYP attribute
typedef uint8_t UPDATE_SLW_SCOM_TO_PHYP_ATTR;
typedef uint8_t ATTR_UPDATE_SLW_SCOM_TO_PHYP_type;

// Type aliases and/or sizes for ATTR_FSP_PM_SPWUP_OHA_FLAG attribute
typedef uint8_t FSP_PM_SPWUP_OHA_FLAG_ATTR;
typedef uint8_t ATTR_FSP_PM_SPWUP_OHA_FLAG_type;

// Type aliases and/or sizes for ATTR_SLW_IN_CHECKSTOP attribute
typedef uint8_t SLW_IN_CHECKSTOP_ATTR;
typedef uint8_t ATTR_SLW_IN_CHECKSTOP_type;

// Type aliases and/or sizes for ATTR_SPECIAL_WAKEUP_NEEDED attribute
typedef uint8_t SPECIAL_WAKEUP_NEEDED_ATTR;
typedef uint8_t ATTR_SPECIAL_WAKEUP_NEEDED_type;

// Type aliases and/or sizes for ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM attribute
typedef uint8_t DISABLE_SPECIAL_WAKEUP_ON_SYSTEM_ATTR;
typedef uint8_t ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM_type;

// Type aliases and/or sizes for ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED attribute
typedef uint8_t FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED_ATTR;
typedef uint8_t ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED_type;

// Type aliases and/or sizes for ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED attribute
typedef uint8_t FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED_ATTR;
typedef uint8_t ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED_type;

// Type aliases and/or sizes for ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH attribute
typedef uint32_t FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH_ATTR;
typedef uint32_t ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH_type;

// Type aliases and/or sizes for ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH attribute
typedef uint32_t FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH_ATTR;
typedef uint32_t ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH_type;

// Type aliases and/or sizes for ATTR_MELTBOX_NEST_FREQ_MHZ attribute
typedef uint32_t MELTBOX_NEST_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_MELTBOX_NEST_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_MELTBOX_FREQ_PB attribute
typedef uint32_t MELTBOX_FREQ_PB_ATTR;
typedef uint32_t ATTR_MELTBOX_FREQ_PB_type;

// Type aliases and/or sizes for ATTR_MELTBOX_FREQ_X attribute
typedef uint32_t MELTBOX_FREQ_X_ATTR;
typedef uint32_t ATTR_MELTBOX_FREQ_X_type;

// Type aliases and/or sizes for ATTR_DEFAULT_NEST_FREQ_MHZ attribute
typedef uint32_t DEFAULT_NEST_FREQ_MHZ_ATTR;
typedef uint32_t ATTR_DEFAULT_NEST_FREQ_MHZ_type;

// Type aliases and/or sizes for ATTR_DEFAULT_FREQ_PB attribute
typedef uint32_t DEFAULT_FREQ_PB_ATTR;
typedef uint32_t ATTR_DEFAULT_FREQ_PB_type;

// Type aliases and/or sizes for ATTR_DEFAULT_FREQ_X attribute
typedef uint32_t DEFAULT_FREQ_X_ATTR;
typedef uint32_t ATTR_DEFAULT_FREQ_X_type;

// Type aliases and/or sizes for ATTR_PROC_SLEEP_WINKLE_LID_ID attribute
typedef uint32_t PROC_SLEEP_WINKLE_LID_ID_ATTR;
typedef uint32_t ATTR_PROC_SLEEP_WINKLE_LID_ID_type;

// Type aliases and/or sizes for ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ attribute
typedef uint32_t FREQ_PROC_REFCLOCK_ACTUAL_KHZ_ATTR;
typedef uint32_t ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ_type;

// Type aliases and/or sizes for ATTR_HW_DECONFIG attribute
typedef uint8_t HW_DECONFIG_ATTR;
typedef uint8_t ATTR_HW_DECONFIG_type;

// Type aliases and/or sizes for ATTR_HB_HW_DECONFIG attribute
typedef uint8_t HB_HW_DECONFIG_ATTR;
typedef uint8_t ATTR_HB_HW_DECONFIG_type;

// Type aliases and/or sizes for ATTR_HW_RECONFIG_CURRENT_ITR attribute
typedef uint32_t HW_RECONFIG_CURRENT_ITR_ATTR;
typedef uint32_t ATTR_HW_RECONFIG_CURRENT_ITR_type;

// Type aliases and/or sizes for ATTR_FSP_HW_RECONFIG_MAX_COUNT attribute
typedef uint32_t FSP_HW_RECONFIG_MAX_COUNT_ATTR;
typedef uint32_t ATTR_FSP_HW_RECONFIG_MAX_COUNT_type;

// Type aliases and/or sizes for ATTR_FMBX_DMA_STATE attribute
typedef FMBX_DMA_STATE FMBX_DMA_STATE_ATTR;
typedef FMBX_DMA_STATE ATTR_FMBX_DMA_STATE_type;

#ifdef FSP
// Type aliases and/or sizes for ATTR_LOCK_SERVICE_LOCK attribute
typedef util::Mutex* LOCK_SERVICE_LOCK_ATTR;
typedef util::Mutex* ATTR_LOCK_SERVICE_LOCK_type;
#endif

// Type aliases and/or sizes for ATTR_SBE_UPDATE attribute
typedef uint8_t SBE_UPDATE_ATTR;
typedef uint8_t ATTR_SBE_UPDATE_type;

// Type aliases and/or sizes for ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB attribute
typedef uint64_t LAST_KNOWN_CONFIGURED_MEM_SIZE_MB_ATTR;
typedef uint64_t ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB_type;

// Type aliases and/or sizes for ATTR_PNOR_PARTITION_SIDE attribute
typedef PNOR_PARTITION_SIDE PNOR_PARTITION_SIDE_ATTR;
typedef PNOR_PARTITION_SIDE ATTR_PNOR_PARTITION_SIDE_type;

// Type aliases and/or sizes for ATTR_DEALLOCATED attribute
typedef uint8_t DEALLOCATED_ATTR;
typedef uint8_t ATTR_DEALLOCATED_type;

// Type aliases and/or sizes for ATTR_BASE_PVR attribute
typedef uint32_t BASE_PVR_ATTR;
typedef uint32_t ATTR_BASE_PVR_type;

// Type aliases and/or sizes for ATTR_IS_MASTER_EX attribute
typedef uint8_t IS_MASTER_EX_ATTR;
typedef uint8_t ATTR_IS_MASTER_EX_type;

// Type aliases and/or sizes for ATTR_OVERRIDE_FREQ_PROC_REFCLOCK attribute
typedef uint32_t OVERRIDE_FREQ_PROC_REFCLOCK_ATTR;
typedef uint32_t ATTR_OVERRIDE_FREQ_PROC_REFCLOCK_type;

// Type aliases and/or sizes for ATTR_PART_ID attribute
typedef char PART_ID_ATTR[30];
typedef char ATTR_PART_ID_type[30];
#if __cplusplus >= 201103L 
typedef std::array<char, 30> ATTR_PART_ID_typeStdArr;
#endif
const size_t ATTR_PART_ID_max_chars = 29;

// Type aliases and/or sizes for ATTR_I2C_SPEED attribute
typedef uint32_t I2C_SPEED_ATTR;
typedef uint32_t ATTR_I2C_SPEED_type;

// Type aliases and/or sizes for ATTR_I2C_ADDRESS attribute
typedef uint32_t I2C_ADDRESS_ATTR;
typedef uint32_t ATTR_I2C_ADDRESS_type;

// Type aliases and/or sizes for ATTR_I2C_DEV_PATH attribute
typedef char I2C_DEV_PATH_ATTR[30];
typedef char ATTR_I2C_DEV_PATH_type[30];
#if __cplusplus >= 201103L 
typedef std::array<char, 30> ATTR_I2C_DEV_PATH_typeStdArr;
#endif
const size_t ATTR_I2C_DEV_PATH_max_chars = 29;

// Type aliases and/or sizes for ATTR_IS_IPL_DECONFIG_ALLOWED attribute
typedef uint8_t IS_IPL_DECONFIG_ALLOWED_ATTR;
typedef uint8_t ATTR_IS_IPL_DECONFIG_ALLOWED_type;

// Type aliases and/or sizes for ATTR_ISTEP_TIMEOUT attribute
typedef uint32_t ISTEP_TIMEOUT_ATTR;
typedef uint32_t ATTR_ISTEP_TIMEOUT_type;

// Type aliases and/or sizes for ATTR_MAX_EID_ON_HBEL_FSP_A attribute
typedef uint32_t MAX_EID_ON_HBEL_FSP_A_ATTR;
typedef uint32_t ATTR_MAX_EID_ON_HBEL_FSP_A_type;

// Type aliases and/or sizes for ATTR_MAX_EID_ON_HBEL_FSP_B attribute
typedef uint32_t MAX_EID_ON_HBEL_FSP_B_ATTR;
typedef uint32_t ATTR_MAX_EID_ON_HBEL_FSP_B_type;

// Type aliases and/or sizes for ATTR_SPL_WAKEUP_STATE attribute
typedef SPL_WAKEUP_STATE SPL_WAKEUP_STATE_ATTR;
typedef SPL_WAKEUP_STATE ATTR_SPL_WAKEUP_STATE_type;

// Type aliases and/or sizes for ATTR_FCO_SUPPORTED attribute
typedef uint8_t FCO_SUPPORTED_ATTR;
typedef uint8_t ATTR_FCO_SUPPORTED_type;

// Type aliases and/or sizes for ATTR_SMP_CONNECTION_STATE attribute
typedef uint8_t SMP_CONNECTION_STATE_ATTR;
typedef uint8_t ATTR_SMP_CONNECTION_STATE_type;

// Type aliases and/or sizes for ATTR_TARGET_SCOMABLE attribute
typedef uint8_t TARGET_SCOMABLE_ATTR;
typedef uint8_t ATTR_TARGET_SCOMABLE_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_CARD_WORKAROUND attribute
typedef uint8_t PROC_PCIE_CARD_WORKAROUND_ATTR[2];
typedef uint8_t ATTR_PROC_PCIE_CARD_WORKAROUND_type[2];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 2> ATTR_PROC_PCIE_CARD_WORKAROUND_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_APPLY_PCIE_WORKAROUND attribute
typedef uint8_t APPLY_PCIE_WORKAROUND_ATTR;
typedef uint8_t ATTR_APPLY_PCIE_WORKAROUND_type;

// Type aliases and/or sizes for ATTR_PERST_CONTROL_PIN_NUMBERS attribute
typedef uint8_t PERST_CONTROL_PIN_NUMBERS_ATTR[3];
typedef uint8_t ATTR_PERST_CONTROL_PIN_NUMBERS_type[3];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 3> ATTR_PERST_CONTROL_PIN_NUMBERS_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_PERST_CONTROL_DEVICE_PATHS attribute
typedef char PERST_CONTROL_DEVICE_PATHS_ATTR[120];
typedef char ATTR_PERST_CONTROL_DEVICE_PATHS_type[120];
#if __cplusplus >= 201103L 
typedef std::array<char, 120> ATTR_PERST_CONTROL_DEVICE_PATHS_typeStdArr;
#endif
const size_t ATTR_PERST_CONTROL_DEVICE_PATHS_max_chars = 119;

// Type aliases and/or sizes for ATTR_SYSTEM_CONFIG_TYPE attribute
typedef uint32_t SYSTEM_CONFIG_TYPE_ATTR;
typedef uint32_t ATTR_SYSTEM_CONFIG_TYPE_type;

// Type aliases and/or sizes for ATTR_RT_DECONFIG_FAILED attribute
typedef uint8_t RT_DECONFIG_FAILED_ATTR;
typedef uint8_t ATTR_RT_DECONFIG_FAILED_type;

// Type aliases and/or sizes for ATTR_DECONFIG_BUT_NOT_GARDED attribute
typedef uint8_t DECONFIG_BUT_NOT_GARDED_ATTR;
typedef uint8_t ATTR_DECONFIG_BUT_NOT_GARDED_type;

// Type aliases and/or sizes for ATTR_SPD_DRAM_DIMM_DEVICE_TYPE attribute
typedef SPD_DRAM_DIMM_DEVICE_TYPE SPD_DRAM_DIMM_DEVICE_TYPE_ATTR;
typedef SPD_DRAM_DIMM_DEVICE_TYPE ATTR_SPD_DRAM_DIMM_DEVICE_TYPE_type;

// Type aliases and/or sizes for ATTR_CRITICAL_CORE_TEMP attribute
typedef uint64_t CRITICAL_CORE_TEMP_ATTR;
typedef uint64_t ATTR_CRITICAL_CORE_TEMP_type;

// Type aliases and/or sizes for ATTR_ENABLE_CORE_TEMP_CHECK attribute
typedef uint8_t ENABLE_CORE_TEMP_CHECK_ATTR;
typedef uint8_t ATTR_ENABLE_CORE_TEMP_CHECK_type;

// Type aliases and/or sizes for ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS attribute
typedef uint8_t CORE_TEMP_CHECK_INTERVAL_SECONDS_ATTR;
typedef uint8_t ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS_type;

// Type aliases and/or sizes for ATTR_IS_MASTER_CORE attribute
typedef uint8_t IS_MASTER_CORE_ATTR;
typedef uint8_t ATTR_IS_MASTER_CORE_type;

// Type aliases and/or sizes for ATTR_FSP_SECURITY_MODE attribute
typedef uint8_t FSP_SECURITY_MODE_ATTR;
typedef uint8_t ATTR_FSP_SECURITY_MODE_type;

// Type aliases and/or sizes for ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH attribute
typedef char FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH_ATTR[35];
typedef char ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH attribute
typedef char FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH_ATTR[35];
typedef char ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_DIMM_SPD_P0_PATH attribute
typedef char FSP_DIMM_SPD_P0_PATH_ATTR[35];
typedef char ATTR_FSP_DIMM_SPD_P0_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_DIMM_SPD_P0_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_DIMM_SPD_P0_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_DIMM_SPD_P1_PATH attribute
typedef char FSP_DIMM_SPD_P1_PATH_ATTR[35];
typedef char ATTR_FSP_DIMM_SPD_P1_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_DIMM_SPD_P1_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_DIMM_SPD_P1_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH attribute
typedef char FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH_ATTR[35];
typedef char ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH attribute
typedef char FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH_ATTR[35];
typedef char ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_A_DIMM_SPD_P0_PATH attribute
typedef char FSP_A_DIMM_SPD_P0_PATH_ATTR[35];
typedef char ATTR_FSP_A_DIMM_SPD_P0_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_A_DIMM_SPD_P0_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_DIMM_SPD_P0_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_A_DIMM_SPD_P1_PATH attribute
typedef char FSP_A_DIMM_SPD_P1_PATH_ATTR[35];
typedef char ATTR_FSP_A_DIMM_SPD_P1_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_A_DIMM_SPD_P1_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_A_DIMM_SPD_P1_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH attribute
typedef char FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH_ATTR[35];
typedef char ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH attribute
typedef char FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH_ATTR[35];
typedef char ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_B_DIMM_SPD_P0_PATH attribute
typedef char FSP_B_DIMM_SPD_P0_PATH_ATTR[35];
typedef char ATTR_FSP_B_DIMM_SPD_P0_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_B_DIMM_SPD_P0_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_DIMM_SPD_P0_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_FSP_B_DIMM_SPD_P1_PATH attribute
typedef char FSP_B_DIMM_SPD_P1_PATH_ATTR[35];
typedef char ATTR_FSP_B_DIMM_SPD_P1_PATH_type[35];
#if __cplusplus >= 201103L 
typedef std::array<char, 35> ATTR_FSP_B_DIMM_SPD_P1_PATH_typeStdArr;
#endif
const size_t ATTR_FSP_B_DIMM_SPD_P1_PATH_max_chars = 34;

// Type aliases and/or sizes for ATTR_PRIMARY_SEEPROM_FAIL_COUNT attribute
typedef uint8_t PRIMARY_SEEPROM_FAIL_COUNT_ATTR;
typedef uint8_t ATTR_PRIMARY_SEEPROM_FAIL_COUNT_type;

// Type aliases and/or sizes for ATTR_SECONDARY_SEEPROM_FAIL_COUNT attribute
typedef uint8_t SECONDARY_SEEPROM_FAIL_COUNT_ATTR;
typedef uint8_t ATTR_SECONDARY_SEEPROM_FAIL_COUNT_type;

// Type aliases and/or sizes for ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT attribute
typedef uint8_t PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT_ATTR;
typedef uint8_t ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT_type;

// Type aliases and/or sizes for ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT attribute
typedef uint8_t SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT_ATTR;
typedef uint8_t ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT_type;

// Type aliases and/or sizes for ATTR_HOSTBOOT_TIME_OUT attribute
typedef uint32_t HOSTBOOT_TIME_OUT_ATTR;
typedef uint32_t ATTR_HOSTBOOT_TIME_OUT_type;

// Type aliases and/or sizes for ATTR_IS_TCES_MODE_ENABLE attribute
typedef uint8_t IS_TCES_MODE_ENABLE_ATTR;
typedef uint8_t ATTR_IS_TCES_MODE_ENABLE_type;

// Type aliases and/or sizes for ATTR_PRIMARY_MF_CLOCK attribute
typedef PRIMARY_MF_CLOCK PRIMARY_MF_CLOCK_ATTR;
typedef PRIMARY_MF_CLOCK ATTR_PRIMARY_MF_CLOCK_type;

// Type aliases and/or sizes for ATTR_REDUNDANT_MF_CLOCKS attribute
typedef REDUNDANT_MF_CLOCKS REDUNDANT_MF_CLOCKS_ATTR;
typedef REDUNDANT_MF_CLOCKS ATTR_REDUNDANT_MF_CLOCKS_type;

// Type aliases and/or sizes for ATTR_TEMP_LOL_ERR_CNT attribute
typedef uint32_t TEMP_LOL_ERR_CNT_ATTR;
typedef uint32_t ATTR_TEMP_LOL_ERR_CNT_type;

// Type aliases and/or sizes for ATTR_DISABLE_SECURITY attribute
typedef uint8_t DISABLE_SECURITY_ATTR;
typedef uint8_t ATTR_DISABLE_SECURITY_type;

// Type aliases and/or sizes for ATTR_MAX_LOL_ERR_CNT attribute
typedef uint32_t MAX_LOL_ERR_CNT_ATTR;
typedef uint32_t ATTR_MAX_LOL_ERR_CNT_type;

// Type aliases and/or sizes for ATTR_DISABLE_SBE_RUNTIME_RECOVERY attribute
typedef uint8_t DISABLE_SBE_RUNTIME_RECOVERY_ATTR;
typedef uint8_t ATTR_DISABLE_SBE_RUNTIME_RECOVERY_type;

// Type aliases and/or sizes for ATTR_CLOCK_PLL_MUX attribute
typedef uint32_t CLOCK_PLL_MUX_ATTR;
typedef uint32_t ATTR_CLOCK_PLL_MUX_type;

// Type aliases and/or sizes for ATTR_NVDIMM_AUTO_ARM attribute
typedef uint8_t NVDIMM_AUTO_ARM_ATTR;
typedef uint8_t ATTR_NVDIMM_AUTO_ARM_type;

// Type aliases and/or sizes for ATTR_NVDIMM_ENCRYPTION_ENABLE attribute
typedef uint8_t NVDIMM_ENCRYPTION_ENABLE_ATTR;
typedef uint8_t ATTR_NVDIMM_ENCRYPTION_ENABLE_type;

// Type aliases and/or sizes for ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR attribute
typedef uint8_t NVDIMM_ENCRYPTION_KEYS_ANCHOR_ATTR[96];
typedef uint8_t ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR_type[96];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 96> ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_NVDIMM_ENCRYPTION_KEYS_FW attribute
typedef uint8_t NVDIMM_ENCRYPTION_KEYS_FW_ATTR[96];
typedef uint8_t ATTR_NVDIMM_ENCRYPTION_KEYS_FW_type[96];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 96> ATTR_NVDIMM_ENCRYPTION_KEYS_FW_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_LINK_TRAIN attribute
typedef uint8_t LINK_TRAIN_ATTR;
typedef uint8_t ATTR_LINK_TRAIN_type;

// Type aliases and/or sizes for ATTR_EFF_DIMM_SIZE attribute
typedef uint32_t EFF_DIMM_SIZE_ATTR[2][2];
typedef uint32_t ATTR_EFF_DIMM_SIZE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint32_t, 2>, 2> ATTR_EFF_DIMM_SIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CEN_EFF_DIMM_SIZE attribute
typedef uint8_t CEN_EFF_DIMM_SIZE_ATTR[2][2];
typedef uint8_t ATTR_CEN_EFF_DIMM_SIZE_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_CEN_EFF_DIMM_SIZE_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_L2_HASCLOCKS attribute
typedef uint8_t L2_HASCLOCKS_ATTR;
typedef uint8_t ATTR_L2_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_C0_EXEC_HASCLOCKS attribute
typedef uint8_t C0_EXEC_HASCLOCKS_ATTR;
typedef uint8_t ATTR_C0_EXEC_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_C1_EXEC_HASCLOCKS attribute
typedef uint8_t C1_EXEC_HASCLOCKS_ATTR;
typedef uint8_t ATTR_C1_EXEC_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_C0_PC_HASCLOCKS attribute
typedef uint8_t C0_PC_HASCLOCKS_ATTR;
typedef uint8_t ATTR_C0_PC_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_C1_PC_HASCLOCKS attribute
typedef uint8_t C1_PC_HASCLOCKS_ATTR;
typedef uint8_t ATTR_C1_PC_HASCLOCKS_type;

// Type aliases and/or sizes for ATTR_L2_HASPOWER attribute
typedef uint8_t L2_HASPOWER_ATTR;
typedef uint8_t ATTR_L2_HASPOWER_type;

// Type aliases and/or sizes for ATTR_C0_HASPOWER attribute
typedef uint8_t C0_HASPOWER_ATTR;
typedef uint8_t ATTR_C0_HASPOWER_type;

// Type aliases and/or sizes for ATTR_C1_HASPOWER attribute
typedef uint8_t C1_HASPOWER_ATTR;
typedef uint8_t ATTR_C1_HASPOWER_type;

// Type aliases and/or sizes for ATTR_CEN_SPD_DRAM_DEVICE_TYPE attribute
typedef uint8_t CEN_SPD_DRAM_DEVICE_TYPE_ATTR;
typedef uint8_t ATTR_CEN_SPD_DRAM_DEVICE_TYPE_type;

// Type aliases and/or sizes for ATTR_TARGET_IS_SCOMMABLE attribute
typedef uint8_t TARGET_IS_SCOMMABLE_ATTR;
typedef uint8_t ATTR_TARGET_IS_SCOMMABLE_type;

// Type aliases and/or sizes for ATTR_PROC_PCIE_CACHE_INJ_MODE attribute
typedef uint8_t PROC_PCIE_CACHE_INJ_MODE_ATTR;
typedef uint8_t ATTR_PROC_PCIE_CACHE_INJ_MODE_type;

// Type aliases and/or sizes for ATTR_FREQ_A_MHZ attribute
typedef uint32_t FREQ_A_MHZ_ATTR;
typedef uint32_t ATTR_FREQ_A_MHZ_type;

// Type aliases and/or sizes for ATTR_EFF_DIMM_RANKS_CONFIGED attribute
typedef uint8_t EFF_DIMM_RANKS_CONFIGED_ATTR[2][2];
typedef uint8_t ATTR_EFF_DIMM_RANKS_CONFIGED_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_DIMM_RANKS_CONFIGED_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM attribute
typedef uint8_t EFF_NUM_MASTER_RANKS_PER_DIMM_ATTR[2][2];
typedef uint8_t ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM_type[2][2];
#if __cplusplus >= 201103L 
typedef std::array<std::array<uint8_t, 2>, 2> ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_CEN_DQ_TO_DIMM_CONN_DQ attribute
typedef uint8_t CEN_DQ_TO_DIMM_CONN_DQ_ATTR[80];
typedef uint8_t ATTR_CEN_DQ_TO_DIMM_CONN_DQ_type[80];
#if __cplusplus >= 201103L 
typedef std::array<uint8_t, 80> ATTR_CEN_DQ_TO_DIMM_CONN_DQ_typeStdArr;
#endif

// Type aliases and/or sizes for ATTR_MSS_FREQ attribute
typedef uint64_t MSS_FREQ_ATTR;
typedef uint64_t ATTR_MSS_FREQ_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_FREQ_OVERRIDE attribute
typedef uint32_t CEN_MSS_FREQ_OVERRIDE_ATTR;
typedef uint32_t ATTR_CEN_MSS_FREQ_OVERRIDE_type;

// Type aliases and/or sizes for ATTR_DD1_SLOW_PCI_REF_CLOCK attribute
typedef uint8_t DD1_SLOW_PCI_REF_CLOCK_ATTR;
typedef uint8_t ATTR_DD1_SLOW_PCI_REF_CLOCK_type;

// Type aliases and/or sizes for ATTR_CEN_MBA_PORT attribute
typedef uint8_t CEN_MBA_PORT_ATTR;
typedef uint8_t ATTR_CEN_MBA_PORT_type;

// Type aliases and/or sizes for ATTR_CEN_MBA_DIMM attribute
typedef uint8_t CEN_MBA_DIMM_ATTR;
typedef uint8_t ATTR_CEN_MBA_DIMM_type;

// Type aliases and/or sizes for ATTR_CEN_MSS_FREQ attribute
typedef uint32_t CEN_MSS_FREQ_ATTR;
typedef uint32_t ATTR_CEN_MSS_FREQ_type;

// Type aliases and/or sizes for ATTR_VDN_BOOT_VOLTAGE attribute
typedef uint32_t VDN_BOOT_VOLTAGE_ATTR;
typedef uint32_t ATTR_VDN_BOOT_VOLTAGE_type;

// Type aliases and/or sizes for ATTR_VDD_BOOT_VOLTAGE attribute
typedef uint32_t VDD_BOOT_VOLTAGE_ATTR;
typedef uint32_t ATTR_VDD_BOOT_VOLTAGE_type;

// Type aliases and/or sizes for ATTR_VCS_BOOT_VOLTAGE attribute
typedef uint32_t VCS_BOOT_VOLTAGE_ATTR;
typedef uint32_t ATTR_VCS_BOOT_VOLTAGE_type;

// Type aliases and/or sizes for ATTR_FREQ_BIAS_ULTRATURBO attribute
typedef int8_t FREQ_BIAS_ULTRATURBO_ATTR;
typedef int8_t ATTR_FREQ_BIAS_ULTRATURBO_type;

// Type aliases and/or sizes for ATTR_FREQ_BIAS_TURBO attribute
typedef int8_t FREQ_BIAS_TURBO_ATTR;
typedef int8_t ATTR_FREQ_BIAS_TURBO_type;

// Type aliases and/or sizes for ATTR_FREQ_BIAS_NOMINAL attribute
typedef int8_t FREQ_BIAS_NOMINAL_ATTR;
typedef int8_t ATTR_FREQ_BIAS_NOMINAL_type;

// Type aliases and/or sizes for ATTR_FREQ_BIAS_POWERSAVE attribute
typedef int8_t FREQ_BIAS_POWERSAVE_ATTR;
typedef int8_t ATTR_FREQ_BIAS_POWERSAVE_type;

// Type aliases and/or sizes for ATTR_COLLECT_ONLY_CLOCK_ON_DATA attribute
typedef uint8_t COLLECT_ONLY_CLOCK_ON_DATA_ATTR;
typedef uint8_t ATTR_COLLECT_ONLY_CLOCK_ON_DATA_type;


/**
 *  @brief Function to return size of specified attribute
 *
 *  @param[in] i_attrId Attribute ID for attribute to look up size
 *  @return uint32_t Size of the attribute
 *
 *  @retval Size of the attribute if succeeded
 *  @retval 0 if failed
 *
 */
inline uint32_t attrSizeLookup(ATTRIBUTE_ID i_attrId)
{
    uint32_t l_attrSize = 0;

    switch(i_attrId) {
    // Get size for ATTR_AUX_FUNC_INVOCATION_TIME_MS attribute
    case ATTR_AUX_FUNC_INVOCATION_TIME_MS:
        l_attrSize = sizeof(ATTR_AUX_FUNC_INVOCATION_TIME_MS_type);
        break;

    // Get size for ATTR_FREQ_BIAS attribute
    case ATTR_FREQ_BIAS:
        l_attrSize = sizeof(ATTR_FREQ_BIAS_type);
        break;

    // Get size for ATTR_VOLTAGE_EXT_BIAS attribute
    case ATTR_VOLTAGE_EXT_BIAS:
        l_attrSize = sizeof(ATTR_VOLTAGE_EXT_BIAS_type);
        break;

    // Get size for ATTR_VOLTAGE_EXT_VDN_BIAS attribute
    case ATTR_VOLTAGE_EXT_VDN_BIAS:
        l_attrSize = sizeof(ATTR_VOLTAGE_EXT_VDN_BIAS_type);
        break;

    // Get size for ATTR_DDR5_VDN_UPLIFT_MV attribute
    case ATTR_DDR5_VDN_UPLIFT_MV:
        l_attrSize = sizeof(ATTR_DDR5_VDN_UPLIFT_MV_type);
        break;

    // Get size for ATTR_WOF_DCCR_VALUE attribute
    case ATTR_WOF_DCCR_VALUE:
        l_attrSize = sizeof(ATTR_WOF_DCCR_VALUE_type);
        break;

    // Get size for ATTR_WOF_FLMR_VALUE attribute
    case ATTR_WOF_FLMR_VALUE:
        l_attrSize = sizeof(ATTR_WOF_FLMR_VALUE_type);
        break;

    // Get size for ATTR_WOF_FMMR_VALUE attribute
    case ATTR_WOF_FMMR_VALUE:
        l_attrSize = sizeof(ATTR_WOF_FMMR_VALUE_type);
        break;

    // Get size for ATTR_DDS_DELAY_ADJUST attribute
    case ATTR_DDS_DELAY_ADJUST:
        l_attrSize = sizeof(ATTR_DDS_DELAY_ADJUST_type);
        break;

    // Get size for ATTR_DDS_LARGE_DROOP_DETECT_ADJUST attribute
    case ATTR_DDS_LARGE_DROOP_DETECT_ADJUST:
        l_attrSize = sizeof(ATTR_DDS_LARGE_DROOP_DETECT_ADJUST_type);
        break;

    // Get size for ATTR_DDS_TRIP_OFFSET_ADJUST attribute
    case ATTR_DDS_TRIP_OFFSET_ADJUST:
        l_attrSize = sizeof(ATTR_DDS_TRIP_OFFSET_ADJUST_type);
        break;

    // Get size for ATTR_DDS_DROOP_EXTREME_OVERRIDE attribute
    case ATTR_DDS_DROOP_EXTREME_OVERRIDE:
        l_attrSize = sizeof(ATTR_DDS_DROOP_EXTREME_OVERRIDE_type);
        break;

    // Get size for ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT attribute
    case ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT:
        l_attrSize = sizeof(ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT_type);
        break;

    // Get size for ATTR_DDS_DPLL_SLEW_MODE attribute
    case ATTR_DDS_DPLL_SLEW_MODE:
        l_attrSize = sizeof(ATTR_DDS_DPLL_SLEW_MODE_type);
        break;

    // Get size for ATTR_DDS_TRIP_MODE attribute
    case ATTR_DDS_TRIP_MODE:
        l_attrSize = sizeof(ATTR_DDS_TRIP_MODE_type);
        break;

    // Get size for ATTR_DDS_TRIP_INTERPOLATION_CONTROL attribute
    case ATTR_DDS_TRIP_INTERPOLATION_CONTROL:
        l_attrSize = sizeof(ATTR_DDS_TRIP_INTERPOLATION_CONTROL_type);
        break;

    // Get size for ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG attribute
    case ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG:
        l_attrSize = sizeof(ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG_type);
        break;

    // Get size for ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE attribute
    case ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE:
        l_attrSize = sizeof(ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE_type);
        break;

    // Get size for ATTR_PGPE_HCODE_FUNCTION_ENABLE attribute
    case ATTR_PGPE_HCODE_FUNCTION_ENABLE:
        l_attrSize = sizeof(ATTR_PGPE_HCODE_FUNCTION_ENABLE_type);
        break;

    // Get size for ATTR_PM_GLOBAL_FIR_TRACE_EN attribute
    case ATTR_PM_GLOBAL_FIR_TRACE_EN:
        l_attrSize = sizeof(ATTR_PM_GLOBAL_FIR_TRACE_EN_type);
        break;

    // Get size for ATTR_POUND_W_STATIC_DATA_ENABLE attribute
    case ATTR_POUND_W_STATIC_DATA_ENABLE:
        l_attrSize = sizeof(ATTR_POUND_W_STATIC_DATA_ENABLE_type);
        break;

    // Get size for ATTR_POUND_V_STATIC_DATA_ENABLE attribute
    case ATTR_POUND_V_STATIC_DATA_ENABLE:
        l_attrSize = sizeof(ATTR_POUND_V_STATIC_DATA_ENABLE_type);
        break;

    // Get size for ATTR_AW_STATIC_DATA_ENABLE attribute
    case ATTR_AW_STATIC_DATA_ENABLE:
        l_attrSize = sizeof(ATTR_AW_STATIC_DATA_ENABLE_type);
        break;

    // Get size for ATTR_IQ_STATIC_DATA_ENABLE attribute
    case ATTR_IQ_STATIC_DATA_ENABLE:
        l_attrSize = sizeof(ATTR_IQ_STATIC_DATA_ENABLE_type);
        break;

    // Get size for ATTR_POUNDV_BUCKET_NUM attribute
    case ATTR_POUNDV_BUCKET_NUM:
        l_attrSize = sizeof(ATTR_POUNDV_BUCKET_NUM_type);
        break;

    // Get size for ATTR_POUNDV_BUCKET_NUM_OVERRIDE attribute
    case ATTR_POUNDV_BUCKET_NUM_OVERRIDE:
        l_attrSize = sizeof(ATTR_POUNDV_BUCKET_NUM_OVERRIDE_type);
        break;

    // Get size for ATTR_SKIP_WAKEUP attribute
    case ATTR_SKIP_WAKEUP:
        l_attrSize = sizeof(ATTR_SKIP_WAKEUP_type);
        break;

    // Get size for ATTR_SYS_VRT_STATIC_DATA_ENABLE attribute
    case ATTR_SYS_VRT_STATIC_DATA_ENABLE:
        l_attrSize = sizeof(ATTR_SYS_VRT_STATIC_DATA_ENABLE_type);
        break;

    // Get size for ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE attribute
    case ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_RING_DBG_MODE attribute
    case ATTR_SYSTEM_RING_DBG_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_RING_DBG_MODE_type);
        break;

    // Get size for ATTR_PM_MALF_ALERT_ENABLE attribute
    case ATTR_PM_MALF_ALERT_ENABLE:
        l_attrSize = sizeof(ATTR_PM_MALF_ALERT_ENABLE_type);
        break;

    // Get size for ATTR_PM_HALT_FFDC_ENABLE attribute
    case ATTR_PM_HALT_FFDC_ENABLE:
        l_attrSize = sizeof(ATTR_PM_HALT_FFDC_ENABLE_type);
        break;

    // Get size for ATTR_SYSTEM_DDS_DISABLE attribute
    case ATTR_SYSTEM_DDS_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_DDS_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_DDS_FREQ_ENABLE attribute
    case ATTR_SYSTEM_DDS_FREQ_ENABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_DDS_FREQ_ENABLE_type);
        break;

    // Get size for ATTR_SYSTEM_AUXILLARY_MODE attribute
    case ATTR_SYSTEM_AUXILLARY_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_AUXILLARY_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_PSTATES_MODE attribute
    case ATTR_SYSTEM_PSTATES_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_PSTATES_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_SUSPEND_OCC_MODE attribute
    case ATTR_SYSTEM_SUSPEND_OCC_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_SUSPEND_OCC_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_RESCLK_DISABLE attribute
    case ATTR_SYSTEM_RESCLK_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_RESCLK_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE attribute
    case ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE_type);
        break;

    // Get size for ATTR_SYSTEM_RVRM_DISABLE attribute
    case ATTR_SYSTEM_RVRM_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_RVRM_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_WOF_DISABLE attribute
    case ATTR_SYSTEM_WOF_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_WOF_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_WOV_OVERV_DISABLE attribute
    case ATTR_SYSTEM_WOV_OVERV_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_WOV_OVERV_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_WOV_UNDERV_DISABLE attribute
    case ATTR_SYSTEM_WOV_UNDERV_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_WOV_UNDERV_DISABLE_type);
        break;

    // Get size for ATTR_WOF_INDEX_SELECT attribute
    case ATTR_WOF_INDEX_SELECT:
        l_attrSize = sizeof(ATTR_WOF_INDEX_SELECT_type);
        break;

    // Get size for ATTR_SYSTEM_WOF_DISABLE_DIMENSION attribute
    case ATTR_SYSTEM_WOF_DISABLE_DIMENSION:
        l_attrSize = sizeof(ATTR_SYSTEM_WOF_DISABLE_DIMENSION_type);
        break;

    // Get size for ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE attribute
    case ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE:
        l_attrSize = sizeof(ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE_type);
        break;

    // Get size for ATTR_WOF_PITCH_ENABLE attribute
    case ATTR_WOF_PITCH_ENABLE:
        l_attrSize = sizeof(ATTR_WOF_PITCH_ENABLE_type);
        break;

    // Get size for ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE attribute
    case ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE:
        l_attrSize = sizeof(ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE_type);
        break;

    // Get size for ATTR_WOF_THROTTLE_CONTROL_KP attribute
    case ATTR_WOF_THROTTLE_CONTROL_KP:
        l_attrSize = sizeof(ATTR_WOF_THROTTLE_CONTROL_KP_type);
        break;

    // Get size for ATTR_WOF_THROTTLE_CONTROL_KI attribute
    case ATTR_WOF_THROTTLE_CONTROL_KI:
        l_attrSize = sizeof(ATTR_WOF_THROTTLE_CONTROL_KI_type);
        break;

    // Get size for ATTR_SYSTEM_OCS_DISABLE attribute
    case ATTR_SYSTEM_OCS_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_OCS_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE attribute
    case ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE_type);
        break;

    // Get size for ATTR_WOF_DCM_TRACKING_ENABLE attribute
    case ATTR_WOF_DCM_TRACKING_ENABLE:
        l_attrSize = sizeof(ATTR_WOF_DCM_TRACKING_ENABLE_type);
        break;

    // Get size for ATTR_SYSTEM_WOF_VALIDATION_MODE attribute
    case ATTR_SYSTEM_WOF_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_WOF_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE attribute
    case ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_PDV_VALIDATION_MODE attribute
    case ATTR_SYSTEM_PDV_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_PDV_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE attribute
    case ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_PDW_VALIDATION_MODE attribute
    case ATTR_SYSTEM_PDW_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_PDW_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_IQ_VALIDATION_MODE attribute
    case ATTR_SYSTEM_IQ_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_IQ_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE attribute
    case ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE attribute
    case ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE:
        l_attrSize = sizeof(ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE_type);
        break;

    // Get size for ATTR_PBAX_BRDCST_ID_VECTOR attribute
    case ATTR_PBAX_BRDCST_ID_VECTOR:
        l_attrSize = sizeof(ATTR_PBAX_BRDCST_ID_VECTOR_type);
        break;

    // Get size for ATTR_PBAX_CHIPID attribute
    case ATTR_PBAX_CHIPID:
        l_attrSize = sizeof(ATTR_PBAX_CHIPID_type);
        break;

    // Get size for ATTR_PBAX_GROUPID attribute
    case ATTR_PBAX_GROUPID:
        l_attrSize = sizeof(ATTR_PBAX_GROUPID_type);
        break;

    // Get size for ATTR_SPIPSS_FREQUENCY attribute
    case ATTR_SPIPSS_FREQUENCY:
        l_attrSize = sizeof(ATTR_SPIPSS_FREQUENCY_type);
        break;

    // Get size for ATTR_SPIPSS_SELECT attribute
    case ATTR_SPIPSS_SELECT:
        l_attrSize = sizeof(ATTR_SPIPSS_SELECT_type);
        break;

    // Get size for ATTR_PROC_R_DISTLOSS_UOHM attribute
    case ATTR_PROC_R_DISTLOSS_UOHM:
        l_attrSize = sizeof(ATTR_PROC_R_DISTLOSS_UOHM_type);
        break;

    // Get size for ATTR_PROC_R_LOADLINE_UOHM attribute
    case ATTR_PROC_R_LOADLINE_UOHM:
        l_attrSize = sizeof(ATTR_PROC_R_LOADLINE_UOHM_type);
        break;

    // Get size for ATTR_PROC_VRM_VOFFSET_UV attribute
    case ATTR_PROC_VRM_VOFFSET_UV:
        l_attrSize = sizeof(ATTR_PROC_VRM_VOFFSET_UV_type);
        break;

    // Get size for ATTR_CORE_THROTTLE_ASSERT_COUNT attribute
    case ATTR_CORE_THROTTLE_ASSERT_COUNT:
        l_attrSize = sizeof(ATTR_CORE_THROTTLE_ASSERT_COUNT_type);
        break;

    // Get size for ATTR_CORE_THROTTLE_DEASSERT_COUNT attribute
    case ATTR_CORE_THROTTLE_DEASSERT_COUNT:
        l_attrSize = sizeof(ATTR_CORE_THROTTLE_DEASSERT_COUNT_type);
        break;

    // Get size for ATTR_AVSBUS_BUSNUM attribute
    case ATTR_AVSBUS_BUSNUM:
        l_attrSize = sizeof(ATTR_AVSBUS_BUSNUM_type);
        break;

    // Get size for ATTR_AVSBUS_FREQUENCY attribute
    case ATTR_AVSBUS_FREQUENCY:
        l_attrSize = sizeof(ATTR_AVSBUS_FREQUENCY_type);
        break;

    // Get size for ATTR_AVSBUS_RAIL attribute
    case ATTR_AVSBUS_RAIL:
        l_attrSize = sizeof(ATTR_AVSBUS_RAIL_type);
        break;

    // Get size for ATTR_EXTERNAL_VRM_STEPSIZE attribute
    case ATTR_EXTERNAL_VRM_STEPSIZE:
        l_attrSize = sizeof(ATTR_EXTERNAL_VRM_STEPSIZE_type);
        break;

    // Get size for ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US attribute
    case ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US:
        l_attrSize = sizeof(ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US_type);
        break;

    // Get size for ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US attribute
    case ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US:
        l_attrSize = sizeof(ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US_type);
        break;

    // Get size for ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS attribute
    case ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS:
        l_attrSize = sizeof(ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS_type);
        break;

    // Get size for ATTR_EXTERNAL_VRM_TRANSITION_START_NS attribute
    case ATTR_EXTERNAL_VRM_TRANSITION_START_NS:
        l_attrSize = sizeof(ATTR_EXTERNAL_VRM_TRANSITION_START_NS_type);
        break;

    // Get size for ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE attribute
    case ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE:
        l_attrSize = sizeof(ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE_type);
        break;

    // Get size for ATTR_WOF_VRATIO_VDD_10THPCT attribute
    case ATTR_WOF_VRATIO_VDD_10THPCT:
        l_attrSize = sizeof(ATTR_WOF_VRATIO_VDD_10THPCT_type);
        break;

    // Get size for ATTR_WOF_VRATIO_VCS_10THPCT attribute
    case ATTR_WOF_VRATIO_VCS_10THPCT:
        l_attrSize = sizeof(ATTR_WOF_VRATIO_VCS_10THPCT_type);
        break;

    // Get size for ATTR_WOF_TABLE_IO_POWER_BASE_W attribute
    case ATTR_WOF_TABLE_IO_POWER_BASE_W:
        l_attrSize = sizeof(ATTR_WOF_TABLE_IO_POWER_BASE_W_type);
        break;

    // Get size for ATTR_WOF_IO_BASE_POWER_0P01W attribute
    case ATTR_WOF_IO_BASE_POWER_0P01W:
        l_attrSize = sizeof(ATTR_WOF_IO_BASE_POWER_0P01W_type);
        break;

    // Get size for ATTR_WOV_MAX_DROOP_10THPCT attribute
    case ATTR_WOV_MAX_DROOP_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_MAX_DROOP_10THPCT_type);
        break;

    // Get size for ATTR_WOV_OVERV_MAX_10THPCT attribute
    case ATTR_WOV_OVERV_MAX_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_OVERV_MAX_10THPCT_type);
        break;

    // Get size for ATTR_WOV_OVERV_STEP_DECR_10THPCT attribute
    case ATTR_WOV_OVERV_STEP_DECR_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_OVERV_STEP_DECR_10THPCT_type);
        break;

    // Get size for ATTR_WOV_OVERV_STEP_INCR_10THPCT attribute
    case ATTR_WOV_OVERV_STEP_INCR_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_OVERV_STEP_INCR_10THPCT_type);
        break;

    // Get size for ATTR_WOV_OVERV_VMAX_SETPOINT_MV attribute
    case ATTR_WOV_OVERV_VMAX_SETPOINT_MV:
        l_attrSize = sizeof(ATTR_WOV_OVERV_VMAX_SETPOINT_MV_type);
        break;

    // Get size for ATTR_WOV_UNDERV_MAX_10THPCT attribute
    case ATTR_WOV_UNDERV_MAX_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_UNDERV_MAX_10THPCT_type);
        break;

    // Get size for ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE attribute
    case ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_WOV_DDS_CALIBRATION_ENABLE_type);
        break;

    // Get size for ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT attribute
    case ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_UNDERV_EXTENDED_MAX_10THPCT_type);
        break;

    // Get size for ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT attribute
    case ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_OVERV_EXTENDED_MAX_10THPCT_type);
        break;

    // Get size for ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT attribute
    case ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT_type);
        break;

    // Get size for ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT attribute
    case ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT_type);
        break;

    // Get size for ATTR_WOV_UNDERV_STEP_DECR_10THPCT attribute
    case ATTR_WOV_UNDERV_STEP_DECR_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_UNDERV_STEP_DECR_10THPCT_type);
        break;

    // Get size for ATTR_WOV_UNDERV_STEP_INCR_10THPCT attribute
    case ATTR_WOV_UNDERV_STEP_INCR_10THPCT:
        l_attrSize = sizeof(ATTR_WOV_UNDERV_STEP_INCR_10THPCT_type);
        break;

    // Get size for ATTR_WOV_UNDERV_VMIN_MV attribute
    case ATTR_WOV_UNDERV_VMIN_MV:
        l_attrSize = sizeof(ATTR_WOV_UNDERV_VMIN_MV_type);
        break;

    // Get size for ATTR_WOV_DIRTY_UNCURRENT_CONTROL attribute
    case ATTR_WOV_DIRTY_UNCURRENT_CONTROL:
        l_attrSize = sizeof(ATTR_WOV_DIRTY_UNCURRENT_CONTROL_type);
        break;

    // Get size for ATTR_OCS_WITH_DDS_DISABLE attribute
    case ATTR_OCS_WITH_DDS_DISABLE:
        l_attrSize = sizeof(ATTR_OCS_WITH_DDS_DISABLE_type);
        break;

    // Get size for ATTR_WOV_OVERV_WITH_DDS_DISABLE attribute
    case ATTR_WOV_OVERV_WITH_DDS_DISABLE:
        l_attrSize = sizeof(ATTR_WOV_OVERV_WITH_DDS_DISABLE_type);
        break;

    // Get size for ATTR_DDS_DPLL_FMAX_FAST_DISABLE attribute
    case ATTR_DDS_DPLL_FMAX_FAST_DISABLE:
        l_attrSize = sizeof(ATTR_DDS_DPLL_FMAX_FAST_DISABLE_type);
        break;

    // Get size for ATTR_DDS_DPLL_FMIN_FAST_DISABLE attribute
    case ATTR_DDS_DPLL_FMIN_FAST_DISABLE:
        l_attrSize = sizeof(ATTR_DDS_DPLL_FMIN_FAST_DISABLE_type);
        break;

    // Get size for ATTR_DDS_FMAX_OVERRIDE_KHZ attribute
    case ATTR_DDS_FMAX_OVERRIDE_KHZ:
        l_attrSize = sizeof(ATTR_DDS_FMAX_OVERRIDE_KHZ_type);
        break;

    // Get size for ATTR_DDS_FMIN_OVERRIDE_KHZ attribute
    case ATTR_DDS_FMIN_OVERRIDE_KHZ:
        l_attrSize = sizeof(ATTR_DDS_FMIN_OVERRIDE_KHZ_type);
        break;

    // Get size for ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK attribute
    case ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK:
        l_attrSize = sizeof(ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK_type);
        break;

    // Get size for ATTR_SAFE_MODE_FREQUENCY_MHZ attribute
    case ATTR_SAFE_MODE_FREQUENCY_MHZ:
        l_attrSize = sizeof(ATTR_SAFE_MODE_FREQUENCY_MHZ_type);
        break;

    // Get size for ATTR_SAFE_MODE_VOLTAGE_MV attribute
    case ATTR_SAFE_MODE_VOLTAGE_MV:
        l_attrSize = sizeof(ATTR_SAFE_MODE_VOLTAGE_MV_type);
        break;

    // Get size for ATTR_VDN_UPLIFT_MV attribute
    case ATTR_VDN_UPLIFT_MV:
        l_attrSize = sizeof(ATTR_VDN_UPLIFT_MV_type);
        break;

    // Get size for ATTR_PMCR_MOST_RECENT_MODE attribute
    case ATTR_PMCR_MOST_RECENT_MODE:
        l_attrSize = sizeof(ATTR_PMCR_MOST_RECENT_MODE_type);
        break;

    // Get size for ATTR_UNSECURE_HOMER_ADDRESS attribute
    case ATTR_UNSECURE_HOMER_ADDRESS:
        l_attrSize = sizeof(ATTR_UNSECURE_HOMER_ADDRESS_type);
        break;

    // Get size for ATTR_UNSECURE_HOMER_SIZE attribute
    case ATTR_UNSECURE_HOMER_SIZE:
        l_attrSize = sizeof(ATTR_UNSECURE_HOMER_SIZE_type);
        break;

    // Get size for ATTR_FUSED_CORE_PAIRED_MODE_ENABLED attribute
    case ATTR_FUSED_CORE_PAIRED_MODE_ENABLED:
        l_attrSize = sizeof(ATTR_FUSED_CORE_PAIRED_MODE_ENABLED_type);
        break;

    // Get size for ATTR_SYSTEM_MMA_POWEROFF_DISABLE attribute
    case ATTR_SYSTEM_MMA_POWEROFF_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_MMA_POWEROFF_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_MMA_POWERON_DISABLE attribute
    case ATTR_SYSTEM_MMA_POWERON_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_MMA_POWERON_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS attribute
    case ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS:
        l_attrSize = sizeof(ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS_type);
        break;

    // Get size for ATTR_RVRM_VID attribute
    case ATTR_RVRM_VID:
        l_attrSize = sizeof(ATTR_RVRM_VID_type);
        break;

    // Get size for ATTR_RVRM_DEADZONE_MV attribute
    case ATTR_RVRM_DEADZONE_MV:
        l_attrSize = sizeof(ATTR_RVRM_DEADZONE_MV_type);
        break;

    // Get size for ATTR_STOP_LEVELS_SUPPORTED attribute
    case ATTR_STOP_LEVELS_SUPPORTED:
        l_attrSize = sizeof(ATTR_STOP_LEVELS_SUPPORTED_type);
        break;

    // Get size for ATTR_STOP_LEVELS_DISABLED attribute
    case ATTR_STOP_LEVELS_DISABLED:
        l_attrSize = sizeof(ATTR_STOP_LEVELS_DISABLED_type);
        break;

    // Get size for ATTR_BOOT_VOLTAGE_BIAS_0P5PCT attribute
    case ATTR_BOOT_VOLTAGE_BIAS_0P5PCT:
        l_attrSize = sizeof(ATTR_BOOT_VOLTAGE_BIAS_0P5PCT_type);
        break;

    // Get size for ATTR_WOF_OMI_FORCE_FREQ_MHZ attribute
    case ATTR_WOF_OMI_FORCE_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_WOF_OMI_FORCE_FREQ_MHZ_type);
        break;

    // Get size for ATTR_SRAM_WRITE_ASSIST_MV attribute
    case ATTR_SRAM_WRITE_ASSIST_MV:
        l_attrSize = sizeof(ATTR_SRAM_WRITE_ASSIST_MV_type);
        break;

    // Get size for ATTR_DDS_THRESHOLD_PSTATE_ENABLE attribute
    case ATTR_DDS_THRESHOLD_PSTATE_ENABLE:
        l_attrSize = sizeof(ATTR_DDS_THRESHOLD_PSTATE_ENABLE_type);
        break;

    // Get size for ATTR_DDS_COARSE_THROTTLE_ENABLE attribute
    case ATTR_DDS_COARSE_THROTTLE_ENABLE:
        l_attrSize = sizeof(ATTR_DDS_COARSE_THROTTLE_ENABLE_type);
        break;

    // Get size for ATTR_DDS_FREQ_JUMP_ENABLE attribute
    case ATTR_DDS_FREQ_JUMP_ENABLE:
        l_attrSize = sizeof(ATTR_DDS_FREQ_JUMP_ENABLE_type);
        break;

    // Get size for ATTR_DDS_BIAS_ENABLE attribute
    case ATTR_DDS_BIAS_ENABLE:
        l_attrSize = sizeof(ATTR_DDS_BIAS_ENABLE_type);
        break;

    // Get size for ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT attribute
    case ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT:
        l_attrSize = sizeof(ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT_type);
        break;

    // Get size for ATTR_THROTTLE_TABLE_OVERRIDE attribute
    case ATTR_THROTTLE_TABLE_OVERRIDE:
        l_attrSize = sizeof(ATTR_THROTTLE_TABLE_OVERRIDE_type);
        break;

    // Get size for ATTR_THROTTLE_MODE attribute
    case ATTR_THROTTLE_MODE:
        l_attrSize = sizeof(ATTR_THROTTLE_MODE_type);
        break;

    // Get size for ATTR_DLR_LINKS_ENABLED attribute
    case ATTR_DLR_LINKS_ENABLED:
        l_attrSize = sizeof(ATTR_DLR_LINKS_ENABLED_type);
        break;

    // Get size for ATTR_DLR_SAMPLE_TIME_MS attribute
    case ATTR_DLR_SAMPLE_TIME_MS:
        l_attrSize = sizeof(ATTR_DLR_SAMPLE_TIME_MS_type);
        break;

    // Get size for ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE attribute
    case ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE:
        l_attrSize = sizeof(ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE_type);
        break;

    // Get size for ATTR_DLR_PLSF_OVERRIDE attribute
    case ATTR_DLR_PLSF_OVERRIDE:
        l_attrSize = sizeof(ATTR_DLR_PLSF_OVERRIDE_type);
        break;

    // Get size for ATTR_SAFE_MODE_XSTOP attribute
    case ATTR_SAFE_MODE_XSTOP:
        l_attrSize = sizeof(ATTR_SAFE_MODE_XSTOP_type);
        break;

    // Get size for ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT attribute
    case ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT:
        l_attrSize = sizeof(ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT_type);
        break;

    // Get size for ATTR_WOF_TDP_ALTITUDE_REFERENCE_M attribute
    case ATTR_WOF_TDP_ALTITUDE_REFERENCE_M:
        l_attrSize = sizeof(ATTR_WOF_TDP_ALTITUDE_REFERENCE_M_type);
        break;

    // Get size for ATTR_SYSTEM_FMAX_ENABLE attribute
    case ATTR_SYSTEM_FMAX_ENABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_FMAX_ENABLE_type);
        break;

    // Get size for ATTR_CURRENT_SCALING_FACTOR attribute
    case ATTR_CURRENT_SCALING_FACTOR:
        l_attrSize = sizeof(ATTR_CURRENT_SCALING_FACTOR_type);
        break;

    // Get size for ATTR_IO_GROUNDED_CONTROLLERS attribute
    case ATTR_IO_GROUNDED_CONTROLLERS:
        l_attrSize = sizeof(ATTR_IO_GROUNDED_CONTROLLERS_type);
        break;

    // Get size for ATTR_IO_GROUNDED_LINKS attribute
    case ATTR_IO_GROUNDED_LINKS:
        l_attrSize = sizeof(ATTR_IO_GROUNDED_LINKS_type);
        break;

    // Get size for ATTR_WOF_IO_POWER_MODE attribute
    case ATTR_WOF_IO_POWER_MODE:
        l_attrSize = sizeof(ATTR_WOF_IO_POWER_MODE_type);
        break;

    // Get size for ATTR_EXTENDED_FREQ_MODE attribute
    case ATTR_EXTENDED_FREQ_MODE:
        l_attrSize = sizeof(ATTR_EXTENDED_FREQ_MODE_type);
        break;

    // Get size for ATTR_DVFS_ADJUSTMENT attribute
    case ATTR_DVFS_ADJUSTMENT:
        l_attrSize = sizeof(ATTR_DVFS_ADJUSTMENT_type);
        break;

    // Get size for ATTR_OCC_START_DISABLE attribute
    case ATTR_OCC_START_DISABLE:
        l_attrSize = sizeof(ATTR_OCC_START_DISABLE_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY attribute
    case ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_ARRAY_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX attribute
    case ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_CORE_COUNT_INDEX_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_EFFICIENCY_ALG attribute
    case ATTR_WTH_OVERRIDE_EFFICIENCY_ALG:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_EFFICIENCY_ALG_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES attribute
    case ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_TIMES_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH attribute
    case ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_EFFICIENCY_IDLE_THRESH_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST attribute
    case ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_EFFICIENCY_CEFF_ADJUST_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS attribute
    case ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_EFFICIENCY_FREQ_LIMITS_type);
        break;

    // Get size for ATTR_WTH_OVERRIDE_TEST_CORE_COUNT attribute
    case ATTR_WTH_OVERRIDE_TEST_CORE_COUNT:
        l_attrSize = sizeof(ATTR_WTH_OVERRIDE_TEST_CORE_COUNT_type);
        break;

    // Get size for ATTR_RUNN_MODE attribute
    case ATTR_RUNN_MODE:
        l_attrSize = sizeof(ATTR_RUNN_MODE_type);
        break;

    // Get size for ATTR_RUNN_SRESET_THREADS_BVEC attribute
    case ATTR_RUNN_SRESET_THREADS_BVEC:
        l_attrSize = sizeof(ATTR_RUNN_SRESET_THREADS_BVEC_type);
        break;

    // Get size for ATTR_RUNN_CYCLE_COUNT attribute
    case ATTR_RUNN_CYCLE_COUNT:
        l_attrSize = sizeof(ATTR_RUNN_CYCLE_COUNT_type);
        break;

    // Get size for ATTR_RUNN_CHIP_CYCLE_OFFSET attribute
    case ATTR_RUNN_CHIP_CYCLE_OFFSET:
        l_attrSize = sizeof(ATTR_RUNN_CHIP_CYCLE_OFFSET_type);
        break;

    // Get size for ATTR_RUNN_QUAD_CYCLE_OFFSET attribute
    case ATTR_RUNN_QUAD_CYCLE_OFFSET:
        l_attrSize = sizeof(ATTR_RUNN_QUAD_CYCLE_OFFSET_type);
        break;

    // Get size for ATTR_RUNN_CORE_CYCLE_OFFSET attribute
    case ATTR_RUNN_CORE_CYCLE_OFFSET:
        l_attrSize = sizeof(ATTR_RUNN_CORE_CYCLE_OFFSET_type);
        break;

    // Get size for ATTR_RUNN_DO_CONFIG_CHECKS attribute
    case ATTR_RUNN_DO_CONFIG_CHECKS:
        l_attrSize = sizeof(ATTR_RUNN_DO_CONFIG_CHECKS_type);
        break;

    // Get size for ATTR_RUNN_USE_QME_TIMEBASE attribute
    case ATTR_RUNN_USE_QME_TIMEBASE:
        l_attrSize = sizeof(ATTR_RUNN_USE_QME_TIMEBASE_type);
        break;

    // Get size for ATTR_RUNN_STOP_ON_XSTOP attribute
    case ATTR_RUNN_STOP_ON_XSTOP:
        l_attrSize = sizeof(ATTR_RUNN_STOP_ON_XSTOP_type);
        break;

    // Get size for ATTR_RUNN_MASTER_SEED attribute
    case ATTR_RUNN_MASTER_SEED:
        l_attrSize = sizeof(ATTR_RUNN_MASTER_SEED_type);
        break;

    // Get size for ATTR_RUNN_CORE_SEED_SELECT attribute
    case ATTR_RUNN_CORE_SEED_SELECT:
        l_attrSize = sizeof(ATTR_RUNN_CORE_SEED_SELECT_type);
        break;

    // Get size for ATTR_RUNN_THREAD_SEEDS attribute
    case ATTR_RUNN_THREAD_SEEDS:
        l_attrSize = sizeof(ATTR_RUNN_THREAD_SEEDS_type);
        break;

    // Get size for ATTR_RUNN_STAGGER_DELAY attribute
    case ATTR_RUNN_STAGGER_DELAY:
        l_attrSize = sizeof(ATTR_RUNN_STAGGER_DELAY_type);
        break;

    // Get size for ATTR_OMI_INBAND_BAR_ENABLE attribute
    case ATTR_OMI_INBAND_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_OMI_INBAND_BAR_ENABLE_type);
        break;

    // Get size for ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_EFF_DRAM_GEN attribute
    case ATTR_EFF_DRAM_GEN:
        l_attrSize = sizeof(ATTR_EFF_DRAM_GEN_type);
        break;

    // Get size for ATTR_EFF_DIMM_TYPE attribute
    case ATTR_EFF_DIMM_TYPE:
        l_attrSize = sizeof(ATTR_EFF_DIMM_TYPE_type);
        break;

    // Get size for ATTR_EFF_HYBRID_MEMORY_TYPE attribute
    case ATTR_EFF_HYBRID_MEMORY_TYPE:
        l_attrSize = sizeof(ATTR_EFF_HYBRID_MEMORY_TYPE_type);
        break;

    // Get size for ATTR_EFF_HYBRID attribute
    case ATTR_EFF_HYBRID:
        l_attrSize = sizeof(ATTR_EFF_HYBRID_type);
        break;

    // Get size for ATTR_EFF_DRAM_DENSITY attribute
    case ATTR_EFF_DRAM_DENSITY:
        l_attrSize = sizeof(ATTR_EFF_DRAM_DENSITY_type);
        break;

    // Get size for ATTR_EFF_DRAM_BANK_BITS attribute
    case ATTR_EFF_DRAM_BANK_BITS:
        l_attrSize = sizeof(ATTR_EFF_DRAM_BANK_BITS_type);
        break;

    // Get size for ATTR_EFF_DRAM_BANK_GROUP_BITS attribute
    case ATTR_EFF_DRAM_BANK_GROUP_BITS:
        l_attrSize = sizeof(ATTR_EFF_DRAM_BANK_GROUP_BITS_type);
        break;

    // Get size for ATTR_EFF_DRAM_COLUMN_BITS attribute
    case ATTR_EFF_DRAM_COLUMN_BITS:
        l_attrSize = sizeof(ATTR_EFF_DRAM_COLUMN_BITS_type);
        break;

    // Get size for ATTR_EFF_DRAM_ROW_BITS attribute
    case ATTR_EFF_DRAM_ROW_BITS:
        l_attrSize = sizeof(ATTR_EFF_DRAM_ROW_BITS_type);
        break;

    // Get size for ATTR_EFF_PRIM_STACK_TYPE attribute
    case ATTR_EFF_PRIM_STACK_TYPE:
        l_attrSize = sizeof(ATTR_EFF_PRIM_STACK_TYPE_type);
        break;

    // Get size for ATTR_EFF_DRAM_PPR attribute
    case ATTR_EFF_DRAM_PPR:
        l_attrSize = sizeof(ATTR_EFF_DRAM_PPR_type);
        break;

    // Get size for ATTR_EFF_DRAM_SOFT_PPR attribute
    case ATTR_EFF_DRAM_SOFT_PPR:
        l_attrSize = sizeof(ATTR_EFF_DRAM_SOFT_PPR_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRCD attribute
    case ATTR_EFF_DRAM_TRCD:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRCD_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRP attribute
    case ATTR_EFF_DRAM_TRP:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRP_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRAS attribute
    case ATTR_EFF_DRAM_TRAS:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRAS_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRC attribute
    case ATTR_EFF_DRAM_TRC:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRC_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRFC attribute
    case ATTR_EFF_DRAM_TRFC:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRFC_type);
        break;

    // Get size for ATTR_EFF_DRAM_TFAW attribute
    case ATTR_EFF_DRAM_TFAW:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TFAW_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRRD_S attribute
    case ATTR_EFF_DRAM_TRRD_S:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRRD_S_type);
        break;

    // Get size for ATTR_EFF_DRAM_TRRD_L attribute
    case ATTR_EFF_DRAM_TRRD_L:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TRRD_L_type);
        break;

    // Get size for ATTR_EFF_DRAM_TCCD_L attribute
    case ATTR_EFF_DRAM_TCCD_L:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TCCD_L_type);
        break;

    // Get size for ATTR_EFF_DRAM_TWR attribute
    case ATTR_EFF_DRAM_TWR:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TWR_type);
        break;

    // Get size for ATTR_EFF_DRAM_TWTR_S attribute
    case ATTR_EFF_DRAM_TWTR_S:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TWTR_S_type);
        break;

    // Get size for ATTR_EFF_DRAM_TWTR_L attribute
    case ATTR_EFF_DRAM_TWTR_L:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TWTR_L_type);
        break;

    // Get size for ATTR_EFF_DRAM_TMAW attribute
    case ATTR_EFF_DRAM_TMAW:
        l_attrSize = sizeof(ATTR_EFF_DRAM_TMAW_type);
        break;

    // Get size for ATTR_EFF_DRAM_WIDTH attribute
    case ATTR_EFF_DRAM_WIDTH:
        l_attrSize = sizeof(ATTR_EFF_DRAM_WIDTH_type);
        break;

    // Get size for ATTR_EFF_DRAM_RANK_MIX attribute
    case ATTR_EFF_DRAM_RANK_MIX:
        l_attrSize = sizeof(ATTR_EFF_DRAM_RANK_MIX_type);
        break;

    // Get size for ATTR_EFF_NUM_RANKS_PER_DIMM attribute
    case ATTR_EFF_NUM_RANKS_PER_DIMM:
        l_attrSize = sizeof(ATTR_EFF_NUM_RANKS_PER_DIMM_type);
        break;

    // Get size for ATTR_EFF_REGISTER_TYPE attribute
    case ATTR_EFF_REGISTER_TYPE:
        l_attrSize = sizeof(ATTR_EFF_REGISTER_TYPE_type);
        break;

    // Get size for ATTR_EFF_DRAM_MFG_ID attribute
    case ATTR_EFF_DRAM_MFG_ID:
        l_attrSize = sizeof(ATTR_EFF_DRAM_MFG_ID_type);
        break;

    // Get size for ATTR_EFF_RCD_MFG_ID attribute
    case ATTR_EFF_RCD_MFG_ID:
        l_attrSize = sizeof(ATTR_EFF_RCD_MFG_ID_type);
        break;

    // Get size for ATTR_EFF_REGISTER_REV attribute
    case ATTR_EFF_REGISTER_REV:
        l_attrSize = sizeof(ATTR_EFF_REGISTER_REV_type);
        break;

    // Get size for ATTR_EFF_PACKAGE_RANK_MAP attribute
    case ATTR_EFF_PACKAGE_RANK_MAP:
        l_attrSize = sizeof(ATTR_EFF_PACKAGE_RANK_MAP_type);
        break;

    // Get size for ATTR_EFF_NIBBLE_MAP attribute
    case ATTR_EFF_NIBBLE_MAP:
        l_attrSize = sizeof(ATTR_EFF_NIBBLE_MAP_type);
        break;

    // Get size for ATTR_ROW_REPAIR_SUPPORTED_MRW attribute
    case ATTR_ROW_REPAIR_SUPPORTED_MRW:
        l_attrSize = sizeof(ATTR_ROW_REPAIR_SUPPORTED_MRW_type);
        break;

    // Get size for ATTR_MEMORY_BAR_REGS attribute
    case ATTR_MEMORY_BAR_REGS:
        l_attrSize = sizeof(ATTR_MEMORY_BAR_REGS_type);
        break;

    // Get size for ATTR_PROC_MEM_BASES attribute
    case ATTR_PROC_MEM_BASES:
        l_attrSize = sizeof(ATTR_PROC_MEM_BASES_type);
        break;

    // Get size for ATTR_PROC_MEM_SIZES attribute
    case ATTR_PROC_MEM_SIZES:
        l_attrSize = sizeof(ATTR_PROC_MEM_SIZES_type);
        break;

    // Get size for ATTR_PROC_MIRROR_BASES attribute
    case ATTR_PROC_MIRROR_BASES:
        l_attrSize = sizeof(ATTR_PROC_MIRROR_BASES_type);
        break;

    // Get size for ATTR_PROC_MIRROR_SIZES attribute
    case ATTR_PROC_MIRROR_SIZES:
        l_attrSize = sizeof(ATTR_PROC_MIRROR_SIZES_type);
        break;

    // Get size for ATTR_PROC_MEM_BASES_ACK attribute
    case ATTR_PROC_MEM_BASES_ACK:
        l_attrSize = sizeof(ATTR_PROC_MEM_BASES_ACK_type);
        break;

    // Get size for ATTR_PROC_MEM_SIZES_ACK attribute
    case ATTR_PROC_MEM_SIZES_ACK:
        l_attrSize = sizeof(ATTR_PROC_MEM_SIZES_ACK_type);
        break;

    // Get size for ATTR_PROC_MIRROR_BASES_ACK attribute
    case ATTR_PROC_MIRROR_BASES_ACK:
        l_attrSize = sizeof(ATTR_PROC_MIRROR_BASES_ACK_type);
        break;

    // Get size for ATTR_MSS_MCC_GROUP_32 attribute
    case ATTR_MSS_MCC_GROUP_32:
        l_attrSize = sizeof(ATTR_MSS_MCC_GROUP_32_type);
        break;

    // Get size for ATTR_HTM_QUEUES attribute
    case ATTR_HTM_QUEUES:
        l_attrSize = sizeof(ATTR_HTM_QUEUES_type);
        break;

    // Get size for ATTR_PROC_MIRROR_SIZES_ACK attribute
    case ATTR_PROC_MIRROR_SIZES_ACK:
        l_attrSize = sizeof(ATTR_PROC_MIRROR_SIZES_ACK_type);
        break;

    // Get size for ATTR_MSS_MEM_MC_IN_GROUP attribute
    case ATTR_MSS_MEM_MC_IN_GROUP:
        l_attrSize = sizeof(ATTR_MSS_MEM_MC_IN_GROUP_type);
        break;

    // Get size for ATTR_MEM_MIRROR_PLACEMENT_POLICY attribute
    case ATTR_MEM_MIRROR_PLACEMENT_POLICY:
        l_attrSize = sizeof(ATTR_MEM_MIRROR_PLACEMENT_POLICY_type);
        break;

    // Get size for ATTR_MAX_INTERLEAVE_GROUP_SIZE attribute
    case ATTR_MAX_INTERLEAVE_GROUP_SIZE:
        l_attrSize = sizeof(ATTR_MAX_INTERLEAVE_GROUP_SIZE_type);
        break;

    // Get size for ATTR_MSS_INTERLEAVE_ENABLE attribute
    case ATTR_MSS_INTERLEAVE_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_INTERLEAVE_ENABLE_type);
        break;

    // Get size for ATTR_MSS_INTERLEAVE_GRANULARITY attribute
    case ATTR_MSS_INTERLEAVE_GRANULARITY:
        l_attrSize = sizeof(ATTR_MSS_INTERLEAVE_GRANULARITY_type);
        break;

    // Get size for ATTR_MSS_MEM_IPL_COMPLETE attribute
    case ATTR_MSS_MEM_IPL_COMPLETE:
        l_attrSize = sizeof(ATTR_MSS_MEM_IPL_COMPLETE_type);
        break;

    // Get size for ATTR_MRW_HW_MIRRORING_ENABLE attribute
    case ATTR_MRW_HW_MIRRORING_ENABLE:
        l_attrSize = sizeof(ATTR_MRW_HW_MIRRORING_ENABLE_type);
        break;

    // Get size for ATTR_DYNAMIC_INIT_FEATURE_VEC attribute
    case ATTR_DYNAMIC_INIT_FEATURE_VEC:
        l_attrSize = sizeof(ATTR_DYNAMIC_INIT_FEATURE_VEC_type);
        break;

    // Get size for ATTR_DYNAMIC_INIT_FEATURE_COUNT attribute
    case ATTR_DYNAMIC_INIT_FEATURE_COUNT:
        l_attrSize = sizeof(ATTR_DYNAMIC_INIT_FEATURE_COUNT_type);
        break;

    // Get size for ATTR_DYNAMIC_INIT_MODE_VEC attribute
    case ATTR_DYNAMIC_INIT_MODE_VEC:
        l_attrSize = sizeof(ATTR_DYNAMIC_INIT_MODE_VEC_type);
        break;

    // Get size for ATTR_DYNAMIC_INIT_MODE_COUNT attribute
    case ATTR_DYNAMIC_INIT_MODE_COUNT:
        l_attrSize = sizeof(ATTR_DYNAMIC_INIT_MODE_COUNT_type);
        break;

    // Get size for ATTR_NHTM_TRACE_TYPE attribute
    case ATTR_NHTM_TRACE_TYPE:
        l_attrSize = sizeof(ATTR_NHTM_TRACE_TYPE_type);
        break;

    // Get size for ATTR_CHTM_TRACE_TYPE attribute
    case ATTR_CHTM_TRACE_TYPE:
        l_attrSize = sizeof(ATTR_CHTM_TRACE_TYPE_type);
        break;

    // Get size for ATTR_NHTM_HTMSC_MODE_CONTENT_SEL attribute
    case ATTR_NHTM_HTMSC_MODE_CONTENT_SEL:
        l_attrSize = sizeof(ATTR_NHTM_HTMSC_MODE_CONTENT_SEL_type);
        break;

    // Get size for ATTR_NHTM_HTMSC_MODE_CAPTURE attribute
    case ATTR_NHTM_HTMSC_MODE_CAPTURE:
        l_attrSize = sizeof(ATTR_NHTM_HTMSC_MODE_CAPTURE_type);
        break;

    // Get size for ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE attribute
    case ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE:
        l_attrSize = sizeof(ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE_type);
        break;

    // Get size for ATTR_NHTM_HTMSC_MODE_WRITETOIO attribute
    case ATTR_NHTM_HTMSC_MODE_WRITETOIO:
        l_attrSize = sizeof(ATTR_NHTM_HTMSC_MODE_WRITETOIO_type);
        break;

    // Get size for ATTR_HTMSC_FILT_STOP_ON_MATCH attribute
    case ATTR_HTMSC_FILT_STOP_ON_MATCH:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_STOP_ON_MATCH_type);
        break;

    // Get size for ATTR_HTMSC_FILT_STOP_CYCLES attribute
    case ATTR_HTMSC_FILT_STOP_CYCLES:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_STOP_CYCLES_type);
        break;

    // Get size for ATTR_HTMSC_TTYPEFILT_PAT attribute
    case ATTR_HTMSC_TTYPEFILT_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_TTYPEFILT_PAT_type);
        break;

    // Get size for ATTR_HTMSC_TSIZEFILT_PAT attribute
    case ATTR_HTMSC_TSIZEFILT_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_TSIZEFILT_PAT_type);
        break;

    // Get size for ATTR_HTMSC_TTYPEFILT_MASK attribute
    case ATTR_HTMSC_TTYPEFILT_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_TTYPEFILT_MASK_type);
        break;

    // Get size for ATTR_HTMSC_TSIZEFILT_MASK attribute
    case ATTR_HTMSC_TSIZEFILT_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_TSIZEFILT_MASK_type);
        break;

    // Get size for ATTR_HTMSC_TTYPEFILT_INVERT attribute
    case ATTR_HTMSC_TTYPEFILT_INVERT:
        l_attrSize = sizeof(ATTR_HTMSC_TTYPEFILT_INVERT_type);
        break;

    // Get size for ATTR_HTMSC_CRESPFILT_INVERT attribute
    case ATTR_HTMSC_CRESPFILT_INVERT:
        l_attrSize = sizeof(ATTR_HTMSC_CRESPFILT_INVERT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_ADDR_PAT attribute
    case ATTR_HTMSC_FILT_ADDR_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_ADDR_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_ADDR_MASK attribute
    case ATTR_HTMSC_FILT_ADDR_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_ADDR_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_TTAG_PAT attribute
    case ATTR_HTMSC_FILT_TTAG_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_TTAG_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_OCC_PAT attribute
    case ATTR_HTMSC_FILT_OCC_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_OCC_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_SCOPE_PAT attribute
    case ATTR_HTMSC_FILT_SCOPE_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_SCOPE_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_SOURCE_PAT attribute
    case ATTR_HTMSC_FILT_SOURCE_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_SOURCE_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_PORT_PAT attribute
    case ATTR_HTMSC_FILT_PORT_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_PORT_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_PORT1_PAT attribute
    case ATTR_HTMSC_FILT_PORT1_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_PORT1_PAT_type);
        break;

    // Get size for ATTR_HTMSC_TTAGFILT_INVERT attribute
    case ATTR_HTMSC_TTAGFILT_INVERT:
        l_attrSize = sizeof(ATTR_HTMSC_TTAGFILT_INVERT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_CRESP_PAT attribute
    case ATTR_HTMSC_FILT_CRESP_PAT:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_CRESP_PAT_type);
        break;

    // Get size for ATTR_HTMSC_FILT_TTAG_MASK attribute
    case ATTR_HTMSC_FILT_TTAG_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_TTAG_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_OCC_MASK attribute
    case ATTR_HTMSC_FILT_OCC_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_OCC_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_SCOPE_MASK attribute
    case ATTR_HTMSC_FILT_SCOPE_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_SCOPE_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_SOURCE_MASK attribute
    case ATTR_HTMSC_FILT_SOURCE_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_SOURCE_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_PORT_MASK attribute
    case ATTR_HTMSC_FILT_PORT_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_PORT_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_PORT1_MASK attribute
    case ATTR_HTMSC_FILT_PORT1_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_PORT1_MASK_type);
        break;

    // Get size for ATTR_HTMSC_FILT_CRESP_MASK attribute
    case ATTR_HTMSC_FILT_CRESP_MASK:
        l_attrSize = sizeof(ATTR_HTMSC_FILT_CRESP_MASK_type);
        break;

    // Get size for ATTR_HTMSC_MEM_SCOPE attribute
    case ATTR_HTMSC_MEM_SCOPE:
        l_attrSize = sizeof(ATTR_HTMSC_MEM_SCOPE_type);
        break;

    // Get size for ATTR_HTMSC_MEM_PRIORITY attribute
    case ATTR_HTMSC_MEM_PRIORITY:
        l_attrSize = sizeof(ATTR_HTMSC_MEM_PRIORITY_type);
        break;

    // Get size for ATTR_NHTM_CTRL_TRIG attribute
    case ATTR_NHTM_CTRL_TRIG:
        l_attrSize = sizeof(ATTR_NHTM_CTRL_TRIG_type);
        break;

    // Get size for ATTR_NHTM_CTRL_MARK attribute
    case ATTR_NHTM_CTRL_MARK:
        l_attrSize = sizeof(ATTR_NHTM_CTRL_MARK_type);
        break;

    // Get size for ATTR_CHTM_CTRL_TRIG attribute
    case ATTR_CHTM_CTRL_TRIG:
        l_attrSize = sizeof(ATTR_CHTM_CTRL_TRIG_type);
        break;

    // Get size for ATTR_CHTM_CTRL_MARK attribute
    case ATTR_CHTM_CTRL_MARK:
        l_attrSize = sizeof(ATTR_CHTM_CTRL_MARK_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_DBG0_STOP attribute
    case ATTR_HTMSC_CTRL_DBG0_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_DBG0_STOP_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_DBG1_STOP attribute
    case ATTR_HTMSC_CTRL_DBG1_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_DBG1_STOP_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_RUN_STOP attribute
    case ATTR_HTMSC_CTRL_RUN_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_RUN_STOP_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_OTHER_DBG0_STOP attribute
    case ATTR_HTMSC_CTRL_OTHER_DBG0_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_OTHER_DBG0_STOP_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_XSTOP_STOP attribute
    case ATTR_HTMSC_CTRL_XSTOP_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_XSTOP_STOP_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_CHIP0_STOP attribute
    case ATTR_HTMSC_CTRL_CHIP0_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_CHIP0_STOP_type);
        break;

    // Get size for ATTR_HTMSC_CTRL_CHIP1_STOP attribute
    case ATTR_HTMSC_CTRL_CHIP1_STOP:
        l_attrSize = sizeof(ATTR_HTMSC_CTRL_CHIP1_STOP_type);
        break;

    // Get size for ATTR_HTMSC_IMA_PDBAR_SCOPE attribute
    case ATTR_HTMSC_IMA_PDBAR_SCOPE:
        l_attrSize = sizeof(ATTR_HTMSC_IMA_PDBAR_SCOPE_type);
        break;

    // Get size for ATTR_HTMSC_IMA_PDBAR_ADDR attribute
    case ATTR_HTMSC_IMA_PDBAR_ADDR:
        l_attrSize = sizeof(ATTR_HTMSC_IMA_PDBAR_ADDR_type);
        break;

    // Get size for ATTR_HTMSC_MODE_WRAP attribute
    case ATTR_HTMSC_MODE_WRAP:
        l_attrSize = sizeof(ATTR_HTMSC_MODE_WRAP_type);
        break;

    // Get size for ATTR_HTMSC_MODE_DIS_TSTAMP attribute
    case ATTR_HTMSC_MODE_DIS_TSTAMP:
        l_attrSize = sizeof(ATTR_HTMSC_MODE_DIS_TSTAMP_type);
        break;

    // Get size for ATTR_HTMSC_MODE_SINGLE_TSTAMP attribute
    case ATTR_HTMSC_MODE_SINGLE_TSTAMP:
        l_attrSize = sizeof(ATTR_HTMSC_MODE_SINGLE_TSTAMP_type);
        break;

    // Get size for ATTR_HTMSC_MODE_MARKERS_ONLY attribute
    case ATTR_HTMSC_MODE_MARKERS_ONLY:
        l_attrSize = sizeof(ATTR_HTMSC_MODE_MARKERS_ONLY_type);
        break;

    // Get size for ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE attribute
    case ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE:
        l_attrSize = sizeof(ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_type);
        break;

    // Get size for ATTR_HTMSC_MODE_VGTARGET attribute
    case ATTR_HTMSC_MODE_VGTARGET:
        l_attrSize = sizeof(ATTR_HTMSC_MODE_VGTARGET_type);
        break;

    // Get size for ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS attribute
    case ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS:
        l_attrSize = sizeof(ATTR_CHTM_MODE_LLAT_CAPTURE_FAIL_DISP_DIS_type);
        break;

    // Get size for ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS attribute
    case ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS:
        l_attrSize = sizeof(ATTR_CHTM_MODE_LLAT_CAPTURE_STORE_DIS_type);
        break;

    // Get size for ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS attribute
    case ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS:
        l_attrSize = sizeof(ATTR_CHTM_MODE_LLAT_CAPTURE_PBL3_HIT_DIS_type);
        break;

    // Get size for ATTR_CHTM_MODE_LLAT_IMBEDDED_TS attribute
    case ATTR_CHTM_MODE_LLAT_IMBEDDED_TS:
        l_attrSize = sizeof(ATTR_CHTM_MODE_LLAT_IMBEDDED_TS_type);
        break;

    // Get size for ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR attribute
    case ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR:
        l_attrSize = sizeof(ATTR_CHTM_MODE_CORE_CAPTURE_TRACE_FULL_ON_ERROR_type);
        break;

    // Get size for ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE attribute
    case ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE:
        l_attrSize = sizeof(ATTR_CHTM_MODE_LLAT_PAUSE_ON_PURGE_type);
        break;

    // Get size for ATTR_CHTM_MODE_CORE_WRAP attribute
    case ATTR_CHTM_MODE_CORE_WRAP:
        l_attrSize = sizeof(ATTR_CHTM_MODE_CORE_WRAP_type);
        break;

    // Get size for ATTR_CHTM_MODE_DIS_TSTAMP attribute
    case ATTR_CHTM_MODE_DIS_TSTAMP:
        l_attrSize = sizeof(ATTR_CHTM_MODE_DIS_TSTAMP_type);
        break;

    // Get size for ATTR_CHTM_MODE_SINGLE_TIME_STAMP attribute
    case ATTR_CHTM_MODE_SINGLE_TIME_STAMP:
        l_attrSize = sizeof(ATTR_CHTM_MODE_SINGLE_TIME_STAMP_type);
        break;

    // Get size for ATTR_CHTM_MODE_DIS_STALL attribute
    case ATTR_CHTM_MODE_DIS_STALL:
        l_attrSize = sizeof(ATTR_CHTM_MODE_DIS_STALL_type);
        break;

    // Get size for ATTR_CHTM_MODE_MARKERS_ONLY attribute
    case ATTR_CHTM_MODE_MARKERS_ONLY:
        l_attrSize = sizeof(ATTR_CHTM_MODE_MARKERS_ONLY_type);
        break;

    // Get size for ATTR_CHTM_MODE_DIS_GROUP attribute
    case ATTR_CHTM_MODE_DIS_GROUP:
        l_attrSize = sizeof(ATTR_CHTM_MODE_DIS_GROUP_type);
        break;

    // Get size for ATTR_CHTM_MODE_VGTARGET attribute
    case ATTR_CHTM_MODE_VGTARGET:
        l_attrSize = sizeof(ATTR_CHTM_MODE_VGTARGET_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL attribute
    case ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_IC_TAP_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_DIS_WRAP_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_FREEZE_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_D_PRE_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EN_I_PRE_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_ONE_EVENT_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_VTID_type);
        break;

    // Get size for ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT attribute
    case ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT:
        l_attrSize = sizeof(ATTR_CHTM_HTMSC_IMA_EVENT_MASK_EVENT_SELECT_type);
        break;

    // Get size for ATTR_OMI_REFCLOCK_SWIZZLE attribute
    case ATTR_OMI_REFCLOCK_SWIZZLE:
        l_attrSize = sizeof(ATTR_OMI_REFCLOCK_SWIZZLE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE attribute
    case ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_SL_DOMAIN attribute
    case ATTR_PROC_FABRIC_SL_DOMAIN:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_SL_DOMAIN_type);
        break;

    // Get size for ATTR_PROC_FABRIC_TSNOOP attribute
    case ATTR_PROC_FABRIC_TSNOOP:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_TSNOOP_type);
        break;

    // Get size for ATTR_PROC_FABRIC_BROADCAST_MODE attribute
    case ATTR_PROC_FABRIC_BROADCAST_MODE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_BROADCAST_MODE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_PRESENT_GROUPS attribute
    case ATTR_PROC_FABRIC_PRESENT_GROUPS:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_PRESENT_GROUPS_type);
        break;

    // Get size for ATTR_PROC_FABRIC_TOPOLOGY_MODE attribute
    case ATTR_PROC_FABRIC_TOPOLOGY_MODE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_TOPOLOGY_MODE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_TOPOLOGY_ID attribute
    case ATTR_PROC_FABRIC_TOPOLOGY_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_TOPOLOGY_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID attribute
    case ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP attribute
    case ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP_type);
        break;

    // Get size for ATTR_PROC_FABRIC_GROUP_MASTER_CHIP attribute
    case ATTR_PROC_FABRIC_GROUP_MASTER_CHIP:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_GROUP_MASTER_CHIP_type);
        break;

    // Get size for ATTR_IOHS_CONFIG_MODE attribute
    case ATTR_IOHS_CONFIG_MODE:
        l_attrSize = sizeof(ATTR_IOHS_CONFIG_MODE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_IOHS_BUS_WIDTH attribute
    case ATTR_PROC_FABRIC_IOHS_BUS_WIDTH:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_IOHS_BUS_WIDTH_type);
        break;

    // Get size for ATTR_IOHS_DRAWER_INTERCONNECT attribute
    case ATTR_IOHS_DRAWER_INTERCONNECT:
        l_attrSize = sizeof(ATTR_IOHS_DRAWER_INTERCONNECT_type);
        break;

    // Get size for ATTR_IOHS_SMP9_INTERCONNECT attribute
    case ATTR_IOHS_SMP9_INTERCONNECT:
        l_attrSize = sizeof(ATTR_IOHS_SMP9_INTERCONNECT_type);
        break;

    // Get size for ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG attribute
    case ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG:
        l_attrSize = sizeof(ATTR_IOHS_FABRIC_TOD_CROSS_CONFIG_type);
        break;

    // Get size for ATTR_IOHS_FABRIC_LANE_REVERSAL attribute
    case ATTR_IOHS_FABRIC_LANE_REVERSAL:
        l_attrSize = sizeof(ATTR_IOHS_FABRIC_LANE_REVERSAL_type);
        break;

    // Get size for ATTR_PROC_FABRIC_LINK_ACTIVE attribute
    case ATTR_PROC_FABRIC_LINK_ACTIVE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_LINK_ACTIVE_type);
        break;

    // Get size for ATTR_IOHS_LINK_TRAIN attribute
    case ATTR_IOHS_LINK_TRAIN:
        l_attrSize = sizeof(ATTR_IOHS_LINK_TRAIN_type);
        break;

    // Get size for ATTR_IOHS_LINK_SPLIT attribute
    case ATTR_IOHS_LINK_SPLIT:
        l_attrSize = sizeof(ATTR_IOHS_LINK_SPLIT_type);
        break;

    // Get size for ATTR_LINK_SPEED attribute
    case ATTR_LINK_SPEED:
        l_attrSize = sizeof(ATTR_LINK_SPEED_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG attribute
    case ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_LINKS_CNFG attribute
    case ATTR_PROC_FABRIC_X_LINKS_CNFG:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_LINKS_CNFG_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG attribute
    case ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_LINKS_CNFG attribute
    case ATTR_PROC_FABRIC_A_LINKS_CNFG:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_LINKS_CNFG_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID attribute
    case ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID attribute
    case ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_ATTACHED_TOPOLOGY_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID attribute
    case ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID attribute
    case ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID attribute
    case ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_ATTACHED_TOPOLOGY_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID attribute
    case ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_AGGREGATE attribute
    case ATTR_PROC_FABRIC_X_AGGREGATE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_AGGREGATE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_ADDR_DIS attribute
    case ATTR_PROC_FABRIC_X_ADDR_DIS:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_ADDR_DIS_type);
        break;

    // Get size for ATTR_PROC_FABRIC_X_LINK_DELAY attribute
    case ATTR_PROC_FABRIC_X_LINK_DELAY:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_X_LINK_DELAY_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_AGGREGATE attribute
    case ATTR_PROC_FABRIC_A_AGGREGATE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_AGGREGATE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_ADDR_DIS attribute
    case ATTR_PROC_FABRIC_A_ADDR_DIS:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_ADDR_DIS_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_INDIRECT attribute
    case ATTR_PROC_FABRIC_A_INDIRECT:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_INDIRECT_type);
        break;

    // Get size for ATTR_PROC_FABRIC_R_INDIRECT_EN attribute
    case ATTR_PROC_FABRIC_R_INDIRECT_EN:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_R_INDIRECT_EN_type);
        break;

    // Get size for ATTR_PROC_FABRIC_A_LINK_DELAY attribute
    case ATTR_PROC_FABRIC_A_LINK_DELAY:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_A_LINK_DELAY_type);
        break;

    // Get size for ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE attribute
    case ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_LINK_TOPOLOGY_ID_TABLE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_ASYNC_MODE attribute
    case ATTR_PROC_FABRIC_ASYNC_MODE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_ASYNC_MODE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_DLR_PSAVE_MODE attribute
    case ATTR_PROC_FABRIC_DLR_PSAVE_MODE:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_DLR_PSAVE_MODE_type);
        break;

    // Get size for ATTR_PROC_FABRIC_CORE_FREQ_RATIO attribute
    case ATTR_PROC_FABRIC_CORE_FREQ_RATIO:
        l_attrSize = sizeof(ATTR_PROC_FABRIC_CORE_FREQ_RATIO_type);
        break;

    // Get size for ATTR_PROC_EPS_GB_PERCENTAGE attribute
    case ATTR_PROC_EPS_GB_PERCENTAGE:
        l_attrSize = sizeof(ATTR_PROC_EPS_GB_PERCENTAGE_type);
        break;

    // Get size for ATTR_PROC_EPS_TABLE_TYPE attribute
    case ATTR_PROC_EPS_TABLE_TYPE:
        l_attrSize = sizeof(ATTR_PROC_EPS_TABLE_TYPE_type);
        break;

    // Get size for ATTR_PROC_EPS_READ_CYCLES_T0 attribute
    case ATTR_PROC_EPS_READ_CYCLES_T0:
        l_attrSize = sizeof(ATTR_PROC_EPS_READ_CYCLES_T0_type);
        break;

    // Get size for ATTR_PROC_EPS_READ_CYCLES_T1 attribute
    case ATTR_PROC_EPS_READ_CYCLES_T1:
        l_attrSize = sizeof(ATTR_PROC_EPS_READ_CYCLES_T1_type);
        break;

    // Get size for ATTR_PROC_EPS_READ_CYCLES_T2 attribute
    case ATTR_PROC_EPS_READ_CYCLES_T2:
        l_attrSize = sizeof(ATTR_PROC_EPS_READ_CYCLES_T2_type);
        break;

    // Get size for ATTR_PROC_EPS_WRITE_CYCLES_T1 attribute
    case ATTR_PROC_EPS_WRITE_CYCLES_T1:
        l_attrSize = sizeof(ATTR_PROC_EPS_WRITE_CYCLES_T1_type);
        break;

    // Get size for ATTR_PROC_EPS_WRITE_CYCLES_T2 attribute
    case ATTR_PROC_EPS_WRITE_CYCLES_T2:
        l_attrSize = sizeof(ATTR_PROC_EPS_WRITE_CYCLES_T2_type);
        break;

    // Get size for ATTR_MRW_L2_INCREASE_JITTER attribute
    case ATTR_MRW_L2_INCREASE_JITTER:
        l_attrSize = sizeof(ATTR_MRW_L2_INCREASE_JITTER_type);
        break;

    // Get size for ATTR_MRW_P1PF_MIN_CONFIDENCE_3 attribute
    case ATTR_MRW_P1PF_MIN_CONFIDENCE_3:
        l_attrSize = sizeof(ATTR_MRW_P1PF_MIN_CONFIDENCE_3_type);
        break;

    // Get size for ATTR_MRW_CONVERT_DCBZ_TO_RWITM attribute
    case ATTR_MRW_CONVERT_DCBZ_TO_RWITM:
        l_attrSize = sizeof(ATTR_MRW_CONVERT_DCBZ_TO_RWITM_type);
        break;

    // Get size for ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH attribute
    case ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH:
        l_attrSize = sizeof(ATTR_PROC_FAVOR_AGGRESSIVE_PREFETCH_type);
        break;

    // Get size for ATTR_PROC_LCO_MODE_DISABLE attribute
    case ATTR_PROC_LCO_MODE_DISABLE:
        l_attrSize = sizeof(ATTR_PROC_LCO_MODE_DISABLE_type);
        break;

    // Get size for ATTR_PROC_LCO_MODE_SETUP attribute
    case ATTR_PROC_LCO_MODE_SETUP:
        l_attrSize = sizeof(ATTR_PROC_LCO_MODE_SETUP_type);
        break;

    // Get size for ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N attribute
    case ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N:
        l_attrSize = sizeof(ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N_type);
        break;

    // Get size for ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D attribute
    case ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D:
        l_attrSize = sizeof(ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D_type);
        break;

    // Get size for ATTR_PROC_LCO_TARGETS_COUNT attribute
    case ATTR_PROC_LCO_TARGETS_COUNT:
        l_attrSize = sizeof(ATTR_PROC_LCO_TARGETS_COUNT_type);
        break;

    // Get size for ATTR_PROC_LCO_TARGETS_VECTOR attribute
    case ATTR_PROC_LCO_TARGETS_VECTOR:
        l_attrSize = sizeof(ATTR_PROC_LCO_TARGETS_VECTOR_type);
        break;

    // Get size for ATTR_PROC_LCO_TARGETS_MIN attribute
    case ATTR_PROC_LCO_TARGETS_MIN:
        l_attrSize = sizeof(ATTR_PROC_LCO_TARGETS_MIN_type);
        break;

    // Get size for ATTR_IOHS_PHY_TO_PAU_MAPPING attribute
    case ATTR_IOHS_PHY_TO_PAU_MAPPING:
        l_attrSize = sizeof(ATTR_IOHS_PHY_TO_PAU_MAPPING_type);
        break;

    // Get size for ATTR_PROC_L2_HASH_DISABLE attribute
    case ATTR_PROC_L2_HASH_DISABLE:
        l_attrSize = sizeof(ATTR_PROC_L2_HASH_DISABLE_type);
        break;

    // Get size for ATTR_PROC_L3_HASH_DISABLE attribute
    case ATTR_PROC_L3_HASH_DISABLE:
        l_attrSize = sizeof(ATTR_PROC_L3_HASH_DISABLE_type);
        break;

    // Get size for ATTR_PROC_SBE_MCS_SETUP_REG_STATES attribute
    case ATTR_PROC_SBE_MCS_SETUP_REG_STATES:
        l_attrSize = sizeof(ATTR_PROC_SBE_MCS_SETUP_REG_STATES_type);
        break;

    // Get size for ATTR_PROC_MEMORY_ENCRYPTION_ENABLED attribute
    case ATTR_PROC_MEMORY_ENCRYPTION_ENABLED:
        l_attrSize = sizeof(ATTR_PROC_MEMORY_ENCRYPTION_ENABLED_type);
        break;

    // Get size for ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC attribute
    case ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC:
        l_attrSize = sizeof(ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC_type);
        break;

    // Get size for ATTR_HW543384_WAR_MODE attribute
    case ATTR_HW543384_WAR_MODE:
        l_attrSize = sizeof(ATTR_HW543384_WAR_MODE_type);
        break;

    // Get size for ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE attribute
    case ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_FUSED_CORE_PAIRED_DISABLE_type);
        break;

    // Get size for ATTR_QME_STATE_LOSS_CORES attribute
    case ATTR_QME_STATE_LOSS_CORES:
        l_attrSize = sizeof(ATTR_QME_STATE_LOSS_CORES_type);
        break;

    // Get size for ATTR_PROC_DPLL_DIVIDER attribute
    case ATTR_PROC_DPLL_DIVIDER:
        l_attrSize = sizeof(ATTR_PROC_DPLL_DIVIDER_type);
        break;

    // Get size for ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET attribute
    case ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET:
        l_attrSize = sizeof(ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET_type);
        break;

    // Get size for ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET attribute
    case ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET:
        l_attrSize = sizeof(ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET_type);
        break;

    // Get size for ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG attribute
    case ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG:
        l_attrSize = sizeof(ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG_type);
        break;

    // Get size for ATTR_OCC_LFIRMASK attribute
    case ATTR_OCC_LFIRMASK:
        l_attrSize = sizeof(ATTR_OCC_LFIRMASK_type);
        break;

    // Get size for ATTR_PBAO_LFIRMASK attribute
    case ATTR_PBAO_LFIRMASK:
        l_attrSize = sizeof(ATTR_PBAO_LFIRMASK_type);
        break;

    // Get size for ATTR_QME_LFIRMASK attribute
    case ATTR_QME_LFIRMASK:
        l_attrSize = sizeof(ATTR_QME_LFIRMASK_type);
        break;

    // Get size for ATTR_PBAF_LFIRMASK attribute
    case ATTR_PBAF_LFIRMASK:
        l_attrSize = sizeof(ATTR_PBAF_LFIRMASK_type);
        break;

    // Get size for ATTR_PM_FIRINIT_DONE_ONCE_FLAG attribute
    case ATTR_PM_FIRINIT_DONE_ONCE_FLAG:
        l_attrSize = sizeof(ATTR_PM_FIRINIT_DONE_ONCE_FLAG_type);
        break;

    // Get size for ATTR_L3_HASCLOCKS attribute
    case ATTR_L3_HASCLOCKS:
        l_attrSize = sizeof(ATTR_L3_HASCLOCKS_type);
        break;

    // Get size for ATTR_CORE_HASCLOCKS attribute
    case ATTR_CORE_HASCLOCKS:
        l_attrSize = sizeof(ATTR_CORE_HASCLOCKS_type);
        break;

    // Get size for ATTR_L3_HASPOWER attribute
    case ATTR_L3_HASPOWER:
        l_attrSize = sizeof(ATTR_L3_HASPOWER_type);
        break;

    // Get size for ATTR_CORE_HASPOWER attribute
    case ATTR_CORE_HASPOWER:
        l_attrSize = sizeof(ATTR_CORE_HASPOWER_type);
        break;

    // Get size for ATTR_PSTATES_ENABLED attribute
    case ATTR_PSTATES_ENABLED:
        l_attrSize = sizeof(ATTR_PSTATES_ENABLED_type);
        break;

    // Get size for ATTR_RESCLK_ENABLED attribute
    case ATTR_RESCLK_ENABLED:
        l_attrSize = sizeof(ATTR_RESCLK_ENABLED_type);
        break;

    // Get size for ATTR_DDS_ENABLED attribute
    case ATTR_DDS_ENABLED:
        l_attrSize = sizeof(ATTR_DDS_ENABLED_type);
        break;

    // Get size for ATTR_RVRM_ENABLED attribute
    case ATTR_RVRM_ENABLED:
        l_attrSize = sizeof(ATTR_RVRM_ENABLED_type);
        break;

    // Get size for ATTR_WOF_ENABLED attribute
    case ATTR_WOF_ENABLED:
        l_attrSize = sizeof(ATTR_WOF_ENABLED_type);
        break;

    // Get size for ATTR_OCS_ENABLED attribute
    case ATTR_OCS_ENABLED:
        l_attrSize = sizeof(ATTR_OCS_ENABLED_type);
        break;

    // Get size for ATTR_WOV_UNDERV_ENABLED attribute
    case ATTR_WOV_UNDERV_ENABLED:
        l_attrSize = sizeof(ATTR_WOV_UNDERV_ENABLED_type);
        break;

    // Get size for ATTR_WOV_OVERV_ENABLED attribute
    case ATTR_WOV_OVERV_ENABLED:
        l_attrSize = sizeof(ATTR_WOV_OVERV_ENABLED_type);
        break;

    // Get size for ATTR_WOF_THROTTLE_CONTROL_DISABLED attribute
    case ATTR_WOF_THROTTLE_CONTROL_DISABLED:
        l_attrSize = sizeof(ATTR_WOF_THROTTLE_CONTROL_DISABLED_type);
        break;

    // Get size for ATTR_XGPE_PHANTOM_HALT_ENABLE attribute
    case ATTR_XGPE_PHANTOM_HALT_ENABLE:
        l_attrSize = sizeof(ATTR_XGPE_PHANTOM_HALT_ENABLE_type);
        break;

    // Get size for ATTR_PGPE_PHANTOM_HALT_ENABLE attribute
    case ATTR_PGPE_PHANTOM_HALT_ENABLE:
        l_attrSize = sizeof(ATTR_PGPE_PHANTOM_HALT_ENABLE_type);
        break;

    // Get size for ATTR_QME_STOP_PHANTOM_HALT_ENABLE attribute
    case ATTR_QME_STOP_PHANTOM_HALT_ENABLE:
        l_attrSize = sizeof(ATTR_QME_STOP_PHANTOM_HALT_ENABLE_type);
        break;

    // Get size for ATTR_CORE_INSIDE_SPECIAL_WAKEUP attribute
    case ATTR_CORE_INSIDE_SPECIAL_WAKEUP:
        l_attrSize = sizeof(ATTR_CORE_INSIDE_SPECIAL_WAKEUP_type);
        break;

    // Get size for ATTR_INITIATED_PM_HALT attribute
    case ATTR_INITIATED_PM_HALT:
        l_attrSize = sizeof(ATTR_INITIATED_PM_HALT_type);
        break;

    // Get size for ATTR_PM_RESTART_PHASE attribute
    case ATTR_PM_RESTART_PHASE:
        l_attrSize = sizeof(ATTR_PM_RESTART_PHASE_type);
        break;

    // Get size for ATTR_PM_MALF_CYCLE attribute
    case ATTR_PM_MALF_CYCLE:
        l_attrSize = sizeof(ATTR_PM_MALF_CYCLE_type);
        break;

    // Get size for ATTR_BOOT_VOLTAGE attribute
    case ATTR_BOOT_VOLTAGE:
        l_attrSize = sizeof(ATTR_BOOT_VOLTAGE_type);
        break;

    // Get size for ATTR_QME_BROADSIDE_SCAN attribute
    case ATTR_QME_BROADSIDE_SCAN:
        l_attrSize = sizeof(ATTR_QME_BROADSIDE_SCAN_type);
        break;

    // Get size for ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ attribute
    case ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_SYSTEM_MAX_OPERATING_FREQ_MHZ_type);
        break;

    // Get size for ATTR_SYSTEM_PSTATE0_FREQ_MHZ attribute
    case ATTR_SYSTEM_PSTATE0_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_SYSTEM_PSTATE0_FREQ_MHZ_type);
        break;

    // Get size for ATTR_HOMER_LOCATION attribute
    case ATTR_HOMER_LOCATION:
        l_attrSize = sizeof(ATTR_HOMER_LOCATION_type);
        break;

    // Get size for ATTR_QME_BOOT_CONTROL attribute
    case ATTR_QME_BOOT_CONTROL:
        l_attrSize = sizeof(ATTR_QME_BOOT_CONTROL_type);
        break;

    // Get size for ATTR_PM_SPIPSS_FRAME_SIZE attribute
    case ATTR_PM_SPIPSS_FRAME_SIZE:
        l_attrSize = sizeof(ATTR_PM_SPIPSS_FRAME_SIZE_type);
        break;

    // Get size for ATTR_PM_SPIPSS_IN_DELAY attribute
    case ATTR_PM_SPIPSS_IN_DELAY:
        l_attrSize = sizeof(ATTR_PM_SPIPSS_IN_DELAY_type);
        break;

    // Get size for ATTR_PM_SPIPSS_CLOCK_POLARITY attribute
    case ATTR_PM_SPIPSS_CLOCK_POLARITY:
        l_attrSize = sizeof(ATTR_PM_SPIPSS_CLOCK_POLARITY_type);
        break;

    // Get size for ATTR_PM_SPIPSS_CLOCK_PHASE attribute
    case ATTR_PM_SPIPSS_CLOCK_PHASE:
        l_attrSize = sizeof(ATTR_PM_SPIPSS_CLOCK_PHASE_type);
        break;

    // Get size for ATTR_PM_SPIPSS_CLOCK_DIVIDER attribute
    case ATTR_PM_SPIPSS_CLOCK_DIVIDER:
        l_attrSize = sizeof(ATTR_PM_SPIPSS_CLOCK_DIVIDER_type);
        break;

    // Get size for ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING attribute
    case ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING:
        l_attrSize = sizeof(ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING_type);
        break;

    // Get size for ATTR_INSIDE_SPECIAL_WAKEUP attribute
    case ATTR_INSIDE_SPECIAL_WAKEUP:
        l_attrSize = sizeof(ATTR_INSIDE_SPECIAL_WAKEUP_type);
        break;

    // Get size for ATTR_SOCKET_POWER_NOMINAL attribute
    case ATTR_SOCKET_POWER_NOMINAL:
        l_attrSize = sizeof(ATTR_SOCKET_POWER_NOMINAL_type);
        break;

    // Get size for ATTR_SYSTEM_COMPAT_FREQ_MHZ attribute
    case ATTR_SYSTEM_COMPAT_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_SYSTEM_COMPAT_FREQ_MHZ_type);
        break;

    // Get size for ATTR_WOF_TABLE_OVERRIDE_UT attribute
    case ATTR_WOF_TABLE_OVERRIDE_UT:
        l_attrSize = sizeof(ATTR_WOF_TABLE_OVERRIDE_UT_type);
        break;

    // Get size for ATTR_WOF_TABLE_OVERRIDE_WB attribute
    case ATTR_WOF_TABLE_OVERRIDE_WB:
        l_attrSize = sizeof(ATTR_WOF_TABLE_OVERRIDE_WB_type);
        break;

    // Get size for ATTR_WOF_TABLE_OVERRIDE_PS attribute
    case ATTR_WOF_TABLE_OVERRIDE_PS:
        l_attrSize = sizeof(ATTR_WOF_TABLE_OVERRIDE_PS_type);
        break;

    // Get size for ATTR_WOF_TABLE_OVERRIDE_FF attribute
    case ATTR_WOF_TABLE_OVERRIDE_FF:
        l_attrSize = sizeof(ATTR_WOF_TABLE_OVERRIDE_FF_type);
        break;

    // Get size for ATTR_WOF_TABLE_OVERRIDE_SP attribute
    case ATTR_WOF_TABLE_OVERRIDE_SP:
        l_attrSize = sizeof(ATTR_WOF_TABLE_OVERRIDE_SP_type);
        break;

    // Get size for ATTR_WOF_TABLE_OVERRIDE_RC attribute
    case ATTR_WOF_TABLE_OVERRIDE_RC:
        l_attrSize = sizeof(ATTR_WOF_TABLE_OVERRIDE_RC_type);
        break;

    // Get size for ATTR_WOF_IO_START attribute
    case ATTR_WOF_IO_START:
        l_attrSize = sizeof(ATTR_WOF_IO_START_type);
        break;

    // Get size for ATTR_WOF_IO_STEP attribute
    case ATTR_WOF_IO_STEP:
        l_attrSize = sizeof(ATTR_WOF_IO_STEP_type);
        break;

    // Get size for ATTR_WOF_IO_COUNT attribute
    case ATTR_WOF_IO_COUNT:
        l_attrSize = sizeof(ATTR_WOF_IO_COUNT_type);
        break;

    // Get size for ATTR_VDN_VOLTAGE_MV attribute
    case ATTR_VDN_VOLTAGE_MV:
        l_attrSize = sizeof(ATTR_VDN_VOLTAGE_MV_type);
        break;

    // Get size for ATTR_WOF_TDP_IO_INDEX attribute
    case ATTR_WOF_TDP_IO_INDEX:
        l_attrSize = sizeof(ATTR_WOF_TDP_IO_INDEX_type);
        break;

    // Get size for ATTR_DEAD_CORE_MODE attribute
    case ATTR_DEAD_CORE_MODE:
        l_attrSize = sizeof(ATTR_DEAD_CORE_MODE_type);
        break;

    // Get size for ATTR_SAFE_MODE_THROTTLE_IDX attribute
    case ATTR_SAFE_MODE_THROTTLE_IDX:
        l_attrSize = sizeof(ATTR_SAFE_MODE_THROTTLE_IDX_type);
        break;

    // Get size for ATTR_PDW_TRACE_ENABLE attribute
    case ATTR_PDW_TRACE_ENABLE:
        l_attrSize = sizeof(ATTR_PDW_TRACE_ENABLE_type);
        break;

    // Get size for ATTR_MIN_PROC_POWER_PER_CHIP attribute
    case ATTR_MIN_PROC_POWER_PER_CHIP:
        l_attrSize = sizeof(ATTR_MIN_PROC_POWER_PER_CHIP_type);
        break;

    // Get size for ATTR_AVSBUS_VRM_FAIL_OVERRIDE attribute
    case ATTR_AVSBUS_VRM_FAIL_OVERRIDE:
        l_attrSize = sizeof(ATTR_AVSBUS_VRM_FAIL_OVERRIDE_type);
        break;

    // Get size for ATTR_OMI_SPREAD_SPECTRUM attribute
    case ATTR_OMI_SPREAD_SPECTRUM:
        l_attrSize = sizeof(ATTR_OMI_SPREAD_SPECTRUM_type);
        break;

    // Get size for ATTR_IOHS_SPREAD_SPECTRUM attribute
    case ATTR_IOHS_SPREAD_SPECTRUM:
        l_attrSize = sizeof(ATTR_IOHS_SPREAD_SPECTRUM_type);
        break;

    // Get size for ATTR_IOHS_MNFG_BAD_LANE_MAX attribute
    case ATTR_IOHS_MNFG_BAD_LANE_MAX:
        l_attrSize = sizeof(ATTR_IOHS_MNFG_BAD_LANE_MAX_type);
        break;

    // Get size for ATTR_IOHS_MNFG_BAD_LANE_DURATION attribute
    case ATTR_IOHS_MNFG_BAD_LANE_DURATION:
        l_attrSize = sizeof(ATTR_IOHS_MNFG_BAD_LANE_DURATION_type);
        break;

    // Get size for ATTR_VIO_SET_POINT_MV attribute
    case ATTR_VIO_SET_POINT_MV:
        l_attrSize = sizeof(ATTR_VIO_SET_POINT_MV_type);
        break;

    // Get size for ATTR_IOHS_MFG_BAD_LANE_VEC attribute
    case ATTR_IOHS_MFG_BAD_LANE_VEC:
        l_attrSize = sizeof(ATTR_IOHS_MFG_BAD_LANE_VEC_type);
        break;

    // Get size for ATTR_IOHS_MFG_BAD_LANE_VEC_VALID attribute
    case ATTR_IOHS_MFG_BAD_LANE_VEC_VALID:
        l_attrSize = sizeof(ATTR_IOHS_MFG_BAD_LANE_VEC_VALID_type);
        break;

    // Get size for ATTR_IO_IOHS_XTALK attribute
    case ATTR_IO_IOHS_XTALK:
        l_attrSize = sizeof(ATTR_IO_IOHS_XTALK_type);
        break;

    // Get size for ATTR_IO_IOHS_CHANNEL_LOSS attribute
    case ATTR_IO_IOHS_CHANNEL_LOSS:
        l_attrSize = sizeof(ATTR_IO_IOHS_CHANNEL_LOSS_type);
        break;

    // Get size for ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND attribute
    case ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND:
        l_attrSize = sizeof(ATTR_IO_IOHS_CHANNEL_LOSS_ISC1_WORKAROUND_type);
        break;

    // Get size for ATTR_IO_OMI_CHANNEL_LOSS attribute
    case ATTR_IO_OMI_CHANNEL_LOSS:
        l_attrSize = sizeof(ATTR_IO_OMI_CHANNEL_LOSS_type);
        break;

    // Get size for ATTR_IO_OMI_PRE1 attribute
    case ATTR_IO_OMI_PRE1:
        l_attrSize = sizeof(ATTR_IO_OMI_PRE1_type);
        break;

    // Get size for ATTR_IO_OMI_PRE2 attribute
    case ATTR_IO_OMI_PRE2:
        l_attrSize = sizeof(ATTR_IO_OMI_PRE2_type);
        break;

    // Get size for ATTR_IO_IOHS_PRE1 attribute
    case ATTR_IO_IOHS_PRE1:
        l_attrSize = sizeof(ATTR_IO_IOHS_PRE1_type);
        break;

    // Get size for ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND attribute
    case ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND:
        l_attrSize = sizeof(ATTR_IO_IOHS_PRE1_ISC1_WORKAROUND_type);
        break;

    // Get size for ATTR_IO_IOHS_PRE2 attribute
    case ATTR_IO_IOHS_PRE2:
        l_attrSize = sizeof(ATTR_IO_IOHS_PRE2_type);
        break;

    // Get size for ATTR_OMI_DL_GROUP_POS attribute
    case ATTR_OMI_DL_GROUP_POS:
        l_attrSize = sizeof(ATTR_OMI_DL_GROUP_POS_type);
        break;

    // Get size for ATTR_OMI_DL_NUM attribute
    case ATTR_OMI_DL_NUM:
        l_attrSize = sizeof(ATTR_OMI_DL_NUM_type);
        break;

    // Get size for ATTR_OCMB_COUNTER attribute
    case ATTR_OCMB_COUNTER:
        l_attrSize = sizeof(ATTR_OCMB_COUNTER_type);
        break;

    // Get size for ATTR_VIO_RAILS_NOT_POWERED attribute
    case ATTR_VIO_RAILS_NOT_POWERED:
        l_attrSize = sizeof(ATTR_VIO_RAILS_NOT_POWERED_type);
        break;

    // Get size for ATTR_SAVED_PB_PTL_FIR_MASK attribute
    case ATTR_SAVED_PB_PTL_FIR_MASK:
        l_attrSize = sizeof(ATTR_SAVED_PB_PTL_FIR_MASK_type);
        break;

    // Get size for ATTR_SAVED_DLP_FIR_MASK attribute
    case ATTR_SAVED_DLP_FIR_MASK:
        l_attrSize = sizeof(ATTR_SAVED_DLP_FIR_MASK_type);
        break;

    // Get size for ATTR_INTERPOSER_REV attribute
    case ATTR_INTERPOSER_REV:
        l_attrSize = sizeof(ATTR_INTERPOSER_REV_type);
        break;

    // Get size for ATTR_INTERPOSER_FEATURE_HW632898 attribute
    case ATTR_INTERPOSER_FEATURE_HW632898:
        l_attrSize = sizeof(ATTR_INTERPOSER_FEATURE_HW632898_type);
        break;

    // Get size for ATTR_PROC_PCIE_PHB_ACTIVE attribute
    case ATTR_PROC_PCIE_PHB_ACTIVE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PHB_ACTIVE_type);
        break;

    // Get size for ATTR_PROC_PCIE_LANE_REVERSAL attribute
    case ATTR_PROC_PCIE_LANE_REVERSAL:
        l_attrSize = sizeof(ATTR_PROC_PCIE_LANE_REVERSAL_type);
        break;

    // Get size for ATTR_PROC_PCIE_BAR_ENABLE attribute
    case ATTR_PROC_PCIE_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_PCIE_BAR_SIZE attribute
    case ATTR_PROC_PCIE_BAR_SIZE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_BAR_SIZE_type);
        break;

    // Get size for ATTR_PROC_PCIE_FW_VERSION_0 attribute
    case ATTR_PROC_PCIE_FW_VERSION_0:
        l_attrSize = sizeof(ATTR_PROC_PCIE_FW_VERSION_0_type);
        break;

    // Get size for ATTR_PROC_PCIE_FW_VERSION_1 attribute
    case ATTR_PROC_PCIE_FW_VERSION_1:
        l_attrSize = sizeof(ATTR_PROC_PCIE_FW_VERSION_1_type);
        break;

    // Get size for ATTR_SYS0_REFCLOCK_RCVR_TERM attribute
    case ATTR_SYS0_REFCLOCK_RCVR_TERM:
        l_attrSize = sizeof(ATTR_SYS0_REFCLOCK_RCVR_TERM_type);
        break;

    // Get size for ATTR_SYS1_REFCLOCK_RCVR_TERM attribute
    case ATTR_SYS1_REFCLOCK_RCVR_TERM:
        l_attrSize = sizeof(ATTR_SYS1_REFCLOCK_RCVR_TERM_type);
        break;

    // Get size for ATTR_PCI0_REFCLOCK_RCVR_TERM attribute
    case ATTR_PCI0_REFCLOCK_RCVR_TERM:
        l_attrSize = sizeof(ATTR_PCI0_REFCLOCK_RCVR_TERM_type);
        break;

    // Get size for ATTR_PCI1_REFCLOCK_RCVR_TERM attribute
    case ATTR_PCI1_REFCLOCK_RCVR_TERM:
        l_attrSize = sizeof(ATTR_PCI1_REFCLOCK_RCVR_TERM_type);
        break;

    // Get size for ATTR_SYS_CLK_NE_TERMINATION_SITE attribute
    case ATTR_SYS_CLK_NE_TERMINATION_SITE:
        l_attrSize = sizeof(ATTR_SYS_CLK_NE_TERMINATION_SITE_type);
        break;

    // Get size for ATTR_SYS_CLK_NE_TERMINATION_STRENGTH attribute
    case ATTR_SYS_CLK_NE_TERMINATION_STRENGTH:
        l_attrSize = sizeof(ATTR_SYS_CLK_NE_TERMINATION_STRENGTH_type);
        break;

    // Get size for ATTR_CP_REFCLOCK_SELECT attribute
    case ATTR_CP_REFCLOCK_SELECT:
        l_attrSize = sizeof(ATTR_CP_REFCLOCK_SELECT_type);
        break;

    // Get size for ATTR_CLOCK_MUX0A_RCS_PLL_INPUT attribute
    case ATTR_CLOCK_MUX0A_RCS_PLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX0A_RCS_PLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX0B_RCS_PLL_INPUT attribute
    case ATTR_CLOCK_MUX0B_RCS_PLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX0B_RCS_PLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX0C_RCS_PLL_INPUT attribute
    case ATTR_CLOCK_MUX0C_RCS_PLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX0C_RCS_PLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX0D_RCS_PLL_INPUT attribute
    case ATTR_CLOCK_MUX0D_RCS_PLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX0D_RCS_PLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX1_INPUT attribute
    case ATTR_CLOCK_MUX1_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX1_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX2A_INPUT attribute
    case ATTR_CLOCK_MUX2A_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX2A_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX2B_INPUT attribute
    case ATTR_CLOCK_MUX2B_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX2B_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX3_INPUT attribute
    case ATTR_CLOCK_MUX3_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX3_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX10_PAU_DPLL_INPUT attribute
    case ATTR_CLOCK_MUX10_PAU_DPLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX10_PAU_DPLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX11_NEST_DPLL_INPUT attribute
    case ATTR_CLOCK_MUX11_NEST_DPLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX11_NEST_DPLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT attribute
    case ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT attribute
    case ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT attribute
    case ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT attribute
    case ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX23_PCI_INPUT attribute
    case ATTR_CLOCK_MUX23_PCI_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX23_PCI_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_MUX_PCI_LCPLL_INPUT attribute
    case ATTR_CLOCK_MUX_PCI_LCPLL_INPUT:
        l_attrSize = sizeof(ATTR_CLOCK_MUX_PCI_LCPLL_INPUT_type);
        break;

    // Get size for ATTR_CLOCK_PLL_MUX_TOD attribute
    case ATTR_CLOCK_PLL_MUX_TOD:
        l_attrSize = sizeof(ATTR_CLOCK_PLL_MUX_TOD_type);
        break;

    // Get size for ATTR_HW543822_WAR_MODE attribute
    case ATTR_HW543822_WAR_MODE:
        l_attrSize = sizeof(ATTR_HW543822_WAR_MODE_type);
        break;

    // Get size for ATTR_DISABLE_TOD_SYNC_SPREAD attribute
    case ATTR_DISABLE_TOD_SYNC_SPREAD:
        l_attrSize = sizeof(ATTR_DISABLE_TOD_SYNC_SPREAD_type);
        break;

    // Get size for ATTR_PROC_FORCE_MC_PLL_BANDSEL attribute
    case ATTR_PROC_FORCE_MC_PLL_BANDSEL:
        l_attrSize = sizeof(ATTR_PROC_FORCE_MC_PLL_BANDSEL_type);
        break;

    // Get size for ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE attribute
    case ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE:
        l_attrSize = sizeof(ATTR_PROC_MC_PLL_BANDSEL_OVERRIDE_type);
        break;

    // Get size for ATTR_SYSTEM_IPL_PHASE attribute
    case ATTR_SYSTEM_IPL_PHASE:
        l_attrSize = sizeof(ATTR_SYSTEM_IPL_PHASE_type);
        break;

    // Get size for ATTR_PROC_CHIP_IPL_PHASE attribute
    case ATTR_PROC_CHIP_IPL_PHASE:
        l_attrSize = sizeof(ATTR_PROC_CHIP_IPL_PHASE_type);
        break;

    // Get size for ATTR_IPL_TYPE attribute
    case ATTR_IPL_TYPE:
        l_attrSize = sizeof(ATTR_IPL_TYPE_type);
        break;

    // Get size for ATTR_CONTAINED_IPL_TYPE attribute
    case ATTR_CONTAINED_IPL_TYPE:
        l_attrSize = sizeof(ATTR_CONTAINED_IPL_TYPE_type);
        break;

    // Get size for ATTR_CONTAINED_LOAD_PATH attribute
    case ATTR_CONTAINED_LOAD_PATH:
        l_attrSize = sizeof(ATTR_CONTAINED_LOAD_PATH_type);
        break;

    // Get size for ATTR_SBE_RUNTIME_MODE attribute
    case ATTR_SBE_RUNTIME_MODE:
        l_attrSize = sizeof(ATTR_SBE_RUNTIME_MODE_type);
        break;

    // Get size for ATTR_IS_SP_MODE attribute
    case ATTR_IS_SP_MODE:
        l_attrSize = sizeof(ATTR_IS_SP_MODE_type);
        break;

    // Get size for ATTR_DISABLE_HBBL_VECTORS attribute
    case ATTR_DISABLE_HBBL_VECTORS:
        l_attrSize = sizeof(ATTR_DISABLE_HBBL_VECTORS_type);
        break;

    // Get size for ATTR_BACKUP_SEEPROM_SELECT attribute
    case ATTR_BACKUP_SEEPROM_SELECT:
        l_attrSize = sizeof(ATTR_BACKUP_SEEPROM_SELECT_type);
        break;

    // Get size for ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT attribute
    case ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT:
        l_attrSize = sizeof(ATTR_BACKUP_MEASUREMENT_SEEPROM_SELECT_type);
        break;

    // Get size for ATTR_BOOT_FLAGS attribute
    case ATTR_BOOT_FLAGS:
        l_attrSize = sizeof(ATTR_BOOT_FLAGS_type);
        break;

    // Get size for ATTR_ALLOW_ATTR_OVERRIDES attribute
    case ATTR_ALLOW_ATTR_OVERRIDES:
        l_attrSize = sizeof(ATTR_ALLOW_ATTR_OVERRIDES_type);
        break;

    // Get size for ATTR_NO_XSCOM_ENFORCEMENT attribute
    case ATTR_NO_XSCOM_ENFORCEMENT:
        l_attrSize = sizeof(ATTR_NO_XSCOM_ENFORCEMENT_type);
        break;

    // Get size for ATTR_SECURITY_ENABLE attribute
    case ATTR_SECURITY_ENABLE:
        l_attrSize = sizeof(ATTR_SECURITY_ENABLE_type);
        break;

    // Get size for ATTR_SBE_SELECT_EX_POLICY attribute
    case ATTR_SBE_SELECT_EX_POLICY:
        l_attrSize = sizeof(ATTR_SBE_SELECT_EX_POLICY_type);
        break;

    // Get size for ATTR_MASTER_CORE attribute
    case ATTR_MASTER_CORE:
        l_attrSize = sizeof(ATTR_MASTER_CORE_type);
        break;

    // Get size for ATTR_ACTIVE_CORES_VEC attribute
    case ATTR_ACTIVE_CORES_VEC:
        l_attrSize = sizeof(ATTR_ACTIVE_CORES_VEC_type);
        break;

    // Get size for ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC attribute
    case ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC:
        l_attrSize = sizeof(ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC_type);
        break;

    // Get size for ATTR_BACKING_CACHES_VEC attribute
    case ATTR_BACKING_CACHES_VEC:
        l_attrSize = sizeof(ATTR_BACKING_CACHES_VEC_type);
        break;

    // Get size for ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC attribute
    case ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC:
        l_attrSize = sizeof(ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC_type);
        break;

    // Get size for ATTR_ACTIVE_CORES_NUM attribute
    case ATTR_ACTIVE_CORES_NUM:
        l_attrSize = sizeof(ATTR_ACTIVE_CORES_NUM_type);
        break;

    // Get size for ATTR_BACKING_CACHES_NUM attribute
    case ATTR_BACKING_CACHES_NUM:
        l_attrSize = sizeof(ATTR_BACKING_CACHES_NUM_type);
        break;

    // Get size for ATTR_CORE_LPAR_MODE_POLICY attribute
    case ATTR_CORE_LPAR_MODE_POLICY:
        l_attrSize = sizeof(ATTR_CORE_LPAR_MODE_POLICY_type);
        break;

    // Get size for ATTR_CORE_LPAR_MODE attribute
    case ATTR_CORE_LPAR_MODE:
        l_attrSize = sizeof(ATTR_CORE_LPAR_MODE_type);
        break;

    // Get size for ATTR_ZERO_CORE_CHIP attribute
    case ATTR_ZERO_CORE_CHIP:
        l_attrSize = sizeof(ATTR_ZERO_CORE_CHIP_type);
        break;

    // Get size for ATTR_HB_FALLBACK_CORES attribute
    case ATTR_HB_FALLBACK_CORES:
        l_attrSize = sizeof(ATTR_HB_FALLBACK_CORES_type);
        break;

    // Get size for ATTR_PVR_82_MODE attribute
    case ATTR_PVR_82_MODE:
        l_attrSize = sizeof(ATTR_PVR_82_MODE_type);
        break;

    // Get size for ATTR_IS_IOSCM attribute
    case ATTR_IS_IOSCM:
        l_attrSize = sizeof(ATTR_IS_IOSCM_type);
        break;

    // Get size for ATTR_PG_MVPD attribute
    case ATTR_PG_MVPD:
        l_attrSize = sizeof(ATTR_PG_MVPD_type);
        break;

    // Get size for ATTR_ECO_MODE attribute
    case ATTR_ECO_MODE:
        l_attrSize = sizeof(ATTR_ECO_MODE_type);
        break;

    // Get size for ATTR_PROC_SBE_MASTER_CHIP attribute
    case ATTR_PROC_SBE_MASTER_CHIP:
        l_attrSize = sizeof(ATTR_PROC_SBE_MASTER_CHIP_type);
        break;

    // Get size for ATTR_SECTOR_BUFFER_STRENGTH attribute
    case ATTR_SECTOR_BUFFER_STRENGTH:
        l_attrSize = sizeof(ATTR_SECTOR_BUFFER_STRENGTH_type);
        break;

    // Get size for ATTR_NDL_MESHCTRL_SETUP attribute
    case ATTR_NDL_MESHCTRL_SETUP:
        l_attrSize = sizeof(ATTR_NDL_MESHCTRL_SETUP_type);
        break;

    // Get size for ATTR_MC_PLL_BUCKET attribute
    case ATTR_MC_PLL_BUCKET:
        l_attrSize = sizeof(ATTR_MC_PLL_BUCKET_type);
        break;

    // Get size for ATTR_IOHS_PLL_BUCKET attribute
    case ATTR_IOHS_PLL_BUCKET:
        l_attrSize = sizeof(ATTR_IOHS_PLL_BUCKET_type);
        break;

    // Get size for ATTR_FILTER_PLL_BUCKET attribute
    case ATTR_FILTER_PLL_BUCKET:
        l_attrSize = sizeof(ATTR_FILTER_PLL_BUCKET_type);
        break;

    // Get size for ATTR_PCI_PLL_BUCKET attribute
    case ATTR_PCI_PLL_BUCKET:
        l_attrSize = sizeof(ATTR_PCI_PLL_BUCKET_type);
        break;

    // Get size for ATTR_CP_PLLTODFLT_BYPASS attribute
    case ATTR_CP_PLLTODFLT_BYPASS:
        l_attrSize = sizeof(ATTR_CP_PLLTODFLT_BYPASS_type);
        break;

    // Get size for ATTR_CP_PLLNESTFLT_BYPASS attribute
    case ATTR_CP_PLLNESTFLT_BYPASS:
        l_attrSize = sizeof(ATTR_CP_PLLNESTFLT_BYPASS_type);
        break;

    // Get size for ATTR_CP_PLLIOFLT_BYPASS attribute
    case ATTR_CP_PLLIOFLT_BYPASS:
        l_attrSize = sizeof(ATTR_CP_PLLIOFLT_BYPASS_type);
        break;

    // Get size for ATTR_CP_PLLIOSSFLT_BYPASS attribute
    case ATTR_CP_PLLIOSSFLT_BYPASS:
        l_attrSize = sizeof(ATTR_CP_PLLIOSSFLT_BYPASS_type);
        break;

    // Get size for ATTR_PAU_DPLL_BYPASS attribute
    case ATTR_PAU_DPLL_BYPASS:
        l_attrSize = sizeof(ATTR_PAU_DPLL_BYPASS_type);
        break;

    // Get size for ATTR_NEST_DPLL_BYPASS attribute
    case ATTR_NEST_DPLL_BYPASS:
        l_attrSize = sizeof(ATTR_NEST_DPLL_BYPASS_type);
        break;

    // Get size for ATTR_IO_TANK_PLL_BYPASS attribute
    case ATTR_IO_TANK_PLL_BYPASS:
        l_attrSize = sizeof(ATTR_IO_TANK_PLL_BYPASS_type);
        break;

    // Get size for ATTR_SKEWADJ_BYPASS attribute
    case ATTR_SKEWADJ_BYPASS:
        l_attrSize = sizeof(ATTR_SKEWADJ_BYPASS_type);
        break;

    // Get size for ATTR_SKEWADJ_CORE_PDLY_OVERRIDE attribute
    case ATTR_SKEWADJ_CORE_PDLY_OVERRIDE:
        l_attrSize = sizeof(ATTR_SKEWADJ_CORE_PDLY_OVERRIDE_type);
        break;

    // Get size for ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE attribute
    case ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE:
        l_attrSize = sizeof(ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE_type);
        break;

    // Get size for ATTR_DCADJ_BYPASS attribute
    case ATTR_DCADJ_BYPASS:
        l_attrSize = sizeof(ATTR_DCADJ_BYPASS_type);
        break;

    // Get size for ATTR_DCADJ_DCC_OVERRIDE attribute
    case ATTR_DCADJ_DCC_OVERRIDE:
        l_attrSize = sizeof(ATTR_DCADJ_DCC_OVERRIDE_type);
        break;

    // Get size for ATTR_DCADJ_TARGET_OVERRIDE attribute
    case ATTR_DCADJ_TARGET_OVERRIDE:
        l_attrSize = sizeof(ATTR_DCADJ_TARGET_OVERRIDE_type);
        break;

    // Get size for ATTR_ECID attribute
    case ATTR_ECID:
        l_attrSize = sizeof(ATTR_ECID_type);
        break;

    // Get size for ATTR_INTERPOSER_ECID attribute
    case ATTR_INTERPOSER_ECID:
        l_attrSize = sizeof(ATTR_INTERPOSER_ECID_type);
        break;

    // Get size for ATTR_LPC_CONSOLE_CNFG attribute
    case ATTR_LPC_CONSOLE_CNFG:
        l_attrSize = sizeof(ATTR_LPC_CONSOLE_CNFG_type);
        break;

    // Get size for ATTR_SBE_SYS_CONFIG attribute
    case ATTR_SBE_SYS_CONFIG:
        l_attrSize = sizeof(ATTR_SBE_SYS_CONFIG_type);
        break;

    // Get size for ATTR_EC_GARD attribute
    case ATTR_EC_GARD:
        l_attrSize = sizeof(ATTR_EC_GARD_type);
        break;

    // Get size for ATTR_CLOCKSTOP_ON_XSTOP attribute
    case ATTR_CLOCKSTOP_ON_XSTOP:
        l_attrSize = sizeof(ATTR_CLOCKSTOP_ON_XSTOP_type);
        break;

    // Get size for ATTR_XSTOP_ON_SPATTN attribute
    case ATTR_XSTOP_ON_SPATTN:
        l_attrSize = sizeof(ATTR_XSTOP_ON_SPATTN_type);
        break;

    // Get size for ATTR_BOOT_PAU_DPLL_BYPASS attribute
    case ATTR_BOOT_PAU_DPLL_BYPASS:
        l_attrSize = sizeof(ATTR_BOOT_PAU_DPLL_BYPASS_type);
        break;

    // Get size for ATTR_ORIG_FIR_SETTINGS_ACTION0 attribute
    case ATTR_ORIG_FIR_SETTINGS_ACTION0:
        l_attrSize = sizeof(ATTR_ORIG_FIR_SETTINGS_ACTION0_type);
        break;

    // Get size for ATTR_ORIG_FIR_SETTINGS_ACTION1 attribute
    case ATTR_ORIG_FIR_SETTINGS_ACTION1:
        l_attrSize = sizeof(ATTR_ORIG_FIR_SETTINGS_ACTION1_type);
        break;

    // Get size for ATTR_QME_HCODE_OFFSET attribute
    case ATTR_QME_HCODE_OFFSET:
        l_attrSize = sizeof(ATTR_QME_HCODE_OFFSET_type);
        break;

    // Get size for ATTR_QME_HCODE_BLOCK_COUNT attribute
    case ATTR_QME_HCODE_BLOCK_COUNT:
        l_attrSize = sizeof(ATTR_QME_HCODE_BLOCK_COUNT_type);
        break;

    // Get size for ATTR_FREQ_CP_REFCLOCK_KHZ attribute
    case ATTR_FREQ_CP_REFCLOCK_KHZ:
        l_attrSize = sizeof(ATTR_FREQ_CP_REFCLOCK_KHZ_type);
        break;

    // Get size for ATTR_FREQ_DPLL_REFCLOCK_KHZ attribute
    case ATTR_FREQ_DPLL_REFCLOCK_KHZ:
        l_attrSize = sizeof(ATTR_FREQ_DPLL_REFCLOCK_KHZ_type);
        break;

    // Get size for ATTR_FREQ_IO_REFCLOCK_KHZ attribute
    case ATTR_FREQ_IO_REFCLOCK_KHZ:
        l_attrSize = sizeof(ATTR_FREQ_IO_REFCLOCK_KHZ_type);
        break;

    // Get size for ATTR_FREQ_CORE_FLOOR_MHZ attribute
    case ATTR_FREQ_CORE_FLOOR_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_CORE_FLOOR_MHZ_type);
        break;

    // Get size for ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ attribute
    case ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_type);
        break;

    // Get size for ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ attribute
    case ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ:
        l_attrSize = sizeof(ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ_type);
        break;

    // Get size for ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ attribute
    case ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_type);
        break;

    // Get size for ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE attribute
    case ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE:
        l_attrSize = sizeof(ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_OVERRIDE_type);
        break;

    // Get size for ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE attribute
    case ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE:
        l_attrSize = sizeof(ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_OVERRIDE_type);
        break;

    // Get size for ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL attribute
    case ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL:
        l_attrSize = sizeof(ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ_ORIGINAL_type);
        break;

    // Get size for ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL attribute
    case ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL:
        l_attrSize = sizeof(ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ_ORIGINAL_type);
        break;

    // Get size for ATTR_FREQ_CORE_BOOT_MHZ attribute
    case ATTR_FREQ_CORE_BOOT_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_CORE_BOOT_MHZ_type);
        break;

    // Get size for ATTR_FREQ_MC_MHZ attribute
    case ATTR_FREQ_MC_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_MC_MHZ_type);
        break;

    // Get size for ATTR_PLL_BUCKET_BUILD_INDEX attribute
    case ATTR_PLL_BUCKET_BUILD_INDEX:
        l_attrSize = sizeof(ATTR_PLL_BUCKET_BUILD_INDEX_type);
        break;

    // Get size for ATTR_FREQ_OMI_MHZ attribute
    case ATTR_FREQ_OMI_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_OMI_MHZ_type);
        break;

    // Get size for ATTR_FREQ_IOHS_MHZ attribute
    case ATTR_FREQ_IOHS_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_IOHS_MHZ_type);
        break;

    // Get size for ATTR_FREQ_IOHS_LINK_MHZ attribute
    case ATTR_FREQ_IOHS_LINK_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_IOHS_LINK_MHZ_type);
        break;

    // Get size for ATTR_FREQ_PROC_IOHS_MHZ attribute
    case ATTR_FREQ_PROC_IOHS_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_PROC_IOHS_MHZ_type);
        break;

    // Get size for ATTR_FREQ_PAU_MHZ attribute
    case ATTR_FREQ_PAU_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_PAU_MHZ_type);
        break;

    // Get size for ATTR_INCREASED_PAU_FREQ attribute
    case ATTR_INCREASED_PAU_FREQ:
        l_attrSize = sizeof(ATTR_INCREASED_PAU_FREQ_type);
        break;

    // Get size for ATTR_FREQ_PCIE_MHZ attribute
    case ATTR_FREQ_PCIE_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_PCIE_MHZ_type);
        break;

    // Get size for ATTR_SPI_BUS_DIV_REF attribute
    case ATTR_SPI_BUS_DIV_REF:
        l_attrSize = sizeof(ATTR_SPI_BUS_DIV_REF_type);
        break;

    // Get size for ATTR_TPM_SPI_BUS_DIV attribute
    case ATTR_TPM_SPI_BUS_DIV:
        l_attrSize = sizeof(ATTR_TPM_SPI_BUS_DIV_type);
        break;

    // Get size for ATTR_MAX_ALLOWED_DIMM_FREQ attribute
    case ATTR_MAX_ALLOWED_DIMM_FREQ:
        l_attrSize = sizeof(ATTR_MAX_ALLOWED_DIMM_FREQ_type);
        break;

    // Get size for ATTR_REQUIRED_SYNCH_MODE attribute
    case ATTR_REQUIRED_SYNCH_MODE:
        l_attrSize = sizeof(ATTR_REQUIRED_SYNCH_MODE_type);
        break;

    // Get size for ATTR_NOMINAL_FREQ_MHZ attribute
    case ATTR_NOMINAL_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_NOMINAL_FREQ_MHZ_type);
        break;

    // Get size for ATTR_WOFBASE_FREQ_MHZ attribute
    case ATTR_WOFBASE_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_WOFBASE_FREQ_MHZ_type);
        break;

    // Get size for ATTR_FREQ_PAU_VPD_MHZ attribute
    case ATTR_FREQ_PAU_VPD_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_PAU_VPD_MHZ_type);
        break;

    // Get size for ATTR_SBE_BOOTLOADER_OFFSET attribute
    case ATTR_SBE_BOOTLOADER_OFFSET:
        l_attrSize = sizeof(ATTR_SBE_BOOTLOADER_OFFSET_type);
        break;

    // Get size for ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET attribute
    case ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET:
        l_attrSize = sizeof(ATTR_SBE_LOAD_BOOTLOADER_CHUNK_OFFSET_type);
        break;

    // Get size for ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE attribute
    case ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE:
        l_attrSize = sizeof(ATTR_SBE_LOAD_BOOTLOADER_HBBL_SIZE_type);
        break;

    // Get size for ATTR_SBE_MASTER_HRMOR_ADDRESS attribute
    case ATTR_SBE_MASTER_HRMOR_ADDRESS:
        l_attrSize = sizeof(ATTR_SBE_MASTER_HRMOR_ADDRESS_type);
        break;

    // Get size for ATTR_HOSTBOOT_HRMOR_OFFSET attribute
    case ATTR_HOSTBOOT_HRMOR_OFFSET:
        l_attrSize = sizeof(ATTR_HOSTBOOT_HRMOR_OFFSET_type);
        break;

    // Get size for ATTR_SBE_BOOT_SIDE attribute
    case ATTR_SBE_BOOT_SIDE:
        l_attrSize = sizeof(ATTR_SBE_BOOT_SIDE_type);
        break;

    // Get size for ATTR_LPC_CONSOLE_INITIALIZED attribute
    case ATTR_LPC_CONSOLE_INITIALIZED:
        l_attrSize = sizeof(ATTR_LPC_CONSOLE_INITIALIZED_type);
        break;

    // Get size for ATTR_SECURE_SETTINGS attribute
    case ATTR_SECURE_SETTINGS:
        l_attrSize = sizeof(ATTR_SECURE_SETTINGS_type);
        break;

    // Get size for ATTR_SBE_HBBL_EXCEPTION_INSTRUCT attribute
    case ATTR_SBE_HBBL_EXCEPTION_INSTRUCT:
        l_attrSize = sizeof(ATTR_SBE_HBBL_EXCEPTION_INSTRUCT_type);
        break;

    // Get size for ATTR_SBE_ADDR_KEY_STASH_ADDR attribute
    case ATTR_SBE_ADDR_KEY_STASH_ADDR:
        l_attrSize = sizeof(ATTR_SBE_ADDR_KEY_STASH_ADDR_type);
        break;

    // Get size for ATTR_NUM_KEY_ADDR_PAIR attribute
    case ATTR_NUM_KEY_ADDR_PAIR:
        l_attrSize = sizeof(ATTR_NUM_KEY_ADDR_PAIR_type);
        break;

    // Get size for ATTR_SBE_MEASUREMENT_SEEPROM_VERSION attribute
    case ATTR_SBE_MEASUREMENT_SEEPROM_VERSION:
        l_attrSize = sizeof(ATTR_SBE_MEASUREMENT_SEEPROM_VERSION_type);
        break;

    // Get size for ATTR_SBE_HW_KEY_HASH_ADDR attribute
    case ATTR_SBE_HW_KEY_HASH_ADDR:
        l_attrSize = sizeof(ATTR_SBE_HW_KEY_HASH_ADDR_type);
        break;

    // Get size for ATTR_SBE_MINIMUM_SECURE_VERSION attribute
    case ATTR_SBE_MINIMUM_SECURE_VERSION:
        l_attrSize = sizeof(ATTR_SBE_MINIMUM_SECURE_VERSION_type);
        break;

    // Get size for ATTR_SBE_SECURE_BOOT_MODE attribute
    case ATTR_SBE_SECURE_BOOT_MODE:
        l_attrSize = sizeof(ATTR_SBE_SECURE_BOOT_MODE_type);
        break;

    // Get size for ATTR_SBE_IMAGE_MINIMUM_VALID_ECS attribute
    case ATTR_SBE_IMAGE_MINIMUM_VALID_ECS:
        l_attrSize = sizeof(ATTR_SBE_IMAGE_MINIMUM_VALID_ECS_type);
        break;

    // Get size for ATTR_MAX_SBE_SEEPROM_SIZE attribute
    case ATTR_MAX_SBE_SEEPROM_SIZE:
        l_attrSize = sizeof(ATTR_MAX_SBE_SEEPROM_SIZE_type);
        break;

    // Get size for ATTR_SBE_CUST_FORCE_MVPD_ONLY attribute
    case ATTR_SBE_CUST_FORCE_MVPD_ONLY:
        l_attrSize = sizeof(ATTR_SBE_CUST_FORCE_MVPD_ONLY_type);
        break;

    // Get size for ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS attribute
    case ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS:
        l_attrSize = sizeof(ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS_type);
        break;

    // Get size for ATTR_PROC_ENABLE_DL_TMPL_1 attribute
    case ATTR_PROC_ENABLE_DL_TMPL_1:
        l_attrSize = sizeof(ATTR_PROC_ENABLE_DL_TMPL_1_type);
        break;

    // Get size for ATTR_PROC_ENABLE_DL_TMPL_4 attribute
    case ATTR_PROC_ENABLE_DL_TMPL_4:
        l_attrSize = sizeof(ATTR_PROC_ENABLE_DL_TMPL_4_type);
        break;

    // Get size for ATTR_PROC_ENABLE_DL_TMPL_7 attribute
    case ATTR_PROC_ENABLE_DL_TMPL_7:
        l_attrSize = sizeof(ATTR_PROC_ENABLE_DL_TMPL_7_type);
        break;

    // Get size for ATTR_PROC_ENABLE_DL_TMPL_A attribute
    case ATTR_PROC_ENABLE_DL_TMPL_A:
        l_attrSize = sizeof(ATTR_PROC_ENABLE_DL_TMPL_A_type);
        break;

    // Get size for ATTR_PROC_TMPL_0_PACING attribute
    case ATTR_PROC_TMPL_0_PACING:
        l_attrSize = sizeof(ATTR_PROC_TMPL_0_PACING_type);
        break;

    // Get size for ATTR_PROC_TMPL_1_PACING attribute
    case ATTR_PROC_TMPL_1_PACING:
        l_attrSize = sizeof(ATTR_PROC_TMPL_1_PACING_type);
        break;

    // Get size for ATTR_PROC_TMPL_4_PACING attribute
    case ATTR_PROC_TMPL_4_PACING:
        l_attrSize = sizeof(ATTR_PROC_TMPL_4_PACING_type);
        break;

    // Get size for ATTR_PROC_TMPL_7_PACING attribute
    case ATTR_PROC_TMPL_7_PACING:
        l_attrSize = sizeof(ATTR_PROC_TMPL_7_PACING_type);
        break;

    // Get size for ATTR_PROC_TMPL_A_PACING attribute
    case ATTR_PROC_TMPL_A_PACING:
        l_attrSize = sizeof(ATTR_PROC_TMPL_A_PACING_type);
        break;

    // Get size for ATTR_SYS_DISABLE_MCU_TIMEOUTS attribute
    case ATTR_SYS_DISABLE_MCU_TIMEOUTS:
        l_attrSize = sizeof(ATTR_SYS_DISABLE_MCU_TIMEOUTS_type);
        break;

    // Get size for ATTR_SYS_DISABLE_HWFM attribute
    case ATTR_SYS_DISABLE_HWFM:
        l_attrSize = sizeof(ATTR_SYS_DISABLE_HWFM_type);
        break;

    // Get size for ATTR_SYS_ENABLE_MC_HW520600_X4CTR attribute
    case ATTR_SYS_ENABLE_MC_HW520600_X4CTR:
        l_attrSize = sizeof(ATTR_SYS_ENABLE_MC_HW520600_X4CTR_type);
        break;

    // Get size for ATTR_PROC_OMI_OC_MAJOR_VER attribute
    case ATTR_PROC_OMI_OC_MAJOR_VER:
        l_attrSize = sizeof(ATTR_PROC_OMI_OC_MAJOR_VER_type);
        break;

    // Get size for ATTR_PROC_OMI_OC_MINOR_VER attribute
    case ATTR_PROC_OMI_OC_MINOR_VER:
        l_attrSize = sizeof(ATTR_PROC_OMI_OC_MINOR_VER_type);
        break;

    // Get size for ATTR_OMI_CHANNEL_FAIL_ACTION attribute
    case ATTR_OMI_CHANNEL_FAIL_ACTION:
        l_attrSize = sizeof(ATTR_OMI_CHANNEL_FAIL_ACTION_type);
        break;

    // Get size for ATTR_MFG_SCREEN_OMI_CRC_ALLOWED attribute
    case ATTR_MFG_SCREEN_OMI_CRC_ALLOWED:
        l_attrSize = sizeof(ATTR_MFG_SCREEN_OMI_CRC_ALLOWED_type);
        break;

    // Get size for ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED attribute
    case ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED:
        l_attrSize = sizeof(ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED_type);
        break;

    // Get size for ATTR_MSS_MNFG_EDPL_TIME attribute
    case ATTR_MSS_MNFG_EDPL_TIME:
        l_attrSize = sizeof(ATTR_MSS_MNFG_EDPL_TIME_type);
        break;

    // Get size for ATTR_MSS_MNFG_EDPL_THRESHOLD attribute
    case ATTR_MSS_MNFG_EDPL_THRESHOLD:
        l_attrSize = sizeof(ATTR_MSS_MNFG_EDPL_THRESHOLD_type);
        break;

    // Get size for ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_FSP_BAR_ENABLE attribute
    case ATTR_PROC_FSP_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_FSP_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_FSP_BAR_SIZE attribute
    case ATTR_PROC_FSP_BAR_SIZE:
        l_attrSize = sizeof(ATTR_PROC_FSP_BAR_SIZE_type);
        break;

    // Get size for ATTR_PROC_FSP_MMIO_MASK_SIZE attribute
    case ATTR_PROC_FSP_MMIO_MASK_SIZE:
        l_attrSize = sizeof(ATTR_PROC_FSP_MMIO_MASK_SIZE_type);
        break;

    // Get size for ATTR_PROC_PAU_MMIO_BAR_ENABLE attribute
    case ATTR_PROC_PAU_MMIO_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_PAU_MMIO_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_PAU_MMIO_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_PSI_BRIDGE_BAR_ENABLE attribute
    case ATTR_PROC_PSI_BRIDGE_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_PSI_BRIDGE_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_NX_RNG_BAR_ENABLE attribute
    case ATTR_PROC_NX_RNG_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_NX_RNG_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_NX_RNG_FAILED_INT_ENABLE attribute
    case ATTR_PROC_NX_RNG_FAILED_INT_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_NX_RNG_FAILED_INT_ENABLE_type);
        break;

    // Get size for ATTR_PROC_NX_RNG_FAILED_INT_ADDR attribute
    case ATTR_PROC_NX_RNG_FAILED_INT_ADDR:
        l_attrSize = sizeof(ATTR_PROC_NX_RNG_FAILED_INT_ADDR_type);
        break;

    // Get size for ATTR_PROC_NHTM_BAR_BASE_ADDR attribute
    case ATTR_PROC_NHTM_BAR_BASE_ADDR:
        l_attrSize = sizeof(ATTR_PROC_NHTM_BAR_BASE_ADDR_type);
        break;

    // Get size for ATTR_PROC_NHTM_BAR_SIZE attribute
    case ATTR_PROC_NHTM_BAR_SIZE:
        l_attrSize = sizeof(ATTR_PROC_NHTM_BAR_SIZE_type);
        break;

    // Get size for ATTR_PROC_CHTM_BAR_BASE_ADDR attribute
    case ATTR_PROC_CHTM_BAR_BASE_ADDR:
        l_attrSize = sizeof(ATTR_PROC_CHTM_BAR_BASE_ADDR_type);
        break;

    // Get size for ATTR_PROC_CHTM_BAR_SIZES attribute
    case ATTR_PROC_CHTM_BAR_SIZES:
        l_attrSize = sizeof(ATTR_PROC_CHTM_BAR_SIZES_type);
        break;

    // Get size for ATTR_PROC_SMF_BAR_BASE_ADDR attribute
    case ATTR_PROC_SMF_BAR_BASE_ADDR:
        l_attrSize = sizeof(ATTR_PROC_SMF_BAR_BASE_ADDR_type);
        break;

    // Get size for ATTR_PROC_SMF_BAR_SIZE attribute
    case ATTR_PROC_SMF_BAR_SIZE:
        l_attrSize = sizeof(ATTR_PROC_SMF_BAR_SIZE_type);
        break;

    // Get size for ATTR_SMF_CONFIG attribute
    case ATTR_SMF_CONFIG:
        l_attrSize = sizeof(ATTR_SMF_CONFIG_type);
        break;

    // Get size for ATTR_PROC_OCC_SANDBOX_BASE_ADDR attribute
    case ATTR_PROC_OCC_SANDBOX_BASE_ADDR:
        l_attrSize = sizeof(ATTR_PROC_OCC_SANDBOX_BASE_ADDR_type);
        break;

    // Get size for ATTR_PROC_OCC_SANDBOX_SIZE attribute
    case ATTR_PROC_OCC_SANDBOX_SIZE:
        l_attrSize = sizeof(ATTR_PROC_OCC_SANDBOX_SIZE_type);
        break;

    // Get size for ATTR_PROC_INT_IC_BAR_ENABLE attribute
    case ATTR_PROC_INT_IC_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_INT_IC_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_INT_IC_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_INT_IC_BAR_PAGE_SIZE attribute
    case ATTR_PROC_INT_IC_BAR_PAGE_SIZE:
        l_attrSize = sizeof(ATTR_PROC_INT_IC_BAR_PAGE_SIZE_type);
        break;

    // Get size for ATTR_PROC_INT_TM_BAR_ENABLE attribute
    case ATTR_PROC_INT_TM_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_INT_TM_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_INT_TM_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_INT_TM_BAR_PAGE_SIZE attribute
    case ATTR_PROC_INT_TM_BAR_PAGE_SIZE:
        l_attrSize = sizeof(ATTR_PROC_INT_TM_BAR_PAGE_SIZE_type);
        break;

    // Get size for ATTR_PROC_INT_NVPG_BAR_ENABLE attribute
    case ATTR_PROC_INT_NVPG_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_INT_NVPG_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE attribute
    case ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE:
        l_attrSize = sizeof(ATTR_PROC_INT_NVPG_BAR_PAGE_SIZE_type);
        break;

    // Get size for ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_INT_NVPG_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR attribute
    case ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR:
        l_attrSize = sizeof(ATTR_PROC_INT_NVPG_BAR_SET_DIVISION_SELECTOR_type);
        break;

    // Get size for ATTR_PROC_INT_NVPG_BAR_RANGE attribute
    case ATTR_PROC_INT_NVPG_BAR_RANGE:
        l_attrSize = sizeof(ATTR_PROC_INT_NVPG_BAR_RANGE_type);
        break;

    // Get size for ATTR_PROC_INT_NVC_BAR_ENABLE attribute
    case ATTR_PROC_INT_NVC_BAR_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_INT_NVC_BAR_ENABLE_type);
        break;

    // Get size for ATTR_PROC_INT_NVC_BAR_PAGE_SIZE attribute
    case ATTR_PROC_INT_NVC_BAR_PAGE_SIZE:
        l_attrSize = sizeof(ATTR_PROC_INT_NVC_BAR_PAGE_SIZE_type);
        break;

    // Get size for ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET attribute
    case ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_PROC_INT_NVC_BAR_BASE_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR attribute
    case ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR:
        l_attrSize = sizeof(ATTR_PROC_INT_NVC_BAR_SET_DIVISION_SELECTOR_type);
        break;

    // Get size for ATTR_PROC_INT_NVC_BAR_RANGE attribute
    case ATTR_PROC_INT_NVC_BAR_RANGE:
        l_attrSize = sizeof(ATTR_PROC_INT_NVC_BAR_RANGE_type);
        break;

    // Get size for ATTR_I2C_DEV_TYPE attribute
    case ATTR_I2C_DEV_TYPE:
        l_attrSize = sizeof(ATTR_I2C_DEV_TYPE_type);
        break;

    // Get size for ATTR_I2C_SUB_POS attribute
    case ATTR_I2C_SUB_POS:
        l_attrSize = sizeof(ATTR_I2C_SUB_POS_type);
        break;

    // Get size for ATTR_FAPI_POS attribute
    case ATTR_FAPI_POS:
        l_attrSize = sizeof(ATTR_FAPI_POS_type);
        break;

    // Get size for ATTR_BUS_POS attribute
    case ATTR_BUS_POS:
        l_attrSize = sizeof(ATTR_BUS_POS_type);
        break;

    // Get size for ATTR_IS_SIMULATION attribute
    case ATTR_IS_SIMULATION:
        l_attrSize = sizeof(ATTR_IS_SIMULATION_type);
        break;

    // Get size for ATTR_EXECUTION_PLATFORM attribute
    case ATTR_EXECUTION_PLATFORM:
        l_attrSize = sizeof(ATTR_EXECUTION_PLATFORM_type);
        break;

    // Get size for ATTR_MFG_FLAGS attribute
    case ATTR_MFG_FLAGS:
        l_attrSize = sizeof(ATTR_MFG_FLAGS_type);
        break;

    // Get size for ATTR_RECONFIGURE_LOOP attribute
    case ATTR_RECONFIGURE_LOOP:
        l_attrSize = sizeof(ATTR_RECONFIGURE_LOOP_type);
        break;

    // Get size for ATTR_MINI_EC attribute
    case ATTR_MINI_EC:
        l_attrSize = sizeof(ATTR_MINI_EC_type);
        break;

    // Get size for ATTR_SCAN_CHIPLET_OVERRIDE attribute
    case ATTR_SCAN_CHIPLET_OVERRIDE:
        l_attrSize = sizeof(ATTR_SCAN_CHIPLET_OVERRIDE_type);
        break;

    // Get size for ATTR_SLOW_MEM_POOL_TEST attribute
    case ATTR_SLOW_MEM_POOL_TEST:
        l_attrSize = sizeof(ATTR_SLOW_MEM_POOL_TEST_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL attribute
    case ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_OMI_CFG_ENDIAN_CTRL_type);
        break;

    // Get size for ATTR_MSS_OCMB_HALF_DIMM_MODE attribute
    case ATTR_MSS_OCMB_HALF_DIMM_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_HALF_DIMM_MODE_type);
        break;

    // Get size for ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE attribute
    case ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE_type);
        break;

    // Get size for ATTR_MEM_DRAM_CWL attribute
    case ATTR_MEM_DRAM_CWL:
        l_attrSize = sizeof(ATTR_MEM_DRAM_CWL_type);
        break;

    // Get size for ATTR_MEM_RDIMM_BUFFER_DELAY attribute
    case ATTR_MEM_RDIMM_BUFFER_DELAY:
        l_attrSize = sizeof(ATTR_MEM_RDIMM_BUFFER_DELAY_type);
        break;

    // Get size for ATTR_MEM_REORDER_QUEUE_SETTING attribute
    case ATTR_MEM_REORDER_QUEUE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_REORDER_QUEUE_SETTING_type);
        break;

    // Get size for ATTR_MEM_THERMAL_INIT_COMPLETE attribute
    case ATTR_MEM_THERMAL_INIT_COMPLETE:
        l_attrSize = sizeof(ATTR_MEM_THERMAL_INIT_COMPLETE_type);
        break;

    // Get size for ATTR_MEM_2N_MODE attribute
    case ATTR_MEM_2N_MODE:
        l_attrSize = sizeof(ATTR_MEM_2N_MODE_type);
        break;

    // Get size for ATTR_MEM_VPD_DQ_MAP attribute
    case ATTR_MEM_VPD_DQ_MAP:
        l_attrSize = sizeof(ATTR_MEM_VPD_DQ_MAP_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC0F attribute
    case ATTR_MEM_DIMM_DDR4_F0RC0F:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC0F_type);
        break;

    // Get size for ATTR_MEM_CS_CMD_LATENCY attribute
    case ATTR_MEM_CS_CMD_LATENCY:
        l_attrSize = sizeof(ATTR_MEM_CS_CMD_LATENCY_type);
        break;

    // Get size for ATTR_MEM_CA_PARITY_LATENCY attribute
    case ATTR_MEM_CA_PARITY_LATENCY:
        l_attrSize = sizeof(ATTR_MEM_CA_PARITY_LATENCY_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC02 attribute
    case ATTR_MEM_DIMM_DDR4_F0RC02:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC02_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC03 attribute
    case ATTR_MEM_DIMM_DDR4_F0RC03:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC03_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC04 attribute
    case ATTR_MEM_DIMM_DDR4_F0RC04:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC04_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC05 attribute
    case ATTR_MEM_DIMM_DDR4_F0RC05:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC05_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC0B attribute
    case ATTR_MEM_DIMM_DDR4_F0RC0B:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC0B_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC1X attribute
    case ATTR_MEM_DIMM_DDR4_F0RC1X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC1X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F0RC7X attribute
    case ATTR_MEM_DIMM_DDR4_F0RC7X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F0RC7X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC00 attribute
    case ATTR_MEM_DIMM_DDR4_F1RC00:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC00_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC02 attribute
    case ATTR_MEM_DIMM_DDR4_F1RC02:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC02_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC03 attribute
    case ATTR_MEM_DIMM_DDR4_F1RC03:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC03_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC04 attribute
    case ATTR_MEM_DIMM_DDR4_F1RC04:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC04_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC05 attribute
    case ATTR_MEM_DIMM_DDR4_F1RC05:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC05_type);
        break;

    // Get size for ATTR_MEM_DIMM_POS_METADATA attribute
    case ATTR_MEM_DIMM_POS_METADATA:
        l_attrSize = sizeof(ATTR_MEM_DIMM_POS_METADATA_type);
        break;

    // Get size for ATTR_MEM_DRAM_GEN_METADATA attribute
    case ATTR_MEM_DRAM_GEN_METADATA:
        l_attrSize = sizeof(ATTR_MEM_DRAM_GEN_METADATA_type);
        break;

    // Get size for ATTR_MEM_DIMM_TYPE_METADATA attribute
    case ATTR_MEM_DIMM_TYPE_METADATA:
        l_attrSize = sizeof(ATTR_MEM_DIMM_TYPE_METADATA_type);
        break;

    // Get size for ATTR_MSS_OMI_EDPL_DISABLE attribute
    case ATTR_MSS_OMI_EDPL_DISABLE:
        l_attrSize = sizeof(ATTR_MSS_OMI_EDPL_DISABLE_type);
        break;

    // Get size for ATTR_MEM_OVERRIDE_FREQ_LIMITATION attribute
    case ATTR_MEM_OVERRIDE_FREQ_LIMITATION:
        l_attrSize = sizeof(ATTR_MEM_OVERRIDE_FREQ_LIMITATION_type);
        break;

    // Get size for ATTR_MEM_IGNORE_PLUG_RULES attribute
    case ATTR_MEM_IGNORE_PLUG_RULES:
        l_attrSize = sizeof(ATTR_MEM_IGNORE_PLUG_RULES_type);
        break;

    // Get size for ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX attribute
    case ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX:
        l_attrSize = sizeof(ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX_type);
        break;

    // Get size for ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX attribute
    case ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX:
        l_attrSize = sizeof(ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX_type);
        break;

    // Get size for ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK attribute
    case ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK:
        l_attrSize = sizeof(ATTR_MEM_IGNORE_PLUG_RULES_SPD_REV_CHECK_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION attribute
    case ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_MIN_SUPPORTED_SPD_REVISION_type);
        break;

    // Get size for ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED attribute
    case ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED:
        l_attrSize = sizeof(ATTR_MEM_DDR5_PLUG_RULES_SPD_REV_TESTED_type);
        break;

    // Get size for ATTR_OMI_X4_DEGRADE_ACTION attribute
    case ATTR_OMI_X4_DEGRADE_ACTION:
        l_attrSize = sizeof(ATTR_OMI_X4_DEGRADE_ACTION_type);
        break;

    // Get size for ATTR_OMI_CRC_DEBUG attribute
    case ATTR_OMI_CRC_DEBUG:
        l_attrSize = sizeof(ATTR_OMI_CRC_DEBUG_type);
        break;

    // Get size for ATTR_ENABLE_FIR_UNMASKING attribute
    case ATTR_ENABLE_FIR_UNMASKING:
        l_attrSize = sizeof(ATTR_ENABLE_FIR_UNMASKING_type);
        break;

    // Get size for ATTR_MSS_IS_APOLLO attribute
    case ATTR_MSS_IS_APOLLO:
        l_attrSize = sizeof(ATTR_MSS_IS_APOLLO_type);
        break;

    // Get size for ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST attribute
    case ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST:
        l_attrSize = sizeof(ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_type);
        break;

    // Get size for ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR attribute
    case ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR:
        l_attrSize = sizeof(ATTR_MSS_POST_MEMDIAGS_READ_SUBTEST_FAIL_BEHAVIOR_type);
        break;

    // Get size for ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL attribute
    case ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL:
        l_attrSize = sizeof(ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL_type);
        break;

    // Get size for ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE attribute
    case ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_CHECKSTOP_OBJ_HANDLE_type);
        break;

    // Get size for ATTR_MSS_OCMB_RECOV_OBJ_HANDLE attribute
    case ATTR_MSS_OCMB_RECOV_OBJ_HANDLE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_RECOV_OBJ_HANDLE_type);
        break;

    // Get size for ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE attribute
    case ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_SPECATTN_OBJ_HANDLE_type);
        break;

    // Get size for ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE attribute
    case ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_APPINTR_OBJ_HANDLE_type);
        break;

    // Get size for ATTR_MEM_DRAM_ADDRESS_MIRRORING attribute
    case ATTR_MEM_DRAM_ADDRESS_MIRRORING:
        l_attrSize = sizeof(ATTR_MEM_DRAM_ADDRESS_MIRRORING_type);
        break;

    // Get size for ATTR_ECS_ERROR_COUNT_THRESHOLD attribute
    case ATTR_ECS_ERROR_COUNT_THRESHOLD:
        l_attrSize = sizeof(ATTR_ECS_ERROR_COUNT_THRESHOLD_type);
        break;

    // Get size for ATTR_MSS_CONFIG_FREQ_LIMIT attribute
    case ATTR_MSS_CONFIG_FREQ_LIMIT:
        l_attrSize = sizeof(ATTR_MSS_CONFIG_FREQ_LIMIT_type);
        break;

    // Get size for ATTR_MSS_OMI_VDD_UPLIFT_APPLIED attribute
    case ATTR_MSS_OMI_VDD_UPLIFT_APPLIED:
        l_attrSize = sizeof(ATTR_MSS_OMI_VDD_UPLIFT_APPLIED_type);
        break;

    // Get size for ATTR_MEM_SI_SIGNATURE_HASH attribute
    case ATTR_MEM_SI_SIGNATURE_HASH:
        l_attrSize = sizeof(ATTR_MEM_SI_SIGNATURE_HASH_type);
        break;

    // Get size for ATTR_MEM_SI_DIMM_RCD_IBT_CA attribute
    case ATTR_MEM_SI_DIMM_RCD_IBT_CA:
        l_attrSize = sizeof(ATTR_MEM_SI_DIMM_RCD_IBT_CA_type);
        break;

    // Get size for ATTR_MEM_SI_DIMM_RCD_IBT_CKE attribute
    case ATTR_MEM_SI_DIMM_RCD_IBT_CKE:
        l_attrSize = sizeof(ATTR_MEM_SI_DIMM_RCD_IBT_CKE_type);
        break;

    // Get size for ATTR_MEM_SI_DIMM_RCD_IBT_CS attribute
    case ATTR_MEM_SI_DIMM_RCD_IBT_CS:
        l_attrSize = sizeof(ATTR_MEM_SI_DIMM_RCD_IBT_CS_type);
        break;

    // Get size for ATTR_MEM_SI_DIMM_RCD_IBT_ODT attribute
    case ATTR_MEM_SI_DIMM_RCD_IBT_ODT:
        l_attrSize = sizeof(ATTR_MEM_SI_DIMM_RCD_IBT_ODT_type);
        break;

    // Get size for ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS attribute
    case ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS:
        l_attrSize = sizeof(ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS_type);
        break;

    // Get size for ATTR_MEM_SI_DRAM_PREAMBLE attribute
    case ATTR_MEM_SI_DRAM_PREAMBLE:
        l_attrSize = sizeof(ATTR_MEM_SI_DRAM_PREAMBLE_type);
        break;

    // Get size for ATTR_MEM_SI_DRAM_RTT_NOM attribute
    case ATTR_MEM_SI_DRAM_RTT_NOM:
        l_attrSize = sizeof(ATTR_MEM_SI_DRAM_RTT_NOM_type);
        break;

    // Get size for ATTR_MEM_SI_DRAM_RTT_PARK attribute
    case ATTR_MEM_SI_DRAM_RTT_PARK:
        l_attrSize = sizeof(ATTR_MEM_SI_DRAM_RTT_PARK_type);
        break;

    // Get size for ATTR_MEM_SI_DRAM_RTT_WR attribute
    case ATTR_MEM_SI_DRAM_RTT_WR:
        l_attrSize = sizeof(ATTR_MEM_SI_DRAM_RTT_WR_type);
        break;

    // Get size for ATTR_MEM_SI_GEARDOWN_MODE attribute
    case ATTR_MEM_SI_GEARDOWN_MODE:
        l_attrSize = sizeof(ATTR_MEM_SI_GEARDOWN_MODE_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_DQ_DQS attribute
    case ATTR_MEM_SI_MC_DRV_DQ_DQS:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_DQ_DQS_type);
        break;

    // Get size for ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS attribute
    case ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS attribute
    case ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS_type);
        break;

    // Get size for ATTR_MEM_SI_PHY_EQUALIZATION attribute
    case ATTR_MEM_SI_PHY_EQUALIZATION:
        l_attrSize = sizeof(ATTR_MEM_SI_PHY_EQUALIZATION_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_IMP_CLK attribute
    case ATTR_MEM_SI_MC_DRV_IMP_CLK:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_IMP_CLK_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR attribute
    case ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_IMP_CNTL attribute
    case ATTR_MEM_SI_MC_DRV_IMP_CNTL:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_IMP_CNTL_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_IMP_CSCID attribute
    case ATTR_MEM_SI_MC_DRV_IMP_CSCID:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_IMP_CSCID_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN attribute
    case ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP attribute
    case ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK attribute
    case ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR attribute
    case ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL attribute
    case ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID attribute
    case ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID_type);
        break;

    // Get size for ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS attribute
    case ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS_type);
        break;

    // Get size for ATTR_MEM_SI_MC_RCV_IMP_ALERT_N attribute
    case ATTR_MEM_SI_MC_RCV_IMP_ALERT_N:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_RCV_IMP_ALERT_N_type);
        break;

    // Get size for ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS attribute
    case ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS:
        l_attrSize = sizeof(ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS_type);
        break;

    // Get size for ATTR_MEM_SI_ODT_RD attribute
    case ATTR_MEM_SI_ODT_RD:
        l_attrSize = sizeof(ATTR_MEM_SI_ODT_RD_type);
        break;

    // Get size for ATTR_MEM_SI_ODT_WR attribute
    case ATTR_MEM_SI_ODT_WR:
        l_attrSize = sizeof(ATTR_MEM_SI_ODT_WR_type);
        break;

    // Get size for ATTR_MEM_SI_VREF_DRAM_WR attribute
    case ATTR_MEM_SI_VREF_DRAM_WR:
        l_attrSize = sizeof(ATTR_MEM_SI_VREF_DRAM_WR_type);
        break;

    // Get size for ATTR_MEM_SI_VREF_MC_RD attribute
    case ATTR_MEM_SI_VREF_MC_RD:
        l_attrSize = sizeof(ATTR_MEM_SI_VREF_MC_RD_type);
        break;

    // Get size for ATTR_MEM_SI_WINDAGE_RD_CTR attribute
    case ATTR_MEM_SI_WINDAGE_RD_CTR:
        l_attrSize = sizeof(ATTR_MEM_SI_WINDAGE_RD_CTR_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC1X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC1X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC1X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC2X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC2X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC2X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC3X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC3X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC3X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC4X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC4X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC4X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC5X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC5X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC5X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC6X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC6X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC6X_type);
        break;

    // Get size for ATTR_MEM_DIMM_DDR4_F1RC7X attribute
    case ATTR_MEM_DIMM_DDR4_F1RC7X:
        l_attrSize = sizeof(ATTR_MEM_DIMM_DDR4_F1RC7X_type);
        break;

    // Get size for ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP attribute
    case ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP:
        l_attrSize = sizeof(ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP_type);
        break;

    // Get size for ATTR_MEM_BURST_LENGTH attribute
    case ATTR_MEM_BURST_LENGTH:
        l_attrSize = sizeof(ATTR_MEM_BURST_LENGTH_type);
        break;

    // Get size for ATTR_MEM_MPSM attribute
    case ATTR_MEM_MPSM:
        l_attrSize = sizeof(ATTR_MEM_MPSM_type);
        break;

    // Get size for ATTR_MEM_CS_ASSERT_IN_MPC attribute
    case ATTR_MEM_CS_ASSERT_IN_MPC:
        l_attrSize = sizeof(ATTR_MEM_CS_ASSERT_IN_MPC_type);
        break;

    // Get size for ATTR_MEM_DEVICE15_MPSM attribute
    case ATTR_MEM_DEVICE15_MPSM:
        l_attrSize = sizeof(ATTR_MEM_DEVICE15_MPSM_type);
        break;

    // Get size for ATTR_MEM_INTERNAL_WR_TIMING_MODE attribute
    case ATTR_MEM_INTERNAL_WR_TIMING_MODE:
        l_attrSize = sizeof(ATTR_MEM_INTERNAL_WR_TIMING_MODE_type);
        break;

    // Get size for ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT attribute
    case ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT:
        l_attrSize = sizeof(ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT_type);
        break;

    // Get size for ATTR_MEM_REF_INTERVAL_RATE_INDIC attribute
    case ATTR_MEM_REF_INTERVAL_RATE_INDIC:
        l_attrSize = sizeof(ATTR_MEM_REF_INTERVAL_RATE_INDIC_type);
        break;

    // Get size for ATTR_MEM_DDR5_MIN_REF_RATE attribute
    case ATTR_MEM_DDR5_MIN_REF_RATE:
        l_attrSize = sizeof(ATTR_MEM_DDR5_MIN_REF_RATE_type);
        break;

    // Get size for ATTR_MEM_REF_WIDE_RANGE attribute
    case ATTR_MEM_REF_WIDE_RANGE:
        l_attrSize = sizeof(ATTR_MEM_REF_WIDE_RANGE_type);
        break;

    // Get size for ATTR_MEM_DDR5_REF_TUF attribute
    case ATTR_MEM_DDR5_REF_TUF:
        l_attrSize = sizeof(ATTR_MEM_DDR5_REF_TUF_type);
        break;

    // Get size for ATTR_DRAM_PU_DRV_IMP attribute
    case ATTR_DRAM_PU_DRV_IMP:
        l_attrSize = sizeof(ATTR_DRAM_PU_DRV_IMP_type);
        break;

    // Get size for ATTR_DDR5_DRAM_TEST_MODE attribute
    case ATTR_DDR5_DRAM_TEST_MODE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_TEST_MODE_type);
        break;

    // Get size for ATTR_DRAM_PD_DRV_IMP attribute
    case ATTR_DRAM_PD_DRV_IMP:
        l_attrSize = sizeof(ATTR_DRAM_PD_DRV_IMP_type);
        break;

    // Get size for ATTR_DDR5_DRAM_RD_PREAMBLE attribute
    case ATTR_DDR5_DRAM_RD_PREAMBLE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_RD_PREAMBLE_type);
        break;

    // Get size for ATTR_DDR5_DRAM_WR_PREAMBLE attribute
    case ATTR_DDR5_DRAM_WR_PREAMBLE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_WR_PREAMBLE_type);
        break;

    // Get size for ATTR_DDR5_DRAM_RD_POSTAMBLE attribute
    case ATTR_DDR5_DRAM_RD_POSTAMBLE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_RD_POSTAMBLE_type);
        break;

    // Get size for ATTR_DDR5_DRAM_WR_POSTAMBLE attribute
    case ATTR_DDR5_DRAM_WR_POSTAMBLE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_WR_POSTAMBLE_type);
        break;

    // Get size for ATTR_DDR5_DRAM_WR_VREFDQ attribute
    case ATTR_DDR5_DRAM_WR_VREFDQ:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_WR_VREFDQ_type);
        break;

    // Get size for ATTR_DDR5_DRAM_VREFCA attribute
    case ATTR_DDR5_DRAM_VREFCA:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_VREFCA_type);
        break;

    // Get size for ATTR_DDR5_DRAM_VREFCS attribute
    case ATTR_DDR5_DRAM_VREFCS:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_VREFCS_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_MODE attribute
    case ATTR_DDR5_DRAM_ECS_MODE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_MODE_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_RESET_COUNTER attribute
    case ATTR_DDR5_DRAM_ECS_RESET_COUNTER:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_RESET_COUNTER_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_COUNT_MODE attribute
    case ATTR_DDR5_DRAM_ECS_COUNT_MODE:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_COUNT_MODE_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_SRANK_SELECT attribute
    case ATTR_DDR5_DRAM_ECS_SRANK_SELECT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_SRANK_SELECT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT attribute
    case ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH attribute
    case ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_WRITEBACK attribute
    case ATTR_DDR5_DRAM_ECS_WRITEBACK:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_WRITEBACK_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ECS_X4_WRITES attribute
    case ATTR_DDR5_DRAM_ECS_X4_WRITES:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ECS_X4_WRITES_type);
        break;

    // Get size for ATTR_DDR5_DRAM_CK_ODT attribute
    case ATTR_DDR5_DRAM_CK_ODT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_CK_ODT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_CS_ODT attribute
    case ATTR_DDR5_DRAM_CS_ODT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_CS_ODT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_CK_ODT_PER_DRAM attribute
    case ATTR_DDR5_DRAM_CK_ODT_PER_DRAM:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_CK_ODT_PER_DRAM_type);
        break;

    // Get size for ATTR_DDR5_DRAM_CS_ODT_PER_DRAM attribute
    case ATTR_DDR5_DRAM_CS_ODT_PER_DRAM:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_CS_ODT_PER_DRAM_type);
        break;

    // Get size for ATTR_DDR5_DRAM_CA_ODT attribute
    case ATTR_DDR5_DRAM_CA_ODT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_CA_ODT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_DQS_RTT_PARK attribute
    case ATTR_DDR5_DRAM_DQS_RTT_PARK:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_DQS_RTT_PARK_type);
        break;

    // Get size for ATTR_DDR5_DRAM_CA_ODT_PER_DRAM attribute
    case ATTR_DDR5_DRAM_CA_ODT_PER_DRAM:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_CA_ODT_PER_DRAM_type);
        break;

    // Get size for ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM attribute
    case ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM_type);
        break;

    // Get size for ATTR_DDR5_DRAM_RTT_WR attribute
    case ATTR_DDR5_DRAM_RTT_WR:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_RTT_WR_type);
        break;

    // Get size for ATTR_DDR5_DRAM_RTT_PARK attribute
    case ATTR_DDR5_DRAM_RTT_PARK:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_RTT_PARK_type);
        break;

    // Get size for ATTR_DDR5_DRAM_RTT_NOM_WR attribute
    case ATTR_DDR5_DRAM_RTT_NOM_WR:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_RTT_NOM_WR_type);
        break;

    // Get size for ATTR_DDR5_DRAM_RTT_NOM_RD attribute
    case ATTR_DDR5_DRAM_RTT_NOM_RD:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_RTT_NOM_RD_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ODTLON_WR attribute
    case ATTR_DDR5_DRAM_ODTLON_WR:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ODTLON_WR_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ODTLOFF_WR attribute
    case ATTR_DDR5_DRAM_ODTLOFF_WR:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ODTLOFF_WR_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ODTLON_WR_NT attribute
    case ATTR_DDR5_DRAM_ODTLON_WR_NT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ODTLON_WR_NT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ODTLOFF_WR_NT attribute
    case ATTR_DDR5_DRAM_ODTLOFF_WR_NT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ODTLOFF_WR_NT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ODTLON_RD_NT attribute
    case ATTR_DDR5_DRAM_ODTLON_RD_NT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ODTLON_RD_NT_type);
        break;

    // Get size for ATTR_DDR5_DRAM_ODTLOFF_RD_NT attribute
    case ATTR_DDR5_DRAM_ODTLOFF_RD_NT:
        l_attrSize = sizeof(ATTR_DDR5_DRAM_ODTLOFF_RD_NT_type);
        break;

    // Get size for ATTR_MEM_DDR5_WR_CRC_ERR_STATUS attribute
    case ATTR_MEM_DDR5_WR_CRC_ERR_STATUS:
        l_attrSize = sizeof(ATTR_MEM_DDR5_WR_CRC_ERR_STATUS_type);
        break;

    // Get size for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE attribute
    case ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE:
        l_attrSize = sizeof(ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE_type);
        break;

    // Get size for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS attribute
    case ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS:
        l_attrSize = sizeof(ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS_type);
        break;

    // Get size for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD attribute
    case ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD:
        l_attrSize = sizeof(ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD_type);
        break;

    // Get size for ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW attribute
    case ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW:
        l_attrSize = sizeof(ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW_type);
        break;

    // Get size for ATTR_MEM_DDR5_GLOBAL_DFE_GAIN attribute
    case ATTR_MEM_DDR5_GLOBAL_DFE_GAIN:
        l_attrSize = sizeof(ATTR_MEM_DDR5_GLOBAL_DFE_GAIN_type);
        break;

    // Get size for ATTR_MEM_DDR5_GLOBAL_DFE_TAP1 attribute
    case ATTR_MEM_DDR5_GLOBAL_DFE_TAP1:
        l_attrSize = sizeof(ATTR_MEM_DDR5_GLOBAL_DFE_TAP1_type);
        break;

    // Get size for ATTR_MEM_DDR5_GLOBAL_DFE_TAP2 attribute
    case ATTR_MEM_DDR5_GLOBAL_DFE_TAP2:
        l_attrSize = sizeof(ATTR_MEM_DDR5_GLOBAL_DFE_TAP2_type);
        break;

    // Get size for ATTR_MEM_DDR5_GLOBAL_DFE_TAP3 attribute
    case ATTR_MEM_DDR5_GLOBAL_DFE_TAP3:
        l_attrSize = sizeof(ATTR_MEM_DDR5_GLOBAL_DFE_TAP3_type);
        break;

    // Get size for ATTR_MEM_DDR5_GLOBAL_DFE_TAP4 attribute
    case ATTR_MEM_DDR5_GLOBAL_DFE_TAP4:
        l_attrSize = sizeof(ATTR_MEM_DDR5_GLOBAL_DFE_TAP4_type);
        break;

    // Get size for ATTR_MEM_DDR5_DFE_GAIN_BIAS attribute
    case ATTR_MEM_DDR5_DFE_GAIN_BIAS:
        l_attrSize = sizeof(ATTR_MEM_DDR5_DFE_GAIN_BIAS_type);
        break;

    // Get size for ATTR_MEM_DDR5_DFE_SIGN_BIT attribute
    case ATTR_MEM_DDR5_DFE_SIGN_BIT:
        l_attrSize = sizeof(ATTR_MEM_DDR5_DFE_SIGN_BIT_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_GEN attribute
    case ATTR_MEM_EFF_DRAM_GEN:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_GEN_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_TYPE attribute
    case ATTR_MEM_EFF_DIMM_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_HYBRID_MEMORY_TYPE attribute
    case ATTR_MEM_EFF_HYBRID_MEMORY_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_HYBRID_MEMORY_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_HYBRID attribute
    case ATTR_MEM_EFF_HYBRID:
        l_attrSize = sizeof(ATTR_MEM_EFF_HYBRID_type);
        break;

    // Get size for ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO attribute
    case ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO:
        l_attrSize = sizeof(ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_DENSITY attribute
    case ATTR_MEM_EFF_DRAM_DENSITY:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_DENSITY_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_BANK_BITS attribute
    case ATTR_MEM_EFF_DRAM_BANK_BITS:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_BANK_BITS_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS attribute
    case ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_COLUMN_BITS attribute
    case ATTR_MEM_EFF_DRAM_COLUMN_BITS:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_COLUMN_BITS_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_ROW_BITS attribute
    case ATTR_MEM_EFF_DRAM_ROW_BITS:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_ROW_BITS_type);
        break;

    // Get size for ATTR_MEM_EFF_PRIM_DIE_COUNT attribute
    case ATTR_MEM_EFF_PRIM_DIE_COUNT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PRIM_DIE_COUNT_type);
        break;

    // Get size for ATTR_MEM_EFF_PRIM_STACK_TYPE attribute
    case ATTR_MEM_EFF_PRIM_STACK_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_PRIM_STACK_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_PRIM_BUS_WIDTH attribute
    case ATTR_MEM_EFF_PRIM_BUS_WIDTH:
        l_attrSize = sizeof(ATTR_MEM_EFF_PRIM_BUS_WIDTH_type);
        break;

    // Get size for ATTR_MEM_EFF_CHANNELS_PER_DIMM attribute
    case ATTR_MEM_EFF_CHANNELS_PER_DIMM:
        l_attrSize = sizeof(ATTR_MEM_EFF_CHANNELS_PER_DIMM_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_PPR attribute
    case ATTR_MEM_EFF_DRAM_PPR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_PPR_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_SOFT_PPR attribute
    case ATTR_MEM_EFF_DRAM_SOFT_PPR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_SOFT_PPR_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRCD attribute
    case ATTR_MEM_EFF_DRAM_TRCD:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRCD_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRP attribute
    case ATTR_MEM_EFF_DRAM_TRP:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRP_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRAS attribute
    case ATTR_MEM_EFF_DRAM_TRAS:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRAS_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRC attribute
    case ATTR_MEM_EFF_DRAM_TRC:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRC_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRFC attribute
    case ATTR_MEM_EFF_DRAM_TRFC:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRFC_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TFAW attribute
    case ATTR_MEM_EFF_DRAM_TFAW:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TFAW_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRRD_S attribute
    case ATTR_MEM_EFF_DRAM_TRRD_S:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRRD_S_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRRD_L attribute
    case ATTR_MEM_EFF_DRAM_TRRD_L:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRRD_L_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRRD_DLR attribute
    case ATTR_MEM_EFF_DRAM_TRRD_DLR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRRD_DLR_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TCCD_L attribute
    case ATTR_MEM_EFF_DRAM_TCCD_L:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TCCD_L_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TCCD_L_WR attribute
    case ATTR_MEM_EFF_DRAM_TCCD_L_WR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TCCD_L_WR_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TWR attribute
    case ATTR_MEM_EFF_DRAM_TWR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TWR_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TWTR_S attribute
    case ATTR_MEM_EFF_DRAM_TWTR_S:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TWTR_S_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TWTR_L attribute
    case ATTR_MEM_EFF_DRAM_TWTR_L:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TWTR_L_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TMAW attribute
    case ATTR_MEM_EFF_DRAM_TMAW:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TMAW_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_WIDTH attribute
    case ATTR_MEM_EFF_DRAM_WIDTH:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_WIDTH_type);
        break;

    // Get size for ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM attribute
    case ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM:
        l_attrSize = sizeof(ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM_type);
        break;

    // Get size for ATTR_MEM_3DS_HEIGHT attribute
    case ATTR_MEM_3DS_HEIGHT:
        l_attrSize = sizeof(ATTR_MEM_3DS_HEIGHT_type);
        break;

    // Get size for ATTR_MEM_EFF_REGISTER_TYPE attribute
    case ATTR_MEM_EFF_REGISTER_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_REGISTER_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_MODULE_MFG_ID attribute
    case ATTR_MEM_EFF_MODULE_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_MODULE_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_MFG_ID attribute
    case ATTR_MEM_EFF_DRAM_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_MODULE_HEIGHT attribute
    case ATTR_MEM_EFF_DRAM_MODULE_HEIGHT:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_MODULE_HEIGHT_type);
        break;

    // Get size for ATTR_MEM_EFF_RCD_MFG_ID attribute
    case ATTR_MEM_EFF_RCD_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_RCD_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_REGISTER_REV attribute
    case ATTR_MEM_EFF_REGISTER_REV:
        l_attrSize = sizeof(ATTR_MEM_EFF_REGISTER_REV_type);
        break;

    // Get size for ATTR_MEM_EFF_PACKAGE_RANK_MAP attribute
    case ATTR_MEM_EFF_PACKAGE_RANK_MAP:
        l_attrSize = sizeof(ATTR_MEM_EFF_PACKAGE_RANK_MAP_type);
        break;

    // Get size for ATTR_MEM_EFF_NIBBLE_MAP attribute
    case ATTR_MEM_EFF_NIBBLE_MAP:
        l_attrSize = sizeof(ATTR_MEM_EFF_NIBBLE_MAP_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_SIZE attribute
    case ATTR_MEM_EFF_DIMM_SIZE:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_SIZE_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_SPARE attribute
    case ATTR_MEM_EFF_DIMM_SPARE:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_SPARE_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_CL attribute
    case ATTR_MEM_EFF_DRAM_CL:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_CL_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_MDS attribute
    case ATTR_MEM_EFF_DRAM_MDS:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_MDS_type);
        break;

    // Get size for ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM attribute
    case ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM:
        l_attrSize = sizeof(ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_RANKS_CONFIGED attribute
    case ATTR_MEM_EFF_DIMM_RANKS_CONFIGED:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_RANKS_CONFIGED_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TREFI attribute
    case ATTR_MEM_EFF_DRAM_TREFI:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TREFI_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRTP attribute
    case ATTR_MEM_EFF_DRAM_TRTP:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRTP_type);
        break;

    // Get size for ATTR_MEM_EFF_DRAM_TRFC_DLR attribute
    case ATTR_MEM_EFF_DRAM_TRFC_DLR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DRAM_TRFC_DLR_type);
        break;

    // Get size for ATTR_MEM_EFF_FREQ attribute
    case ATTR_MEM_EFF_FREQ:
        l_attrSize = sizeof(ATTR_MEM_EFF_FREQ_type);
        break;

    // Get size for ATTR_MEM_EFF_VOLT_VDDR attribute
    case ATTR_MEM_EFF_VOLT_VDDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_VOLT_VDDR_type);
        break;

    // Get size for ATTR_MEM_EFF_VOLT_VDDQ attribute
    case ATTR_MEM_EFF_VOLT_VDDQ:
        l_attrSize = sizeof(ATTR_MEM_EFF_VOLT_VDDQ_type);
        break;

    // Get size for ATTR_MEM_EFF_VOLT_VPP attribute
    case ATTR_MEM_EFF_VOLT_VPP:
        l_attrSize = sizeof(ATTR_MEM_EFF_VOLT_VPP_type);
        break;

    // Get size for ATTR_MEM_EFF_SPD_REVISION attribute
    case ATTR_MEM_EFF_SPD_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_SPD_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_SPD_CONTENT_REVISION attribute
    case ATTR_MEM_EFF_SPD_CONTENT_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_SPD_CONTENT_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_SUPPORTED_RCD attribute
    case ATTR_MEM_EFF_SUPPORTED_RCD:
        l_attrSize = sizeof(ATTR_MEM_EFF_SUPPORTED_RCD_type);
        break;

    // Get size for ATTR_MEM_EFF_BYTE_ENABLES attribute
    case ATTR_MEM_EFF_BYTE_ENABLES:
        l_attrSize = sizeof(ATTR_MEM_EFF_BYTE_ENABLES_type);
        break;

    // Get size for ATTR_MEM_EFF_NIBBLE_ENABLES attribute
    case ATTR_MEM_EFF_NIBBLE_ENABLES:
        l_attrSize = sizeof(ATTR_MEM_EFF_NIBBLE_ENABLES_type);
        break;

    // Get size for ATTR_MEM_EFF_Z_MODE attribute
    case ATTR_MEM_EFF_Z_MODE:
        l_attrSize = sizeof(ATTR_MEM_EFF_Z_MODE_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_SERIAL_NUMBER attribute
    case ATTR_MEM_EFF_DIMM_SERIAL_NUMBER:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_SERIAL_NUMBER_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN attribute
    case ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN_type);
        break;

    // Get size for ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION attribute
    case ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_MODULE_THERMAL_SENSORS attribute
    case ATTR_MEM_EFF_MODULE_THERMAL_SENSORS:
        l_attrSize = sizeof(ATTR_MEM_EFF_MODULE_THERMAL_SENSORS_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_TYPE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_USAGE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_USAGE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_USAGE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_TYPE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_USAGE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_USAGE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_USAGE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_2_TYPE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_2_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_2_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_2_USAGE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_2_USAGE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_2_USAGE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_3_TYPE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_3_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_3_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_3_USAGE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_3_USAGE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_3_USAGE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL attribute
    case ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION attribute
    case ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION attribute
    case ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION attribute
    case ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION attribute
    case ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION_type);
        break;

    // Get size for ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE attribute
    case ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE:
        l_attrSize = sizeof(ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE_type);
        break;

    // Get size for ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
    case ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT:
        l_attrSize = sizeof(ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT_type);
        break;

    // Get size for ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
    case ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT:
        l_attrSize = sizeof(ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type);
        break;

    // Get size for ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
    case ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT:
        l_attrSize = sizeof(ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_type);
        break;

    // Get size for ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
    case ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT:
        l_attrSize = sizeof(ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type);
        break;

    // Get size for ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
    case ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT:
        l_attrSize = sizeof(ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT_type);
        break;

    // Get size for ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
    case ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT:
        l_attrSize = sizeof(ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type);
        break;

    // Get size for ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
    case ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT:
        l_attrSize = sizeof(ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT_type);
        break;

    // Get size for ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT attribute
    case ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT:
        l_attrSize = sizeof(ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT_type);
        break;

    // Get size for ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
    case ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT:
        l_attrSize = sizeof(ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_type);
        break;

    // Get size for ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS attribute
    case ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS:
        l_attrSize = sizeof(ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS_type);
        break;

    // Get size for ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE attribute
    case ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE:
        l_attrSize = sizeof(ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE_type);
        break;

    // Get size for ATTR_EXP_MEM_WATT_TARGET attribute
    case ATTR_EXP_MEM_WATT_TARGET:
        l_attrSize = sizeof(ATTR_EXP_MEM_WATT_TARGET_type);
        break;

    // Get size for ATTR_EXP_TOTAL_PWR_SLOPE attribute
    case ATTR_EXP_TOTAL_PWR_SLOPE:
        l_attrSize = sizeof(ATTR_EXP_TOTAL_PWR_SLOPE_type);
        break;

    // Get size for ATTR_EXP_TOTAL_PWR_INTERCEPT attribute
    case ATTR_EXP_TOTAL_PWR_INTERCEPT:
        l_attrSize = sizeof(ATTR_EXP_TOTAL_PWR_INTERCEPT_type);
        break;

    // Get size for ATTR_EXP_PORT_MAXPOWER attribute
    case ATTR_EXP_PORT_MAXPOWER:
        l_attrSize = sizeof(ATTR_EXP_PORT_MAXPOWER_type);
        break;

    // Get size for ATTR_EXP_DIMM_THERMAL_LIMIT attribute
    case ATTR_EXP_DIMM_THERMAL_LIMIT:
        l_attrSize = sizeof(ATTR_EXP_DIMM_THERMAL_LIMIT_type);
        break;

    // Get size for ATTR_MEM_MRW_IS_PLANAR attribute
    case ATTR_MEM_MRW_IS_PLANAR:
        l_attrSize = sizeof(ATTR_MEM_MRW_IS_PLANAR_type);
        break;

    // Get size for ATTR_MSS_MRW_CONFIG_FREQ_LIMIT attribute
    case ATTR_MSS_MRW_CONFIG_FREQ_LIMIT:
        l_attrSize = sizeof(ATTR_MSS_MRW_CONFIG_FREQ_LIMIT_type);
        break;

    // Get size for ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT attribute
    case ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT:
        l_attrSize = sizeof(ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT_type);
        break;

    // Get size for ATTR_MSS_MRW_PWR_INTERCEPT attribute
    case ATTR_MSS_MRW_PWR_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_MRW_PWR_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_MRW_PWR_SLOPE attribute
    case ATTR_MSS_MRW_PWR_SLOPE:
        l_attrSize = sizeof(ATTR_MSS_MRW_PWR_SLOPE_type);
        break;

    // Get size for ATTR_MSS_MRW_REFRESH_RATE_REQUEST attribute
    case ATTR_MSS_MRW_REFRESH_RATE_REQUEST:
        l_attrSize = sizeof(ATTR_MSS_MRW_REFRESH_RATE_REQUEST_type);
        break;

    // Get size for ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT attribute
    case ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT:
        l_attrSize = sizeof(ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_type);
        break;

    // Get size for ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE attribute
    case ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE_type);
        break;

    // Get size for ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS attribute
    case ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS:
        l_attrSize = sizeof(ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS_type);
        break;

    // Get size for ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL attribute
    case ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL:
        l_attrSize = sizeof(ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL_type);
        break;

    // Get size for ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL attribute
    case ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL:
        l_attrSize = sizeof(ATTR_MSS_MRW_DDR5_MAX_DRAM_DATABUS_UTIL_type);
        break;

    // Get size for ATTR_MSS_MRW_POWER_CONTROL_REQUESTED attribute
    case ATTR_MSS_MRW_POWER_CONTROL_REQUESTED:
        l_attrSize = sizeof(ATTR_MSS_MRW_POWER_CONTROL_REQUESTED_type);
        break;

    // Get size for ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED attribute
    case ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED:
        l_attrSize = sizeof(ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_type);
        break;

    // Get size for ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE attribute
    case ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_type);
        break;

    // Get size for ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3 attribute
    case ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3:
        l_attrSize = sizeof(ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3_type);
        break;

    // Get size for ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4 attribute
    case ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4:
        l_attrSize = sizeof(ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4_type);
        break;

    // Get size for ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR attribute
    case ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR:
        l_attrSize = sizeof(ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR_type);
        break;

    // Get size for ATTR_MSS_MRW_AVDD_OFFSET_ENABLE attribute
    case ATTR_MSS_MRW_AVDD_OFFSET_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_AVDD_OFFSET_ENABLE_type);
        break;

    // Get size for ATTR_MSS_MRW_VDD_OFFSET_ENABLE attribute
    case ATTR_MSS_MRW_VDD_OFFSET_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_VDD_OFFSET_ENABLE_type);
        break;

    // Get size for ATTR_MSS_MRW_VCS_OFFSET_ENABLE attribute
    case ATTR_MSS_MRW_VCS_OFFSET_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_VCS_OFFSET_ENABLE_type);
        break;

    // Get size for ATTR_MSS_MRW_VPP_OFFSET_ENABLE attribute
    case ATTR_MSS_MRW_VPP_OFFSET_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_VPP_OFFSET_ENABLE_type);
        break;

    // Get size for ATTR_MSS_MRW_VDDR_OFFSET_ENABLE attribute
    case ATTR_MSS_MRW_VDDR_OFFSET_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_MRW_VDDR_OFFSET_ENABLE_type);
        break;

    // Get size for ATTR_MSS_MRW_FINE_REFRESH_MODE attribute
    case ATTR_MSS_MRW_FINE_REFRESH_MODE:
        l_attrSize = sizeof(ATTR_MSS_MRW_FINE_REFRESH_MODE_type);
        break;

    // Get size for ATTR_MSS_MRW_TEMP_REFRESH_RANGE attribute
    case ATTR_MSS_MRW_TEMP_REFRESH_RANGE:
        l_attrSize = sizeof(ATTR_MSS_MRW_TEMP_REFRESH_RANGE_type);
        break;

    // Get size for ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL attribute
    case ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL:
        l_attrSize = sizeof(ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL_type);
        break;

    // Get size for ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS attribute
    case ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS:
        l_attrSize = sizeof(ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS_type);
        break;

    // Get size for ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS attribute
    case ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS:
        l_attrSize = sizeof(ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS_type);
        break;

    // Get size for ATTR_MSS_MRW_DRAM_2N_MODE attribute
    case ATTR_MSS_MRW_DRAM_2N_MODE:
        l_attrSize = sizeof(ATTR_MSS_MRW_DRAM_2N_MODE_type);
        break;

    // Get size for ATTR_MSS_MRW_DRAM_WRITE_CRC attribute
    case ATTR_MSS_MRW_DRAM_WRITE_CRC:
        l_attrSize = sizeof(ATTR_MSS_MRW_DRAM_WRITE_CRC_type);
        break;

    // Get size for ATTR_MSS_MRW_DDR5_DRAM_READ_CRC attribute
    case ATTR_MSS_MRW_DDR5_DRAM_READ_CRC:
        l_attrSize = sizeof(ATTR_MSS_MRW_DDR5_DRAM_READ_CRC_type);
        break;

    // Get size for ATTR_MSS_MRW_TEMP_REFRESH_MODE attribute
    case ATTR_MSS_MRW_TEMP_REFRESH_MODE:
        l_attrSize = sizeof(ATTR_MSS_MRW_TEMP_REFRESH_MODE_type);
        break;

    // Get size for ATTR_MSS_MRW_FORCE_BCMODE_OFF attribute
    case ATTR_MSS_MRW_FORCE_BCMODE_OFF:
        l_attrSize = sizeof(ATTR_MSS_MRW_FORCE_BCMODE_OFF_type);
        break;

    // Get size for ATTR_MSS_MRW_NVDIMM_PLUG_RULES attribute
    case ATTR_MSS_MRW_NVDIMM_PLUG_RULES:
        l_attrSize = sizeof(ATTR_MSS_MRW_NVDIMM_PLUG_RULES_type);
        break;

    // Get size for ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW attribute
    case ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW:
        l_attrSize = sizeof(ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW_type);
        break;

    // Get size for ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH attribute
    case ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH:
        l_attrSize = sizeof(ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH_type);
        break;

    // Get size for ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT attribute
    case ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT:
        l_attrSize = sizeof(ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT_type);
        break;

    // Get size for ATTR_MSS_MRW_OCMB_PWR_SLOPE attribute
    case ATTR_MSS_MRW_OCMB_PWR_SLOPE:
        l_attrSize = sizeof(ATTR_MSS_MRW_OCMB_PWR_SLOPE_type);
        break;

    // Get size for ATTR_MSS_MRW_OCMB_PWR_INTERCEPT attribute
    case ATTR_MSS_MRW_OCMB_PWR_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_MRW_OCMB_PWR_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT attribute
    case ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT:
        l_attrSize = sizeof(ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT_type);
        break;

    // Get size for ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL attribute
    case ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL:
        l_attrSize = sizeof(ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL_type);
        break;

    // Get size for ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD attribute
    case ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD:
        l_attrSize = sizeof(ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD_type);
        break;

    // Get size for ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW attribute
    case ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW:
        l_attrSize = sizeof(ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW_type);
        break;

    // Get size for ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE attribute
    case ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE:
        l_attrSize = sizeof(ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE_type);
        break;

    // Get size for ATTR_MSS_MRW_OCMB_RESET_GROUP attribute
    case ATTR_MSS_MRW_OCMB_RESET_GROUP:
        l_attrSize = sizeof(ATTR_MSS_MRW_OCMB_RESET_GROUP_type);
        break;

    // Get size for ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY attribute
    case ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY:
        l_attrSize = sizeof(ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY_type);
        break;

    // Get size for ATTR_MSS_MRW_SUPPORTED_FREQ attribute
    case ATTR_MSS_MRW_SUPPORTED_FREQ:
        l_attrSize = sizeof(ATTR_MSS_MRW_SUPPORTED_FREQ_type);
        break;

    // Get size for ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT attribute
    case ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT:
        l_attrSize = sizeof(ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT_type);
        break;

    // Get size for ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE attribute
    case ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE:
        l_attrSize = sizeof(ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE_type);
        break;

    // Get size for ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY attribute
    case ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY:
        l_attrSize = sizeof(ATTR_MSS_MRW_OCMB_SAFEMODE_UTIL_ARRAY_type);
        break;

    // Get size for ATTR_MSS_MRW_ALLOW_DDR5 attribute
    case ATTR_MSS_MRW_ALLOW_DDR5:
        l_attrSize = sizeof(ATTR_MSS_MRW_ALLOW_DDR5_type);
        break;

    // Get size for ATTR_MRW_MAX_DDR_FREQ_PER_SLOT attribute
    case ATTR_MRW_MAX_DDR_FREQ_PER_SLOT:
        l_attrSize = sizeof(ATTR_MRW_MAX_DDR_FREQ_PER_SLOT_type);
        break;

    // Get size for ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF attribute
    case ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF:
        l_attrSize = sizeof(ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_FOR_POWER_CONTROL_OFF_type);
        break;

    // Get size for ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME attribute
    case ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME:
        l_attrSize = sizeof(ATTR_MSS_MRW_MIN_DOMAIN_REDUCTION_TIME_type);
        break;

    // Get size for ATTR_MSS_MRW_ENTER_STR_TIME attribute
    case ATTR_MSS_MRW_ENTER_STR_TIME:
        l_attrSize = sizeof(ATTR_MSS_MRW_ENTER_STR_TIME_type);
        break;

    // Get size for ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME attribute
    case ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME:
        l_attrSize = sizeof(ATTR_MSS_MRW_IDLE_PSMODE_MIN_DOMAIN_REDUCTION_TIME_type);
        break;

    // Get size for ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME attribute
    case ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME:
        l_attrSize = sizeof(ATTR_MSS_MRW_IDLE_PSMODE_ENTER_STR_TIME_type);
        break;

    // Get size for ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM attribute
    case ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM:
        l_attrSize = sizeof(ATTR_MRW_MAX_DDR_FREQ_ON_IOSCM_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ attribute
    case ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ attribute
    case ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC attribute
    case ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC attribute
    case ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK attribute
    case ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK attribute
    case ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK_type);
        break;

    // Get size for ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0 attribute
    case ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0:
        l_attrSize = sizeof(ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0_type);
        break;

    // Get size for ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1 attribute
    case ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1:
        l_attrSize = sizeof(ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1_type);
        break;

    // Get size for ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN attribute
    case ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN:
        l_attrSize = sizeof(ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN_type);
        break;

    // Get size for ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0 attribute
    case ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0:
        l_attrSize = sizeof(ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0_type);
        break;

    // Get size for ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1 attribute
    case ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1:
        l_attrSize = sizeof(ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1_type);
        break;

    // Get size for ATTR_DDR5_TX_DM_PREAMBLE_PATTERN attribute
    case ATTR_DDR5_TX_DM_PREAMBLE_PATTERN:
        l_attrSize = sizeof(ATTR_DDR5_TX_DM_PREAMBLE_PATTERN_type);
        break;

    // Get size for ATTR_MEM_EFF_REDUNDANT_CS_EN attribute
    case ATTR_MEM_EFF_REDUNDANT_CS_EN:
        l_attrSize = sizeof(ATTR_MEM_EFF_REDUNDANT_CS_EN_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_RXEN_ADJ attribute
    case ATTR_MEM_EFF_DDR5_RXEN_ADJ:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_RXEN_ADJ_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_WL_ADJ_START attribute
    case ATTR_MEM_EFF_DDR5_WL_ADJ_START:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_WL_ADJ_START_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_WL_ADJ_END attribute
    case ATTR_MEM_EFF_DDR5_WL_ADJ_END:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_WL_ADJ_END_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_PHY_VREF_RD attribute
    case ATTR_MEM_EFF_DDR5_PHY_VREF_RD:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_PHY_VREF_RD_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_RTT_PARK_RD attribute
    case ATTR_MEM_EFF_DDR5_RTT_PARK_RD:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_RTT_PARK_RD_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_RTT_PARK_WR attribute
    case ATTR_MEM_EFF_DDR5_RTT_PARK_WR:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_RTT_PARK_WR_type);
        break;

    // Get size for ATTR_MEM_DDR5_SPD_CL_SUPPORTED attribute
    case ATTR_MEM_DDR5_SPD_CL_SUPPORTED:
        l_attrSize = sizeof(ATTR_MEM_DDR5_SPD_CL_SUPPORTED_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_CHB_ACTIVE attribute
    case ATTR_MEM_EFF_DDR5_CHB_ACTIVE:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_CHB_ACTIVE_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE attribute
    case ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH attribute
    case ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN attribute
    case ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX attribute
    case ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN attribute
    case ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN_type);
        break;

    // Get size for ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX attribute
    case ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX_type);
        break;

    // Get size for ATTR_RCW00_CHA_D0 attribute
    case ATTR_RCW00_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW00_CHA_D0_type);
        break;

    // Get size for ATTR_RCW01_CHA_D0 attribute
    case ATTR_RCW01_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW01_CHA_D0_type);
        break;

    // Get size for ATTR_RCW05_CHA_D0 attribute
    case ATTR_RCW05_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW05_CHA_D0_type);
        break;

    // Get size for ATTR_RCW08_CHA_D0 attribute
    case ATTR_RCW08_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW08_CHA_D0_type);
        break;

    // Get size for ATTR_RCW09_CHA_D0 attribute
    case ATTR_RCW09_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW09_CHA_D0_type);
        break;

    // Get size for ATTR_RCW0A_CHA_D0 attribute
    case ATTR_RCW0A_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW0A_CHA_D0_type);
        break;

    // Get size for ATTR_RCW0C_CHA_D0 attribute
    case ATTR_RCW0C_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW0C_CHA_D0_type);
        break;

    // Get size for ATTR_RCW0D_CHA_D0 attribute
    case ATTR_RCW0D_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW0D_CHA_D0_type);
        break;

    // Get size for ATTR_RCW0E_CHA_D0 attribute
    case ATTR_RCW0E_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW0E_CHA_D0_type);
        break;

    // Get size for ATTR_RCW0F_CHA_D0 attribute
    case ATTR_RCW0F_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW0F_CHA_D0_type);
        break;

    // Get size for ATTR_RCW40_CHA_D0 attribute
    case ATTR_RCW40_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW40_CHA_D0_type);
        break;

    // Get size for ATTR_RCW41_CHA_D0 attribute
    case ATTR_RCW41_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW41_CHA_D0_type);
        break;

    // Get size for ATTR_RCW42_CHA_D0 attribute
    case ATTR_RCW42_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW42_CHA_D0_type);
        break;

    // Get size for ATTR_RCW43_CHA_D0 attribute
    case ATTR_RCW43_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW43_CHA_D0_type);
        break;

    // Get size for ATTR_RCW44_CHA_D0 attribute
    case ATTR_RCW44_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW44_CHA_D0_type);
        break;

    // Get size for ATTR_RCW45_CHA_D0 attribute
    case ATTR_RCW45_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW45_CHA_D0_type);
        break;

    // Get size for ATTR_RCW46_CHA_D0 attribute
    case ATTR_RCW46_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW46_CHA_D0_type);
        break;

    // Get size for ATTR_RCW47_CHA_D0 attribute
    case ATTR_RCW47_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW47_CHA_D0_type);
        break;

    // Get size for ATTR_RCW48_CHA_D0 attribute
    case ATTR_RCW48_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW48_CHA_D0_type);
        break;

    // Get size for ATTR_RCW49_CHA_D0 attribute
    case ATTR_RCW49_CHA_D0:
        l_attrSize = sizeof(ATTR_RCW49_CHA_D0_type);
        break;

    // Get size for ATTR_RCW00_CHA_D1 attribute
    case ATTR_RCW00_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW00_CHA_D1_type);
        break;

    // Get size for ATTR_RCW01_CHA_D1 attribute
    case ATTR_RCW01_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW01_CHA_D1_type);
        break;

    // Get size for ATTR_RCW05_CHA_D1 attribute
    case ATTR_RCW05_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW05_CHA_D1_type);
        break;

    // Get size for ATTR_RCW08_CHA_D1 attribute
    case ATTR_RCW08_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW08_CHA_D1_type);
        break;

    // Get size for ATTR_RCW09_CHA_D1 attribute
    case ATTR_RCW09_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW09_CHA_D1_type);
        break;

    // Get size for ATTR_RCW0A_CHA_D1 attribute
    case ATTR_RCW0A_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW0A_CHA_D1_type);
        break;

    // Get size for ATTR_RCW0C_CHA_D1 attribute
    case ATTR_RCW0C_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW0C_CHA_D1_type);
        break;

    // Get size for ATTR_RCW0D_CHA_D1 attribute
    case ATTR_RCW0D_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW0D_CHA_D1_type);
        break;

    // Get size for ATTR_RCW0E_CHA_D1 attribute
    case ATTR_RCW0E_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW0E_CHA_D1_type);
        break;

    // Get size for ATTR_RCW0F_CHA_D1 attribute
    case ATTR_RCW0F_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW0F_CHA_D1_type);
        break;

    // Get size for ATTR_RCW40_CHA_D1 attribute
    case ATTR_RCW40_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW40_CHA_D1_type);
        break;

    // Get size for ATTR_RCW41_CHA_D1 attribute
    case ATTR_RCW41_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW41_CHA_D1_type);
        break;

    // Get size for ATTR_RCW42_CHA_D1 attribute
    case ATTR_RCW42_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW42_CHA_D1_type);
        break;

    // Get size for ATTR_RCW43_CHA_D1 attribute
    case ATTR_RCW43_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW43_CHA_D1_type);
        break;

    // Get size for ATTR_RCW44_CHA_D1 attribute
    case ATTR_RCW44_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW44_CHA_D1_type);
        break;

    // Get size for ATTR_RCW45_CHA_D1 attribute
    case ATTR_RCW45_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW45_CHA_D1_type);
        break;

    // Get size for ATTR_RCW46_CHA_D1 attribute
    case ATTR_RCW46_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW46_CHA_D1_type);
        break;

    // Get size for ATTR_RCW47_CHA_D1 attribute
    case ATTR_RCW47_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW47_CHA_D1_type);
        break;

    // Get size for ATTR_RCW48_CHA_D1 attribute
    case ATTR_RCW48_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW48_CHA_D1_type);
        break;

    // Get size for ATTR_RCW49_CHA_D1 attribute
    case ATTR_RCW49_CHA_D1:
        l_attrSize = sizeof(ATTR_RCW49_CHA_D1_type);
        break;

    // Get size for ATTR_RCW00_CHB_D0 attribute
    case ATTR_RCW00_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW00_CHB_D0_type);
        break;

    // Get size for ATTR_RCW01_CHB_D0 attribute
    case ATTR_RCW01_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW01_CHB_D0_type);
        break;

    // Get size for ATTR_RCW05_CHB_D0 attribute
    case ATTR_RCW05_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW05_CHB_D0_type);
        break;

    // Get size for ATTR_RCW08_CHB_D0 attribute
    case ATTR_RCW08_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW08_CHB_D0_type);
        break;

    // Get size for ATTR_RCW09_CHB_D0 attribute
    case ATTR_RCW09_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW09_CHB_D0_type);
        break;

    // Get size for ATTR_RCW0A_CHB_D0 attribute
    case ATTR_RCW0A_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW0A_CHB_D0_type);
        break;

    // Get size for ATTR_RCW0C_CHB_D0 attribute
    case ATTR_RCW0C_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW0C_CHB_D0_type);
        break;

    // Get size for ATTR_RCW0D_CHB_D0 attribute
    case ATTR_RCW0D_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW0D_CHB_D0_type);
        break;

    // Get size for ATTR_RCW0E_CHB_D0 attribute
    case ATTR_RCW0E_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW0E_CHB_D0_type);
        break;

    // Get size for ATTR_RCW0F_CHB_D0 attribute
    case ATTR_RCW0F_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW0F_CHB_D0_type);
        break;

    // Get size for ATTR_RCW40_CHB_D0 attribute
    case ATTR_RCW40_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW40_CHB_D0_type);
        break;

    // Get size for ATTR_RCW41_CHB_D0 attribute
    case ATTR_RCW41_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW41_CHB_D0_type);
        break;

    // Get size for ATTR_RCW42_CHB_D0 attribute
    case ATTR_RCW42_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW42_CHB_D0_type);
        break;

    // Get size for ATTR_RCW43_CHB_D0 attribute
    case ATTR_RCW43_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW43_CHB_D0_type);
        break;

    // Get size for ATTR_RCW44_CHB_D0 attribute
    case ATTR_RCW44_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW44_CHB_D0_type);
        break;

    // Get size for ATTR_RCW45_CHB_D0 attribute
    case ATTR_RCW45_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW45_CHB_D0_type);
        break;

    // Get size for ATTR_RCW46_CHB_D0 attribute
    case ATTR_RCW46_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW46_CHB_D0_type);
        break;

    // Get size for ATTR_RCW47_CHB_D0 attribute
    case ATTR_RCW47_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW47_CHB_D0_type);
        break;

    // Get size for ATTR_RCW48_CHB_D0 attribute
    case ATTR_RCW48_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW48_CHB_D0_type);
        break;

    // Get size for ATTR_RCW49_CHB_D0 attribute
    case ATTR_RCW49_CHB_D0:
        l_attrSize = sizeof(ATTR_RCW49_CHB_D0_type);
        break;

    // Get size for ATTR_RCW00_CHB_D1 attribute
    case ATTR_RCW00_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW00_CHB_D1_type);
        break;

    // Get size for ATTR_RCW01_CHB_D1 attribute
    case ATTR_RCW01_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW01_CHB_D1_type);
        break;

    // Get size for ATTR_RCW05_CHB_D1 attribute
    case ATTR_RCW05_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW05_CHB_D1_type);
        break;

    // Get size for ATTR_RCW08_CHB_D1 attribute
    case ATTR_RCW08_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW08_CHB_D1_type);
        break;

    // Get size for ATTR_RCW09_CHB_D1 attribute
    case ATTR_RCW09_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW09_CHB_D1_type);
        break;

    // Get size for ATTR_RCW0A_CHB_D1 attribute
    case ATTR_RCW0A_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW0A_CHB_D1_type);
        break;

    // Get size for ATTR_RCW0C_CHB_D1 attribute
    case ATTR_RCW0C_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW0C_CHB_D1_type);
        break;

    // Get size for ATTR_RCW0D_CHB_D1 attribute
    case ATTR_RCW0D_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW0D_CHB_D1_type);
        break;

    // Get size for ATTR_RCW0E_CHB_D1 attribute
    case ATTR_RCW0E_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW0E_CHB_D1_type);
        break;

    // Get size for ATTR_RCW0F_CHB_D1 attribute
    case ATTR_RCW0F_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW0F_CHB_D1_type);
        break;

    // Get size for ATTR_RCW40_CHB_D1 attribute
    case ATTR_RCW40_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW40_CHB_D1_type);
        break;

    // Get size for ATTR_RCW41_CHB_D1 attribute
    case ATTR_RCW41_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW41_CHB_D1_type);
        break;

    // Get size for ATTR_RCW42_CHB_D1 attribute
    case ATTR_RCW42_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW42_CHB_D1_type);
        break;

    // Get size for ATTR_RCW43_CHB_D1 attribute
    case ATTR_RCW43_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW43_CHB_D1_type);
        break;

    // Get size for ATTR_RCW44_CHB_D1 attribute
    case ATTR_RCW44_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW44_CHB_D1_type);
        break;

    // Get size for ATTR_RCW45_CHB_D1 attribute
    case ATTR_RCW45_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW45_CHB_D1_type);
        break;

    // Get size for ATTR_RCW46_CHB_D1 attribute
    case ATTR_RCW46_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW46_CHB_D1_type);
        break;

    // Get size for ATTR_RCW47_CHB_D1 attribute
    case ATTR_RCW47_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW47_CHB_D1_type);
        break;

    // Get size for ATTR_RCW48_CHB_D1 attribute
    case ATTR_RCW48_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW48_CHB_D1_type);
        break;

    // Get size for ATTR_RCW49_CHB_D1 attribute
    case ATTR_RCW49_CHB_D1:
        l_attrSize = sizeof(ATTR_RCW49_CHB_D1_type);
        break;

    // Get size for ATTR_EXPLR_ENABLE_US_TMPL_1 attribute
    case ATTR_EXPLR_ENABLE_US_TMPL_1:
        l_attrSize = sizeof(ATTR_EXPLR_ENABLE_US_TMPL_1_type);
        break;

    // Get size for ATTR_EXPLR_ENABLE_US_TMPL_5 attribute
    case ATTR_EXPLR_ENABLE_US_TMPL_5:
        l_attrSize = sizeof(ATTR_EXPLR_ENABLE_US_TMPL_5_type);
        break;

    // Get size for ATTR_EXPLR_ENABLE_US_TMPL_9 attribute
    case ATTR_EXPLR_ENABLE_US_TMPL_9:
        l_attrSize = sizeof(ATTR_EXPLR_ENABLE_US_TMPL_9_type);
        break;

    // Get size for ATTR_EXPLR_ENABLE_US_TMPL_A attribute
    case ATTR_EXPLR_ENABLE_US_TMPL_A:
        l_attrSize = sizeof(ATTR_EXPLR_ENABLE_US_TMPL_A_type);
        break;

    // Get size for ATTR_EXPLR_ENABLE_US_TMPL_B attribute
    case ATTR_EXPLR_ENABLE_US_TMPL_B:
        l_attrSize = sizeof(ATTR_EXPLR_ENABLE_US_TMPL_B_type);
        break;

    // Get size for ATTR_EXPLR_TMPL_0_PACING attribute
    case ATTR_EXPLR_TMPL_0_PACING:
        l_attrSize = sizeof(ATTR_EXPLR_TMPL_0_PACING_type);
        break;

    // Get size for ATTR_EXPLR_TMPL_1_PACING attribute
    case ATTR_EXPLR_TMPL_1_PACING:
        l_attrSize = sizeof(ATTR_EXPLR_TMPL_1_PACING_type);
        break;

    // Get size for ATTR_EXPLR_TMPL_5_PACING attribute
    case ATTR_EXPLR_TMPL_5_PACING:
        l_attrSize = sizeof(ATTR_EXPLR_TMPL_5_PACING_type);
        break;

    // Get size for ATTR_EXPLR_TMPL_9_PACING attribute
    case ATTR_EXPLR_TMPL_9_PACING:
        l_attrSize = sizeof(ATTR_EXPLR_TMPL_9_PACING_type);
        break;

    // Get size for ATTR_EXPLR_TMPL_B_PACING attribute
    case ATTR_EXPLR_TMPL_B_PACING:
        l_attrSize = sizeof(ATTR_EXPLR_TMPL_B_PACING_type);
        break;

    // Get size for ATTR_EXPLR_SHRT_BACKOFF_TIMER attribute
    case ATTR_EXPLR_SHRT_BACKOFF_TIMER:
        l_attrSize = sizeof(ATTR_EXPLR_SHRT_BACKOFF_TIMER_type);
        break;

    // Get size for ATTR_EXPLR_METADATA_ENABLE attribute
    case ATTR_EXPLR_METADATA_ENABLE:
        l_attrSize = sizeof(ATTR_EXPLR_METADATA_ENABLE_type);
        break;

    // Get size for ATTR_EXPLR_PASID_BASE attribute
    case ATTR_EXPLR_PASID_BASE:
        l_attrSize = sizeof(ATTR_EXPLR_PASID_BASE_type);
        break;

    // Get size for ATTR_EXPLR_ACTAG_BASE attribute
    case ATTR_EXPLR_ACTAG_BASE:
        l_attrSize = sizeof(ATTR_EXPLR_ACTAG_BASE_type);
        break;

    // Get size for ATTR_EXPLR_AFU_ACTAG_LEN attribute
    case ATTR_EXPLR_AFU_ACTAG_LEN:
        l_attrSize = sizeof(ATTR_EXPLR_AFU_ACTAG_LEN_type);
        break;

    // Get size for ATTR_EXPLR_PASID_LEN attribute
    case ATTR_EXPLR_PASID_LEN:
        l_attrSize = sizeof(ATTR_EXPLR_PASID_LEN_type);
        break;

    // Get size for ATTR_IS_IBM_SIMULATION attribute
    case ATTR_IS_IBM_SIMULATION:
        l_attrSize = sizeof(ATTR_IS_IBM_SIMULATION_type);
        break;

    // Get size for ATTR_MSS_OCMB_ENTERPRISE_MODE attribute
    case ATTR_MSS_OCMB_ENTERPRISE_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_ENTERPRISE_MODE_type);
        break;

    // Get size for ATTR_MSS_OCMB_ENTERPRISE_POLICY attribute
    case ATTR_MSS_OCMB_ENTERPRISE_POLICY:
        l_attrSize = sizeof(ATTR_MSS_OCMB_ENTERPRISE_POLICY_type);
        break;

    // Get size for ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE attribute
    case ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE_type);
        break;

    // Get size for ATTR_MEM_EXP_INIT_VREF_DQ attribute
    case ATTR_MEM_EXP_INIT_VREF_DQ:
        l_attrSize = sizeof(ATTR_MEM_EXP_INIT_VREF_DQ_type);
        break;

    // Get size for ATTR_MEM_EXP_INIT_PHY_VREF attribute
    case ATTR_MEM_EXP_INIT_PHY_VREF:
        l_attrSize = sizeof(ATTR_MEM_EXP_INIT_PHY_VREF_type);
        break;

    // Get size for ATTR_MEM_EXP_RCD_DIC attribute
    case ATTR_MEM_EXP_RCD_DIC:
        l_attrSize = sizeof(ATTR_MEM_EXP_RCD_DIC_type);
        break;

    // Get size for ATTR_MEM_EXP_RCD_VOLTAGE_CTRL attribute
    case ATTR_MEM_EXP_RCD_VOLTAGE_CTRL:
        l_attrSize = sizeof(ATTR_MEM_EXP_RCD_VOLTAGE_CTRL_type);
        break;

    // Get size for ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING attribute
    case ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING:
        l_attrSize = sizeof(ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING_type);
        break;

    // Get size for ATTR_MEM_EXP_RCD_SLEW_RATE attribute
    case ATTR_MEM_EXP_RCD_SLEW_RATE:
        l_attrSize = sizeof(ATTR_MEM_EXP_RCD_SLEW_RATE_type);
        break;

    // Get size for ATTR_MEM_EXP_SPD_CL_SUPPORTED attribute
    case ATTR_MEM_EXP_SPD_CL_SUPPORTED:
        l_attrSize = sizeof(ATTR_MEM_EXP_SPD_CL_SUPPORTED_type);
        break;

    // Get size for ATTR_MEM_EXP_SPD_TAA_MIN attribute
    case ATTR_MEM_EXP_SPD_TAA_MIN:
        l_attrSize = sizeof(ATTR_MEM_EXP_SPD_TAA_MIN_type);
        break;

    // Get size for ATTR_MSS_EXP_REORDER_QUEUE_SETTING attribute
    case ATTR_MSS_EXP_REORDER_QUEUE_SETTING:
        l_attrSize = sizeof(ATTR_MSS_EXP_REORDER_QUEUE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE attribute
    case ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE:
        l_attrSize = sizeof(ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL attribute
    case ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN attribute
    case ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP attribute
    case ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_STRUCT_MMIO_WORD_SWAP_type);
        break;

    // Get size for ATTR_MSS_OCMB_ECID attribute
    case ATTR_MSS_OCMB_ECID:
        l_attrSize = sizeof(ATTR_MSS_OCMB_ECID_type);
        break;

    // Get size for ATTR_MEM_EXP_DFIMRL_CLK attribute
    case ATTR_MEM_EXP_DFIMRL_CLK:
        l_attrSize = sizeof(ATTR_MEM_EXP_DFIMRL_CLK_type);
        break;

    // Get size for ATTR_MEM_EFF_ATXDLY_A attribute
    case ATTR_MEM_EFF_ATXDLY_A:
        l_attrSize = sizeof(ATTR_MEM_EFF_ATXDLY_A_type);
        break;

    // Get size for ATTR_MEM_EFF_ATXDLY_B attribute
    case ATTR_MEM_EFF_ATXDLY_B:
        l_attrSize = sizeof(ATTR_MEM_EFF_ATXDLY_B_type);
        break;

    // Get size for ATTR_MSS_OCMB_PHY_INIT_MODE attribute
    case ATTR_MSS_OCMB_PHY_INIT_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_PHY_INIT_MODE_type);
        break;

    // Get size for ATTR_MSS_CHECK_FOR_READY_TIMEOUT attribute
    case ATTR_MSS_CHECK_FOR_READY_TIMEOUT:
        l_attrSize = sizeof(ATTR_MSS_CHECK_FOR_READY_TIMEOUT_type);
        break;

    // Get size for ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ attribute
    case ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ:
        l_attrSize = sizeof(ATTR_MSS_OCMB_DISABLE_THERM_INIT_READ_type);
        break;

    // Get size for ATTR_MSS_EXP_FW_API_VERSION attribute
    case ATTR_MSS_EXP_FW_API_VERSION:
        l_attrSize = sizeof(ATTR_MSS_EXP_FW_API_VERSION_type);
        break;

    // Get size for ATTR_MSS_EXP_FW_VERSION_A attribute
    case ATTR_MSS_EXP_FW_VERSION_A:
        l_attrSize = sizeof(ATTR_MSS_EXP_FW_VERSION_A_type);
        break;

    // Get size for ATTR_MSS_EXP_FW_VERSION_B attribute
    case ATTR_MSS_EXP_FW_VERSION_B:
        l_attrSize = sizeof(ATTR_MSS_EXP_FW_VERSION_B_type);
        break;

    // Get size for ATTR_MSS_EXP_FW_PARTITION_ID attribute
    case ATTR_MSS_EXP_FW_PARTITION_ID:
        l_attrSize = sizeof(ATTR_MSS_EXP_FW_PARTITION_ID_type);
        break;

    // Get size for ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A attribute
    case ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A:
        l_attrSize = sizeof(ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_A_type);
        break;

    // Get size for ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B attribute
    case ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B:
        l_attrSize = sizeof(ATTR_MSS_EXP_FW_FAILED_AUTHENTICATION_B_type);
        break;

    // Get size for ATTR_MSS_EXP_COMM_STATE attribute
    case ATTR_MSS_EXP_COMM_STATE:
        l_attrSize = sizeof(ATTR_MSS_EXP_COMM_STATE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC00 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC00:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC00_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC01 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC01:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC01_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC03 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC03:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC03_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC04 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC04:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC04_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC05 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC05:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC05_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC0B attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC0B:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC0B_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC0E attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC0E:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC0E_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC0F attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC0F:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC0F_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC1X attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC1X:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC1X_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F0RC7X attribute
    case ATTR_MSS_EXP_RESP_DDR4_F0RC7X:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F0RC7X_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F1RC00 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F1RC00:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F1RC00_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F1RC02 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F1RC02:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F1RC02_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F1RC03 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F1RC03:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F1RC03_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F1RC04 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F1RC04:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F1RC04_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DDR4_F1RC05 attribute
    case ATTR_MSS_EXP_RESP_DDR4_F1RC05:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DDR4_F1RC05_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_RBT attribute
    case ATTR_MSS_EXP_RESP_DRAM_RBT:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_RBT_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_TM attribute
    case ATTR_MSS_EXP_RESP_DRAM_TM:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_TM_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_DLL_RESET attribute
    case ATTR_MSS_EXP_RESP_DRAM_DLL_RESET:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_DLL_RESET_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH attribute
    case ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_BURST_LENGTH_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE attribute
    case ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_DLL_ENABLE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_ODIC attribute
    case ATTR_MSS_EXP_RESP_DRAM_ODIC:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_ODIC_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_AL attribute
    case ATTR_MSS_EXP_RESP_DRAM_AL:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_AL_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE attribute
    case ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_WR_LVL_ENABLE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_RTT_NOM attribute
    case ATTR_MSS_EXP_RESP_DRAM_RTT_NOM:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_RTT_NOM_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_RTT_PARK attribute
    case ATTR_MSS_EXP_RESP_DRAM_RTT_PARK:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_RTT_PARK_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_TDQS attribute
    case ATTR_MSS_EXP_RESP_DRAM_TDQS:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_TDQS_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER attribute
    case ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_OUTPUT_BUFFER_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_LPASR attribute
    case ATTR_MSS_EXP_RESP_DRAM_LPASR:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_LPASR_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DRAM_RTT_WR attribute
    case ATTR_MSS_EXP_RESP_DRAM_RTT_WR:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DRAM_RTT_WR_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_MPR_PAGE attribute
    case ATTR_MSS_EXP_RESP_MPR_PAGE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_MPR_PAGE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_MPR_MODE attribute
    case ATTR_MSS_EXP_RESP_MPR_MODE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_MPR_MODE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_GEARDOWN_MODE attribute
    case ATTR_MSS_EXP_RESP_GEARDOWN_MODE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_GEARDOWN_MODE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS attribute
    case ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_PER_DRAM_ACCESS_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_TEMP_READOUT attribute
    case ATTR_MSS_EXP_RESP_TEMP_READOUT:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_TEMP_READOUT_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_CRC_WR_LATENCY attribute
    case ATTR_MSS_EXP_RESP_CRC_WR_LATENCY:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_CRC_WR_LATENCY_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_MPR_RD_FORMAT attribute
    case ATTR_MSS_EXP_RESP_MPR_RD_FORMAT:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_MPR_RD_FORMAT_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE attribute
    case ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_MAX_POWERDOWN_MODE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR attribute
    case ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_INTERNAL_VREF_MONITOR_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_SELF_REF_ABORT attribute
    case ATTR_MSS_EXP_RESP_SELF_REF_ABORT:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_SELF_REF_ABORT_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN attribute
    case ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_RD_PREAMBLE_TRAIN_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_RD_PREAMBLE attribute
    case ATTR_MSS_EXP_RESP_RD_PREAMBLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_RD_PREAMBLE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_WR_PREAMBLE attribute
    case ATTR_MSS_EXP_RESP_WR_PREAMBLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_WR_PREAMBLE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR attribute
    case ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_CRC_ERROR_CLEAR_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS attribute
    case ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_CA_PARITY_ERROR_STATUS_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF attribute
    case ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_ODT_INPUT_BUFF_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_CA_PARITY attribute
    case ATTR_MSS_EXP_RESP_CA_PARITY:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_CA_PARITY_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_DATA_MASK attribute
    case ATTR_MSS_EXP_RESP_DATA_MASK:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_DATA_MASK_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_WRITE_DBI attribute
    case ATTR_MSS_EXP_RESP_WRITE_DBI:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_WRITE_DBI_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_READ_DBI attribute
    case ATTR_MSS_EXP_RESP_READ_DBI:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_READ_DBI_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE attribute
    case ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_VALUE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE attribute
    case ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_RANGE_type);
        break;

    // Get size for ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE attribute
    case ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_RESP_VREF_DQ_TRAIN_ENABLE_type);
        break;

    // Get size for ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE attribute
    case ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_CDR_BW_OVERRIDE_ENABLE_type);
        break;

    // Get size for ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE attribute
    case ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE:
        l_attrSize = sizeof(ATTR_MSS_EXP_CDR_BW_OVERRIDE_VALUE_type);
        break;

    // Get size for ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE attribute
    case ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE:
        l_attrSize = sizeof(ATTR_MSS_EXP_OMI_CDR_BW_OVERRIDE_type);
        break;

    // Get size for ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT attribute
    case ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT:
        l_attrSize = sizeof(ATTR_MSS_EXP_OMI_SETUP_POLL_COUNT_type);
        break;

    // Get size for ATTR_MSS_EXP_OMI_CDR_OFFSET attribute
    case ATTR_MSS_EXP_OMI_CDR_OFFSET:
        l_attrSize = sizeof(ATTR_MSS_EXP_OMI_CDR_OFFSET_type);
        break;

    // Get size for ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK attribute
    case ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK:
        l_attrSize = sizeof(ATTR_MSS_EXP_OMI_CDR_OFFSET_LANE_MASK_type);
        break;

    // Get size for ATTR_MSS_EXP_INTR_MASK_DISABLE attribute
    case ATTR_MSS_EXP_INTR_MASK_DISABLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_INTR_MASK_DISABLE_type);
        break;

    // Get size for ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE attribute
    case ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE:
        l_attrSize = sizeof(ATTR_MSS_EXP_I2C_FW_LOG_DUMP_DISABLE_type);
        break;

    // Get size for ATTR_MSS_EXP_SERIAL_NUMBER attribute
    case ATTR_MSS_EXP_SERIAL_NUMBER:
        l_attrSize = sizeof(ATTR_MSS_EXP_SERIAL_NUMBER_type);
        break;

    // Get size for ATTR_MEM_EFF_PSTATES attribute
    case ATTR_MEM_EFF_PSTATES:
        l_attrSize = sizeof(ATTR_MEM_EFF_PSTATES_type);
        break;

    // Get size for ATTR_MEM_EFF_FOUR_RANK_MODE attribute
    case ATTR_MEM_EFF_FOUR_RANK_MODE:
        l_attrSize = sizeof(ATTR_MEM_EFF_FOUR_RANK_MODE_type);
        break;

    // Get size for ATTR_MEM_EFF_MRAM_SUPPORT attribute
    case ATTR_MEM_EFF_MRAM_SUPPORT:
        l_attrSize = sizeof(ATTR_MEM_EFF_MRAM_SUPPORT_type);
        break;

    // Get size for ATTR_MEM_EFF_DDP_COMPATIBILITY attribute
    case ATTR_MEM_EFF_DDP_COMPATIBILITY:
        l_attrSize = sizeof(ATTR_MEM_EFF_DDP_COMPATIBILITY_type);
        break;

    // Get size for ATTR_MEM_EFF_TSV_8H_SUPPORT attribute
    case ATTR_MEM_EFF_TSV_8H_SUPPORT:
        l_attrSize = sizeof(ATTR_MEM_EFF_TSV_8H_SUPPORT_type);
        break;

    // Get size for ATTR_MEM_EFF_MDS_DDIMM attribute
    case ATTR_MEM_EFF_MDS_DDIMM:
        l_attrSize = sizeof(ATTR_MEM_EFF_MDS_DDIMM_type);
        break;

    // Get size for ATTR_OMI_DL_PREIPL_PRBS_TIME attribute
    case ATTR_OMI_DL_PREIPL_PRBS_TIME:
        l_attrSize = sizeof(ATTR_OMI_DL_PREIPL_PRBS_TIME_type);
        break;

    // Get size for ATTR_EXP_DATABUS_UTIL attribute
    case ATTR_EXP_DATABUS_UTIL:
        l_attrSize = sizeof(ATTR_EXP_DATABUS_UTIL_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY_type);
        break;

    // Get size for ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE attribute
    case ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE:
        l_attrSize = sizeof(ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE_type);
        break;

    // Get size for ATTR_OMI_FFE_SETTINGS_COMMAND attribute
    case ATTR_OMI_FFE_SETTINGS_COMMAND:
        l_attrSize = sizeof(ATTR_OMI_FFE_SETTINGS_COMMAND_type);
        break;

    // Get size for ATTR_OMI_FFE_PRE_CURSOR attribute
    case ATTR_OMI_FFE_PRE_CURSOR:
        l_attrSize = sizeof(ATTR_OMI_FFE_PRE_CURSOR_type);
        break;

    // Get size for ATTR_OMI_FFE_POST_CURSOR attribute
    case ATTR_OMI_FFE_POST_CURSOR:
        l_attrSize = sizeof(ATTR_OMI_FFE_POST_CURSOR_type);
        break;

    // Get size for ATTR_ODY_ENABLE_US_TMPL_1 attribute
    case ATTR_ODY_ENABLE_US_TMPL_1:
        l_attrSize = sizeof(ATTR_ODY_ENABLE_US_TMPL_1_type);
        break;

    // Get size for ATTR_ODY_ENABLE_US_TMPL_5 attribute
    case ATTR_ODY_ENABLE_US_TMPL_5:
        l_attrSize = sizeof(ATTR_ODY_ENABLE_US_TMPL_5_type);
        break;

    // Get size for ATTR_ODY_ENABLE_US_TMPL_9 attribute
    case ATTR_ODY_ENABLE_US_TMPL_9:
        l_attrSize = sizeof(ATTR_ODY_ENABLE_US_TMPL_9_type);
        break;

    // Get size for ATTR_ODY_ENABLE_US_TMPL_A attribute
    case ATTR_ODY_ENABLE_US_TMPL_A:
        l_attrSize = sizeof(ATTR_ODY_ENABLE_US_TMPL_A_type);
        break;

    // Get size for ATTR_ODY_ENABLE_US_TMPL_B attribute
    case ATTR_ODY_ENABLE_US_TMPL_B:
        l_attrSize = sizeof(ATTR_ODY_ENABLE_US_TMPL_B_type);
        break;

    // Get size for ATTR_ODY_TMPL_0_PACING attribute
    case ATTR_ODY_TMPL_0_PACING:
        l_attrSize = sizeof(ATTR_ODY_TMPL_0_PACING_type);
        break;

    // Get size for ATTR_ODY_TMPL_1_PACING attribute
    case ATTR_ODY_TMPL_1_PACING:
        l_attrSize = sizeof(ATTR_ODY_TMPL_1_PACING_type);
        break;

    // Get size for ATTR_ODY_TMPL_5_PACING attribute
    case ATTR_ODY_TMPL_5_PACING:
        l_attrSize = sizeof(ATTR_ODY_TMPL_5_PACING_type);
        break;

    // Get size for ATTR_ODY_TMPL_9_PACING attribute
    case ATTR_ODY_TMPL_9_PACING:
        l_attrSize = sizeof(ATTR_ODY_TMPL_9_PACING_type);
        break;

    // Get size for ATTR_ODY_TMPL_B_PACING attribute
    case ATTR_ODY_TMPL_B_PACING:
        l_attrSize = sizeof(ATTR_ODY_TMPL_B_PACING_type);
        break;

    // Get size for ATTR_ODY_SHRT_BACKOFF_TIMER attribute
    case ATTR_ODY_SHRT_BACKOFF_TIMER:
        l_attrSize = sizeof(ATTR_ODY_SHRT_BACKOFF_TIMER_type);
        break;

    // Get size for ATTR_ODY_METADATA_ENABLE attribute
    case ATTR_ODY_METADATA_ENABLE:
        l_attrSize = sizeof(ATTR_ODY_METADATA_ENABLE_type);
        break;

    // Get size for ATTR_ODY_PASID_BASE attribute
    case ATTR_ODY_PASID_BASE:
        l_attrSize = sizeof(ATTR_ODY_PASID_BASE_type);
        break;

    // Get size for ATTR_ODY_ACTAG_BASE attribute
    case ATTR_ODY_ACTAG_BASE:
        l_attrSize = sizeof(ATTR_ODY_ACTAG_BASE_type);
        break;

    // Get size for ATTR_ODY_AFU_ACTAG_LEN attribute
    case ATTR_ODY_AFU_ACTAG_LEN:
        l_attrSize = sizeof(ATTR_ODY_AFU_ACTAG_LEN_type);
        break;

    // Get size for ATTR_ODY_PASID_LEN attribute
    case ATTR_ODY_PASID_LEN:
        l_attrSize = sizeof(ATTR_ODY_PASID_LEN_type);
        break;

    // Get size for ATTR_SPPE_TARGET_STATE attribute
    case ATTR_SPPE_TARGET_STATE:
        l_attrSize = sizeof(ATTR_SPPE_TARGET_STATE_type);
        break;

    // Get size for ATTR_SPPE_I2C_DEV_ADDR attribute
    case ATTR_SPPE_I2C_DEV_ADDR:
        l_attrSize = sizeof(ATTR_SPPE_I2C_DEV_ADDR_type);
        break;

    // Get size for ATTR_SPPE_I2C_ENGINE attribute
    case ATTR_SPPE_I2C_ENGINE:
        l_attrSize = sizeof(ATTR_SPPE_I2C_ENGINE_type);
        break;

    // Get size for ATTR_SPPE_I2C_PORT attribute
    case ATTR_SPPE_I2C_PORT:
        l_attrSize = sizeof(ATTR_SPPE_I2C_PORT_type);
        break;

    // Get size for ATTR_SPPE_I2C_MAX_RETRY_COUNT attribute
    case ATTR_SPPE_I2C_MAX_RETRY_COUNT:
        l_attrSize = sizeof(ATTR_SPPE_I2C_MAX_RETRY_COUNT_type);
        break;

    // Get size for ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL attribute
    case ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL:
        l_attrSize = sizeof(ATTR_MSS_OCMB_ODY_OMI_CFG_ENDIAN_CTRL_type);
        break;

    // Get size for ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT attribute
    case ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT:
        l_attrSize = sizeof(ATTR_MSS_ODY_PASSED_SWIZZLE_DETECT_type);
        break;

    // Get size for ATTR_MSS_ODY_PHY_IMAGE_SELECT attribute
    case ATTR_MSS_ODY_PHY_IMAGE_SELECT:
        l_attrSize = sizeof(ATTR_MSS_ODY_PHY_IMAGE_SELECT_type);
        break;

    // Get size for ATTR_ODY_MSG_BLOCK_DATA_SOURCE attribute
    case ATTR_ODY_MSG_BLOCK_DATA_SOURCE:
        l_attrSize = sizeof(ATTR_ODY_MSG_BLOCK_DATA_SOURCE_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE attribute
    case ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_ERROR_ON_FAILURE_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_RECOVERY_ENABLE attribute
    case ATTR_ODY_DRAMINIT_RECOVERY_ENABLE:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_RECOVERY_ENABLE_type);
        break;

    // Get size for ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE attribute
    case ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE:
        l_attrSize = sizeof(ATTR_ODY_SWIZZLE_DETECT_FAIL_VALUE_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE attribute
    case ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_FIR_CHECK_ENABLE_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_STEP_ENABLE attribute
    case ATTR_ODY_DRAMINIT_STEP_ENABLE:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_STEP_ENABLE_type);
        break;

    // Get size for ATTR_ODY_SENSOR_POLLING_PERIOD_MS attribute
    case ATTR_ODY_SENSOR_POLLING_PERIOD_MS:
        l_attrSize = sizeof(ATTR_ODY_SENSOR_POLLING_PERIOD_MS_type);
        break;

    // Get size for ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT attribute
    case ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT:
        l_attrSize = sizeof(ATTR_ODY_SENSOR_POLLING_PERIOD_MS_INIT_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET attribute
    case ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_HALF_DIMM_TARGET_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_PERIOD attribute
    case ATTR_ODY_DQS_TRACKING_PERIOD:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_PERIOD_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_PERIOD_INIT attribute
    case ATTR_ODY_DQS_TRACKING_PERIOD_INIT:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_PERIOD_INIT_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD attribute
    case ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_TEMP_THRESHOLD_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD attribute
    case ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_COUNT_THRESHOLD_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL attribute
    case ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_COUNT_SINCE_LAST_RECAL_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_RECAL_COUNT attribute
    case ATTR_ODY_DQS_TRACKING_RECAL_COUNT:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_RECAL_COUNT_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_LOG attribute
    case ATTR_ODY_DQS_TRACKING_LOG:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_LOG_type);
        break;

    // Get size for ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE attribute
    case ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE:
        l_attrSize = sizeof(ATTR_ODY_THERMAL_SENSOR_DIFF_PREVIOUS_VALUE_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_SUSPENDED attribute
    case ATTR_ODY_DQS_TRACKING_SUSPENDED:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_SUSPENDED_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT attribute
    case ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_MISSED_QUIESCE_COUNT_type);
        break;

    // Get size for ATTR_ODY_DQS_TRACKING_FAILED attribute
    case ATTR_ODY_DQS_TRACKING_FAILED:
        l_attrSize = sizeof(ATTR_ODY_DQS_TRACKING_FAILED_type);
        break;

    // Get size for ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE attribute
    case ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE:
        l_attrSize = sizeof(ATTR_ODY_THERMAL_SENSOR_0_PREVIOUS_VALUE_type);
        break;

    // Get size for ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE attribute
    case ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE:
        l_attrSize = sizeof(ATTR_ODY_THERMAL_SENSOR_1_PREVIOUS_VALUE_type);
        break;

    // Get size for ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE attribute
    case ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE:
        l_attrSize = sizeof(ATTR_ODY_THERMAL_SENSOR_2_PREVIOUS_VALUE_type);
        break;

    // Get size for ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE attribute
    case ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE:
        l_attrSize = sizeof(ATTR_ODY_THERMAL_SENSOR_3_PREVIOUS_VALUE_type);
        break;

    // Get size for ATTR_ODY_SENSOR_READ_FIRST_FAIL attribute
    case ATTR_ODY_SENSOR_READ_FIRST_FAIL:
        l_attrSize = sizeof(ATTR_ODY_SENSOR_READ_FIRST_FAIL_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_VERBOSITY attribute
    case ATTR_ODY_DRAMINIT_VERBOSITY:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_VERBOSITY_type);
        break;

    // Get size for ATTR_PHY_GET_MAIL_TIMEOUT attribute
    case ATTR_PHY_GET_MAIL_TIMEOUT:
        l_attrSize = sizeof(ATTR_PHY_GET_MAIL_TIMEOUT_type);
        break;

    // Get size for ATTR_DRAMINIT_TRAINING_TIMEOUT attribute
    case ATTR_DRAMINIT_TRAINING_TIMEOUT:
        l_attrSize = sizeof(ATTR_DRAMINIT_TRAINING_TIMEOUT_type);
        break;

    // Get size for ATTR_MAIL_MESSAGE_BITMAP attribute
    case ATTR_MAIL_MESSAGE_BITMAP:
        l_attrSize = sizeof(ATTR_MAIL_MESSAGE_BITMAP_type);
        break;

    // Get size for ATTR_MEM_EFF_ARDPTRINITVAL attribute
    case ATTR_MEM_EFF_ARDPTRINITVAL:
        l_attrSize = sizeof(ATTR_MEM_EFF_ARDPTRINITVAL_type);
        break;

    // Get size for ATTR_MEM_EFF_ARDPTRINITVALOVR attribute
    case ATTR_MEM_EFF_ARDPTRINITVALOVR:
        l_attrSize = sizeof(ATTR_MEM_EFF_ARDPTRINITVALOVR_type);
        break;

    // Get size for ATTR_ODY_DIS_PTRINITCLR_TXTRACKING attribute
    case ATTR_ODY_DIS_PTRINITCLR_TXTRACKING:
        l_attrSize = sizeof(ATTR_ODY_DIS_PTRINITCLR_TXTRACKING_type);
        break;

    // Get size for ATTR_MEM_EFF_EXTCALRESVAL attribute
    case ATTR_MEM_EFF_EXTCALRESVAL:
        l_attrSize = sizeof(ATTR_MEM_EFF_EXTCALRESVAL_type);
        break;

    // Get size for ATTR_MEM_EFF_MEMALERTEN attribute
    case ATTR_MEM_EFF_MEMALERTEN:
        l_attrSize = sizeof(ATTR_MEM_EFF_MEMALERTEN_type);
        break;

    // Get size for ATTR_ODY_PHY_MSTRTRAIN_INTERVAL attribute
    case ATTR_ODY_PHY_MSTRTRAIN_INTERVAL:
        l_attrSize = sizeof(ATTR_ODY_PHY_MSTRTRAIN_INTERVAL_type);
        break;

    // Get size for ATTR_ODY_PHY_MSTRMAXREQTOACK attribute
    case ATTR_ODY_PHY_MSTRMAXREQTOACK:
        l_attrSize = sizeof(ATTR_ODY_PHY_MSTRMAXREQTOACK_type);
        break;

    // Get size for ATTR_ODY_PHY_MSTRCTRLMODE attribute
    case ATTR_ODY_PHY_MSTRCTRLMODE:
        l_attrSize = sizeof(ATTR_ODY_PHY_MSTRCTRLMODE_type);
        break;

    // Get size for ATTR_ODY_PHY_CALINTERVAL attribute
    case ATTR_ODY_PHY_CALINTERVAL:
        l_attrSize = sizeof(ATTR_ODY_PHY_CALINTERVAL_type);
        break;

    // Get size for ATTR_ODY_PHY_CALONCE attribute
    case ATTR_ODY_PHY_CALONCE:
        l_attrSize = sizeof(ATTR_ODY_PHY_CALONCE_type);
        break;

    // Get size for ATTR_ODY_IS_HIGHVDD attribute
    case ATTR_ODY_IS_HIGHVDD:
        l_attrSize = sizeof(ATTR_ODY_IS_HIGHVDD_type);
        break;

    // Get size for ATTR_ODY_EN_TDQS2DQ_TRACKING attribute
    case ATTR_ODY_EN_TDQS2DQ_TRACKING:
        l_attrSize = sizeof(ATTR_ODY_EN_TDQS2DQ_TRACKING_type);
        break;

    // Get size for ATTR_ODY_DQS_OSC_RUNTIME_SEL attribute
    case ATTR_ODY_DQS_OSC_RUNTIME_SEL:
        l_attrSize = sizeof(ATTR_ODY_DQS_OSC_RUNTIME_SEL_type);
        break;

    // Get size for ATTR_ODY_EN_RXDQS_TRACKING attribute
    case ATTR_ODY_EN_RXDQS_TRACKING:
        l_attrSize = sizeof(ATTR_ODY_EN_RXDQS_TRACKING_type);
        break;

    // Get size for ATTR_ODY_DISABLE_PMU_ECC attribute
    case ATTR_ODY_DISABLE_PMU_ECC:
        l_attrSize = sizeof(ATTR_ODY_DISABLE_PMU_ECC_type);
        break;

    // Get size for ATTR_ODY_ENABLE_MALERT_ASYNC attribute
    case ATTR_ODY_ENABLE_MALERT_ASYNC:
        l_attrSize = sizeof(ATTR_ODY_ENABLE_MALERT_ASYNC_type);
        break;

    // Get size for ATTR_ODY_ALERT_RECOV_ENABLE attribute
    case ATTR_ODY_ALERT_RECOV_ENABLE:
        l_attrSize = sizeof(ATTR_ODY_ALERT_RECOV_ENABLE_type);
        break;

    // Get size for ATTR_ODY_RST_RXTRK_STATE attribute
    case ATTR_ODY_RST_RXTRK_STATE:
        l_attrSize = sizeof(ATTR_ODY_RST_RXTRK_STATE_type);
        break;

    // Get size for ATTR_ODY_UPPERNIBBLE_OVERRIDE attribute
    case ATTR_ODY_UPPERNIBBLE_OVERRIDE:
        l_attrSize = sizeof(ATTR_ODY_UPPERNIBBLE_OVERRIDE_type);
        break;

    // Get size for ATTR_ODY_UPPERNIBBLE_TG attribute
    case ATTR_ODY_UPPERNIBBLE_TG:
        l_attrSize = sizeof(ATTR_ODY_UPPERNIBBLE_TG_type);
        break;

    // Get size for ATTR_ODY_DFIPHYUPDCNT attribute
    case ATTR_ODY_DFIPHYUPDCNT:
        l_attrSize = sizeof(ATTR_ODY_DFIPHYUPDCNT_type);
        break;

    // Get size for ATTR_ODY_DFIPHYUPDRESP attribute
    case ATTR_ODY_DFIPHYUPDRESP:
        l_attrSize = sizeof(ATTR_ODY_DFIPHYUPDRESP_type);
        break;

    // Get size for ATTR_ODY_SIM_TDQS2DQ attribute
    case ATTR_ODY_SIM_TDQS2DQ:
        l_attrSize = sizeof(ATTR_ODY_SIM_TDQS2DQ_type);
        break;

    // Get size for ATTR_ODY_SIM_TDQSCK attribute
    case ATTR_ODY_SIM_TDQSCK:
        l_attrSize = sizeof(ATTR_ODY_SIM_TDQSCK_type);
        break;

    // Get size for ATTR_ODY_SIM_TSTAOFF attribute
    case ATTR_ODY_SIM_TSTAOFF:
        l_attrSize = sizeof(ATTR_ODY_SIM_TSTAOFF_type);
        break;

    // Get size for ATTR_ODY_SIM_TPDM attribute
    case ATTR_ODY_SIM_TPDM:
        l_attrSize = sizeof(ATTR_ODY_SIM_TPDM_type);
        break;

    // Get size for ATTR_ODY_SIM_TCASL_OVERRIDE attribute
    case ATTR_ODY_SIM_TCASL_OVERRIDE:
        l_attrSize = sizeof(ATTR_ODY_SIM_TCASL_OVERRIDE_type);
        break;

    // Get size for ATTR_ODY_SIM_TCASL_ADD attribute
    case ATTR_ODY_SIM_TCASL_ADD:
        l_attrSize = sizeof(ATTR_ODY_SIM_TCASL_ADD_type);
        break;

    // Get size for ATTR_ODY_POWERDOWN_ANIBS attribute
    case ATTR_ODY_POWERDOWN_ANIBS:
        l_attrSize = sizeof(ATTR_ODY_POWERDOWN_ANIBS_type);
        break;

    // Get size for ATTR_ODY_LP2_PWRSAVINGS attribute
    case ATTR_ODY_LP2_PWRSAVINGS:
        l_attrSize = sizeof(ATTR_ODY_LP2_PWRSAVINGS_type);
        break;

    // Get size for ATTR_ODY_SPECIAL_OFFSET_VALUE attribute
    case ATTR_ODY_SPECIAL_OFFSET_VALUE:
        l_attrSize = sizeof(ATTR_ODY_SPECIAL_OFFSET_VALUE_type);
        break;

    // Get size for ATTR_ODY_ADV_TRAIN_OPT attribute
    case ATTR_ODY_ADV_TRAIN_OPT:
        l_attrSize = sizeof(ATTR_ODY_ADV_TRAIN_OPT_type);
        break;

    // Get size for ATTR_ODY_MSG_MISC attribute
    case ATTR_ODY_MSG_MISC:
        l_attrSize = sizeof(ATTR_ODY_MSG_MISC_type);
        break;

    // Get size for ATTR_ODY_PLL_BYPASS_EN attribute
    case ATTR_ODY_PLL_BYPASS_EN:
        l_attrSize = sizeof(ATTR_ODY_PLL_BYPASS_EN_type);
        break;

    // Get size for ATTR_ODY_RX2D_DFE_MISC attribute
    case ATTR_ODY_RX2D_DFE_MISC:
        l_attrSize = sizeof(ATTR_ODY_RX2D_DFE_MISC_type);
        break;

    // Get size for ATTR_ODY_D5MISC attribute
    case ATTR_ODY_D5MISC:
        l_attrSize = sizeof(ATTR_ODY_D5MISC_type);
        break;

    // Get size for ATTR_ODY_WL_ADJ attribute
    case ATTR_ODY_WL_ADJ:
        l_attrSize = sizeof(ATTR_ODY_WL_ADJ_type);
        break;

    // Get size for ATTR_ODY_SEQUENCE_CTRL attribute
    case ATTR_ODY_SEQUENCE_CTRL:
        l_attrSize = sizeof(ATTR_ODY_SEQUENCE_CTRL_type);
        break;

    // Get size for ATTR_ODY_PHY_CFG attribute
    case ATTR_ODY_PHY_CFG:
        l_attrSize = sizeof(ATTR_ODY_PHY_CFG_type);
        break;

    // Get size for ATTR_ODY_PHY_DFIMRL_MARGIN attribute
    case ATTR_ODY_PHY_DFIMRL_MARGIN:
        l_attrSize = sizeof(ATTR_ODY_PHY_DFIMRL_MARGIN_type);
        break;

    // Get size for ATTR_ODY_PHY_USE_BROADCAST_MR attribute
    case ATTR_ODY_PHY_USE_BROADCAST_MR:
        l_attrSize = sizeof(ATTR_ODY_PHY_USE_BROADCAST_MR_type);
        break;

    // Get size for ATTR_ODY_PHY_DISABLED_DBYTE attribute
    case ATTR_ODY_PHY_DISABLED_DBYTE:
        l_attrSize = sizeof(ATTR_ODY_PHY_DISABLED_DBYTE_type);
        break;

    // Get size for ATTR_ODY_PHY_CA_TRAIN_OPTIONS attribute
    case ATTR_ODY_PHY_CA_TRAIN_OPTIONS:
        l_attrSize = sizeof(ATTR_ODY_PHY_CA_TRAIN_OPTIONS_type);
        break;

    // Get size for ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS attribute
    case ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS:
        l_attrSize = sizeof(ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS_type);
        break;

    // Get size for ATTR_ODY_PHY_TX2D_DFE_MISC attribute
    case ATTR_ODY_PHY_TX2D_DFE_MISC:
        l_attrSize = sizeof(ATTR_ODY_PHY_TX2D_DFE_MISC_type);
        break;

    // Get size for ATTR_ODY_PHY_RX2D_TRAIN_OPT attribute
    case ATTR_ODY_PHY_RX2D_TRAIN_OPT:
        l_attrSize = sizeof(ATTR_ODY_PHY_RX2D_TRAIN_OPT_type);
        break;

    // Get size for ATTR_ODY_PHY_TX2D_TRAIN_OPT attribute
    case ATTR_ODY_PHY_TX2D_TRAIN_OPT:
        l_attrSize = sizeof(ATTR_ODY_PHY_TX2D_TRAIN_OPT_type);
        break;

    // Get size for ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS attribute
    case ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS:
        l_attrSize = sizeof(ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS_type);
        break;

    // Get size for ATTR_ODY_PHY_CONFIG_OVERRIDE attribute
    case ATTR_ODY_PHY_CONFIG_OVERRIDE:
        l_attrSize = sizeof(ATTR_ODY_PHY_CONFIG_OVERRIDE_type);
        break;

    // Get size for ATTR_ODY_PHY_ENABLED_DQ_CHA attribute
    case ATTR_ODY_PHY_ENABLED_DQ_CHA:
        l_attrSize = sizeof(ATTR_ODY_PHY_ENABLED_DQ_CHA_type);
        break;

    // Get size for ATTR_ODY_PHY_ENABLED_DQ_CHB attribute
    case ATTR_ODY_PHY_ENABLED_DQ_CHB:
        l_attrSize = sizeof(ATTR_ODY_PHY_ENABLED_DQ_CHB_type);
        break;

    // Get size for ATTR_ODY_TX_IMPEDANCE_CTRL1 attribute
    case ATTR_ODY_TX_IMPEDANCE_CTRL1:
        l_attrSize = sizeof(ATTR_ODY_TX_IMPEDANCE_CTRL1_type);
        break;

    // Get size for ATTR_ODY_TX_IMPEDANCE_CTRL2 attribute
    case ATTR_ODY_TX_IMPEDANCE_CTRL2:
        l_attrSize = sizeof(ATTR_ODY_TX_IMPEDANCE_CTRL2_type);
        break;

    // Get size for ATTR_ODY_MRR_ODT_TERM attribute
    case ATTR_ODY_MRR_ODT_TERM:
        l_attrSize = sizeof(ATTR_ODY_MRR_ODT_TERM_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_FW_REVISION attribute
    case ATTR_ODY_DRAMINIT_FW_REVISION:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_FW_REVISION_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0 attribute
    case ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1 attribute
    case ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1_type);
        break;

    // Get size for ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET attribute
    case ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET:
        l_attrSize = sizeof(ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET_type);
        break;

    // Get size for ATTR_ODY_DMEM_FIRST_LOAD attribute
    case ATTR_ODY_DMEM_FIRST_LOAD:
        l_attrSize = sizeof(ATTR_ODY_DMEM_FIRST_LOAD_type);
        break;

    // Get size for ATTR_ODY_PSRO attribute
    case ATTR_ODY_PSRO:
        l_attrSize = sizeof(ATTR_ODY_PSRO_type);
        break;

    // Get size for ATTR_ODY_SETUP_SAFEMODE_THROTTLES attribute
    case ATTR_ODY_SETUP_SAFEMODE_THROTTLES:
        l_attrSize = sizeof(ATTR_ODY_SETUP_SAFEMODE_THROTTLES_type);
        break;

    // Get size for ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0 attribute
    case ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0:
        l_attrSize = sizeof(ATTR_ODY_DISABLE_DRAM_WITH_BAD_DQ0_type);
        break;

    // Get size for ATTR_OMI_RX_LANES attribute
    case ATTR_OMI_RX_LANES:
        l_attrSize = sizeof(ATTR_OMI_RX_LANES_type);
        break;

    // Get size for ATTR_OMI_TX_LANES attribute
    case ATTR_OMI_TX_LANES:
        l_attrSize = sizeof(ATTR_OMI_TX_LANES_type);
        break;

    // Get size for ATTR_OMI_BIST_ESD_TEST attribute
    case ATTR_OMI_BIST_ESD_TEST:
        l_attrSize = sizeof(ATTR_OMI_BIST_ESD_TEST_type);
        break;

    // Get size for ATTR_OMI_BIST_DAC_TEST attribute
    case ATTR_OMI_BIST_DAC_TEST:
        l_attrSize = sizeof(ATTR_OMI_BIST_DAC_TEST_type);
        break;

    // Get size for ATTR_OMI_BIST_TIMER attribute
    case ATTR_OMI_BIST_TIMER:
        l_attrSize = sizeof(ATTR_OMI_BIST_TIMER_type);
        break;

    // Get size for ATTR_OMI_CHANNEL_LENGTH attribute
    case ATTR_OMI_CHANNEL_LENGTH:
        l_attrSize = sizeof(ATTR_OMI_CHANNEL_LENGTH_type);
        break;

    // Get size for ATTR_OMI_RX_LTEG attribute
    case ATTR_OMI_RX_LTEG:
        l_attrSize = sizeof(ATTR_OMI_RX_LTEG_type);
        break;

    // Get size for ATTR_OMI_RX_LTEZ attribute
    case ATTR_OMI_RX_LTEZ:
        l_attrSize = sizeof(ATTR_OMI_RX_LTEZ_type);
        break;

    // Get size for ATTR_OMI_TX_PRE1 attribute
    case ATTR_OMI_TX_PRE1:
        l_attrSize = sizeof(ATTR_OMI_TX_PRE1_type);
        break;

    // Get size for ATTR_OMI_TX_PRE2 attribute
    case ATTR_OMI_TX_PRE2:
        l_attrSize = sizeof(ATTR_OMI_TX_PRE2_type);
        break;

    // Get size for ATTR_OMI_TX_POST attribute
    case ATTR_OMI_TX_POST:
        l_attrSize = sizeof(ATTR_OMI_TX_POST_type);
        break;

    // Get size for ATTR_OMI_RX_VERT_OFFSET attribute
    case ATTR_OMI_RX_VERT_OFFSET:
        l_attrSize = sizeof(ATTR_OMI_RX_VERT_OFFSET_type);
        break;

    // Get size for ATTR_OMI_RX_HORIZ_DATA_OFFSET attribute
    case ATTR_OMI_RX_HORIZ_DATA_OFFSET:
        l_attrSize = sizeof(ATTR_OMI_RX_HORIZ_DATA_OFFSET_type);
        break;

    // Get size for ATTR_OMI_RX_HORIZ_EDGE_OFFSET attribute
    case ATTR_OMI_RX_HORIZ_EDGE_OFFSET:
        l_attrSize = sizeof(ATTR_OMI_RX_HORIZ_EDGE_OFFSET_type);
        break;

    // Get size for ATTR_OMI_EDPL attribute
    case ATTR_OMI_EDPL:
        l_attrSize = sizeof(ATTR_OMI_EDPL_type);
        break;

    // Get size for ATTR_HOTPLUG attribute
    case ATTR_HOTPLUG:
        l_attrSize = sizeof(ATTR_HOTPLUG_type);
        break;

    // Get size for ATTR_HOTPLUG_MASK attribute
    case ATTR_HOTPLUG_MASK:
        l_attrSize = sizeof(ATTR_HOTPLUG_MASK_type);
        break;

    // Get size for ATTR_OCMB_REL_POS attribute
    case ATTR_OCMB_REL_POS:
        l_attrSize = sizeof(ATTR_OCMB_REL_POS_type);
        break;

    // Get size for ATTR_OCMB_PLL_BUCKET attribute
    case ATTR_OCMB_PLL_BUCKET:
        l_attrSize = sizeof(ATTR_OCMB_PLL_BUCKET_type);
        break;

    // Get size for ATTR_OCMB_PLL_BUCKET_SIM attribute
    case ATTR_OCMB_PLL_BUCKET_SIM:
        l_attrSize = sizeof(ATTR_OCMB_PLL_BUCKET_SIM_type);
        break;

    // Get size for ATTR_SIM_CHIPLET_MASK attribute
    case ATTR_SIM_CHIPLET_MASK:
        l_attrSize = sizeof(ATTR_SIM_CHIPLET_MASK_type);
        break;

    // Get size for ATTR_SCAN0_SCAN_RATIO attribute
    case ATTR_SCAN0_SCAN_RATIO:
        l_attrSize = sizeof(ATTR_SCAN0_SCAN_RATIO_type);
        break;

    // Get size for ATTR_SPPE_BOOT_SIDE attribute
    case ATTR_SPPE_BOOT_SIDE:
        l_attrSize = sizeof(ATTR_SPPE_BOOT_SIDE_type);
        break;

    // Get size for ATTR_OCMB_BOOT_FLAGS attribute
    case ATTR_OCMB_BOOT_FLAGS:
        l_attrSize = sizeof(ATTR_OCMB_BOOT_FLAGS_type);
        break;

    // Get size for ATTR_ENABLE_LBIST attribute
    case ATTR_ENABLE_LBIST:
        l_attrSize = sizeof(ATTR_ENABLE_LBIST_type);
        break;

    // Get size for ATTR_ENABLE_ABIST attribute
    case ATTR_ENABLE_ABIST:
        l_attrSize = sizeof(ATTR_ENABLE_ABIST_type);
        break;

    // Get size for ATTR_SECURITY_LEVEL attribute
    case ATTR_SECURITY_LEVEL:
        l_attrSize = sizeof(ATTR_SECURITY_LEVEL_type);
        break;

    // Get size for ATTR_RTG_SCAN_ORDER attribute
    case ATTR_RTG_SCAN_ORDER:
        l_attrSize = sizeof(ATTR_RTG_SCAN_ORDER_type);
        break;

    // Get size for ATTR_MEM_PMIC_4U_N_MODE attribute
    case ATTR_MEM_PMIC_4U_N_MODE:
        l_attrSize = sizeof(ATTR_MEM_PMIC_4U_N_MODE_type);
        break;

    // Get size for ATTR_MEM_PMIC_FORCE_N_MODE attribute
    case ATTR_MEM_PMIC_FORCE_N_MODE:
        l_attrSize = sizeof(ATTR_MEM_PMIC_FORCE_N_MODE_type);
        break;

    // Get size for ATTR_I2C_FAIL_COUNT attribute
    case ATTR_I2C_FAIL_COUNT:
        l_attrSize = sizeof(ATTR_I2C_FAIL_COUNT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_MFG_ID attribute
    case ATTR_MEM_EFF_PMIC0_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40 attribute
    case ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG0_R40_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41 attribute
    case ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG1_R41_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42 attribute
    case ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG2_R42_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43 attribute
    case ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SEQUENCE_CFG3_R43_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_MFG_ID attribute
    case ATTR_MEM_EFF_PMIC1_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40 attribute
    case ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG0_R40_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41 attribute
    case ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG1_R41_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42 attribute
    case ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG2_R42_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43 attribute
    case ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SEQUENCE_CFG3_R43_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_MFG_ID attribute
    case ATTR_MEM_EFF_PMIC2_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40 attribute
    case ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG0_R40_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41 attribute
    case ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG1_R41_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42 attribute
    case ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG2_R42_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43 attribute
    case ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SEQUENCE_CFG3_R43_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_MFG_ID attribute
    case ATTR_MEM_EFF_PMIC3_MFG_ID:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_MFG_ID_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40 attribute
    case ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG0_R40_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41 attribute
    case ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG1_R41_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42 attribute
    case ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG2_R42_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING attribute
    case ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_SETTING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT attribute
    case ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_RANGE_SELECT_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET attribute
    case ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_VOLTAGE_COARSE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY attribute
    case ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_DELAY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER attribute
    case ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_SEQUENCE_ORDER_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43 attribute
    case ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SEQUENCE_CFG3_R43_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_REDUNDANCY attribute
    case ATTR_MEM_EFF_PMIC0_REDUNDANCY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_REDUNDANCY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_REVISION attribute
    case ATTR_MEM_EFF_PMIC0_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_PHASE_COMB attribute
    case ATTR_MEM_EFF_PMIC0_PHASE_COMB:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_PHASE_COMB_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SEQUENCE attribute
    case ATTR_MEM_EFF_PMIC0_SEQUENCE:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SEQUENCE_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC0_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC0_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC0_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC0_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWA_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWB_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWC_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC0_SWD_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_REDUNDANCY attribute
    case ATTR_MEM_EFF_PMIC1_REDUNDANCY:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_REDUNDANCY_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_REVISION attribute
    case ATTR_MEM_EFF_PMIC1_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_PHASE_COMB attribute
    case ATTR_MEM_EFF_PMIC1_PHASE_COMB:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_PHASE_COMB_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SEQUENCE attribute
    case ATTR_MEM_EFF_PMIC1_SEQUENCE:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SEQUENCE_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC1_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC1_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC1_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC1_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWA_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWB_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWC_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC1_SWD_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_REVISION attribute
    case ATTR_MEM_EFF_PMIC2_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_PHASE_COMB attribute
    case ATTR_MEM_EFF_PMIC2_PHASE_COMB:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_PHASE_COMB_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SEQUENCE attribute
    case ATTR_MEM_EFF_PMIC2_SEQUENCE:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SEQUENCE_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC2_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC2_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC2_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC2_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWA_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWB_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWC_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC2_SWD_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_REVISION attribute
    case ATTR_MEM_EFF_PMIC3_REVISION:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_REVISION_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_PHASE_COMB attribute
    case ATTR_MEM_EFF_PMIC3_PHASE_COMB:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_PHASE_COMB_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SEQUENCE attribute
    case ATTR_MEM_EFF_PMIC3_SEQUENCE:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SEQUENCE_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC3_SWA_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC3_SWB_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC3_SWC_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET attribute
    case ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET:
        l_attrSize = sizeof(ATTR_MEM_EFF_EFD_PMIC3_SWD_VOLTAGE_OFFSET_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWA_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWB_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWC_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING attribute
    case ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING:
        l_attrSize = sizeof(ATTR_MEM_EFF_PMIC3_SWD_CURRENT_WARNING_type);
        break;

    // Get size for ATTR_FREQ_PB_MHZ attribute
    case ATTR_FREQ_PB_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_PB_MHZ_type);
        break;

    // Get size for ATTR_FREQ_X_MHZ attribute
    case ATTR_FREQ_X_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_X_MHZ_type);
        break;

    // Get size for ATTR_MC_SYNC_MODE attribute
    case ATTR_MC_SYNC_MODE:
        l_attrSize = sizeof(ATTR_MC_SYNC_MODE_type);
        break;

    // Get size for ATTR_FREQ_CORE_NOMINAL_MHZ attribute
    case ATTR_FREQ_CORE_NOMINAL_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_CORE_NOMINAL_MHZ_type);
        break;

    // Get size for ATTR_BOOT_FREQ_MHZ attribute
    case ATTR_BOOT_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_BOOT_FREQ_MHZ_type);
        break;

    // Get size for ATTR_RISK_LEVEL attribute
    case ATTR_RISK_LEVEL:
        l_attrSize = sizeof(ATTR_RISK_LEVEL_type);
        break;

    // Get size for ATTR_PM_RESET_FFDC_ENABLE attribute
    case ATTR_PM_RESET_FFDC_ENABLE:
        l_attrSize = sizeof(ATTR_PM_RESET_FFDC_ENABLE_type);
        break;

    // Get size for ATTR_PROC_EFF_FABRIC_GROUP_ID attribute
    case ATTR_PROC_EFF_FABRIC_GROUP_ID:
        l_attrSize = sizeof(ATTR_PROC_EFF_FABRIC_GROUP_ID_type);
        break;

    // Get size for ATTR_HB_HRMOR_BYTES attribute
    case ATTR_HB_HRMOR_BYTES:
        l_attrSize = sizeof(ATTR_HB_HRMOR_BYTES_type);
        break;

    // Get size for ATTR_PROC_EFF_FABRIC_CHIP_ID attribute
    case ATTR_PROC_EFF_FABRIC_CHIP_ID:
        l_attrSize = sizeof(ATTR_PROC_EFF_FABRIC_CHIP_ID_type);
        break;

    // Get size for ATTR_FREQ_O_MHZ attribute
    case ATTR_FREQ_O_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_O_MHZ_type);
        break;

    // Get size for ATTR_OPTICS_CONFIG_MODE attribute
    case ATTR_OPTICS_CONFIG_MODE:
        l_attrSize = sizeof(ATTR_OPTICS_CONFIG_MODE_type);
        break;

    // Get size for ATTR_MSS_RDVREF_CAL_ENABLE attribute
    case ATTR_MSS_RDVREF_CAL_ENABLE:
        l_attrSize = sizeof(ATTR_MSS_RDVREF_CAL_ENABLE_type);
        break;

    // Get size for ATTR_SKIP_HW_VREF_CAL attribute
    case ATTR_SKIP_HW_VREF_CAL:
        l_attrSize = sizeof(ATTR_SKIP_HW_VREF_CAL_type);
        break;

    // Get size for ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE attribute
    case ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE:
        l_attrSize = sizeof(ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE_type);
        break;

    // Get size for ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE attribute
    case ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE:
        l_attrSize = sizeof(ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE_type);
        break;

    // Get size for ATTR_PERF_24x7_INVOCATION_TIME_MS attribute
    case ATTR_PERF_24x7_INVOCATION_TIME_MS:
        l_attrSize = sizeof(ATTR_PERF_24x7_INVOCATION_TIME_MS_type);
        break;

    // Get size for ATTR_CME_INSTRUCTION_TRACE_ENABLE attribute
    case ATTR_CME_INSTRUCTION_TRACE_ENABLE:
        l_attrSize = sizeof(ATTR_CME_INSTRUCTION_TRACE_ENABLE_type);
        break;

    // Get size for ATTR_SYS_VFRT_STATIC_DATA_ENABLE attribute
    case ATTR_SYS_VFRT_STATIC_DATA_ENABLE:
        l_attrSize = sizeof(ATTR_SYS_VFRT_STATIC_DATA_ENABLE_type);
        break;

    // Get size for ATTR_IO_OBUS_DCCAL_FLAGS attribute
    case ATTR_IO_OBUS_DCCAL_FLAGS:
        l_attrSize = sizeof(ATTR_IO_OBUS_DCCAL_FLAGS_type);
        break;

    // Get size for ATTR_IO_O_DEBUG attribute
    case ATTR_IO_O_DEBUG:
        l_attrSize = sizeof(ATTR_IO_O_DEBUG_type);
        break;

    // Get size for ATTR_IO_OBUS_TX_MARGIN_RATIO attribute
    case ATTR_IO_OBUS_TX_MARGIN_RATIO:
        l_attrSize = sizeof(ATTR_IO_OBUS_TX_MARGIN_RATIO_type);
        break;

    // Get size for ATTR_IO_OBUS_TX_FFE_PRECURSOR attribute
    case ATTR_IO_OBUS_TX_FFE_PRECURSOR:
        l_attrSize = sizeof(ATTR_IO_OBUS_TX_FFE_PRECURSOR_type);
        break;

    // Get size for ATTR_IO_OBUS_TX_FFE_POSTCURSOR attribute
    case ATTR_IO_OBUS_TX_FFE_POSTCURSOR:
        l_attrSize = sizeof(ATTR_IO_OBUS_TX_FFE_POSTCURSOR_type);
        break;

    // Get size for ATTR_EFF_RANK_GROUP_OVERRIDE attribute
    case ATTR_EFF_RANK_GROUP_OVERRIDE:
        l_attrSize = sizeof(ATTR_EFF_RANK_GROUP_OVERRIDE_type);
        break;

    // Get size for ATTR_IO_X_MFG_CHK attribute
    case ATTR_IO_X_MFG_CHK:
        l_attrSize = sizeof(ATTR_IO_X_MFG_CHK_type);
        break;

    // Get size for ATTR_IO_X_MFG_MIN_EYE_WIDTH attribute
    case ATTR_IO_X_MFG_MIN_EYE_WIDTH:
        l_attrSize = sizeof(ATTR_IO_X_MFG_MIN_EYE_WIDTH_type);
        break;

    // Get size for ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN attribute
    case ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN:
        l_attrSize = sizeof(ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN_type);
        break;

    // Get size for ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD attribute
    case ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD:
        l_attrSize = sizeof(ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD_type);
        break;

    // Get size for ATTR_CME_CHTM_TRACE_ENABLE attribute
    case ATTR_CME_CHTM_TRACE_ENABLE:
        l_attrSize = sizeof(ATTR_CME_CHTM_TRACE_ENABLE_type);
        break;

    // Get size for ATTR_CME_CHTM_TRACE_MEMORY_CONFIG attribute
    case ATTR_CME_CHTM_TRACE_MEMORY_CONFIG:
        l_attrSize = sizeof(ATTR_CME_CHTM_TRACE_MEMORY_CONFIG_type);
        break;

    // Get size for ATTR_SYSTEM_VDM_DISABLE attribute
    case ATTR_SYSTEM_VDM_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_VDM_DISABLE_type);
        break;

    // Get size for ATTR_VDM_ENABLED attribute
    case ATTR_VDM_ENABLED:
        l_attrSize = sizeof(ATTR_VDM_ENABLED_type);
        break;

    // Get size for ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA attribute
    case ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA:
        l_attrSize = sizeof(ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA_type);
        break;

    // Get size for ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA attribute
    case ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA:
        l_attrSize = sizeof(ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA_type);
        break;

    // Get size for ATTR_SYSTEM_IVRM_DISABLE attribute
    case ATTR_SYSTEM_IVRM_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_IVRM_DISABLE_type);
        break;

    // Get size for ATTR_IVRM_ENABLED attribute
    case ATTR_IVRM_ENABLED:
        l_attrSize = sizeof(ATTR_IVRM_ENABLED_type);
        break;

    // Get size for ATTR_WOF_ENABLE_FRATIO attribute
    case ATTR_WOF_ENABLE_FRATIO:
        l_attrSize = sizeof(ATTR_WOF_ENABLE_FRATIO_type);
        break;

    // Get size for ATTR_WOF_ENABLE_VRATIO attribute
    case ATTR_WOF_ENABLE_VRATIO:
        l_attrSize = sizeof(ATTR_WOF_ENABLE_VRATIO_type);
        break;

    // Get size for ATTR_WOF_VRATIO_SELECT attribute
    case ATTR_WOF_VRATIO_SELECT:
        l_attrSize = sizeof(ATTR_WOF_VRATIO_SELECT_type);
        break;

    // Get size for ATTR_NEST_LEAKAGE_PERCENT attribute
    case ATTR_NEST_LEAKAGE_PERCENT:
        l_attrSize = sizeof(ATTR_NEST_LEAKAGE_PERCENT_type);
        break;

    // Get size for ATTR_MSS_RUN_DCD_CALIBRATION attribute
    case ATTR_MSS_RUN_DCD_CALIBRATION:
        l_attrSize = sizeof(ATTR_MSS_RUN_DCD_CALIBRATION_type);
        break;

    // Get size for ATTR_MSS_EFF_WR_CRC attribute
    case ATTR_MSS_EFF_WR_CRC:
        l_attrSize = sizeof(ATTR_MSS_EFF_WR_CRC_type);
        break;

    // Get size for ATTR_IO_O_MFG_CHK attribute
    case ATTR_IO_O_MFG_CHK:
        l_attrSize = sizeof(ATTR_IO_O_MFG_CHK_type);
        break;

    // Get size for ATTR_IO_O_MFG_MIN_EYE_WIDTH attribute
    case ATTR_IO_O_MFG_MIN_EYE_WIDTH:
        l_attrSize = sizeof(ATTR_IO_O_MFG_MIN_EYE_WIDTH_type);
        break;

    // Get size for ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE attribute
    case ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE_type);
        break;

    // Get size for ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE attribute
    case ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE:
        l_attrSize = sizeof(ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE_type);
        break;

    // Get size for ATTR_EQ_INSIDE_SPECIAL_WAKEUP attribute
    case ATTR_EQ_INSIDE_SPECIAL_WAKEUP:
        l_attrSize = sizeof(ATTR_EQ_INSIDE_SPECIAL_WAKEUP_type);
        break;

    // Get size for ATTR_MSS_VPD_MT_MC_BIAS_TRIM attribute
    case ATTR_MSS_VPD_MT_MC_BIAS_TRIM:
        l_attrSize = sizeof(ATTR_MSS_VPD_MT_MC_BIAS_TRIM_type);
        break;

    // Get size for ATTR_EX_INSIDE_SPECIAL_WAKEUP attribute
    case ATTR_EX_INSIDE_SPECIAL_WAKEUP:
        l_attrSize = sizeof(ATTR_EX_INSIDE_SPECIAL_WAKEUP_type);
        break;

    // Get size for ATTR_IO_XBUS_CHAN_EQ attribute
    case ATTR_IO_XBUS_CHAN_EQ:
        l_attrSize = sizeof(ATTR_IO_XBUS_CHAN_EQ_type);
        break;

    // Get size for ATTR_IO_O_CHANNEL_TYPE attribute
    case ATTR_IO_O_CHANNEL_TYPE:
        l_attrSize = sizeof(ATTR_IO_O_CHANNEL_TYPE_type);
        break;

    // Get size for ATTR_NEST_PLL_BUCKET attribute
    case ATTR_NEST_PLL_BUCKET:
        l_attrSize = sizeof(ATTR_NEST_PLL_BUCKET_type);
        break;

    // Get size for ATTR_AFFINITY_PATH attribute
    case ATTR_AFFINITY_PATH:
        l_attrSize = sizeof(ATTR_AFFINITY_PATH_type);
        break;

    // Get size for ATTR_ALLOW_EEPROM_WRITES attribute
    case ATTR_ALLOW_EEPROM_WRITES:
        l_attrSize = sizeof(ATTR_ALLOW_EEPROM_WRITES_type);
        break;

    // Get size for ATTR_ALL_MCS_IN_INTERLEAVING_GROUP attribute
    case ATTR_ALL_MCS_IN_INTERLEAVING_GROUP:
        l_attrSize = sizeof(ATTR_ALL_MCS_IN_INTERLEAVING_GROUP_type);
        break;

    // Get size for ATTR_ALTFSI_MASTER_CHIP attribute
    case ATTR_ALTFSI_MASTER_CHIP:
        l_attrSize = sizeof(ATTR_ALTFSI_MASTER_CHIP_type);
        break;

    // Get size for ATTR_ALTFSI_MASTER_PORT attribute
    case ATTR_ALTFSI_MASTER_PORT:
        l_attrSize = sizeof(ATTR_ALTFSI_MASTER_PORT_type);
        break;

    // Get size for ATTR_ASYNC_NEST_FREQ_MHZ attribute
    case ATTR_ASYNC_NEST_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_ASYNC_NEST_FREQ_MHZ_type);
        break;

    // Get size for ATTR_ATTN_AREA_1_ADDR attribute
    case ATTR_ATTN_AREA_1_ADDR:
        l_attrSize = sizeof(ATTR_ATTN_AREA_1_ADDR_type);
        break;

    // Get size for ATTR_ATTN_AREA_2_ADDR attribute
    case ATTR_ATTN_AREA_2_ADDR:
        l_attrSize = sizeof(ATTR_ATTN_AREA_2_ADDR_type);
        break;

    // Get size for ATTR_AVDD_ID attribute
    case ATTR_AVDD_ID:
        l_attrSize = sizeof(ATTR_AVDD_ID_type);
        break;

    // Get size for ATTR_BLOCK_SPEC_DECONFIG attribute
    case ATTR_BLOCK_SPEC_DECONFIG:
        l_attrSize = sizeof(ATTR_BLOCK_SPEC_DECONFIG_type);
        break;

    // Get size for ATTR_BMC_FRU_ID attribute
    case ATTR_BMC_FRU_ID:
        l_attrSize = sizeof(ATTR_BMC_FRU_ID_type);
        break;

    // Get size for ATTR_CDM_DOMAIN attribute
    case ATTR_CDM_DOMAIN:
        l_attrSize = sizeof(ATTR_CDM_DOMAIN_type);
        break;

    // Get size for ATTR_CDM_POLICIES attribute
    case ATTR_CDM_POLICIES:
        l_attrSize = sizeof(ATTR_CDM_POLICIES_type);
        break;

    // Get size for ATTR_CEC_IPL_TYPE attribute
    case ATTR_CEC_IPL_TYPE:
        l_attrSize = sizeof(ATTR_CEC_IPL_TYPE_type);
        break;

    // Get size for ATTR_CENTAUR_ECID_FRU_ID attribute
    case ATTR_CENTAUR_ECID_FRU_ID:
        l_attrSize = sizeof(ATTR_CENTAUR_ECID_FRU_ID_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_AVDD_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VCS_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VDDR_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VDD_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VPP_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS attribute
    case ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_CHASSIS_LOCATION_CODE attribute
    case ATTR_CHASSIS_LOCATION_CODE:
        l_attrSize = sizeof(ATTR_CHASSIS_LOCATION_CODE_type);
        break;

    // Get size for ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL attribute
    case ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL:
        l_attrSize = sizeof(ATTR_CHECK_ATTN_AFTER_ISTEP_FAIL_type);
        break;

    // Get size for ATTR_CHIPLET_ID attribute
    case ATTR_CHIPLET_ID:
        l_attrSize = sizeof(ATTR_CHIPLET_ID_type);
        break;

    // Get size for ATTR_CHIP_FAN_CFM attribute
    case ATTR_CHIP_FAN_CFM:
        l_attrSize = sizeof(ATTR_CHIP_FAN_CFM_type);
        break;

    // Get size for ATTR_CHIP_ID attribute
    case ATTR_CHIP_ID:
        l_attrSize = sizeof(ATTR_CHIP_ID_type);
        break;

    // Get size for ATTR_CHIP_UNIT attribute
    case ATTR_CHIP_UNIT:
        l_attrSize = sizeof(ATTR_CHIP_UNIT_type);
        break;

    // Get size for ATTR_CLASS attribute
    case ATTR_CLASS:
        l_attrSize = sizeof(ATTR_CLASS_type);
        break;

    // Get size for ATTR_COLLECT_SBE_SCRATCH_DATA attribute
    case ATTR_COLLECT_SBE_SCRATCH_DATA:
        l_attrSize = sizeof(ATTR_COLLECT_SBE_SCRATCH_DATA_type);
        break;

    // Get size for ATTR_CORE_IS_SPARE attribute
    case ATTR_CORE_IS_SPARE:
        l_attrSize = sizeof(ATTR_CORE_IS_SPARE_type);
        break;

    // Get size for ATTR_CPU_ATTR attribute
    case ATTR_CPU_ATTR:
        l_attrSize = sizeof(ATTR_CPU_ATTR_type);
        break;

    // Get size for ATTR_DATA_CACHE_LINE_SIZE attribute
    case ATTR_DATA_CACHE_LINE_SIZE:
        l_attrSize = sizeof(ATTR_DATA_CACHE_LINE_SIZE_type);
        break;

    // Get size for ATTR_DATA_CACHE_SIZE attribute
    case ATTR_DATA_CACHE_SIZE:
        l_attrSize = sizeof(ATTR_DATA_CACHE_SIZE_type);
        break;

    // Get size for ATTR_DCACHE_ASSOC_SETS attribute
    case ATTR_DCACHE_ASSOC_SETS:
        l_attrSize = sizeof(ATTR_DCACHE_ASSOC_SETS_type);
        break;

    // Get size for ATTR_DCACHE_LINE_SIZE attribute
    case ATTR_DCACHE_LINE_SIZE:
        l_attrSize = sizeof(ATTR_DCACHE_LINE_SIZE_type);
        break;

    // Get size for ATTR_DEBUG_OCMB_LOGS attribute
    case ATTR_DEBUG_OCMB_LOGS:
        l_attrSize = sizeof(ATTR_DEBUG_OCMB_LOGS_type);
        break;

    // Get size for ATTR_DEBUG_ODY_HRESET_CONTROL attribute
    case ATTR_DEBUG_ODY_HRESET_CONTROL:
        l_attrSize = sizeof(ATTR_DEBUG_ODY_HRESET_CONTROL_type);
        break;

    // Get size for ATTR_DECONFIG_GARDABLE attribute
    case ATTR_DECONFIG_GARDABLE:
        l_attrSize = sizeof(ATTR_DECONFIG_GARDABLE_type);
        break;

    // Get size for ATTR_DIMM_POWER attribute
    case ATTR_DIMM_POWER:
        l_attrSize = sizeof(ATTR_DIMM_POWER_type);
        break;

    // Get size for ATTR_DIMM_POWER_UTIL attribute
    case ATTR_DIMM_POWER_UTIL:
        l_attrSize = sizeof(ATTR_DIMM_POWER_UTIL_type);
        break;

    // Get size for ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS attribute
    case ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS:
        l_attrSize = sizeof(ATTR_DIMM_POWER_UTIL_INTERMEDIATE_POINTS_type);
        break;

    // Get size for ATTR_DIMM_PREHEAT_POWER attribute
    case ATTR_DIMM_PREHEAT_POWER:
        l_attrSize = sizeof(ATTR_DIMM_PREHEAT_POWER_type);
        break;

    // Get size for ATTR_DISABLE_PLD_WAIT attribute
    case ATTR_DISABLE_PLD_WAIT:
        l_attrSize = sizeof(ATTR_DISABLE_PLD_WAIT_type);
        break;

    // Get size for ATTR_DISABLE_PREDICTIVE_MEM_GUARD attribute
    case ATTR_DISABLE_PREDICTIVE_MEM_GUARD:
        l_attrSize = sizeof(ATTR_DISABLE_PREDICTIVE_MEM_GUARD_type);
        break;

    // Get size for ATTR_DUMMY_HEAP_ZERO_DEFAULT attribute
    case ATTR_DUMMY_HEAP_ZERO_DEFAULT:
        l_attrSize = sizeof(ATTR_DUMMY_HEAP_ZERO_DEFAULT_type);
        break;

    // Get size for ATTR_DUMMY_RO attribute
    case ATTR_DUMMY_RO:
        l_attrSize = sizeof(ATTR_DUMMY_RO_type);
        break;

    // Get size for ATTR_DUMMY_RW attribute
    case ATTR_DUMMY_RW:
        l_attrSize = sizeof(ATTR_DUMMY_RW_type);
        break;

    // Get size for ATTR_DUMMY_WO attribute
    case ATTR_DUMMY_WO:
        l_attrSize = sizeof(ATTR_DUMMY_WO_type);
        break;

    // Get size for ATTR_EC attribute
    case ATTR_EC:
        l_attrSize = sizeof(ATTR_EC_type);
        break;

    // Get size for ATTR_EECACHE_DISABLE_AUTO_RESET attribute
    case ATTR_EECACHE_DISABLE_AUTO_RESET:
        l_attrSize = sizeof(ATTR_EECACHE_DISABLE_AUTO_RESET_type);
        break;

    // Get size for ATTR_EECACHE_VPD_STATE attribute
    case ATTR_EECACHE_VPD_STATE:
        l_attrSize = sizeof(ATTR_EECACHE_VPD_STATE_type);
        break;

    // Get size for ATTR_EEPROM_CONTENT_TYPE attribute
    case ATTR_EEPROM_CONTENT_TYPE:
        l_attrSize = sizeof(ATTR_EEPROM_CONTENT_TYPE_type);
        break;

    // Get size for ATTR_EEPROM_NV_INFO attribute
    case ATTR_EEPROM_NV_INFO:
        l_attrSize = sizeof(ATTR_EEPROM_NV_INFO_type);
        break;

    // Get size for ATTR_EEPROM_SBE_BACKUP_INFO attribute
    case ATTR_EEPROM_SBE_BACKUP_INFO:
        l_attrSize = sizeof(ATTR_EEPROM_SBE_BACKUP_INFO_type);
        break;

    // Get size for ATTR_EEPROM_SBE_PRIMARY_INFO attribute
    case ATTR_EEPROM_SBE_PRIMARY_INFO:
        l_attrSize = sizeof(ATTR_EEPROM_SBE_PRIMARY_INFO_type);
        break;

    // Get size for ATTR_EEPROM_VPD_ACCESSIBILITY attribute
    case ATTR_EEPROM_VPD_ACCESSIBILITY:
        l_attrSize = sizeof(ATTR_EEPROM_VPD_ACCESSIBILITY_type);
        break;

    // Get size for ATTR_EEPROM_VPD_ACTIVE_COPY attribute
    case ATTR_EEPROM_VPD_ACTIVE_COPY:
        l_attrSize = sizeof(ATTR_EEPROM_VPD_ACTIVE_COPY_type);
        break;

    // Get size for ATTR_EEPROM_VPD_BACKUP_INFO attribute
    case ATTR_EEPROM_VPD_BACKUP_INFO:
        l_attrSize = sizeof(ATTR_EEPROM_VPD_BACKUP_INFO_type);
        break;

    // Get size for ATTR_EEPROM_VPD_PRIMARY_INFO attribute
    case ATTR_EEPROM_VPD_PRIMARY_INFO:
        l_attrSize = sizeof(ATTR_EEPROM_VPD_PRIMARY_INFO_type);
        break;

    // Get size for ATTR_EEPROM_VPD_REDUNDANCY attribute
    case ATTR_EEPROM_VPD_REDUNDANCY:
        l_attrSize = sizeof(ATTR_EEPROM_VPD_REDUNDANCY_type);
        break;

    // Get size for ATTR_EFFECTIVE_EC attribute
    case ATTR_EFFECTIVE_EC:
        l_attrSize = sizeof(ATTR_EFFECTIVE_EC_type);
        break;

    // Get size for ATTR_ENABLED_THREADS attribute
    case ATTR_ENABLED_THREADS:
        l_attrSize = sizeof(ATTR_ENABLED_THREADS_type);
        break;

    // Get size for ATTR_ENGINE_TYPE attribute
    case ATTR_ENGINE_TYPE:
        l_attrSize = sizeof(ATTR_ENGINE_TYPE_type);
        break;

    // Get size for ATTR_FABRIC_CHIP_ID attribute
    case ATTR_FABRIC_CHIP_ID:
        l_attrSize = sizeof(ATTR_FABRIC_CHIP_ID_type);
        break;

    // Get size for ATTR_FABRIC_GROUP_ID attribute
    case ATTR_FABRIC_GROUP_ID:
        l_attrSize = sizeof(ATTR_FABRIC_GROUP_ID_type);
        break;

    // Get size for ATTR_FABRIC_PRESENT_GROUPS attribute
    case ATTR_FABRIC_PRESENT_GROUPS:
        l_attrSize = sizeof(ATTR_FABRIC_PRESENT_GROUPS_type);
        break;

    // Get size for ATTR_FABRIC_TO_PHYSICAL_NODE_MAP attribute
    case ATTR_FABRIC_TO_PHYSICAL_NODE_MAP:
        l_attrSize = sizeof(ATTR_FABRIC_TO_PHYSICAL_NODE_MAP_type);
        break;

    // Get size for ATTR_FAPI_I2C_CONTROL_INFO attribute
    case ATTR_FAPI_I2C_CONTROL_INFO:
        l_attrSize = sizeof(ATTR_FAPI_I2C_CONTROL_INFO_type);
        break;

    // Get size for ATTR_FAPI_NAME attribute
    case ATTR_FAPI_NAME:
        l_attrSize = sizeof(ATTR_FAPI_NAME_type);
        break;

    // Get size for ATTR_FIELD_CORE_OVERRIDE attribute
    case ATTR_FIELD_CORE_OVERRIDE:
        l_attrSize = sizeof(ATTR_FIELD_CORE_OVERRIDE_type);
        break;

    // Get size for ATTR_FIELD_TH_L2_LINE_DELETES attribute
    case ATTR_FIELD_TH_L2_LINE_DELETES:
        l_attrSize = sizeof(ATTR_FIELD_TH_L2_LINE_DELETES_type);
        break;

    // Get size for ATTR_FIELD_TH_L3_LINE_DELETES attribute
    case ATTR_FIELD_TH_L3_LINE_DELETES:
        l_attrSize = sizeof(ATTR_FIELD_TH_L3_LINE_DELETES_type);
        break;

    // Get size for ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION attribute
    case ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION:
        l_attrSize = sizeof(ATTR_FORCE_SBE_SCRATCH_DATA_COLLECTION_type);
        break;

    // Get size for ATTR_FORCE_SERIAL_ISTEPS attribute
    case ATTR_FORCE_SERIAL_ISTEPS:
        l_attrSize = sizeof(ATTR_FORCE_SERIAL_ISTEPS_type);
        break;

    // Get size for ATTR_FORCE_SRAM_MMIO_OVER_I2C attribute
    case ATTR_FORCE_SRAM_MMIO_OVER_I2C:
        l_attrSize = sizeof(ATTR_FORCE_SRAM_MMIO_OVER_I2C_type);
        break;

    // Get size for ATTR_FOUND_PRESENT_BY_SP attribute
    case ATTR_FOUND_PRESENT_BY_SP:
        l_attrSize = sizeof(ATTR_FOUND_PRESENT_BY_SP_type);
        break;

    // Get size for ATTR_FREQ_CORE_CEILING_MHZ attribute
    case ATTR_FREQ_CORE_CEILING_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_CORE_CEILING_MHZ_type);
        break;

    // Get size for ATTR_FREQ_PROC_REFCLOCK attribute
    case ATTR_FREQ_PROC_REFCLOCK:
        l_attrSize = sizeof(ATTR_FREQ_PROC_REFCLOCK_type);
        break;

    // Get size for ATTR_FRU_ID attribute
    case ATTR_FRU_ID:
        l_attrSize = sizeof(ATTR_FRU_ID_type);
        break;

    // Get size for ATTR_FSI_MASTER_CHIP attribute
    case ATTR_FSI_MASTER_CHIP:
        l_attrSize = sizeof(ATTR_FSI_MASTER_CHIP_type);
        break;

    // Get size for ATTR_FSI_MASTER_PORT attribute
    case ATTR_FSI_MASTER_PORT:
        l_attrSize = sizeof(ATTR_FSI_MASTER_PORT_type);
        break;

    // Get size for ATTR_FSI_MASTER_TYPE attribute
    case ATTR_FSI_MASTER_TYPE:
        l_attrSize = sizeof(ATTR_FSI_MASTER_TYPE_type);
        break;

    // Get size for ATTR_FSI_OPTION_FLAGS attribute
    case ATTR_FSI_OPTION_FLAGS:
        l_attrSize = sizeof(ATTR_FSI_OPTION_FLAGS_type);
        break;

    // Get size for ATTR_FSI_SLAVE_CASCADE attribute
    case ATTR_FSI_SLAVE_CASCADE:
        l_attrSize = sizeof(ATTR_FSI_SLAVE_CASCADE_type);
        break;

    // Get size for ATTR_FSP_BAR_SIZE attribute
    case ATTR_FSP_BAR_SIZE:
        l_attrSize = sizeof(ATTR_FSP_BAR_SIZE_type);
        break;

    // Get size for ATTR_FSP_BASE_ADDR attribute
    case ATTR_FSP_BASE_ADDR:
        l_attrSize = sizeof(ATTR_FSP_BASE_ADDR_type);
        break;

    // Get size for ATTR_FUSED_CORE_MODE_HB attribute
    case ATTR_FUSED_CORE_MODE_HB:
        l_attrSize = sizeof(ATTR_FUSED_CORE_MODE_HB_type);
        break;

    // Get size for ATTR_FUSED_CORE_OPTION attribute
    case ATTR_FUSED_CORE_OPTION:
        l_attrSize = sizeof(ATTR_FUSED_CORE_OPTION_type);
        break;

    // Get size for ATTR_HBRT_HYP_ID attribute
    case ATTR_HBRT_HYP_ID:
        l_attrSize = sizeof(ATTR_HBRT_HYP_ID_type);
        break;

    // Get size for ATTR_HB_HRMOR_NODAL_BASE attribute
    case ATTR_HB_HRMOR_NODAL_BASE:
        l_attrSize = sizeof(ATTR_HB_HRMOR_NODAL_BASE_type);
        break;

    // Get size for ATTR_HB_MIN_BACKING_CACHE_FC attribute
    case ATTR_HB_MIN_BACKING_CACHE_FC:
        l_attrSize = sizeof(ATTR_HB_MIN_BACKING_CACHE_FC_type);
        break;

    // Get size for ATTR_HB_RSV_MEM_SIZE_MB attribute
    case ATTR_HB_RSV_MEM_SIZE_MB:
        l_attrSize = sizeof(ATTR_HB_RSV_MEM_SIZE_MB_type);
        break;

    // Get size for ATTR_HB_SETTINGS attribute
    case ATTR_HB_SETTINGS:
        l_attrSize = sizeof(ATTR_HB_SETTINGS_type);
        break;

    // Get size for ATTR_HB_SETTINGS_OVERRIDE attribute
    case ATTR_HB_SETTINGS_OVERRIDE:
        l_attrSize = sizeof(ATTR_HB_SETTINGS_OVERRIDE_type);
        break;

    // Get size for ATTR_HDAT_EC attribute
    case ATTR_HDAT_EC:
        l_attrSize = sizeof(ATTR_HDAT_EC_type);
        break;

    // Get size for ATTR_HDAT_HBRT_NUM_SECTIONS attribute
    case ATTR_HDAT_HBRT_NUM_SECTIONS:
        l_attrSize = sizeof(ATTR_HDAT_HBRT_NUM_SECTIONS_type);
        break;

    // Get size for ATTR_HDAT_HBRT_SECTION_SIZE attribute
    case ATTR_HDAT_HBRT_SECTION_SIZE:
        l_attrSize = sizeof(ATTR_HDAT_HBRT_SECTION_SIZE_type);
        break;

    // Get size for ATTR_HDAT_RSV_MEM_NUM_SECTIONS attribute
    case ATTR_HDAT_RSV_MEM_NUM_SECTIONS:
        l_attrSize = sizeof(ATTR_HDAT_RSV_MEM_NUM_SECTIONS_type);
        break;

    // Get size for ATTR_HDDW_ORDER attribute
    case ATTR_HDDW_ORDER:
        l_attrSize = sizeof(ATTR_HDDW_ORDER_type);
        break;

    // Get size for ATTR_HOMER_PHYS_ADDR attribute
    case ATTR_HOMER_PHYS_ADDR:
        l_attrSize = sizeof(ATTR_HOMER_PHYS_ADDR_type);
        break;

    // Get size for ATTR_HOSTSVC_PLID attribute
    case ATTR_HOSTSVC_PLID:
        l_attrSize = sizeof(ATTR_HOSTSVC_PLID_type);
        break;

    // Get size for ATTR_HOT_PLUG_POWER_CONTROLLER_INFO attribute
    case ATTR_HOT_PLUG_POWER_CONTROLLER_INFO:
        l_attrSize = sizeof(ATTR_HOT_PLUG_POWER_CONTROLLER_INFO_type);
        break;

    // Get size for ATTR_HUID attribute
    case ATTR_HUID:
        l_attrSize = sizeof(ATTR_HUID_type);
        break;

    // Get size for ATTR_HWAS_STATE attribute
    case ATTR_HWAS_STATE:
        l_attrSize = sizeof(ATTR_HWAS_STATE_type);
        break;

    // Get size for ATTR_HWAS_STATE_CHANGED_FLAG attribute
    case ATTR_HWAS_STATE_CHANGED_FLAG:
        l_attrSize = sizeof(ATTR_HWAS_STATE_CHANGED_FLAG_type);
        break;

    // Get size for ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK attribute
    case ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK:
        l_attrSize = sizeof(ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK_type);
        break;

    // Get size for ATTR_HWAS_STATE_TESTSAVE attribute
    case ATTR_HWAS_STATE_TESTSAVE:
        l_attrSize = sizeof(ATTR_HWAS_STATE_TESTSAVE_type);
        break;

    // Get size for ATTR_I2C_BUS_SPEED_ARRAY attribute
    case ATTR_I2C_BUS_SPEED_ARRAY:
        l_attrSize = sizeof(ATTR_I2C_BUS_SPEED_ARRAY_type);
        break;

    // Get size for ATTR_I2C_CONTROL_INFO attribute
    case ATTR_I2C_CONTROL_INFO:
        l_attrSize = sizeof(ATTR_I2C_CONTROL_INFO_type);
        break;

    // Get size for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A attribute
    case ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A:
        l_attrSize = sizeof(ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A_type);
        break;

    // Get size for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B attribute
    case ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B:
        l_attrSize = sizeof(ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B_type);
        break;

    // Get size for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C attribute
    case ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C:
        l_attrSize = sizeof(ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C_type);
        break;

    // Get size for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D attribute
    case ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D:
        l_attrSize = sizeof(ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D_type);
        break;

    // Get size for ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E attribute
    case ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E:
        l_attrSize = sizeof(ATTR_I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E_type);
        break;

    // Get size for ATTR_I2C_SWITCHES attribute
    case ATTR_I2C_SWITCHES:
        l_attrSize = sizeof(ATTR_I2C_SWITCHES_type);
        break;

    // Get size for ATTR_IBSCOM_MCS_BASE_ADDR attribute
    case ATTR_IBSCOM_MCS_BASE_ADDR:
        l_attrSize = sizeof(ATTR_IBSCOM_MCS_BASE_ADDR_type);
        break;

    // Get size for ATTR_IBSCOM_PROC_BASE_ADDR attribute
    case ATTR_IBSCOM_PROC_BASE_ADDR:
        l_attrSize = sizeof(ATTR_IBSCOM_PROC_BASE_ADDR_type);
        break;

    // Get size for ATTR_ICACHE_ASSOC_SETS attribute
    case ATTR_ICACHE_ASSOC_SETS:
        l_attrSize = sizeof(ATTR_ICACHE_ASSOC_SETS_type);
        break;

    // Get size for ATTR_ICACHE_BLOCK_SIZE attribute
    case ATTR_ICACHE_BLOCK_SIZE:
        l_attrSize = sizeof(ATTR_ICACHE_BLOCK_SIZE_type);
        break;

    // Get size for ATTR_ICACHE_LINE_SIZE attribute
    case ATTR_ICACHE_LINE_SIZE:
        l_attrSize = sizeof(ATTR_ICACHE_LINE_SIZE_type);
        break;

    // Get size for ATTR_ICACHE_SIZE attribute
    case ATTR_ICACHE_SIZE:
        l_attrSize = sizeof(ATTR_ICACHE_SIZE_type);
        break;

    // Get size for ATTR_INIT_TO_AVAILABLE attribute
    case ATTR_INIT_TO_AVAILABLE:
        l_attrSize = sizeof(ATTR_INIT_TO_AVAILABLE_type);
        break;

    // Get size for ATTR_INT_CQ_TM_BAR_ADDR attribute
    case ATTR_INT_CQ_TM_BAR_ADDR:
        l_attrSize = sizeof(ATTR_INT_CQ_TM_BAR_ADDR_type);
        break;

    // Get size for ATTR_ISTEP_CALLOUT_INJECT_ACTION attribute
    case ATTR_ISTEP_CALLOUT_INJECT_ACTION:
        l_attrSize = sizeof(ATTR_ISTEP_CALLOUT_INJECT_ACTION_type);
        break;

    // Get size for ATTR_ISTEP_CALLOUT_INJECT_ENABLE attribute
    case ATTR_ISTEP_CALLOUT_INJECT_ENABLE:
        l_attrSize = sizeof(ATTR_ISTEP_CALLOUT_INJECT_ENABLE_type);
        break;

    // Get size for ATTR_ISTEP_MODE attribute
    case ATTR_ISTEP_MODE:
        l_attrSize = sizeof(ATTR_ISTEP_MODE_type);
        break;

    // Get size for ATTR_ISTEP_PAUSE_CONFIG attribute
    case ATTR_ISTEP_PAUSE_CONFIG:
        l_attrSize = sizeof(ATTR_ISTEP_PAUSE_CONFIG_type);
        break;

    // Get size for ATTR_ISTEP_PAUSE_ENABLE attribute
    case ATTR_ISTEP_PAUSE_ENABLE:
        l_attrSize = sizeof(ATTR_ISTEP_PAUSE_ENABLE_type);
        break;

    // Get size for ATTR_IS_INTER_ENCLOSURE_BUS attribute
    case ATTR_IS_INTER_ENCLOSURE_BUS:
        l_attrSize = sizeof(ATTR_IS_INTER_ENCLOSURE_BUS_type);
        break;

    // Get size for ATTR_IS_STANDALONE attribute
    case ATTR_IS_STANDALONE:
        l_attrSize = sizeof(ATTR_IS_STANDALONE_type);
        break;

    // Get size for ATTR_KEY_CLEAR_REQUEST attribute
    case ATTR_KEY_CLEAR_REQUEST:
        l_attrSize = sizeof(ATTR_KEY_CLEAR_REQUEST_type);
        break;

    // Get size for ATTR_KEY_TRANSITION_STATE attribute
    case ATTR_KEY_TRANSITION_STATE:
        l_attrSize = sizeof(ATTR_KEY_TRANSITION_STATE_type);
        break;

    // Get size for ATTR_L2_CACHE_ASSOC_SETS attribute
    case ATTR_L2_CACHE_ASSOC_SETS:
        l_attrSize = sizeof(ATTR_L2_CACHE_ASSOC_SETS_type);
        break;

    // Get size for ATTR_L2_CACHE_LINE_SIZE attribute
    case ATTR_L2_CACHE_LINE_SIZE:
        l_attrSize = sizeof(ATTR_L2_CACHE_LINE_SIZE_type);
        break;

    // Get size for ATTR_L2_CACHE_SIZE attribute
    case ATTR_L2_CACHE_SIZE:
        l_attrSize = sizeof(ATTR_L2_CACHE_SIZE_type);
        break;

    // Get size for ATTR_L3_CACHE_LINE_SIZE attribute
    case ATTR_L3_CACHE_LINE_SIZE:
        l_attrSize = sizeof(ATTR_L3_CACHE_LINE_SIZE_type);
        break;

    // Get size for ATTR_L3_CACHE_SIZE attribute
    case ATTR_L3_CACHE_SIZE:
        l_attrSize = sizeof(ATTR_L3_CACHE_SIZE_type);
        break;

    // Get size for ATTR_LAST_IPLTIME_EID attribute
    case ATTR_LAST_IPLTIME_EID:
        l_attrSize = sizeof(ATTR_LAST_IPLTIME_EID_type);
        break;

    // Get size for ATTR_LMB_SIZE attribute
    case ATTR_LMB_SIZE:
        l_attrSize = sizeof(ATTR_LMB_SIZE_type);
        break;

    // Get size for ATTR_LOCATION_CODE attribute
    case ATTR_LOCATION_CODE:
        l_attrSize = sizeof(ATTR_LOCATION_CODE_type);
        break;

    // Get size for ATTR_LPC_BUS_ADDR attribute
    case ATTR_LPC_BUS_ADDR:
        l_attrSize = sizeof(ATTR_LPC_BUS_ADDR_type);
        break;

    // Get size for ATTR_MAX_CHIPLETS_PER_PROC attribute
    case ATTR_MAX_CHIPLETS_PER_PROC:
        l_attrSize = sizeof(ATTR_MAX_CHIPLETS_PER_PROC_type);
        break;

    // Get size for ATTR_MAX_COMPUTE_NODES_PER_SYSTEM attribute
    case ATTR_MAX_COMPUTE_NODES_PER_SYSTEM:
        l_attrSize = sizeof(ATTR_MAX_COMPUTE_NODES_PER_SYSTEM_type);
        break;

    // Get size for ATTR_MAX_DIMMS_PER_MBA_PORT attribute
    case ATTR_MAX_DIMMS_PER_MBA_PORT:
        l_attrSize = sizeof(ATTR_MAX_DIMMS_PER_MBA_PORT_type);
        break;

    // Get size for ATTR_MAX_DIMM_POWER attribute
    case ATTR_MAX_DIMM_POWER:
        l_attrSize = sizeof(ATTR_MAX_DIMM_POWER_type);
        break;

    // Get size for ATTR_MAX_DMI_PER_PROC attribute
    case ATTR_MAX_DMI_PER_PROC:
        l_attrSize = sizeof(ATTR_MAX_DMI_PER_PROC_type);
        break;

    // Get size for ATTR_MAX_EXS_PER_PROC_CHIP attribute
    case ATTR_MAX_EXS_PER_PROC_CHIP:
        l_attrSize = sizeof(ATTR_MAX_EXS_PER_PROC_CHIP_type);
        break;

    // Get size for ATTR_MAX_MBAS_PER_MEMBUF_CHIP attribute
    case ATTR_MAX_MBAS_PER_MEMBUF_CHIP:
        l_attrSize = sizeof(ATTR_MAX_MBAS_PER_MEMBUF_CHIP_type);
        break;

    // Get size for ATTR_MAX_MBA_PORTS_PER_MBA attribute
    case ATTR_MAX_MBA_PORTS_PER_MBA:
        l_attrSize = sizeof(ATTR_MAX_MBA_PORTS_PER_MBA_type);
        break;

    // Get size for ATTR_MAX_MCS_PER_SYSTEM attribute
    case ATTR_MAX_MCS_PER_SYSTEM:
        l_attrSize = sizeof(ATTR_MAX_MCS_PER_SYSTEM_type);
        break;

    // Get size for ATTR_MAX_POWER attribute
    case ATTR_MAX_POWER:
        l_attrSize = sizeof(ATTR_MAX_POWER_type);
        break;

    // Get size for ATTR_MAX_PROC_CHIPS_PER_NODE attribute
    case ATTR_MAX_PROC_CHIPS_PER_NODE:
        l_attrSize = sizeof(ATTR_MAX_PROC_CHIPS_PER_NODE_type);
        break;

    // Get size for ATTR_MBA_DIMM attribute
    case ATTR_MBA_DIMM:
        l_attrSize = sizeof(ATTR_MBA_DIMM_type);
        break;

    // Get size for ATTR_MBA_PORT attribute
    case ATTR_MBA_PORT:
        l_attrSize = sizeof(ATTR_MBA_PORT_type);
        break;

    // Get size for ATTR_MEM_AVDD_OFFSET_MILLIVOLTS attribute
    case ATTR_MEM_AVDD_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MEM_AVDD_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MEM_BASE attribute
    case ATTR_MEM_BASE:
        l_attrSize = sizeof(ATTR_MEM_BASE_type);
        break;

    // Get size for ATTR_MEM_PORT attribute
    case ATTR_MEM_PORT:
        l_attrSize = sizeof(ATTR_MEM_PORT_type);
        break;

    // Get size for ATTR_MEM_VCS_OFFSET_MILLIVOLTS attribute
    case ATTR_MEM_VCS_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MEM_VCS_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MEM_VDDR_OFFSET_MILLIVOLTS attribute
    case ATTR_MEM_VDDR_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MEM_VDDR_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MEM_VDD_OFFSET_MILLIVOLTS attribute
    case ATTR_MEM_VDD_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MEM_VDD_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MEM_VPP_OFFSET_MILLIVOLTS attribute
    case ATTR_MEM_VPP_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MEM_VPP_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MFG_TRACE_ENABLE attribute
    case ATTR_MFG_TRACE_ENABLE:
        l_attrSize = sizeof(ATTR_MFG_TRACE_ENABLE_type);
        break;

    // Get size for ATTR_MGC_LOAD_SOURCE attribute
    case ATTR_MGC_LOAD_SOURCE:
        l_attrSize = sizeof(ATTR_MGC_LOAD_SOURCE_type);
        break;

    // Get size for ATTR_MIN_FREQ_MHZ attribute
    case ATTR_MIN_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_MIN_FREQ_MHZ_type);
        break;

    // Get size for ATTR_MIRROR_BASE_ADDRESS attribute
    case ATTR_MIRROR_BASE_ADDRESS:
        l_attrSize = sizeof(ATTR_MIRROR_BASE_ADDRESS_type);
        break;

    // Get size for ATTR_MMIO_PHYS_ADDR attribute
    case ATTR_MMIO_PHYS_ADDR:
        l_attrSize = sizeof(ATTR_MMIO_PHYS_ADDR_type);
        break;

    // Get size for ATTR_MNFG_ABUS_MIN_EYE_HEIGHT attribute
    case ATTR_MNFG_ABUS_MIN_EYE_HEIGHT:
        l_attrSize = sizeof(ATTR_MNFG_ABUS_MIN_EYE_HEIGHT_type);
        break;

    // Get size for ATTR_MNFG_ABUS_MIN_EYE_WIDTH attribute
    case ATTR_MNFG_ABUS_MIN_EYE_WIDTH:
        l_attrSize = sizeof(ATTR_MNFG_ABUS_MIN_EYE_WIDTH_type);
        break;

    // Get size for ATTR_MNFG_DMI_MIN_EYE_HEIGHT attribute
    case ATTR_MNFG_DMI_MIN_EYE_HEIGHT:
        l_attrSize = sizeof(ATTR_MNFG_DMI_MIN_EYE_HEIGHT_type);
        break;

    // Get size for ATTR_MNFG_DMI_MIN_EYE_WIDTH attribute
    case ATTR_MNFG_DMI_MIN_EYE_WIDTH:
        l_attrSize = sizeof(ATTR_MNFG_DMI_MIN_EYE_WIDTH_type);
        break;

    // Get size for ATTR_MNFG_TH_L2_CACHE_CES attribute
    case ATTR_MNFG_TH_L2_CACHE_CES:
        l_attrSize = sizeof(ATTR_MNFG_TH_L2_CACHE_CES_type);
        break;

    // Get size for ATTR_MNFG_TH_L2_DIR_CES attribute
    case ATTR_MNFG_TH_L2_DIR_CES:
        l_attrSize = sizeof(ATTR_MNFG_TH_L2_DIR_CES_type);
        break;

    // Get size for ATTR_MNFG_TH_L2_LINE_DELETES attribute
    case ATTR_MNFG_TH_L2_LINE_DELETES:
        l_attrSize = sizeof(ATTR_MNFG_TH_L2_LINE_DELETES_type);
        break;

    // Get size for ATTR_MNFG_TH_L3_CACHE_CES attribute
    case ATTR_MNFG_TH_L3_CACHE_CES:
        l_attrSize = sizeof(ATTR_MNFG_TH_L3_CACHE_CES_type);
        break;

    // Get size for ATTR_MNFG_TH_L3_DIR_CES attribute
    case ATTR_MNFG_TH_L3_DIR_CES:
        l_attrSize = sizeof(ATTR_MNFG_TH_L3_DIR_CES_type);
        break;

    // Get size for ATTR_MNFG_TH_L3_LINE_DELETES attribute
    case ATTR_MNFG_TH_L3_LINE_DELETES:
        l_attrSize = sizeof(ATTR_MNFG_TH_L3_LINE_DELETES_type);
        break;

    // Get size for ATTR_MNFG_TH_MEMORY_IMPES attribute
    case ATTR_MNFG_TH_MEMORY_IMPES:
        l_attrSize = sizeof(ATTR_MNFG_TH_MEMORY_IMPES_type);
        break;

    // Get size for ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO attribute
    case ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO:
        l_attrSize = sizeof(ATTR_MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO_type);
        break;

    // Get size for ATTR_MNFG_TH_MEMORY_IUES attribute
    case ATTR_MNFG_TH_MEMORY_IUES:
        l_attrSize = sizeof(ATTR_MNFG_TH_MEMORY_IUES_type);
        break;

    // Get size for ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS attribute
    case ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS:
        l_attrSize = sizeof(ATTR_MNFG_TH_MEMORY_RCD_PARITY_ERRORS_type);
        break;

    // Get size for ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK attribute
    case ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK:
        l_attrSize = sizeof(ATTR_MNFG_TH_MEMORY_RT_RCE_PER_RANK_type);
        break;

    // Get size for ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO attribute
    case ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO:
        l_attrSize = sizeof(ATTR_MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO_type);
        break;

    // Get size for ATTR_MNFG_XBUS_MIN_EYE_WIDTH attribute
    case ATTR_MNFG_XBUS_MIN_EYE_WIDTH:
        l_attrSize = sizeof(ATTR_MNFG_XBUS_MIN_EYE_WIDTH_type);
        break;

    // Get size for ATTR_MODEL attribute
    case ATTR_MODEL:
        l_attrSize = sizeof(ATTR_MODEL_type);
        break;

    // Get size for ATTR_MRU_ID attribute
    case ATTR_MRU_ID:
        l_attrSize = sizeof(ATTR_MRU_ID_type);
        break;

    // Get size for ATTR_MRW_DDR3_VDDR_MAX_LIMIT attribute
    case ATTR_MRW_DDR3_VDDR_MAX_LIMIT:
        l_attrSize = sizeof(ATTR_MRW_DDR3_VDDR_MAX_LIMIT_type);
        break;

    // Get size for ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT attribute
    case ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MRW_DDR4_VDDR_MAX_LIMIT attribute
    case ATTR_MRW_DDR4_VDDR_MAX_LIMIT:
        l_attrSize = sizeof(ATTR_MRW_DDR4_VDDR_MAX_LIMIT_type);
        break;

    // Get size for ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT attribute
    case ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MRW_DEFAULT_RISK_LEVEL attribute
    case ATTR_MRW_DEFAULT_RISK_LEVEL:
        l_attrSize = sizeof(ATTR_MRW_DEFAULT_RISK_LEVEL_type);
        break;

    // Get size for ATTR_MRW_MEM_THROTTLE_DENOMINATOR attribute
    case ATTR_MRW_MEM_THROTTLE_DENOMINATOR:
        l_attrSize = sizeof(ATTR_MRW_MEM_THROTTLE_DENOMINATOR_type);
        break;

    // Get size for ATTR_MSL_FIELD_SUPPORTED attribute
    case ATTR_MSL_FIELD_SUPPORTED:
        l_attrSize = sizeof(ATTR_MSL_FIELD_SUPPORTED_type);
        break;

    // Get size for ATTR_MSL_MFG_ALLOW attribute
    case ATTR_MSL_MFG_ALLOW:
        l_attrSize = sizeof(ATTR_MSL_MFG_ALLOW_type);
        break;

    // Get size for ATTR_MSS_AVDD_PROGRAM attribute
    case ATTR_MSS_AVDD_PROGRAM:
        l_attrSize = sizeof(ATTR_MSS_AVDD_PROGRAM_type);
        break;

    // Get size for ATTR_MSS_CENT_AVDD_INTERCEPT attribute
    case ATTR_MSS_CENT_AVDD_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_CENT_AVDD_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE attribute
    case ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE:
        l_attrSize = sizeof(ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE_type);
        break;

    // Get size for ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE attribute
    case ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE:
        l_attrSize = sizeof(ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE_type);
        break;

    // Get size for ATTR_MSS_CENT_VCS_INTERCEPT attribute
    case ATTR_MSS_CENT_VCS_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_CENT_VCS_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_CENT_VCS_SLOPE_ACTIVE attribute
    case ATTR_MSS_CENT_VCS_SLOPE_ACTIVE:
        l_attrSize = sizeof(ATTR_MSS_CENT_VCS_SLOPE_ACTIVE_type);
        break;

    // Get size for ATTR_MSS_CENT_VCS_SLOPE_INACTIVE attribute
    case ATTR_MSS_CENT_VCS_SLOPE_INACTIVE:
        l_attrSize = sizeof(ATTR_MSS_CENT_VCS_SLOPE_INACTIVE_type);
        break;

    // Get size for ATTR_MSS_CENT_VDD_INTERCEPT attribute
    case ATTR_MSS_CENT_VDD_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_CENT_VDD_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_CENT_VDD_SLOPE_ACTIVE attribute
    case ATTR_MSS_CENT_VDD_SLOPE_ACTIVE:
        l_attrSize = sizeof(ATTR_MSS_CENT_VDD_SLOPE_ACTIVE_type);
        break;

    // Get size for ATTR_MSS_CENT_VDD_SLOPE_INACTIVE attribute
    case ATTR_MSS_CENT_VDD_SLOPE_INACTIVE:
        l_attrSize = sizeof(ATTR_MSS_CENT_VDD_SLOPE_INACTIVE_type);
        break;

    // Get size for ATTR_MSS_DATABUS_UTIL_PER_MBA attribute
    case ATTR_MSS_DATABUS_UTIL_PER_MBA:
        l_attrSize = sizeof(ATTR_MSS_DATABUS_UTIL_PER_MBA_type);
        break;

    // Get size for ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT attribute
    case ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT:
        l_attrSize = sizeof(ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT_type);
        break;

    // Get size for ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE attribute
    case ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE:
        l_attrSize = sizeof(ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE_type);
        break;

    // Get size for ATTR_MSS_PHY_SEQ_REFRESH attribute
    case ATTR_MSS_PHY_SEQ_REFRESH:
        l_attrSize = sizeof(ATTR_MSS_PHY_SEQ_REFRESH_type);
        break;

    // Get size for ATTR_MSS_VCS_PROGRAM attribute
    case ATTR_MSS_VCS_PROGRAM:
        l_attrSize = sizeof(ATTR_MSS_VCS_PROGRAM_type);
        break;

    // Get size for ATTR_MSS_VDDR_PROGRAM attribute
    case ATTR_MSS_VDDR_PROGRAM:
        l_attrSize = sizeof(ATTR_MSS_VDDR_PROGRAM_type);
        break;

    // Get size for ATTR_MSS_VDD_PROGRAM attribute
    case ATTR_MSS_VDD_PROGRAM:
        l_attrSize = sizeof(ATTR_MSS_VDD_PROGRAM_type);
        break;

    // Get size for ATTR_MSS_VOLT_AVDD_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_AVDD_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_AVDD_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT attribute
    case ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT attribute
    case ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR3_VDDR_SLOPE attribute
    case ATTR_MSS_VOLT_DDR3_VDDR_SLOPE:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT attribute
    case ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT attribute
    case ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT attribute
    case ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR4_VDDR_SLOPE attribute
    case ATTR_MSS_VOLT_DDR4_VDDR_SLOPE:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_type);
        break;

    // Get size for ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT attribute
    case ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MSS_VOLT_VCS_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VCS_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VCS_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VDDR_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VDDR_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VDDR_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VDD_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VDD_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VDD_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VPP_INTERCEPT attribute
    case ATTR_MSS_VOLT_VPP_INTERCEPT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VPP_INTERCEPT_type);
        break;

    // Get size for ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT attribute
    case ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MSS_VOLT_VPP_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VPP_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VPP_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS attribute
    case ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS_type);
        break;

    // Get size for ATTR_MSS_VOLT_VPP_SLOPE attribute
    case ATTR_MSS_VOLT_VPP_SLOPE:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VPP_SLOPE_type);
        break;

    // Get size for ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT attribute
    case ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT:
        l_attrSize = sizeof(ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT_type);
        break;

    // Get size for ATTR_MSS_VPP_PROGRAM attribute
    case ATTR_MSS_VPP_PROGRAM:
        l_attrSize = sizeof(ATTR_MSS_VPP_PROGRAM_type);
        break;

    // Get size for ATTR_NEST_PLL_FREQ_BUCKETS attribute
    case ATTR_NEST_PLL_FREQ_BUCKETS:
        l_attrSize = sizeof(ATTR_NEST_PLL_FREQ_BUCKETS_type);
        break;

    // Get size for ATTR_NEST_PLL_FREQ_I2CDIV_LIST attribute
    case ATTR_NEST_PLL_FREQ_I2CDIV_LIST:
        l_attrSize = sizeof(ATTR_NEST_PLL_FREQ_I2CDIV_LIST_type);
        break;

    // Get size for ATTR_NEST_PLL_FREQ_LIST attribute
    case ATTR_NEST_PLL_FREQ_LIST:
        l_attrSize = sizeof(ATTR_NEST_PLL_FREQ_LIST_type);
        break;

    // Get size for ATTR_NEST_VCS_ID attribute
    case ATTR_NEST_VCS_ID:
        l_attrSize = sizeof(ATTR_NEST_VCS_ID_type);
        break;

    // Get size for ATTR_NEST_VDDR_ID attribute
    case ATTR_NEST_VDDR_ID:
        l_attrSize = sizeof(ATTR_NEST_VDDR_ID_type);
        break;

    // Get size for ATTR_NEST_VDD_ID attribute
    case ATTR_NEST_VDD_ID:
        l_attrSize = sizeof(ATTR_NEST_VDD_ID_type);
        break;

    // Get size for ATTR_NEST_VDN_ID attribute
    case ATTR_NEST_VDN_ID:
        l_attrSize = sizeof(ATTR_NEST_VDN_ID_type);
        break;

    // Get size for ATTR_NEST_VIO_ID attribute
    case ATTR_NEST_VIO_ID:
        l_attrSize = sizeof(ATTR_NEST_VIO_ID_type);
        break;

    // Get size for ATTR_NO_RECONFIG_ON_DECONFIG attribute
    case ATTR_NO_RECONFIG_ON_DECONFIG:
        l_attrSize = sizeof(ATTR_NO_RECONFIG_ON_DECONFIG_type);
        break;

    // Get size for ATTR_NPU_MMIO_BAR_BASE_ADDR attribute
    case ATTR_NPU_MMIO_BAR_BASE_ADDR:
        l_attrSize = sizeof(ATTR_NPU_MMIO_BAR_BASE_ADDR_type);
        break;

    // Get size for ATTR_NPU_MMIO_BAR_SIZE attribute
    case ATTR_NPU_MMIO_BAR_SIZE:
        l_attrSize = sizeof(ATTR_NPU_MMIO_BAR_SIZE_type);
        break;

    // Get size for ATTR_NUMERIC_POD_TYPE_TEST attribute
    case ATTR_NUMERIC_POD_TYPE_TEST:
        l_attrSize = sizeof(ATTR_NUMERIC_POD_TYPE_TEST_type);
        break;

    // Get size for ATTR_NVDIMM_ARMED attribute
    case ATTR_NVDIMM_ARMED:
        l_attrSize = sizeof(ATTR_NVDIMM_ARMED_type);
        break;

    // Get size for ATTR_NV_OPS_TIMEOUT_MSEC attribute
    case ATTR_NV_OPS_TIMEOUT_MSEC:
        l_attrSize = sizeof(ATTR_NV_OPS_TIMEOUT_MSEC_type);
        break;

    // Get size for ATTR_NV_STATUS_FLAG attribute
    case ATTR_NV_STATUS_FLAG:
        l_attrSize = sizeof(ATTR_NV_STATUS_FLAG_type);
        break;

    // Get size for ATTR_OBUS_BRICK_LANE_MASK attribute
    case ATTR_OBUS_BRICK_LANE_MASK:
        l_attrSize = sizeof(ATTR_OBUS_BRICK_LANE_MASK_type);
        break;

    // Get size for ATTR_OBUS_SLOT_INDEX attribute
    case ATTR_OBUS_SLOT_INDEX:
        l_attrSize = sizeof(ATTR_OBUS_SLOT_INDEX_type);
        break;

    // Get size for ATTR_OCC_MASTER_CAPABLE attribute
    case ATTR_OCC_MASTER_CAPABLE:
        l_attrSize = sizeof(ATTR_OCC_MASTER_CAPABLE_type);
        break;

    // Get size for ATTR_OCMB_BOOT_SIDE attribute
    case ATTR_OCMB_BOOT_SIDE:
        l_attrSize = sizeof(ATTR_OCMB_BOOT_SIDE_type);
        break;

    // Get size for ATTR_OCMB_CODE_LEVEL_SUMMARY attribute
    case ATTR_OCMB_CODE_LEVEL_SUMMARY:
        l_attrSize = sizeof(ATTR_OCMB_CODE_LEVEL_SUMMARY_type);
        break;

    // Get size for ATTR_OCMB_CODE_UPDATED attribute
    case ATTR_OCMB_CODE_UPDATED:
        l_attrSize = sizeof(ATTR_OCMB_CODE_UPDATED_type);
        break;

    // Get size for ATTR_OCMB_FORCE_IMAGE_SYNC attribute
    case ATTR_OCMB_FORCE_IMAGE_SYNC:
        l_attrSize = sizeof(ATTR_OCMB_FORCE_IMAGE_SYNC_type);
        break;

    // Get size for ATTR_OCMB_FW_STATE attribute
    case ATTR_OCMB_FW_STATE:
        l_attrSize = sizeof(ATTR_OCMB_FW_STATE_type);
        break;

    // Get size for ATTR_OCMB_FW_UPDATE_OVERRIDE attribute
    case ATTR_OCMB_FW_UPDATE_OVERRIDE:
        l_attrSize = sizeof(ATTR_OCMB_FW_UPDATE_OVERRIDE_type);
        break;

    // Get size for ATTR_OCMB_FW_UPDATE_STATUS attribute
    case ATTR_OCMB_FW_UPDATE_STATUS:
        l_attrSize = sizeof(ATTR_OCMB_FW_UPDATE_STATUS_type);
        break;

    // Get size for ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED attribute
    case ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED:
        l_attrSize = sizeof(ATTR_OCMB_GOLDEN_BOOT_ATTEMPTED_type);
        break;

    // Get size for ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE attribute
    case ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE:
        l_attrSize = sizeof(ATTR_OCMB_IGNORE_SCOM_CHECK_DISABLE_type);
        break;

    // Get size for ATTR_OCMB_ISTEP_MODE attribute
    case ATTR_OCMB_ISTEP_MODE:
        l_attrSize = sizeof(ATTR_OCMB_ISTEP_MODE_type);
        break;

    // Get size for ATTR_OCMB_RESET_DELAY_SEC attribute
    case ATTR_OCMB_RESET_DELAY_SEC:
        l_attrSize = sizeof(ATTR_OCMB_RESET_DELAY_SEC_type);
        break;

    // Get size for ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE attribute
    case ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE:
        l_attrSize = sizeof(ATTR_ODYSSEY_PRIORITY_CODE_UPDATE_RULE_type);
        break;

    // Get size for ATTR_ODY_PNOR_COMBINED_IMAGES_HASH attribute
    case ATTR_ODY_PNOR_COMBINED_IMAGES_HASH:
        l_attrSize = sizeof(ATTR_ODY_PNOR_COMBINED_IMAGES_HASH_type);
        break;

    // Get size for ATTR_ORDINAL_ID attribute
    case ATTR_ORDINAL_ID:
        l_attrSize = sizeof(ATTR_ORDINAL_ID_type);
        break;

    // Get size for ATTR_PARENT_DECONFIG_RULES attribute
    case ATTR_PARENT_DECONFIG_RULES:
        l_attrSize = sizeof(ATTR_PARENT_DECONFIG_RULES_type);
        break;

    // Get size for ATTR_PAYLOAD_BASE attribute
    case ATTR_PAYLOAD_BASE:
        l_attrSize = sizeof(ATTR_PAYLOAD_BASE_type);
        break;

    // Get size for ATTR_PAYLOAD_ENTRY attribute
    case ATTR_PAYLOAD_ENTRY:
        l_attrSize = sizeof(ATTR_PAYLOAD_ENTRY_type);
        break;

    // Get size for ATTR_PAYLOAD_IN_MIRROR_MEM attribute
    case ATTR_PAYLOAD_IN_MIRROR_MEM:
        l_attrSize = sizeof(ATTR_PAYLOAD_IN_MIRROR_MEM_type);
        break;

    // Get size for ATTR_PAYLOAD_KIND attribute
    case ATTR_PAYLOAD_KIND:
        l_attrSize = sizeof(ATTR_PAYLOAD_KIND_type);
        break;

    // Get size for ATTR_PCIE_32BIT_DMA_SIZE attribute
    case ATTR_PCIE_32BIT_DMA_SIZE:
        l_attrSize = sizeof(ATTR_PCIE_32BIT_DMA_SIZE_type);
        break;

    // Get size for ATTR_PCIE_32BIT_MMIO_SIZE attribute
    case ATTR_PCIE_32BIT_MMIO_SIZE:
        l_attrSize = sizeof(ATTR_PCIE_32BIT_MMIO_SIZE_type);
        break;

    // Get size for ATTR_PCIE_64BIT_DMA_SIZE attribute
    case ATTR_PCIE_64BIT_DMA_SIZE:
        l_attrSize = sizeof(ATTR_PCIE_64BIT_DMA_SIZE_type);
        break;

    // Get size for ATTR_PCIE_64BIT_MMIO_SIZE attribute
    case ATTR_PCIE_64BIT_MMIO_SIZE:
        l_attrSize = sizeof(ATTR_PCIE_64BIT_MMIO_SIZE_type);
        break;

    // Get size for ATTR_PCIE_CAPABILITES attribute
    case ATTR_PCIE_CAPABILITES:
        l_attrSize = sizeof(ATTR_PCIE_CAPABILITES_type);
        break;

    // Get size for ATTR_PCIE_NVME_CCIN attribute
    case ATTR_PCIE_NVME_CCIN:
        l_attrSize = sizeof(ATTR_PCIE_NVME_CCIN_type);
        break;

    // Get size for ATTR_PCIE_NVME_PHB_CONFIG attribute
    case ATTR_PCIE_NVME_PHB_CONFIG:
        l_attrSize = sizeof(ATTR_PCIE_NVME_PHB_CONFIG_type);
        break;

    // Get size for ATTR_PCI_REFCLOCK_RCVR_TERM attribute
    case ATTR_PCI_REFCLOCK_RCVR_TERM:
        l_attrSize = sizeof(ATTR_PCI_REFCLOCK_RCVR_TERM_type);
        break;

    // Get size for ATTR_PEC_IS_BIFURCATABLE attribute
    case ATTR_PEC_IS_BIFURCATABLE:
        l_attrSize = sizeof(ATTR_PEC_IS_BIFURCATABLE_type);
        break;

    // Get size for ATTR_PEC_PCIE_HX_KEYWORD_DATA attribute
    case ATTR_PEC_PCIE_HX_KEYWORD_DATA:
        l_attrSize = sizeof(ATTR_PEC_PCIE_HX_KEYWORD_DATA_type);
        break;

    // Get size for ATTR_PEC_PCIE_IOP_REVERSAL attribute
    case ATTR_PEC_PCIE_IOP_REVERSAL:
        l_attrSize = sizeof(ATTR_PEC_PCIE_IOP_REVERSAL_type);
        break;

    // Get size for ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED attribute
    case ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED:
        l_attrSize = sizeof(ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED_type);
        break;

    // Get size for ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED attribute
    case ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED:
        l_attrSize = sizeof(ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED_type);
        break;

    // Get size for ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED attribute
    case ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED:
        l_attrSize = sizeof(ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED_type);
        break;

    // Get size for ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED attribute
    case ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED:
        l_attrSize = sizeof(ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED_type);
        break;

    // Get size for ATTR_PEC_PCIE_LANE_MASK_BIFURCATED attribute
    case ATTR_PEC_PCIE_LANE_MASK_BIFURCATED:
        l_attrSize = sizeof(ATTR_PEC_PCIE_LANE_MASK_BIFURCATED_type);
        break;

    // Get size for ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED attribute
    case ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED:
        l_attrSize = sizeof(ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED_type);
        break;

    // Get size for ATTR_PEER_PATH attribute
    case ATTR_PEER_PATH:
        l_attrSize = sizeof(ATTR_PEER_PATH_type);
        break;

    // Get size for ATTR_PEER_TARGET attribute
    case ATTR_PEER_TARGET:
        l_attrSize = sizeof(ATTR_PEER_TARGET_type);
        break;

    // Get size for ATTR_PG attribute
    case ATTR_PG:
        l_attrSize = sizeof(ATTR_PG_type);
        break;

    // Get size for ATTR_PG_SAVED attribute
    case ATTR_PG_SAVED:
        l_attrSize = sizeof(ATTR_PG_SAVED_type);
        break;

    // Get size for ATTR_PHB_BASE_ADDRS attribute
    case ATTR_PHB_BASE_ADDRS:
        l_attrSize = sizeof(ATTR_PHB_BASE_ADDRS_type);
        break;

    // Get size for ATTR_PHYS_PATH attribute
    case ATTR_PHYS_PATH:
        l_attrSize = sizeof(ATTR_PHYS_PATH_type);
        break;

    // Get size for ATTR_PIB_I2C_NEST_PLL attribute
    case ATTR_PIB_I2C_NEST_PLL:
        l_attrSize = sizeof(ATTR_PIB_I2C_NEST_PLL_type);
        break;

    // Get size for ATTR_PIB_I2C_REFCLOCK attribute
    case ATTR_PIB_I2C_REFCLOCK:
        l_attrSize = sizeof(ATTR_PIB_I2C_REFCLOCK_type);
        break;

    // Get size for ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST attribute
    case ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST:
        l_attrSize = sizeof(ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST_type);
        break;

    // Get size for ATTR_PMIC_CALLBACK_STAGGER_TIME attribute
    case ATTR_PMIC_CALLBACK_STAGGER_TIME:
        l_attrSize = sizeof(ATTR_PMIC_CALLBACK_STAGGER_TIME_type);
        break;

    // Get size for ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER attribute
    case ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER:
        l_attrSize = sizeof(ATTR_PMIC_HEALTH_CHECK_DDR5_TIMER_type);
        break;

    // Get size for ATTR_PMIC_HEALTH_CHECK_TIMER attribute
    case ATTR_PMIC_HEALTH_CHECK_TIMER:
        l_attrSize = sizeof(ATTR_PMIC_HEALTH_CHECK_TIMER_type);
        break;

    // Get size for ATTR_PNOR_FLASH_WORKAROUNDS attribute
    case ATTR_PNOR_FLASH_WORKAROUNDS:
        l_attrSize = sizeof(ATTR_PNOR_FLASH_WORKAROUNDS_type);
        break;

    // Get size for ATTR_POSITION attribute
    case ATTR_POSITION:
        l_attrSize = sizeof(ATTR_POSITION_type);
        break;

    // Get size for ATTR_POS_ON_MEM_PORT attribute
    case ATTR_POS_ON_MEM_PORT:
        l_attrSize = sizeof(ATTR_POS_ON_MEM_PORT_type);
        break;

    // Get size for ATTR_POWERVS_P10_FW_VER attribute
    case ATTR_POWERVS_P10_FW_VER:
        l_attrSize = sizeof(ATTR_POWERVS_P10_FW_VER_type);
        break;

    // Get size for ATTR_POWER_PATH attribute
    case ATTR_POWER_PATH:
        l_attrSize = sizeof(ATTR_POWER_PATH_type);
        break;

    // Get size for ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE attribute
    case ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE:
        l_attrSize = sizeof(ATTR_PRD_DD1_OMI_DEGRADE_PREDICTIVE_type);
        break;

    // Get size for ATTR_PRD_HWP_PLID attribute
    case ATTR_PRD_HWP_PLID:
        l_attrSize = sizeof(ATTR_PRD_HWP_PLID_type);
        break;

    // Get size for ATTR_PREHEAT_PERCENT attribute
    case ATTR_PREHEAT_PERCENT:
        l_attrSize = sizeof(ATTR_PREHEAT_PERCENT_type);
        break;

    // Get size for ATTR_PRIMARY_CAPABILITIES attribute
    case ATTR_PRIMARY_CAPABILITIES:
        l_attrSize = sizeof(ATTR_PRIMARY_CAPABILITIES_type);
        break;

    // Get size for ATTR_PROC_COMPATIBILITY_REQ attribute
    case ATTR_PROC_COMPATIBILITY_REQ:
        l_attrSize = sizeof(ATTR_PROC_COMPATIBILITY_REQ_type);
        break;

    // Get size for ATTR_PROC_DCM_INSTALLED attribute
    case ATTR_PROC_DCM_INSTALLED:
        l_attrSize = sizeof(ATTR_PROC_DCM_INSTALLED_type);
        break;

    // Get size for ATTR_PROC_MASTER_TYPE attribute
    case ATTR_PROC_MASTER_TYPE:
        l_attrSize = sizeof(ATTR_PROC_MASTER_TYPE_type);
        break;

    // Get size for ATTR_PROC_MODULE_TYPE attribute
    case ATTR_PROC_MODULE_TYPE:
        l_attrSize = sizeof(ATTR_PROC_MODULE_TYPE_type);
        break;

    // Get size for ATTR_PROC_PCIE_IOP_CONFIG attribute
    case ATTR_PROC_PCIE_IOP_CONFIG:
        l_attrSize = sizeof(ATTR_PROC_PCIE_IOP_CONFIG_type);
        break;

    // Get size for ATTR_PROC_PCIE_IOVALID_ENABLE attribute
    case ATTR_PROC_PCIE_IOVALID_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_IOVALID_ENABLE_type);
        break;

    // Get size for ATTR_PROC_PCIE_IS_SLOT attribute
    case ATTR_PROC_PCIE_IS_SLOT:
        l_attrSize = sizeof(ATTR_PROC_PCIE_IS_SLOT_type);
        break;

    // Get size for ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3 attribute
    case ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3:
        l_attrSize = sizeof(ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3_type);
        break;

    // Get size for ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4 attribute
    case ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4:
        l_attrSize = sizeof(ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4_type);
        break;

    // Get size for ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5 attribute
    case ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5:
        l_attrSize = sizeof(ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN5_type);
        break;

    // Get size for ATTR_PROC_PCIE_LANE_MASK attribute
    case ATTR_PROC_PCIE_LANE_MASK:
        l_attrSize = sizeof(ATTR_PROC_PCIE_LANE_MASK_type);
        break;

    // Get size for ATTR_PROC_PCIE_LANE_REVERSAL_BASE attribute
    case ATTR_PROC_PCIE_LANE_REVERSAL_BASE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_LANE_REVERSAL_BASE_type);
        break;

    // Get size for ATTR_PROC_PCIE_NUM_PEC attribute
    case ATTR_PROC_PCIE_NUM_PEC:
        l_attrSize = sizeof(ATTR_PROC_PCIE_NUM_PEC_type);
        break;

    // Get size for ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL attribute
    case ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL_type);
        break;

    // Get size for ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL attribute
    case ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL_type);
        break;

    // Get size for ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL attribute
    case ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL_type);
        break;

    // Get size for ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3 attribute
    case ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3_type);
        break;

    // Get size for ATTR_PROC_PCIE_PHB_ACTIVE_BASE attribute
    case ATTR_PROC_PCIE_PHB_ACTIVE_BASE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_PHB_ACTIVE_BASE_type);
        break;

    // Get size for ATTR_PROC_PCIE_REFCLOCK_ENABLE attribute
    case ATTR_PROC_PCIE_REFCLOCK_ENABLE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_REFCLOCK_ENABLE_type);
        break;

    // Get size for ATTR_PROC_REFCLOCK_RCVR_TERM attribute
    case ATTR_PROC_REFCLOCK_RCVR_TERM:
        l_attrSize = sizeof(ATTR_PROC_REFCLOCK_RCVR_TERM_type);
        break;

    // Get size for ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE attribute
    case ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE:
        l_attrSize = sizeof(ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE_type);
        break;

    // Get size for ATTR_PROC_SELECT_SEEPROM_IMAGE attribute
    case ATTR_PROC_SELECT_SEEPROM_IMAGE:
        l_attrSize = sizeof(ATTR_PROC_SELECT_SEEPROM_IMAGE_type);
        break;

    // Get size for ATTR_PSI_BRIDGE_BASE_ADDR attribute
    case ATTR_PSI_BRIDGE_BASE_ADDR:
        l_attrSize = sizeof(ATTR_PSI_BRIDGE_BASE_ADDR_type);
        break;

    // Get size for ATTR_PSI_HB_ESB_ADDR attribute
    case ATTR_PSI_HB_ESB_ADDR:
        l_attrSize = sizeof(ATTR_PSI_HB_ESB_ADDR_type);
        break;

    // Get size for ATTR_RAW_MTM attribute
    case ATTR_RAW_MTM:
        l_attrSize = sizeof(ATTR_RAW_MTM_type);
        break;

    // Get size for ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED attribute
    case ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED:
        l_attrSize = sizeof(ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED_type);
        break;

    // Get size for ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT attribute
    case ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT:
        l_attrSize = sizeof(ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT_type);
        break;

    // Get size for ATTR_RECONFIG_LOOP_TESTS attribute
    case ATTR_RECONFIG_LOOP_TESTS:
        l_attrSize = sizeof(ATTR_RECONFIG_LOOP_TESTS_type);
        break;

    // Get size for ATTR_RECONFIG_LOOP_TESTS_ENABLE attribute
    case ATTR_RECONFIG_LOOP_TESTS_ENABLE:
        l_attrSize = sizeof(ATTR_RECONFIG_LOOP_TESTS_ENABLE_type);
        break;

    // Get size for ATTR_REDUNDANT_CLOCKS attribute
    case ATTR_REDUNDANT_CLOCKS:
        l_attrSize = sizeof(ATTR_REDUNDANT_CLOCKS_type);
        break;

    // Get size for ATTR_REL_POS attribute
    case ATTR_REL_POS:
        l_attrSize = sizeof(ATTR_REL_POS_type);
        break;

    // Get size for ATTR_REPLACED_BY_SPARE attribute
    case ATTR_REPLACED_BY_SPARE:
        l_attrSize = sizeof(ATTR_REPLACED_BY_SPARE_type);
        break;

    // Get size for ATTR_RESOURCE_IS_CRITICAL attribute
    case ATTR_RESOURCE_IS_CRITICAL:
        l_attrSize = sizeof(ATTR_RESOURCE_IS_CRITICAL_type);
        break;

    // Get size for ATTR_RISK_LEVEL_ORIGIN attribute
    case ATTR_RISK_LEVEL_ORIGIN:
        l_attrSize = sizeof(ATTR_RISK_LEVEL_ORIGIN_type);
        break;

    // Get size for ATTR_RNG_BAR_SIZE attribute
    case ATTR_RNG_BAR_SIZE:
        l_attrSize = sizeof(ATTR_RNG_BAR_SIZE_type);
        break;

    // Get size for ATTR_RNG_BASE_ADDR attribute
    case ATTR_RNG_BASE_ADDR:
        l_attrSize = sizeof(ATTR_RNG_BASE_ADDR_type);
        break;

    // Get size for ATTR_RUN_MAX_MEM_PATTERNS attribute
    case ATTR_RUN_MAX_MEM_PATTERNS:
        l_attrSize = sizeof(ATTR_RUN_MAX_MEM_PATTERNS_type);
        break;

    // Get size for ATTR_RUN_ODY_HWP_FROM_HOST attribute
    case ATTR_RUN_ODY_HWP_FROM_HOST:
        l_attrSize = sizeof(ATTR_RUN_ODY_HWP_FROM_HOST_type);
        break;

    // Get size for ATTR_SAVED_STATE_UINT8 attribute
    case ATTR_SAVED_STATE_UINT8:
        l_attrSize = sizeof(ATTR_SAVED_STATE_UINT8_type);
        break;

    // Get size for ATTR_SBE_BOOTLOADER_CODELEVEL attribute
    case ATTR_SBE_BOOTLOADER_CODELEVEL:
        l_attrSize = sizeof(ATTR_SBE_BOOTLOADER_CODELEVEL_type);
        break;

    // Get size for ATTR_SBE_BUILD_TAG attribute
    case ATTR_SBE_BUILD_TAG:
        l_attrSize = sizeof(ATTR_SBE_BUILD_TAG_type);
        break;

    // Get size for ATTR_SBE_COMMIT_ID attribute
    case ATTR_SBE_COMMIT_ID:
        l_attrSize = sizeof(ATTR_SBE_COMMIT_ID_type);
        break;

    // Get size for ATTR_SBE_EKB_BUILD_TAG attribute
    case ATTR_SBE_EKB_BUILD_TAG:
        l_attrSize = sizeof(ATTR_SBE_EKB_BUILD_TAG_type);
        break;

    // Get size for ATTR_SBE_FIFO_CAPABILITIES attribute
    case ATTR_SBE_FIFO_CAPABILITIES:
        l_attrSize = sizeof(ATTR_SBE_FIFO_CAPABILITIES_type);
        break;

    // Get size for ATTR_SBE_HANDLES_SMP_TPM_EXTEND attribute
    case ATTR_SBE_HANDLES_SMP_TPM_EXTEND:
        l_attrSize = sizeof(ATTR_SBE_HANDLES_SMP_TPM_EXTEND_type);
        break;

    // Get size for ATTR_SBE_IS_STARTED attribute
    case ATTR_SBE_IS_STARTED:
        l_attrSize = sizeof(ATTR_SBE_IS_STARTED_type);
        break;

    // Get size for ATTR_SBE_NUM_CAPABILITIES attribute
    case ATTR_SBE_NUM_CAPABILITIES:
        l_attrSize = sizeof(ATTR_SBE_NUM_CAPABILITIES_type);
        break;

    // Get size for ATTR_SBE_NUM_IMAGES attribute
    case ATTR_SBE_NUM_IMAGES:
        l_attrSize = sizeof(ATTR_SBE_NUM_IMAGES_type);
        break;

    // Get size for ATTR_SBE_RELEASE_TAG attribute
    case ATTR_SBE_RELEASE_TAG:
        l_attrSize = sizeof(ATTR_SBE_RELEASE_TAG_type);
        break;

    // Get size for ATTR_SBE_RUNTIME_CODELEVEL attribute
    case ATTR_SBE_RUNTIME_CODELEVEL:
        l_attrSize = sizeof(ATTR_SBE_RUNTIME_CODELEVEL_type);
        break;

    // Get size for ATTR_SBE_UPDATE_DISABLE attribute
    case ATTR_SBE_UPDATE_DISABLE:
        l_attrSize = sizeof(ATTR_SBE_UPDATE_DISABLE_type);
        break;

    // Get size for ATTR_SBE_VERSION_INFO attribute
    case ATTR_SBE_VERSION_INFO:
        l_attrSize = sizeof(ATTR_SBE_VERSION_INFO_type);
        break;

    // Get size for ATTR_SCOM_SWITCHES attribute
    case ATTR_SCOM_SWITCHES:
        l_attrSize = sizeof(ATTR_SCOM_SWITCHES_type);
        break;

    // Get size for ATTR_SCRATCH_UINT32_1 attribute
    case ATTR_SCRATCH_UINT32_1:
        l_attrSize = sizeof(ATTR_SCRATCH_UINT32_1_type);
        break;

    // Get size for ATTR_SCRATCH_UINT32_2 attribute
    case ATTR_SCRATCH_UINT32_2:
        l_attrSize = sizeof(ATTR_SCRATCH_UINT32_2_type);
        break;

    // Get size for ATTR_SCRATCH_UINT64_1 attribute
    case ATTR_SCRATCH_UINT64_1:
        l_attrSize = sizeof(ATTR_SCRATCH_UINT64_1_type);
        break;

    // Get size for ATTR_SCRATCH_UINT64_2 attribute
    case ATTR_SCRATCH_UINT64_2:
        l_attrSize = sizeof(ATTR_SCRATCH_UINT64_2_type);
        break;

    // Get size for ATTR_SCRATCH_UINT8_1 attribute
    case ATTR_SCRATCH_UINT8_1:
        l_attrSize = sizeof(ATTR_SCRATCH_UINT8_1_type);
        break;

    // Get size for ATTR_SCRATCH_UINT8_2 attribute
    case ATTR_SCRATCH_UINT8_2:
        l_attrSize = sizeof(ATTR_SCRATCH_UINT8_2_type);
        break;

    // Get size for ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM attribute
    case ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM:
        l_attrSize = sizeof(ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM_type);
        break;

    // Get size for ATTR_SECURE_VERSION_LOCKIN_POLICY attribute
    case ATTR_SECURE_VERSION_LOCKIN_POLICY:
        l_attrSize = sizeof(ATTR_SECURE_VERSION_LOCKIN_POLICY_type);
        break;

    // Get size for ATTR_SECURE_VERSION_NUM attribute
    case ATTR_SECURE_VERSION_NUM:
        l_attrSize = sizeof(ATTR_SECURE_VERSION_NUM_type);
        break;

    // Get size for ATTR_SECURE_VERSION_SEEPROM attribute
    case ATTR_SECURE_VERSION_SEEPROM:
        l_attrSize = sizeof(ATTR_SECURE_VERSION_SEEPROM_type);
        break;

    // Get size for ATTR_SKIP_HBRT_ATTR_UPDATE attribute
    case ATTR_SKIP_HBRT_ATTR_UPDATE:
        l_attrSize = sizeof(ATTR_SKIP_HBRT_ATTR_UPDATE_type);
        break;

    // Get size for ATTR_SLOT_INDEX attribute
    case ATTR_SLOT_INDEX:
        l_attrSize = sizeof(ATTR_SLOT_INDEX_type);
        break;

    // Get size for ATTR_SLOT_NAME attribute
    case ATTR_SLOT_NAME:
        l_attrSize = sizeof(ATTR_SLOT_NAME_type);
        break;

    // Get size for ATTR_SMF_MEM_AMT_REQUESTED attribute
    case ATTR_SMF_MEM_AMT_REQUESTED:
        l_attrSize = sizeof(ATTR_SMF_MEM_AMT_REQUESTED_type);
        break;

    // Get size for ATTR_SOCKET_POWER_TURBO attribute
    case ATTR_SOCKET_POWER_TURBO:
        l_attrSize = sizeof(ATTR_SOCKET_POWER_TURBO_type);
        break;

    // Get size for ATTR_SPARE_CORES attribute
    case ATTR_SPARE_CORES:
        l_attrSize = sizeof(ATTR_SPARE_CORES_type);
        break;

    // Get size for ATTR_SPARE_CORES_DEPLOYED attribute
    case ATTR_SPARE_CORES_DEPLOYED:
        l_attrSize = sizeof(ATTR_SPARE_CORES_DEPLOYED_type);
        break;

    // Get size for ATTR_SPARE_CORE_ACTIONS_DISABLED attribute
    case ATTR_SPARE_CORE_ACTIONS_DISABLED:
        l_attrSize = sizeof(ATTR_SPARE_CORE_ACTIONS_DISABLED_type);
        break;

    // Get size for ATTR_SPI_EEPROM_SPARE_INFO attribute
    case ATTR_SPI_EEPROM_SPARE_INFO:
        l_attrSize = sizeof(ATTR_SPI_EEPROM_SPARE_INFO_type);
        break;

    // Get size for ATTR_SPI_EEPROM_VPD_BACKUP_INFO attribute
    case ATTR_SPI_EEPROM_VPD_BACKUP_INFO:
        l_attrSize = sizeof(ATTR_SPI_EEPROM_VPD_BACKUP_INFO_type);
        break;

    // Get size for ATTR_SPI_EEPROM_VPD_PRIMARY_INFO attribute
    case ATTR_SPI_EEPROM_VPD_PRIMARY_INFO:
        l_attrSize = sizeof(ATTR_SPI_EEPROM_VPD_PRIMARY_INFO_type);
        break;

    // Get size for ATTR_SPI_KEYSTORE_INFO_HOSTBOOT attribute
    case ATTR_SPI_KEYSTORE_INFO_HOSTBOOT:
        l_attrSize = sizeof(ATTR_SPI_KEYSTORE_INFO_HOSTBOOT_type);
        break;

    // Get size for ATTR_SPI_KEYSTORE_INFO_OPAL_0 attribute
    case ATTR_SPI_KEYSTORE_INFO_OPAL_0:
        l_attrSize = sizeof(ATTR_SPI_KEYSTORE_INFO_OPAL_0_type);
        break;

    // Get size for ATTR_SPI_KEYSTORE_INFO_OPAL_1 attribute
    case ATTR_SPI_KEYSTORE_INFO_OPAL_1:
        l_attrSize = sizeof(ATTR_SPI_KEYSTORE_INFO_OPAL_1_type);
        break;

    // Get size for ATTR_SPI_KEYSTORE_INFO_OPAL_2 attribute
    case ATTR_SPI_KEYSTORE_INFO_OPAL_2:
        l_attrSize = sizeof(ATTR_SPI_KEYSTORE_INFO_OPAL_2_type);
        break;

    // Get size for ATTR_SPI_KEYSTORE_INFO_PHYP attribute
    case ATTR_SPI_KEYSTORE_INFO_PHYP:
        l_attrSize = sizeof(ATTR_SPI_KEYSTORE_INFO_PHYP_type);
        break;

    // Get size for ATTR_SPI_MVPD_BACKUP_INFO attribute
    case ATTR_SPI_MVPD_BACKUP_INFO:
        l_attrSize = sizeof(ATTR_SPI_MVPD_BACKUP_INFO_type);
        break;

    // Get size for ATTR_SPI_MVPD_PRIMARY_INFO attribute
    case ATTR_SPI_MVPD_PRIMARY_INFO:
        l_attrSize = sizeof(ATTR_SPI_MVPD_PRIMARY_INFO_type);
        break;

    // Get size for ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO attribute
    case ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO:
        l_attrSize = sizeof(ATTR_SPI_SBE_BOOT_CODE_BACKUP_INFO_type);
        break;

    // Get size for ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO attribute
    case ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO:
        l_attrSize = sizeof(ATTR_SPI_SBE_BOOT_CODE_PRIMARY_INFO_type);
        break;

    // Get size for ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO attribute
    case ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO:
        l_attrSize = sizeof(ATTR_SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO_type);
        break;

    // Get size for ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO attribute
    case ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO:
        l_attrSize = sizeof(ATTR_SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO_type);
        break;

    // Get size for ATTR_SPI_SWITCHES attribute
    case ATTR_SPI_SWITCHES:
        l_attrSize = sizeof(ATTR_SPI_SWITCHES_type);
        break;

    // Get size for ATTR_SPI_TPM_INFO attribute
    case ATTR_SPI_TPM_INFO:
        l_attrSize = sizeof(ATTR_SPI_TPM_INFO_type);
        break;

    // Get size for ATTR_SPI_WOF_DATA_INFO attribute
    case ATTR_SPI_WOF_DATA_INFO:
        l_attrSize = sizeof(ATTR_SPI_WOF_DATA_INFO_type);
        break;

    // Get size for ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH attribute
    case ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH:
        l_attrSize = sizeof(ATTR_SPPE_BOOTLOADER_MEASUREMENT_HASH_type);
        break;

    // Get size for ATTR_SPPE_RUNTIME_MEASUREMENT_HASH attribute
    case ATTR_SPPE_RUNTIME_MEASUREMENT_HASH:
        l_attrSize = sizeof(ATTR_SPPE_RUNTIME_MEASUREMENT_HASH_type);
        break;

    // Get size for ATTR_SP_FUNCTIONS attribute
    case ATTR_SP_FUNCTIONS:
        l_attrSize = sizeof(ATTR_SP_FUNCTIONS_type);
        break;

    // Get size for ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN attribute
    case ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN:
        l_attrSize = sizeof(ATTR_START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN_type);
        break;

    // Get size for ATTR_STOP5_DISABLE attribute
    case ATTR_STOP5_DISABLE:
        l_attrSize = sizeof(ATTR_STOP5_DISABLE_type);
        break;

    // Get size for ATTR_SUPPORTED_STOP_STATES attribute
    case ATTR_SUPPORTED_STOP_STATES:
        l_attrSize = sizeof(ATTR_SUPPORTED_STOP_STATES_type);
        break;

    // Get size for ATTR_SUPPORTS_DYNAMIC_MEM_VOLT attribute
    case ATTR_SUPPORTS_DYNAMIC_MEM_VOLT:
        l_attrSize = sizeof(ATTR_SUPPORTS_DYNAMIC_MEM_VOLT_type);
        break;

    // Get size for ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG attribute
    case ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG:
        l_attrSize = sizeof(ATTR_SW511706_CHECKSTOP_ON_GTE_LV1_HANG_type);
        break;

    // Get size for ATTR_SYNC_BETWEEN_STEPS attribute
    case ATTR_SYNC_BETWEEN_STEPS:
        l_attrSize = sizeof(ATTR_SYNC_BETWEEN_STEPS_type);
        break;

    // Get size for ATTR_SYSTEM_FAMILY attribute
    case ATTR_SYSTEM_FAMILY:
        l_attrSize = sizeof(ATTR_SYSTEM_FAMILY_type);
        break;

    // Get size for ATTR_SYSTEM_THERMAL_RESISTANCE attribute
    case ATTR_SYSTEM_THERMAL_RESISTANCE:
        l_attrSize = sizeof(ATTR_SYSTEM_THERMAL_RESISTANCE_type);
        break;

    // Get size for ATTR_SYSTEM_TYPE attribute
    case ATTR_SYSTEM_TYPE:
        l_attrSize = sizeof(ATTR_SYSTEM_TYPE_type);
        break;

    // Get size for ATTR_SYS_LOCATION_CODE attribute
    case ATTR_SYS_LOCATION_CODE:
        l_attrSize = sizeof(ATTR_SYS_LOCATION_CODE_type);
        break;

    // Get size for ATTR_TCE_START_TOKEN_FOR_HDAT attribute
    case ATTR_TCE_START_TOKEN_FOR_HDAT:
        l_attrSize = sizeof(ATTR_TCE_START_TOKEN_FOR_HDAT_type);
        break;

    // Get size for ATTR_TCE_START_TOKEN_FOR_PAYLOAD attribute
    case ATTR_TCE_START_TOKEN_FOR_PAYLOAD:
        l_attrSize = sizeof(ATTR_TCE_START_TOKEN_FOR_PAYLOAD_type);
        break;

    // Get size for ATTR_TEMP_SENSOR_I2C_CONFIG attribute
    case ATTR_TEMP_SENSOR_I2C_CONFIG:
        l_attrSize = sizeof(ATTR_TEMP_SENSOR_I2C_CONFIG_type);
        break;

    // Get size for ATTR_TEST_MAX_STRING attribute
    case ATTR_TEST_MAX_STRING:
        l_attrSize = sizeof(ATTR_TEST_MAX_STRING_type);
        break;

    // Get size for ATTR_TEST_MIN_STRING attribute
    case ATTR_TEST_MIN_STRING:
        l_attrSize = sizeof(ATTR_TEST_MIN_STRING_type);
        break;

    // Get size for ATTR_TEST_NEGATIVE_FCN attribute
    case ATTR_TEST_NEGATIVE_FCN:
        l_attrSize = sizeof(ATTR_TEST_NEGATIVE_FCN_type);
        break;

    // Get size for ATTR_TEST_NO_DEFAULT_STRING attribute
    case ATTR_TEST_NO_DEFAULT_STRING:
        l_attrSize = sizeof(ATTR_TEST_NO_DEFAULT_STRING_type);
        break;

    // Get size for ATTR_TEST_NULL_STRING attribute
    case ATTR_TEST_NULL_STRING:
        l_attrSize = sizeof(ATTR_TEST_NULL_STRING_type);
        break;

    // Get size for ATTR_THREAD_COUNT attribute
    case ATTR_THREAD_COUNT:
        l_attrSize = sizeof(ATTR_THREAD_COUNT_type);
        break;

    // Get size for ATTR_TIME_BASE attribute
    case ATTR_TIME_BASE:
        l_attrSize = sizeof(ATTR_TIME_BASE_type);
        break;

    // Get size for ATTR_TLB_DATA_ASSOC_SETS attribute
    case ATTR_TLB_DATA_ASSOC_SETS:
        l_attrSize = sizeof(ATTR_TLB_DATA_ASSOC_SETS_type);
        break;

    // Get size for ATTR_TLB_DATA_ENTRIES attribute
    case ATTR_TLB_DATA_ENTRIES:
        l_attrSize = sizeof(ATTR_TLB_DATA_ENTRIES_type);
        break;

    // Get size for ATTR_TLB_INSTR_ASSOC_SETS attribute
    case ATTR_TLB_INSTR_ASSOC_SETS:
        l_attrSize = sizeof(ATTR_TLB_INSTR_ASSOC_SETS_type);
        break;

    // Get size for ATTR_TLB_INSTR_ENTRIES attribute
    case ATTR_TLB_INSTR_ENTRIES:
        l_attrSize = sizeof(ATTR_TLB_INSTR_ENTRIES_type);
        break;

    // Get size for ATTR_TLB_RESERVE_SIZE attribute
    case ATTR_TLB_RESERVE_SIZE:
        l_attrSize = sizeof(ATTR_TLB_RESERVE_SIZE_type);
        break;

    // Get size for ATTR_TOD_CPU_DATA attribute
    case ATTR_TOD_CPU_DATA:
        l_attrSize = sizeof(ATTR_TOD_CPU_DATA_type);
        break;

    // Get size for ATTR_TOD_ROLE attribute
    case ATTR_TOD_ROLE:
        l_attrSize = sizeof(ATTR_TOD_ROLE_type);
        break;

    // Get size for ATTR_TPM_ENABLED attribute
    case ATTR_TPM_ENABLED:
        l_attrSize = sizeof(ATTR_TPM_ENABLED_type);
        break;

    // Get size for ATTR_TPM_POISONED attribute
    case ATTR_TPM_POISONED:
        l_attrSize = sizeof(ATTR_TPM_POISONED_type);
        break;

    // Get size for ATTR_TPM_REQUIRED attribute
    case ATTR_TPM_REQUIRED:
        l_attrSize = sizeof(ATTR_TPM_REQUIRED_type);
        break;

    // Get size for ATTR_TPM_UNUSABLE attribute
    case ATTR_TPM_UNUSABLE:
        l_attrSize = sizeof(ATTR_TPM_UNUSABLE_type);
        break;

    // Get size for ATTR_TYPE attribute
    case ATTR_TYPE:
        l_attrSize = sizeof(ATTR_TYPE_type);
        break;

    // Get size for ATTR_UCD_MFR_REVISION_OVERRIDE attribute
    case ATTR_UCD_MFR_REVISION_OVERRIDE:
        l_attrSize = sizeof(ATTR_UCD_MFR_REVISION_OVERRIDE_type);
        break;

    // Get size for ATTR_ULTRA_TURBO_FREQ_MHZ attribute
    case ATTR_ULTRA_TURBO_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_ULTRA_TURBO_FREQ_MHZ_type);
        break;

    // Get size for ATTR_USE_11S_SPD attribute
    case ATTR_USE_11S_SPD:
        l_attrSize = sizeof(ATTR_USE_11S_SPD_type);
        break;

    // Get size for ATTR_USE_PIPE_FIFO attribute
    case ATTR_USE_PIPE_FIFO:
        l_attrSize = sizeof(ATTR_USE_PIPE_FIFO_type);
        break;

    // Get size for ATTR_USE_TCES_FOR_DMAS attribute
    case ATTR_USE_TCES_FOR_DMAS:
        l_attrSize = sizeof(ATTR_USE_TCES_FOR_DMAS_type);
        break;

    // Get size for ATTR_VCS_ID attribute
    case ATTR_VCS_ID:
        l_attrSize = sizeof(ATTR_VCS_ID_type);
        break;

    // Get size for ATTR_VDDR_ID attribute
    case ATTR_VDDR_ID:
        l_attrSize = sizeof(ATTR_VDDR_ID_type);
        break;

    // Get size for ATTR_VDD_ID attribute
    case ATTR_VDD_ID:
        l_attrSize = sizeof(ATTR_VDD_ID_type);
        break;

    // Get size for ATTR_VENDOR_ID attribute
    case ATTR_VENDOR_ID:
        l_attrSize = sizeof(ATTR_VENDOR_ID_type);
        break;

    // Get size for ATTR_VPD_REC_NUM attribute
    case ATTR_VPD_REC_NUM:
        l_attrSize = sizeof(ATTR_VPD_REC_NUM_type);
        break;

    // Get size for ATTR_VPP_ID attribute
    case ATTR_VPP_ID:
        l_attrSize = sizeof(ATTR_VPP_ID_type);
        break;

    // Get size for ATTR_WOF_POWER_LIMIT attribute
    case ATTR_WOF_POWER_LIMIT:
        l_attrSize = sizeof(ATTR_WOF_POWER_LIMIT_type);
        break;

    // Get size for ATTR_WOF_TABLE_LID_NUMBER attribute
    case ATTR_WOF_TABLE_LID_NUMBER:
        l_attrSize = sizeof(ATTR_WOF_TABLE_LID_NUMBER_type);
        break;

    // Get size for ATTR_XIVE_CONTROLLER_BAR_ADDR attribute
    case ATTR_XIVE_CONTROLLER_BAR_ADDR:
        l_attrSize = sizeof(ATTR_XIVE_CONTROLLER_BAR_ADDR_type);
        break;

    // Get size for ATTR_XSCOM_BASE_ADDRESS attribute
    case ATTR_XSCOM_BASE_ADDRESS:
        l_attrSize = sizeof(ATTR_XSCOM_BASE_ADDRESS_type);
        break;

    // Get size for ATTR_I2C_CHIP_INFO attribute
    case ATTR_I2C_CHIP_INFO:
        l_attrSize = sizeof(ATTR_I2C_CHIP_INFO_type);
        break;

    // Get size for ATTR_SBE_STATE attribute
    case ATTR_SBE_STATE:
        l_attrSize = sizeof(ATTR_SBE_STATE_type);
        break;

    // Get size for ATTR_HCSI_CHIP_SBE_INTERFACE_PTR attribute
    case ATTR_HCSI_CHIP_SBE_INTERFACE_PTR:
        l_attrSize = sizeof(ATTR_HCSI_CHIP_SBE_INTERFACE_PTR_type);
        break;

    // Get size for ATTR_HCSI_CHIP_INTERFACE_PTR attribute
    case ATTR_HCSI_CHIP_INTERFACE_PTR:
        l_attrSize = sizeof(ATTR_HCSI_CHIP_INTERFACE_PTR_type);
        break;

    // Get size for ATTR_SCANRING_FACTORY_PTR attribute
    case ATTR_SCANRING_FACTORY_PTR:
        l_attrSize = sizeof(ATTR_SCANRING_FACTORY_PTR_type);
        break;

    // Get size for ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER attribute
    case ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER:
        l_attrSize = sizeof(ATTR_ALG_TYPE_TO_ALG_TOKEN_CONTAINER_type);
        break;

    // Get size for ATTR_ECMD_TARGET attribute
    case ATTR_ECMD_TARGET:
        l_attrSize = sizeof(ATTR_ECMD_TARGET_type);
        break;

    // Get size for ATTR_RID attribute
    case ATTR_RID:
        l_attrSize = sizeof(ATTR_RID_type);
        break;

    // Get size for ATTR_FSP_SCOM_DEVICE_PATH attribute
    case ATTR_FSP_SCOM_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_SCOM_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_A_SCOM_DEVICE_PATH attribute
    case ATTR_FSP_A_SCOM_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_SCOM_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_B_SCOM_DEVICE_PATH attribute
    case ATTR_FSP_B_SCOM_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_SCOM_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_SCAN_DEVICE_PATH attribute
    case ATTR_FSP_SCAN_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_SCAN_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_A_SCAN_DEVICE_PATH attribute
    case ATTR_FSP_A_SCAN_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_SCAN_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_B_SCAN_DEVICE_PATH attribute
    case ATTR_FSP_B_SCAN_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_SCAN_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_MBOX_DEVICE_PATH attribute
    case ATTR_FSP_MBOX_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_MBOX_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_A_MBOX_DEVICE_PATH attribute
    case ATTR_FSP_A_MBOX_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_MBOX_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_B_MBOX_DEVICE_PATH attribute
    case ATTR_FSP_B_MBOX_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_MBOX_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_SBEFIFO_DEVICE_PATH attribute
    case ATTR_FSP_SBEFIFO_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_SBEFIFO_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_A_SBEFIFO_DEVICE_PATH attribute
    case ATTR_FSP_A_SBEFIFO_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_SBEFIFO_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_B_SBEFIFO_DEVICE_PATH attribute
    case ATTR_FSP_B_SBEFIFO_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_SBEFIFO_DEVICE_PATH_type);
        break;

    // Get size for ATTR_MAX_MS_ADDR attribute
    case ATTR_MAX_MS_ADDR:
        l_attrSize = sizeof(ATTR_MAX_MS_ADDR_type);
        break;

    // Get size for ATTR_PAYLOAD_STATE attribute
    case ATTR_PAYLOAD_STATE:
        l_attrSize = sizeof(ATTR_PAYLOAD_STATE_type);
        break;

    // Get size for ATTR_PAYLOAD_STARTED attribute
    case ATTR_PAYLOAD_STARTED:
        l_attrSize = sizeof(ATTR_PAYLOAD_STARTED_type);
        break;

    // Get size for ATTR_HB_RUNNING attribute
    case ATTR_HB_RUNNING:
        l_attrSize = sizeof(ATTR_HB_RUNNING_type);
        break;

    // Get size for ATTR_RESUME_PAYLOAD attribute
    case ATTR_RESUME_PAYLOAD:
        l_attrSize = sizeof(ATTR_RESUME_PAYLOAD_type);
        break;

    // Get size for ATTR_PSI_LINK_STATE attribute
    case ATTR_PSI_LINK_STATE:
        l_attrSize = sizeof(ATTR_PSI_LINK_STATE_type);
        break;

    // Get size for ATTR_PSI_DEVICE_PATH attribute
    case ATTR_PSI_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_PSI_DEVICE_PATH_type);
        break;

    // Get size for ATTR_HOST_MAILBOX_DEV_PATH attribute
    case ATTR_HOST_MAILBOX_DEV_PATH:
        l_attrSize = sizeof(ATTR_HOST_MAILBOX_DEV_PATH_type);
        break;

    // Get size for ATTR_FSP_MTD_DEVICE_PATH attribute
    case ATTR_FSP_MTD_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_MTD_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_MTDBLOCK_DEVICE_PATH attribute
    case ATTR_FSP_MTDBLOCK_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_MTDBLOCK_DEVICE_PATH_type);
        break;

    // Get size for ATTR_EFF_HOSTBOOT_IMG_OFFSET attribute
    case ATTR_EFF_HOSTBOOT_IMG_OFFSET:
        l_attrSize = sizeof(ATTR_EFF_HOSTBOOT_IMG_OFFSET_type);
        break;

    // Get size for ATTR_PROC_HW_TOPOLOGY attribute
    case ATTR_PROC_HW_TOPOLOGY:
        l_attrSize = sizeof(ATTR_PROC_HW_TOPOLOGY_type);
        break;

    // Get size for ATTR_FSP_VMEM_DEVICE_PATH attribute
    case ATTR_FSP_VMEM_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VMEM_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VMEM_I2C_ADDR attribute
    case ATTR_FSP_VMEM_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VMEM_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_VDDR_DEVICE_PATH attribute
    case ATTR_FSP_VDDR_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VDDR_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VDDR_I2C_ADDR attribute
    case ATTR_FSP_VDDR_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VDDR_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_VDD_DEVICE_PATH attribute
    case ATTR_FSP_VDD_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VDD_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VDD_I2C_ADDR attribute
    case ATTR_FSP_VDD_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VDD_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_AVDD_DEVICE_PATH attribute
    case ATTR_FSP_AVDD_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_AVDD_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_AVDD_I2C_ADDR attribute
    case ATTR_FSP_AVDD_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_AVDD_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_VCS_DEVICE_PATH attribute
    case ATTR_FSP_VCS_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VCS_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VCS_I2C_ADDR attribute
    case ATTR_FSP_VCS_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VCS_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_VPP_DEVICE_PATH attribute
    case ATTR_FSP_VPP_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VPP_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VPP_I2C_ADDR attribute
    case ATTR_FSP_VPP_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VPP_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_VIO_DEVICE_PATH attribute
    case ATTR_FSP_VIO_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VIO_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VIO_I2C_ADDR attribute
    case ATTR_FSP_VIO_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VIO_I2C_ADDR_type);
        break;

    // Get size for ATTR_FSP_VDN_DEVICE_PATH attribute
    case ATTR_FSP_VDN_DEVICE_PATH:
        l_attrSize = sizeof(ATTR_FSP_VDN_DEVICE_PATH_type);
        break;

    // Get size for ATTR_FSP_VDN_I2C_ADDR attribute
    case ATTR_FSP_VDN_I2C_ADDR:
        l_attrSize = sizeof(ATTR_FSP_VDN_I2C_ADDR_type);
        break;

    // Get size for ATTR_IS_MPIPL attribute
    case ATTR_IS_MPIPL:
        l_attrSize = sizeof(ATTR_IS_MPIPL_type);
        break;

    // Get size for ATTR_MSL_CHECK attribute
    case ATTR_MSL_CHECK:
        l_attrSize = sizeof(ATTR_MSL_CHECK_type);
        break;

    // Get size for ATTR_PRIMARY_SBE_SEEPROM_ADDRESS attribute
    case ATTR_PRIMARY_SBE_SEEPROM_ADDRESS:
        l_attrSize = sizeof(ATTR_PRIMARY_SBE_SEEPROM_ADDRESS_type);
        break;

    // Get size for ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS attribute
    case ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS:
        l_attrSize = sizeof(ATTR_FSP_A_PRIMARY_SBE_SEEPROM_ADDRESS_type);
        break;

    // Get size for ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS attribute
    case ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS:
        l_attrSize = sizeof(ATTR_FSP_B_PRIMARY_SBE_SEEPROM_ADDRESS_type);
        break;

    // Get size for ATTR_SECONDARY_SBE_SEEPROM_ADDRESS attribute
    case ATTR_SECONDARY_SBE_SEEPROM_ADDRESS:
        l_attrSize = sizeof(ATTR_SECONDARY_SBE_SEEPROM_ADDRESS_type);
        break;

    // Get size for ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS attribute
    case ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS:
        l_attrSize = sizeof(ATTR_FSP_A_SECONDARY_SBE_SEEPROM_ADDRESS_type);
        break;

    // Get size for ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS attribute
    case ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS:
        l_attrSize = sizeof(ATTR_FSP_B_SECONDARY_SBE_SEEPROM_ADDRESS_type);
        break;

    // Get size for ATTR_PROC_SELECT_CLOCK_MUX_MODE attribute
    case ATTR_PROC_SELECT_CLOCK_MUX_MODE:
        l_attrSize = sizeof(ATTR_PROC_SELECT_CLOCK_MUX_MODE_type);
        break;

    // Get size for ATTR_POWERSAVE_FREQ_MHZ attribute
    case ATTR_POWERSAVE_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_POWERSAVE_FREQ_MHZ_type);
        break;

    // Get size for ATTR_TURBO_FREQ_MHZ attribute
    case ATTR_TURBO_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_TURBO_FREQ_MHZ_type);
        break;

    // Get size for ATTR_FFO_FREQ_MHZ attribute
    case ATTR_FFO_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_FFO_FREQ_MHZ_type);
        break;

    // Get size for ATTR_OCC_MIN_FREQ_MHZ attribute
    case ATTR_OCC_MIN_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_OCC_MIN_FREQ_MHZ_type);
        break;

    // Get size for ATTR_MAX_NUM_PSI_LINKS_PER_FSP attribute
    case ATTR_MAX_NUM_PSI_LINKS_PER_FSP:
        l_attrSize = sizeof(ATTR_MAX_NUM_PSI_LINKS_PER_FSP_type);
        break;

    // Get size for ATTR_MIN_NUM_PSI_LINKS_PER_FSP attribute
    case ATTR_MIN_NUM_PSI_LINKS_PER_FSP:
        l_attrSize = sizeof(ATTR_MIN_NUM_PSI_LINKS_PER_FSP_type);
        break;

    // Get size for ATTR_PRIORITY_PSI_LINK_SELECTION attribute
    case ATTR_PRIORITY_PSI_LINK_SELECTION:
        l_attrSize = sizeof(ATTR_PRIORITY_PSI_LINK_SELECTION_type);
        break;

    // Get size for ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT attribute
    case ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT:
        l_attrSize = sizeof(ATTR_MAX_EXS_PER_PROC_CHIP_ARCH_LIMIT_type);
        break;

    // Get size for ATTR_MODEL_EC attribute
    case ATTR_MODEL_EC:
        l_attrSize = sizeof(ATTR_MODEL_EC_type);
        break;

    // Get size for ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ attribute
    case ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_VPD_POWERSAVE_MIN_FREQ_MHZ_type);
        break;

    // Get size for ATTR_IS_MASTER_NODE attribute
    case ATTR_IS_MASTER_NODE:
        l_attrSize = sizeof(ATTR_IS_MASTER_NODE_type);
        break;

    // Get size for ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS attribute
    case ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS:
        l_attrSize = sizeof(ATTR_IS_PNOR_ECC_RECOVERY_IN_PROGRESS_type);
        break;

    // Get size for ATTR_UPDATE_SLW_SCOM_TO_PHYP attribute
    case ATTR_UPDATE_SLW_SCOM_TO_PHYP:
        l_attrSize = sizeof(ATTR_UPDATE_SLW_SCOM_TO_PHYP_type);
        break;

    // Get size for ATTR_FSP_PM_SPWUP_OHA_FLAG attribute
    case ATTR_FSP_PM_SPWUP_OHA_FLAG:
        l_attrSize = sizeof(ATTR_FSP_PM_SPWUP_OHA_FLAG_type);
        break;

    // Get size for ATTR_SLW_IN_CHECKSTOP attribute
    case ATTR_SLW_IN_CHECKSTOP:
        l_attrSize = sizeof(ATTR_SLW_IN_CHECKSTOP_type);
        break;

    // Get size for ATTR_SPECIAL_WAKEUP_NEEDED attribute
    case ATTR_SPECIAL_WAKEUP_NEEDED:
        l_attrSize = sizeof(ATTR_SPECIAL_WAKEUP_NEEDED_type);
        break;

    // Get size for ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM attribute
    case ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM:
        l_attrSize = sizeof(ATTR_DISABLE_SPECIAL_WAKEUP_ON_SYSTEM_type);
        break;

    // Get size for ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED attribute
    case ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED:
        l_attrSize = sizeof(ATTR_FORCE_DISABLE_SPECIAL_WAKEUP_ASSERTED_type);
        break;

    // Get size for ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED attribute
    case ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED:
        l_attrSize = sizeof(ATTR_FORCE_ENABLE_SPECIAL_WAKEUP_ASSERTED_type);
        break;

    // Get size for ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH attribute
    case ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH:
        l_attrSize = sizeof(ATTR_FSP_PROC_NEST_ABST_FAST_SETUP_LENGTH_type);
        break;

    // Get size for ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH attribute
    case ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH:
        l_attrSize = sizeof(ATTR_FSP_PROC_NEST_GPTR_FAST_SETUP_LENGTH_type);
        break;

    // Get size for ATTR_MELTBOX_NEST_FREQ_MHZ attribute
    case ATTR_MELTBOX_NEST_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_MELTBOX_NEST_FREQ_MHZ_type);
        break;

    // Get size for ATTR_MELTBOX_FREQ_PB attribute
    case ATTR_MELTBOX_FREQ_PB:
        l_attrSize = sizeof(ATTR_MELTBOX_FREQ_PB_type);
        break;

    // Get size for ATTR_MELTBOX_FREQ_X attribute
    case ATTR_MELTBOX_FREQ_X:
        l_attrSize = sizeof(ATTR_MELTBOX_FREQ_X_type);
        break;

    // Get size for ATTR_DEFAULT_NEST_FREQ_MHZ attribute
    case ATTR_DEFAULT_NEST_FREQ_MHZ:
        l_attrSize = sizeof(ATTR_DEFAULT_NEST_FREQ_MHZ_type);
        break;

    // Get size for ATTR_DEFAULT_FREQ_PB attribute
    case ATTR_DEFAULT_FREQ_PB:
        l_attrSize = sizeof(ATTR_DEFAULT_FREQ_PB_type);
        break;

    // Get size for ATTR_DEFAULT_FREQ_X attribute
    case ATTR_DEFAULT_FREQ_X:
        l_attrSize = sizeof(ATTR_DEFAULT_FREQ_X_type);
        break;

    // Get size for ATTR_PROC_SLEEP_WINKLE_LID_ID attribute
    case ATTR_PROC_SLEEP_WINKLE_LID_ID:
        l_attrSize = sizeof(ATTR_PROC_SLEEP_WINKLE_LID_ID_type);
        break;

    // Get size for ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ attribute
    case ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ:
        l_attrSize = sizeof(ATTR_FREQ_PROC_REFCLOCK_ACTUAL_KHZ_type);
        break;

    // Get size for ATTR_HW_DECONFIG attribute
    case ATTR_HW_DECONFIG:
        l_attrSize = sizeof(ATTR_HW_DECONFIG_type);
        break;

    // Get size for ATTR_HB_HW_DECONFIG attribute
    case ATTR_HB_HW_DECONFIG:
        l_attrSize = sizeof(ATTR_HB_HW_DECONFIG_type);
        break;

    // Get size for ATTR_HW_RECONFIG_CURRENT_ITR attribute
    case ATTR_HW_RECONFIG_CURRENT_ITR:
        l_attrSize = sizeof(ATTR_HW_RECONFIG_CURRENT_ITR_type);
        break;

    // Get size for ATTR_FSP_HW_RECONFIG_MAX_COUNT attribute
    case ATTR_FSP_HW_RECONFIG_MAX_COUNT:
        l_attrSize = sizeof(ATTR_FSP_HW_RECONFIG_MAX_COUNT_type);
        break;

    // Get size for ATTR_FMBX_DMA_STATE attribute
    case ATTR_FMBX_DMA_STATE:
        l_attrSize = sizeof(ATTR_FMBX_DMA_STATE_type);
        break;

    // Get size for ATTR_LOCK_SERVICE_LOCK attribute
    case ATTR_LOCK_SERVICE_LOCK:
        l_attrSize = sizeof(ATTR_LOCK_SERVICE_LOCK_type);
        break;

    // Get size for ATTR_SBE_UPDATE attribute
    case ATTR_SBE_UPDATE:
        l_attrSize = sizeof(ATTR_SBE_UPDATE_type);
        break;

    // Get size for ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB attribute
    case ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB:
        l_attrSize = sizeof(ATTR_LAST_KNOWN_CONFIGURED_MEM_SIZE_MB_type);
        break;

    // Get size for ATTR_PNOR_PARTITION_SIDE attribute
    case ATTR_PNOR_PARTITION_SIDE:
        l_attrSize = sizeof(ATTR_PNOR_PARTITION_SIDE_type);
        break;

    // Get size for ATTR_DEALLOCATED attribute
    case ATTR_DEALLOCATED:
        l_attrSize = sizeof(ATTR_DEALLOCATED_type);
        break;

    // Get size for ATTR_BASE_PVR attribute
    case ATTR_BASE_PVR:
        l_attrSize = sizeof(ATTR_BASE_PVR_type);
        break;

    // Get size for ATTR_IS_MASTER_EX attribute
    case ATTR_IS_MASTER_EX:
        l_attrSize = sizeof(ATTR_IS_MASTER_EX_type);
        break;

    // Get size for ATTR_OVERRIDE_FREQ_PROC_REFCLOCK attribute
    case ATTR_OVERRIDE_FREQ_PROC_REFCLOCK:
        l_attrSize = sizeof(ATTR_OVERRIDE_FREQ_PROC_REFCLOCK_type);
        break;

    // Get size for ATTR_PART_ID attribute
    case ATTR_PART_ID:
        l_attrSize = sizeof(ATTR_PART_ID_type);
        break;

    // Get size for ATTR_I2C_SPEED attribute
    case ATTR_I2C_SPEED:
        l_attrSize = sizeof(ATTR_I2C_SPEED_type);
        break;

    // Get size for ATTR_I2C_ADDRESS attribute
    case ATTR_I2C_ADDRESS:
        l_attrSize = sizeof(ATTR_I2C_ADDRESS_type);
        break;

    // Get size for ATTR_I2C_DEV_PATH attribute
    case ATTR_I2C_DEV_PATH:
        l_attrSize = sizeof(ATTR_I2C_DEV_PATH_type);
        break;

    // Get size for ATTR_IS_IPL_DECONFIG_ALLOWED attribute
    case ATTR_IS_IPL_DECONFIG_ALLOWED:
        l_attrSize = sizeof(ATTR_IS_IPL_DECONFIG_ALLOWED_type);
        break;

    // Get size for ATTR_ISTEP_TIMEOUT attribute
    case ATTR_ISTEP_TIMEOUT:
        l_attrSize = sizeof(ATTR_ISTEP_TIMEOUT_type);
        break;

    // Get size for ATTR_MAX_EID_ON_HBEL_FSP_A attribute
    case ATTR_MAX_EID_ON_HBEL_FSP_A:
        l_attrSize = sizeof(ATTR_MAX_EID_ON_HBEL_FSP_A_type);
        break;

    // Get size for ATTR_MAX_EID_ON_HBEL_FSP_B attribute
    case ATTR_MAX_EID_ON_HBEL_FSP_B:
        l_attrSize = sizeof(ATTR_MAX_EID_ON_HBEL_FSP_B_type);
        break;

    // Get size for ATTR_SPL_WAKEUP_STATE attribute
    case ATTR_SPL_WAKEUP_STATE:
        l_attrSize = sizeof(ATTR_SPL_WAKEUP_STATE_type);
        break;

    // Get size for ATTR_FCO_SUPPORTED attribute
    case ATTR_FCO_SUPPORTED:
        l_attrSize = sizeof(ATTR_FCO_SUPPORTED_type);
        break;

    // Get size for ATTR_SMP_CONNECTION_STATE attribute
    case ATTR_SMP_CONNECTION_STATE:
        l_attrSize = sizeof(ATTR_SMP_CONNECTION_STATE_type);
        break;

    // Get size for ATTR_TARGET_SCOMABLE attribute
    case ATTR_TARGET_SCOMABLE:
        l_attrSize = sizeof(ATTR_TARGET_SCOMABLE_type);
        break;

    // Get size for ATTR_PROC_PCIE_CARD_WORKAROUND attribute
    case ATTR_PROC_PCIE_CARD_WORKAROUND:
        l_attrSize = sizeof(ATTR_PROC_PCIE_CARD_WORKAROUND_type);
        break;

    // Get size for ATTR_APPLY_PCIE_WORKAROUND attribute
    case ATTR_APPLY_PCIE_WORKAROUND:
        l_attrSize = sizeof(ATTR_APPLY_PCIE_WORKAROUND_type);
        break;

    // Get size for ATTR_PERST_CONTROL_PIN_NUMBERS attribute
    case ATTR_PERST_CONTROL_PIN_NUMBERS:
        l_attrSize = sizeof(ATTR_PERST_CONTROL_PIN_NUMBERS_type);
        break;

    // Get size for ATTR_PERST_CONTROL_DEVICE_PATHS attribute
    case ATTR_PERST_CONTROL_DEVICE_PATHS:
        l_attrSize = sizeof(ATTR_PERST_CONTROL_DEVICE_PATHS_type);
        break;

    // Get size for ATTR_SYSTEM_CONFIG_TYPE attribute
    case ATTR_SYSTEM_CONFIG_TYPE:
        l_attrSize = sizeof(ATTR_SYSTEM_CONFIG_TYPE_type);
        break;

    // Get size for ATTR_RT_DECONFIG_FAILED attribute
    case ATTR_RT_DECONFIG_FAILED:
        l_attrSize = sizeof(ATTR_RT_DECONFIG_FAILED_type);
        break;

    // Get size for ATTR_DECONFIG_BUT_NOT_GARDED attribute
    case ATTR_DECONFIG_BUT_NOT_GARDED:
        l_attrSize = sizeof(ATTR_DECONFIG_BUT_NOT_GARDED_type);
        break;

    // Get size for ATTR_SPD_DRAM_DIMM_DEVICE_TYPE attribute
    case ATTR_SPD_DRAM_DIMM_DEVICE_TYPE:
        l_attrSize = sizeof(ATTR_SPD_DRAM_DIMM_DEVICE_TYPE_type);
        break;

    // Get size for ATTR_CRITICAL_CORE_TEMP attribute
    case ATTR_CRITICAL_CORE_TEMP:
        l_attrSize = sizeof(ATTR_CRITICAL_CORE_TEMP_type);
        break;

    // Get size for ATTR_ENABLE_CORE_TEMP_CHECK attribute
    case ATTR_ENABLE_CORE_TEMP_CHECK:
        l_attrSize = sizeof(ATTR_ENABLE_CORE_TEMP_CHECK_type);
        break;

    // Get size for ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS attribute
    case ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS:
        l_attrSize = sizeof(ATTR_CORE_TEMP_CHECK_INTERVAL_SECONDS_type);
        break;

    // Get size for ATTR_IS_MASTER_CORE attribute
    case ATTR_IS_MASTER_CORE:
        l_attrSize = sizeof(ATTR_IS_MASTER_CORE_type);
        break;

    // Get size for ATTR_FSP_SECURITY_MODE attribute
    case ATTR_FSP_SECURITY_MODE:
        l_attrSize = sizeof(ATTR_FSP_SECURITY_MODE_type);
        break;

    // Get size for ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH attribute
    case ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH:
        l_attrSize = sizeof(ATTR_FSP_PRIMARY_FRU_AND_MODULE_VPD_PATH_type);
        break;

    // Get size for ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH attribute
    case ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH:
        l_attrSize = sizeof(ATTR_FSP_REDUNDANT_FRU_AND_MODULE_VPD_PATH_type);
        break;

    // Get size for ATTR_FSP_DIMM_SPD_P0_PATH attribute
    case ATTR_FSP_DIMM_SPD_P0_PATH:
        l_attrSize = sizeof(ATTR_FSP_DIMM_SPD_P0_PATH_type);
        break;

    // Get size for ATTR_FSP_DIMM_SPD_P1_PATH attribute
    case ATTR_FSP_DIMM_SPD_P1_PATH:
        l_attrSize = sizeof(ATTR_FSP_DIMM_SPD_P1_PATH_type);
        break;

    // Get size for ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH attribute
    case ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_PRIMARY_FRU_AND_MODULE_VPD_PATH_type);
        break;

    // Get size for ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH attribute
    case ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_REDUNDANT_FRU_AND_MODULE_VPD_PATH_type);
        break;

    // Get size for ATTR_FSP_A_DIMM_SPD_P0_PATH attribute
    case ATTR_FSP_A_DIMM_SPD_P0_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_DIMM_SPD_P0_PATH_type);
        break;

    // Get size for ATTR_FSP_A_DIMM_SPD_P1_PATH attribute
    case ATTR_FSP_A_DIMM_SPD_P1_PATH:
        l_attrSize = sizeof(ATTR_FSP_A_DIMM_SPD_P1_PATH_type);
        break;

    // Get size for ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH attribute
    case ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_PRIMARY_FRU_AND_MODULE_VPD_PATH_type);
        break;

    // Get size for ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH attribute
    case ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_REDUNDANT_FRU_AND_MODULE_VPD_PATH_type);
        break;

    // Get size for ATTR_FSP_B_DIMM_SPD_P0_PATH attribute
    case ATTR_FSP_B_DIMM_SPD_P0_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_DIMM_SPD_P0_PATH_type);
        break;

    // Get size for ATTR_FSP_B_DIMM_SPD_P1_PATH attribute
    case ATTR_FSP_B_DIMM_SPD_P1_PATH:
        l_attrSize = sizeof(ATTR_FSP_B_DIMM_SPD_P1_PATH_type);
        break;

    // Get size for ATTR_PRIMARY_SEEPROM_FAIL_COUNT attribute
    case ATTR_PRIMARY_SEEPROM_FAIL_COUNT:
        l_attrSize = sizeof(ATTR_PRIMARY_SEEPROM_FAIL_COUNT_type);
        break;

    // Get size for ATTR_SECONDARY_SEEPROM_FAIL_COUNT attribute
    case ATTR_SECONDARY_SEEPROM_FAIL_COUNT:
        l_attrSize = sizeof(ATTR_SECONDARY_SEEPROM_FAIL_COUNT_type);
        break;

    // Get size for ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT attribute
    case ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT:
        l_attrSize = sizeof(ATTR_PRIMARY_MEASUREMENT_SEEPROM_FAIL_COUNT_type);
        break;

    // Get size for ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT attribute
    case ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT:
        l_attrSize = sizeof(ATTR_SECONDARY_MEASUREMENT_SEEPROM_FAIL_COUNT_type);
        break;

    // Get size for ATTR_HOSTBOOT_TIME_OUT attribute
    case ATTR_HOSTBOOT_TIME_OUT:
        l_attrSize = sizeof(ATTR_HOSTBOOT_TIME_OUT_type);
        break;

    // Get size for ATTR_IS_TCES_MODE_ENABLE attribute
    case ATTR_IS_TCES_MODE_ENABLE:
        l_attrSize = sizeof(ATTR_IS_TCES_MODE_ENABLE_type);
        break;

    // Get size for ATTR_PRIMARY_MF_CLOCK attribute
    case ATTR_PRIMARY_MF_CLOCK:
        l_attrSize = sizeof(ATTR_PRIMARY_MF_CLOCK_type);
        break;

    // Get size for ATTR_REDUNDANT_MF_CLOCKS attribute
    case ATTR_REDUNDANT_MF_CLOCKS:
        l_attrSize = sizeof(ATTR_REDUNDANT_MF_CLOCKS_type);
        break;

    // Get size for ATTR_TEMP_LOL_ERR_CNT attribute
    case ATTR_TEMP_LOL_ERR_CNT:
        l_attrSize = sizeof(ATTR_TEMP_LOL_ERR_CNT_type);
        break;

    // Get size for ATTR_DISABLE_SECURITY attribute
    case ATTR_DISABLE_SECURITY:
        l_attrSize = sizeof(ATTR_DISABLE_SECURITY_type);
        break;

    // Get size for ATTR_MAX_LOL_ERR_CNT attribute
    case ATTR_MAX_LOL_ERR_CNT:
        l_attrSize = sizeof(ATTR_MAX_LOL_ERR_CNT_type);
        break;

    // Get size for ATTR_DISABLE_SBE_RUNTIME_RECOVERY attribute
    case ATTR_DISABLE_SBE_RUNTIME_RECOVERY:
        l_attrSize = sizeof(ATTR_DISABLE_SBE_RUNTIME_RECOVERY_type);
        break;

    // Get size for ATTR_CLOCK_PLL_MUX attribute
    case ATTR_CLOCK_PLL_MUX:
        l_attrSize = sizeof(ATTR_CLOCK_PLL_MUX_type);
        break;

    // Get size for ATTR_NVDIMM_AUTO_ARM attribute
    case ATTR_NVDIMM_AUTO_ARM:
        l_attrSize = sizeof(ATTR_NVDIMM_AUTO_ARM_type);
        break;

    // Get size for ATTR_NVDIMM_ENCRYPTION_ENABLE attribute
    case ATTR_NVDIMM_ENCRYPTION_ENABLE:
        l_attrSize = sizeof(ATTR_NVDIMM_ENCRYPTION_ENABLE_type);
        break;

    // Get size for ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR attribute
    case ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR:
        l_attrSize = sizeof(ATTR_NVDIMM_ENCRYPTION_KEYS_ANCHOR_type);
        break;

    // Get size for ATTR_NVDIMM_ENCRYPTION_KEYS_FW attribute
    case ATTR_NVDIMM_ENCRYPTION_KEYS_FW:
        l_attrSize = sizeof(ATTR_NVDIMM_ENCRYPTION_KEYS_FW_type);
        break;

    // Get size for ATTR_LINK_TRAIN attribute
    case ATTR_LINK_TRAIN:
        l_attrSize = sizeof(ATTR_LINK_TRAIN_type);
        break;

    // Get size for ATTR_EFF_DIMM_SIZE attribute
    case ATTR_EFF_DIMM_SIZE:
        l_attrSize = sizeof(ATTR_EFF_DIMM_SIZE_type);
        break;

    // Get size for ATTR_CEN_EFF_DIMM_SIZE attribute
    case ATTR_CEN_EFF_DIMM_SIZE:
        l_attrSize = sizeof(ATTR_CEN_EFF_DIMM_SIZE_type);
        break;

    // Get size for ATTR_L2_HASCLOCKS attribute
    case ATTR_L2_HASCLOCKS:
        l_attrSize = sizeof(ATTR_L2_HASCLOCKS_type);
        break;

    // Get size for ATTR_C0_EXEC_HASCLOCKS attribute
    case ATTR_C0_EXEC_HASCLOCKS:
        l_attrSize = sizeof(ATTR_C0_EXEC_HASCLOCKS_type);
        break;

    // Get size for ATTR_C1_EXEC_HASCLOCKS attribute
    case ATTR_C1_EXEC_HASCLOCKS:
        l_attrSize = sizeof(ATTR_C1_EXEC_HASCLOCKS_type);
        break;

    // Get size for ATTR_C0_PC_HASCLOCKS attribute
    case ATTR_C0_PC_HASCLOCKS:
        l_attrSize = sizeof(ATTR_C0_PC_HASCLOCKS_type);
        break;

    // Get size for ATTR_C1_PC_HASCLOCKS attribute
    case ATTR_C1_PC_HASCLOCKS:
        l_attrSize = sizeof(ATTR_C1_PC_HASCLOCKS_type);
        break;

    // Get size for ATTR_L2_HASPOWER attribute
    case ATTR_L2_HASPOWER:
        l_attrSize = sizeof(ATTR_L2_HASPOWER_type);
        break;

    // Get size for ATTR_C0_HASPOWER attribute
    case ATTR_C0_HASPOWER:
        l_attrSize = sizeof(ATTR_C0_HASPOWER_type);
        break;

    // Get size for ATTR_C1_HASPOWER attribute
    case ATTR_C1_HASPOWER:
        l_attrSize = sizeof(ATTR_C1_HASPOWER_type);
        break;

    // Get size for ATTR_CEN_SPD_DRAM_DEVICE_TYPE attribute
    case ATTR_CEN_SPD_DRAM_DEVICE_TYPE:
        l_attrSize = sizeof(ATTR_CEN_SPD_DRAM_DEVICE_TYPE_type);
        break;

    // Get size for ATTR_TARGET_IS_SCOMMABLE attribute
    case ATTR_TARGET_IS_SCOMMABLE:
        l_attrSize = sizeof(ATTR_TARGET_IS_SCOMMABLE_type);
        break;

    // Get size for ATTR_PROC_PCIE_CACHE_INJ_MODE attribute
    case ATTR_PROC_PCIE_CACHE_INJ_MODE:
        l_attrSize = sizeof(ATTR_PROC_PCIE_CACHE_INJ_MODE_type);
        break;

    // Get size for ATTR_FREQ_A_MHZ attribute
    case ATTR_FREQ_A_MHZ:
        l_attrSize = sizeof(ATTR_FREQ_A_MHZ_type);
        break;

    // Get size for ATTR_EFF_DIMM_RANKS_CONFIGED attribute
    case ATTR_EFF_DIMM_RANKS_CONFIGED:
        l_attrSize = sizeof(ATTR_EFF_DIMM_RANKS_CONFIGED_type);
        break;

    // Get size for ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM attribute
    case ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM:
        l_attrSize = sizeof(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM_type);
        break;

    // Get size for ATTR_CEN_DQ_TO_DIMM_CONN_DQ attribute
    case ATTR_CEN_DQ_TO_DIMM_CONN_DQ:
        l_attrSize = sizeof(ATTR_CEN_DQ_TO_DIMM_CONN_DQ_type);
        break;

    // Get size for ATTR_MSS_FREQ attribute
    case ATTR_MSS_FREQ:
        l_attrSize = sizeof(ATTR_MSS_FREQ_type);
        break;

    // Get size for ATTR_CEN_MSS_FREQ_OVERRIDE attribute
    case ATTR_CEN_MSS_FREQ_OVERRIDE:
        l_attrSize = sizeof(ATTR_CEN_MSS_FREQ_OVERRIDE_type);
        break;

    // Get size for ATTR_DD1_SLOW_PCI_REF_CLOCK attribute
    case ATTR_DD1_SLOW_PCI_REF_CLOCK:
        l_attrSize = sizeof(ATTR_DD1_SLOW_PCI_REF_CLOCK_type);
        break;

    // Get size for ATTR_CEN_MBA_PORT attribute
    case ATTR_CEN_MBA_PORT:
        l_attrSize = sizeof(ATTR_CEN_MBA_PORT_type);
        break;

    // Get size for ATTR_CEN_MBA_DIMM attribute
    case ATTR_CEN_MBA_DIMM:
        l_attrSize = sizeof(ATTR_CEN_MBA_DIMM_type);
        break;

    // Get size for ATTR_CEN_MSS_FREQ attribute
    case ATTR_CEN_MSS_FREQ:
        l_attrSize = sizeof(ATTR_CEN_MSS_FREQ_type);
        break;

    // Get size for ATTR_VDN_BOOT_VOLTAGE attribute
    case ATTR_VDN_BOOT_VOLTAGE:
        l_attrSize = sizeof(ATTR_VDN_BOOT_VOLTAGE_type);
        break;

    // Get size for ATTR_VDD_BOOT_VOLTAGE attribute
    case ATTR_VDD_BOOT_VOLTAGE:
        l_attrSize = sizeof(ATTR_VDD_BOOT_VOLTAGE_type);
        break;

    // Get size for ATTR_VCS_BOOT_VOLTAGE attribute
    case ATTR_VCS_BOOT_VOLTAGE:
        l_attrSize = sizeof(ATTR_VCS_BOOT_VOLTAGE_type);
        break;

    // Get size for ATTR_FREQ_BIAS_ULTRATURBO attribute
    case ATTR_FREQ_BIAS_ULTRATURBO:
        l_attrSize = sizeof(ATTR_FREQ_BIAS_ULTRATURBO_type);
        break;

    // Get size for ATTR_FREQ_BIAS_TURBO attribute
    case ATTR_FREQ_BIAS_TURBO:
        l_attrSize = sizeof(ATTR_FREQ_BIAS_TURBO_type);
        break;

    // Get size for ATTR_FREQ_BIAS_NOMINAL attribute
    case ATTR_FREQ_BIAS_NOMINAL:
        l_attrSize = sizeof(ATTR_FREQ_BIAS_NOMINAL_type);
        break;

    // Get size for ATTR_FREQ_BIAS_POWERSAVE attribute
    case ATTR_FREQ_BIAS_POWERSAVE:
        l_attrSize = sizeof(ATTR_FREQ_BIAS_POWERSAVE_type);
        break;

    // Get size for ATTR_COLLECT_ONLY_CLOCK_ON_DATA attribute
    case ATTR_COLLECT_ONLY_CLOCK_ON_DATA:
        l_attrSize = sizeof(ATTR_COLLECT_ONLY_CLOCK_ON_DATA_type);
        break;

    default:
        break;
    }

    return l_attrSize;
}

} // End namespace TARGETING

#endif // TARG_ATTRIBUTETRAITS_H

