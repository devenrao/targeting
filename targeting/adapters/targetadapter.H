// IBM_PROLOG_BEGIN_TAG 
// This is an automatically generated prolog. 
//  
// fips1110 src/hbfw/fsp/targeting/adapters/targetadapter.H 1.2 
//  
// IBM CONFIDENTIAL 
//  
// OBJECT CODE ONLY SOURCE MATERIALS 
//  
// COPYRIGHT International Business Machines Corp. 2013 
// All Rights Reserved 
//  
// The source code for this program is not published or otherwise 
// divested of its trade secrets, irrespective of what has been 
// deposited with the U.S. Copyright Office. 
//  
// IBM_PROLOG_END_TAG 

/**
 *  @file targeting/adapters/targetadapter.H
 *
 *  @brief Platform specific target.H attribute accessor template
 *      specializations
 *
 *  @warning This file is included verbatim into middle of target.H which must 
 *      be the only file that includes this file.  Do not edit this file unless
 *      you know what you are doing.
 *
 *  @note Include guards intentionally omitted
 *
 *  @page ChangeLogs Change Logs
 *  @section TARGETADAPTER_H targetadapter.H
 *  @verbatim
 *
 *  Change Log *****************************************************************
 *
 *  Flag   Defect/Feature User     Date        Description
 *  ------ -------------- -------- ----------- ---------------------------------
 *         F 872211       rajadas2 Mar 21,2013 Created.
 *         D 888668       rajadas2 Jul 03,2013 x86 Peer Targeting Issue Fixed
 *
 *  @endverbatim
 */

// Global Definition used within this file (i.e. target.H)
const uint32_t FSP_PEER_TARGET_32BIT_SHIFT = 32;

/**
  *  @brief Specialized template to try and get the target's
  *      PEER_TARGET attribute value
  *
  *  @par Detailed Description
  *      Attempts to return the target's PEER_TARGET attribute value.  It
  *      returns false (with invalid o_targetHandle) if the PEER_TARGET
  *      attribute does not exist for the associated target, true (with a
  *      valid o_targetHandle) otherwise.
  *
  *  @param[out] o_targetHandle 
  *      Target handle returned from the PEER_TARGET attribute
  *      When return value is false, this will return NULL
  *
  *  @pre Target service must be initialized
  *
  *  @post See "return"
  *
  *  @return bool indicating whether the PEER_TARGET attribute was returned
  *      or not
  *
  *  @retval true Attribute returned in o_targetHandle
  *  @retval false Attribute not found; o_targetHandle not valid
  */
template<>
inline bool Target::tryGetAttr<TARGETING::ATTR_PEER_TARGET>(
    TARGETING::Target*& o_targetHandle) const
{
    bool l_ret = false;
    uint64_t l_pHuidTarget = 0;
    if(_tryGetAttr(ATTR_PEER_TARGET, sizeof(l_pHuidTarget), &l_pHuidTarget))
    {
        l_pHuidTarget = (l_pHuidTarget >> FSP_PEER_TARGET_32BIT_SHIFT);
        o_targetHandle = getTargetFromHuid(
             static_cast<const TARGETING::ATTR_HUID_type>(l_pHuidTarget));
        l_ret = true;
    }
    else
    {
        l_ret = false;
    }
    return l_ret;
}

/**
  *  @brief Specialized template to get the target's PEER_TARGET
  *      attribute value
  *
  *  @par Detailed Description:
  *      Returns the target's PEER_TARGET attribute value.
  *
  *  @pre Target service must be initialized
  *
  *  @post See "return"
  *
  *  @return Peer target handle if available, otherwise NULL
  *
  *  @retval !NULL Target handle of peer target
  *  @retval NULL Target does not have a peer
  */
template<>
inline TARGETING::Target* Target::getAttr<ATTR_PEER_TARGET> () const
{
    TARGETING::Target* l_pTarget = NULL;
    bool l_read = tryGetAttr<ATTR_PEER_TARGET>(l_pTarget);

    TARG_ASSERT(l_read,"TARGETING::Target::getAttr<%d>: tryGetAttr "
            "returned false", ATTR_PEER_TARGET);

    return l_pTarget;
}

